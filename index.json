[{"categories":["bash"],"content":"shell脚本记录:网络联通测试","date":"2023-07-03","objectID":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E7%BD%91%E7%BB%9C%E8%81%94%E9%80%9A%E6%B5%8B%E8%AF%95/","tags":["shell脚本"],"title":"shell脚本记录:网络联通测试","uri":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E7%BD%91%E7%BB%9C%E8%81%94%E9%80%9A%E6%B5%8B%E8%AF%95/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 功能 脚本 功能 使用 for 循环来遍历 192.168.1.1 到 192.168.1.254 的 IP 地址。对于每个地址，它使用 ping 命令尝试发送一个 ICMP 回应包，等待 1 秒钟，如果返回值为 0（成功），则输出 “Ping 成功: IP 地址” 脚本 1 2 3 4 5 6 7 8 9 10 11 12 ```bash #!/bin/bash for i in {1..254} do ip=\"192.168.1.$i\" if ping -c 1 -W 1 \"$ip\" \u0026\u003e /dev/null then echo \"Ping 成功: $ip\" fi done ``` ","date":"2023-07-03","objectID":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E7%BD%91%E7%BB%9C%E8%81%94%E9%80%9A%E6%B5%8B%E8%AF%95/:0:0","tags":["shell脚本"],"title":"shell脚本记录:网络联通测试","uri":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E7%BD%91%E7%BB%9C%E8%81%94%E9%80%9A%E6%B5%8B%E8%AF%95/"},{"categories":["AI"],"content":"AI中的部分数学基础概念","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 标量、向量、矩阵、张量 标量 向量 矩阵 张量 标量、向量、矩阵、张量 点——标量（scalar） 线——向量（vector） 面——矩阵（matrix） 体——张量（tensor） ","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/:0:0","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":"标量 标量只有大小概念，没有方向的概念。通过一个具体的数值就能表达完整。 比如：重量、温度、长度、提及、时间、热量等都数据标量。 ","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/:1:0","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":"向量 主要有2个维度：大小、方向。 大小：箭头的长度表示大小 方向：箭头所指的方向表示方向 ","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/:2:0","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":"矩阵 矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合，元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵。而行数与列数都等于n的矩阵称为n阶矩阵或n阶方阵。 由 m × n 个数aij排成的m行n列的数表称为m行n列的矩阵，简称m × n矩阵。记作： ","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/:3:0","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":"张量 张量有很多种定义的方式，这里只讨论人工智能领域里的概念。 在人工智能领域，定义比较简单，TensorFlow是这么定义的： A tensor is a generalization of vectors and matrices to potentially higher dimensions. 简单翻译过来就是：张量是多维数组，目的是把向量、矩阵推向更高的维度。 ","date":"2023-02-15","objectID":"/posts/ai/math/mathbase/:4:0","tags":["AI"],"title":"AI：数学基础概念","uri":"/posts/ai/math/mathbase/"},{"categories":["AI"],"content":"深度学习基本概念","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 计算机视觉 图像分类 目标检测 语义分割 实例分割 视频分类 人体关键点检测 场景文字识别 目标跟踪 模型、算法和训练的关系 卷积神经网络 CNN 的基本原理 MNN NNIE 神经网络模型可视化工具netron 名词解释 算力（TOPS） 监督学习和非监督学习 训练集和测试集 损失函数（Loss Function） 优化器（optimizer） 转移学习（transfer learning） CV : Computer Vision 计算机视觉 CNN : Convolutional Neural Network 卷积神经网络 计算机视觉 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:0:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"图像分类 图像分类是计算机视觉中重要的基础问题。 举几个典型的例子：人脸识别、图片鉴黄、相册根据人物自动分类等。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:1:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"目标检测 目标检测任务的目标是给定一张图像或是一个视频帧，让计算机找出其中所有目标的位置，并给出每个目标的具体类别。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:2:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"语义分割 它将整个图像分成像素组，然后对像素组进行标记和分类。语义分割试图在语义上理解图像中每个像素是什么（人、车、狗、树…）。 如下图，除了识别人、道路、汽车、树木等之外，我们还必须确定每个物体的边界。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:3:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"实例分割 除了语义分割之外，实例分割将不同类型的实例进行分类，比如用 5 种不同颜色来标记 5 辆汽车。我们会看到多个重叠物体和不同背景的复杂景象，我们不仅需要将这些不同的对象进行分类，而且还要确定对象的边界、差异和彼此之间的关系！ ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:4:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"视频分类 与图像分类不同的是，分类的对象不再是静止的图像，而是一个由多帧图像构成的、包含语音数据、包含运动信息等的视频对象，因此理解视频需要获得更多的上下文信息，不仅要理解每帧图像是什么、包含什么，还需要结合不同帧，知道上下文的关联信息。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:5:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"人体关键点检测 体关键点检测，通过人体关键节点的组合和追踪来识别人的运动和行为，对于描述人体姿态，预测人体行为至关重要。 在 Xbox 中就有利用到这个技术。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:6:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"场景文字识别 很多照片中都有一些文字信息，这对理解图像有重要的作用。 场景文字识别是在图像背景复杂、分辨率低下、字体多样、分布随意等情况下，将图像信息转化为文字序列的过程。 停车场、收费站的车牌识别就是典型的应用场景。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:7:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"目标跟踪 目标跟踪，是指在特定场景跟踪某一个或多个特定感兴趣对象的过程。传统的应用就是视频和真实世界的交互，在检测到初始对象之后进行观察。 无人驾驶里就会用到这个技术。 模型、算法和训练的关系 数据算法模型的关系： 普通程序： 模型和训练程序： 卷积神经网络 CNN 有2大特点： 能够有效的将大数据量的图片降维成小数据量 能够有效的保留图片特征，符合图片处理的原则 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:8:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"CNN 的基本原理 卷积神经网络（CNN）原理及应用 MNN MNN : 轻量级的深度神经网络推理引擎 开源的端上推理引擎除了OpenCV的DNN之外，还有tensorFlow-lite、paddle-lite、NCNN、MNN等多个推理框架。目前端上推理引擎主要支持CPU及端上GPU，主流的的设备是CPU(arm)+GPU(mali qualcomm powerVR),主要的编程语言包括c、neon、汇编、OpenCL、OpenGL、vulkan,其中前三种主要是针对CPU的优化，后三种是GPU编程语言。 NNIE NNIE : Neural Network Inference Engine 海思媒体 SoC 中专门针对神经网 络特别是深度学习卷积神经网络进行加速处理的硬件单元，支持现有大部分的公开网 络，如 Alexnet、VGG16、Googlenet、Resnet18、Resnet50 等分类网络，Faster R- CNN、YOLO、SSD、RFCN 等检测网络，以及 SegNet、FCN 等场景分割网络。目前 NNIE 配套软件及工具链仅支持以 Caffe 框架，使用其他框架的网络模型需要转化 为 Caffe 框架下的模型。 神经网络模型可视化工具netron netron 名词解释 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:9:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"算力（TOPS） TOPS是Tera Operations Per Second的缩写，1TOPS代表处理器每秒钟可进行一万亿次（10^12）操作。 与此对应的还有GOPS（Giga Operations Per Second），MOPS（Million Operation Per Second）算力单位。1GOPS代表处理器每秒钟可进行十亿次（10^9）操作，1MOPS代表处理器每秒钟可进行一百万次（10^6）操作。TOPS同GOPS与MOPS可以换算，都代表每秒钟能处理的次数，单位不同而已。 在某些情况下，还使用 TOPS/W 来作为评价处理器运算能力的一个性能指标，TOPS/W 用于度量在1W功耗的情况下，处理器能进行多少万亿次操作。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:10:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"监督学习和非监督学习 监督学习是指存在先验知识的情况下进行训练，通过用带标签的数据来进行训练，然后运用训练结果来推导新的样本。 非监督学习是指在没有带标记的样本数据下进行训练（无先验知识），比如说想从大量的服务器日志中去找到异常的的记录，但是事先我们并不知道异常记录的特征是什么样的，没有任何的带标记的数据，只有靠计算机去找到其中隐藏的某种模式。非监督学习主要是一些聚类算法，即按照数据的相似度将它们分类。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:11:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"训练集和测试集 训练集很好理解，就是真正用来训练模型的数据；测试集是用来检验训练效果的数据，简单来说就是用训练完的模型来推导测试集的数据，对比推导结果和测试数据的标签来评估训练效果，如准确率。 训练集和测试集的划分有很多方法，最简单的是将数据顺序打乱以后，按照一定比例进行切分，比如 70% 的数据划分到训练集，剩下 30% 的划分到测试集。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:12:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"损失函数（Loss Function） 损失函数是用来衡量学习预测和现实结果差距的转换为具体数值（损失 Loss）的一方法，那么整个训练过程的就是不停的迭代优化（optimize），将损失减少到最小。比如我们用训练得到的模型来推导测试数据集里面的数据，将得到的结果和数据的真实标签进行对比，把他们的差距量化为一个数值，即损失值。然后再想办法降低这个损失值。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:13:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"优化器（optimizer） 一个算法的参数可能有几十来个，对于复杂的神经网络，参数可能有成千上万个，显然用人来调整是不现实的，所以这个工作也是由计算机来完成的，即优化器（optimizer）。它的原理是先选择一个参数集作为起始的参数集，完成一次训练后，根据学习效果（损失值）按照一定算法调整参数，然后不停的迭代调整寻找最优参数集（损失值最小）。常见的优化算法有梯度下降和其变种，Adadelta、Adagrad、RMSProp 等。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:14:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["AI"],"content":"转移学习（transfer learning） 转移学习：将已经训练好的模型的参数移植到新的模型上面帮助其训练，比起从零开始训练一个新模型，使用转移学习进行的训练所花的时间将大大减少。 ","date":"2023-02-15","objectID":"/posts/ai/ai/aibase/:15:0","tags":["AI"],"title":"AI：深度学习基本概念","uri":"/posts/ai/ai/aibase/"},{"categories":["tools"],"content":"conda","date":"2023-02-11","objectID":"/posts/tools/conda/conda/","tags":["conda"],"title":"tool:conda","uri":"/posts/tools/conda/conda/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 conda 命令 JupyterLab写C++ 介绍 Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 Conda 是为 Python 程序创建的，适用于 Linux，OS X 和Windows，也可以打包和分发其他软件 。 是最流行的 Python 环境管理工具。 安装 conda 是包含在 Anaconda 里的。我们安装了Anaconda就可以使用Conda了。 下载 清华源 1 https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M\u0026O=D 1 2 3 4 5 ## 下载 $ wget -c https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.05-Linux-x86_64.sh ## 查看 $ ls Anaconda3-2021.05-Linux-x86_64.sh 命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 判断版本 conda -V # 如果要更新版本 conda update conda # 列出当前环境 conda info --envs # 创建环境 conda create --name [name] [dependent package list] # 例如： conda create --name snowflakes biopython # 指定了python版本 conda create --name bunnies python=3.5 astroid babel # 从其他环境拷贝到新的环境 conda create --name flowers --clone snowflakes conda create --name flet --clone base # 删除指定环境 conda remove --name flowers --all # 激活环境 conda activate test # 推出环境 conda deactivate JupyterLab写C++ 新建文件，命名为cling.yml 1 touch cling.yml 将以下内容复制黏贴到cling.yml中： 1 2 3 4 5 6 7 8 9 10 11 12 13 name: cling channels: - conda-forge - https://mirrors.ustc.edu.cn/anaconda/pkgs/free/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - defaults dependencies: - python=3 - pip=19.2.1 - jupyter - notebook - xeus-cling=0.7.1 通过yml文件创建虚拟环境 1 conda env create -f cling.yml ","date":"2023-02-11","objectID":"/posts/tools/conda/conda/:0:0","tags":["conda"],"title":"tool:conda","uri":"/posts/tools/conda/conda/"},{"categories":["Computer"],"content":"CPU和显卡","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 显卡GPU 显卡分类 集成显卡 独立显卡 核芯显卡 显卡性能 架构 流处理器 核心频率 显存位宽 异构计算 CPU+GPU CUDA CUDA编程模型 检查的GPU的硬件配置 _global/device/host kernel 显卡GPU 显卡：将计算机系统需要的显示信息进行转换驱动显示器，并向显示器提供逐行或隔行扫描信号，控制显示器的正确显示，是连接显示器和个人计算机主板的重要组件，是“人机”的重要设备之一，其内置的并行计算能力现阶段也用于深度学习等运算。 用NVIDIA显示芯片的显卡称为N卡，而将采用AMD显示芯片的显卡称为A卡。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:0:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"显卡分类 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:1:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"集成显卡 集成显卡是将显示芯片、显存及其相关电路都集成在主板上，与其融为一体的元件；集成显卡的显示芯片有单独的，但大部分都集成在主板的北桥芯片中；一些主板集成的显卡也在主板上单独安装了显存，但其容量较小。 集成显卡的优点是功耗低、发热量小，集成显卡的缺点是性能相对略低，且固化在主板或CPU上，本身无法更换，如果必须换，就只能换主板。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:1:1","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"独立显卡 独立显卡是指将显示芯片、显存及其相关电路单独做在一块电路板上，自成一体而作为一块独立的板卡存在，它需占用主板的扩展插槽(ISA、 PCI、AGP或PCI-E)。 独立显卡的优点是单独安装有显存，一般不占用系统内存，在技术上也较集成显卡先进得多，但性能肯定不差于集成显卡，容易进行显卡的硬件升级。独立显卡的缺点是系统功耗有所加大，发热量也较大。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:1:2","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"核芯显卡 核芯显卡是Intel产品新一代图形处理核心，和以往的显卡设计不同，Intel 凭借其在处理器制程上的先进工艺以及新的架构设计，将图形核心与处理核心整合在同一块基板上，构成一个完整的处理器。智能处理器架构这种设计上的整合大大缩减了处理核心、图形核心、内存及内存控制器间的数据周转时间，有效提升处理效能并大幅降低芯片组整体功耗，有助于缩小核心组件的尺寸，为笔记本、一体机等产品的设计提供了更大选择空间。 需要注意的是，核芯显卡和传统意义上的集成显卡并不相同。笔记本平台采用的图形解决方案主要有“独立”和“集成”两种，前者拥有单独的图形核心和独立的显存，能够满足复杂庞大的图形处理需求，并提供高效的视频编码应用；集成显卡则将图形核心以单独芯片的方式集成在主板上，并且动态共享部分系统内存作为显存使用，因此能够提供简单的图形处理能力，以及较为流畅的编码应用。相对于前两者，核芯显卡则将图形核心整合在处理器当中，进一步加强了图形处理的效率，并把集成显卡中的“处理器+南桥+北桥(图形核心+内存控制+显示输出)”三芯片解决方案精简为“处理器(处理核心+图形核心十内存控制)十主板芯片(显示输出)”的双芯片模式，有效降低了核心组件的整体功耗，更利于延长笔记本的续航时间。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:1:3","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"显卡性能 显卡的作用就在于接收CPU送来的影像资料，并经过GPU处理，再送到显示器。显卡相当于一个转运体系，将CPU送来的货经过GPU的加工，再送到显示器。本质上，显卡的性能就是处理“货”，也就是数据的能力强弱。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:2:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"架构 英伟达从960时代的麦克斯架构 到10时代的帕斯卡架构 再到现在20系显卡采用的图灵架构。（帕斯卡用GP缩写 图灵用TU缩写）。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:2:1","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"流处理器 流处理器（简称SP）是显卡参数中核心的核心，其能直接影响到显卡性能，个数说则显卡性能强。流处理器的作用是将图像的像素点一个一个的渲染，也就不难理解上述提到的越多越好的结论了，毕竟人多力量大。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:2:2","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"核心频率 一般认为核心频率越高，显卡性能就越强。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:2:3","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"显存位宽 显存位宽表示一个时钟周期内所能传送数据的位数，位数越大则传输量越大，常见的有64位、128位和256位显卡。在显存频率相当情况下，显存位宽决定着带宽的大小。（显存带宽=显存频率 * 显存位宽 ） 异构计算 异构计算的英文名称是Heterogeneous computing，主要是指使用不同类型指令集和体系架构的计算单元组成系统的计算方式。 常见的计算单元类别包括CPU、GPU等协处理器、DSP、ASIC、FPGA等。我们常说的并行计算正是异构计算中的重要组成部分异构计算近年来得到更多关注，主要是因为通过提升CPU时钟频率和内核数量而提高计算能力的传统方式遇到了散热和能耗瓶颈。而与此同时，GPU等专用计算单元虽然工作频率较低，具有更多的内核数和并行计算能力，总体性能/芯片面积的比和性能/功耗比都很高，却远远没有得到充分利用。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:2:4","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"CPU+GPU CPU的目标是快速执行单一指令流； CPU将其用于乱序执行、寄存器重命名、分支预测以及巨大的cache上，这些设计都是为了加速单一线程的执行速度； CPU利用cache来降低内存访问延迟； CPU通过大量的cache和分支预测来降低延迟，这些机制消耗了大量的晶体管的电能； CPU每个核心支持1~2个线程； CPU切换线程的代价是数百个时钟周期； CPU通过SIMD（单指令多数据）来处理矢量数据； Intel的CPU没有集成内存控制器 GPU的目标是快速执行大量的并行指令流； GPU将晶体管用于处理器阵列、多线程管理、共享内存、内存控制器； 这些设计并不着眼于提高单一线程的执行速度，而是为了使GPU可以同时执行成千上万的线程； 实现线程间通信，并提供极高的内存带宽； GPU使用cache来放大内存带宽； GPU通过同时运行上千个线程来隐藏延迟，等待内存访问的线程会被切换掉，GPU切换线程不耗时间； 对于支持CUDA的GPU，每个流处理器可以同时处理1024个线程； GPU切换线程的代价是0，事实上GPU通常每个时钟周期都切换线程； GPU则使用SIMT（单指令多线程），SIMT的好处是无需开发者费力把数据凑成合适的矢量长度，并且SIMT允许每个线程有不同的分支； 支持CUDA的GPU集成有8个内存控制器，GPU的内存带宽通常是CPU的十倍。 CPU的长项是整数计算，GPU的优势则是浮点计算。 CUDA CUDA Toolkit Documentation v11.0.3 CUDA是NVIDIA公司所开发的GPU编程模型，它提供了GPU编程的简易接口，基于CUDA编程可以构建基于GPU计算的应用程序，利用GPUs的并行计算引擎来更加高效地解决比较复杂的计算难题。近年来，GPU最成功的一个应用就是深度学习领域，基于GPU的并行计算已经成为训练深度学习模型的标配。 GPU并不是一个独立运行的计算平台，而需要与CPU协同工作，可以看成是CPU的协处理器，因此当我们在说GPU并行计算时，其实是指的基于CPU+GPU的异构计算架构。在异构计算架构中，GPU与CPU通过PCIe总线连接在一起来协同工作，CPU所在位置称为为主机端（host），而GPU所在位置称为设备端（device），如下: GPU包括更多的运算核心，其特别适合数据并行的计算密集型任务，如大型矩阵运算，而CPU的运算核心较少，但是其可以实现复杂的逻辑运算，因此其适合控制密集型任务。另外，CPU上的线程是重量级的，上下文切换开销大，但是GPU由于存在很多核心，其线程是轻量级的。因此，基于CPU+GPU的异构计算平台可以优势互补，CPU负责处理逻辑复杂的串行程序，而GPU重点处理数据密集型的并行计算程序，从而发挥最大功效。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:3:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"CUDA编程模型 CUDA编程入门极简教程 CUDA运算速度和显卡CUDA核心数量关系大吗? CUDA编程模型是一个异构模型，需要CPU和GPU协同工作。在CUDA中，host和device是两个重要的概念，我们用host指代CPU及其内存，而用device指代GPU及其内存。CUDA程序中既包含host程序，又包含device程序，它们分别在CPU和GPU上运行。同时，host与device之间可以进行通信，这样它们之间可以进行数据拷贝。典型的CUDA程序的执行流程如下： 分配host内存，并进行数据初始化； 分配device内存，并从host将数据拷贝到device上； 调用CUDA的核函数在device上完成指定的运算； 将device上的运算结果拷贝到host上； 释放device和host上分配的内存。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:4:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"检查的GPU的硬件配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int dev = 0; cudaDeviceProp devProp; CHECK(cudaGetDeviceProperties(\u0026devProp, dev)); std::cout \u003c\u003c \"使用GPU device \" \u003c\u003c dev \u003c\u003c \": \" \u003c\u003c devProp.name \u003c\u003c std::endl; std::cout \u003c\u003c \"SM的数量：\" \u003c\u003c devProp.multiProcessorCount \u003c\u003c std::endl; std::cout \u003c\u003c \"每个线程块的共享内存大小：\" \u003c\u003c devProp.sharedMemPerBlock / 1024.0 \u003c\u003c \" KB\" \u003c\u003c std::endl; std::cout \u003c\u003c \"每个线程块的最大线程数：\" \u003c\u003c devProp.maxThreadsPerBlock \u003c\u003c std::endl; std::cout \u003c\u003c \"每个EM的最大线程数：\" \u003c\u003c devProp.maxThreadsPerMultiProcessor \u003c\u003c std::endl; std::cout \u003c\u003c \"每个EM的最大线程束数：\" \u003c\u003c devProp.maxThreadsPerMultiProcessor / 32 \u003c\u003c std::endl; // 输出如下 使用GPU device 0: GeForce GT 730 SM的数量：2 每个线程块的共享内存大小：48 KB 每个线程块的最大线程数：1024 每个EM的最大线程数：2048 每个EM的最大线程束数：64 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:4:1","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"_global/device/host GPU实际上是异构模型，所以需要区分host和device上的代码，在CUDA中是通过函数类型限定词开区别host和device上的函数，主要的三个函数类型限定词如下： 1 2 3 __global__：在device上执行，从host中调用（一些特定的GPU也可以从device上调用），返回类型必须是void，不支持可变参数参数，不能成为类成员函数。注意用__global__定义的kernel是异步的，这意味着host不会等待kernel执行完就执行下一步。 __device__：在device上执行，单仅可以从device中调用，不可以和__global__同时用。 __host__：在host上执行，仅可以从host上调用，一般省略不写，不可以和__global__同时用，但可和__device__，此时函数会在device和host都编译。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:4:2","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Computer"],"content":"kernel GPU上很多并行化的轻量级线程。kernel在device上执行时实际上是启动很多线程，一个kernel所启动的所有线程称为一个网格（grid），同一个网格上的线程共享相同的全局内存空间，grid是线程结构的第一层次，而网格又可以分为很多线程块（block），一个线程块里面包含很多线程，这是第二个层次。如下： ","date":"2023-02-09","objectID":"/posts/basic_knowledge/computer/computerbase/:5:0","tags":["Computer"],"title":"Computer:CPU和显卡","uri":"/posts/basic_knowledge/computer/computerbase/"},{"categories":["Embedded"],"content":"AI 芯片 XPU 简介","date":"2023-02-09","objectID":"/posts/embedded/aichip/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AI 芯片 XPU 简介","uri":"/posts/embedded/aichip/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 base AI芯片XPU base ARM：英国公司，专门提供微处理器IP核授权。 ceva：美国公司，提供DSP IP授权。ceva相当于是dsp领域的arm。 DSP（digital singnal processor）: 是一种独特的微处理器，有自己的完整指令系统，是以数字信号来处理大量信息的器件。DSP芯片一般具有如下主要特点： （1）在一个指令周期内可完成一次乘法和一次加法； （2）程序和数据空间分开，可以同时访问指令和数据； （3）片内具有快速RAM，通常可通过独立的数据总线在两块中同时访问； （4）具有低开销或无开销循环及跳转的硬件支持； （5）快速的中断处理和硬件I/O支持； （6）具有在单周期内操作的多个硬件地址产生器； （7）可以并行执行多个操作； （8）支持流水线操作，使取指、译码和执行等操作可以重叠执行。 FPGA(Field Programmable Gate Array)（现场可编程门阵列）:是在PAL、GAL、PLD等可编程器件的基础上进一步发展的产物，是专用集成电路（ASIC）中集成度最高的一种。 eMMC (Embedded Multi Media Card）：是MMC协会订立、主要针对手机或平板电脑等产品的内嵌式存储器标准规格。eMMC在封装中集成了一个控制器，提供标准接口并管理闪存，使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。 big.LITTLE：big.LITTLE 处理的设计旨在为适当的作业分配恰当的处理器，就是用大核干重活，用小核来干轻活。big.LITTLE模型在计算机术语上称为HMP（Heterogeneous Multi-Processing）。 AI芯片XPU APU – Accelerated Processing Unit, 加速处理器，AMD公司推出加速图像处理芯片产品。 BPU – Brain Processing Unit, 地平线公司主导的嵌入式处理器架构。 CPU – Central Processing Unit 中央处理器， 目前PC core的主流产品。 DPU – Deep learning Processing Unit, 深度学习处理器，最早由国内深鉴科技提出；另说有Dataflow Processing Unit 数据流处理器， Wave Computing 公司提出的AI架构；Data storage Processing Unit，深圳大普微的智能固态硬盘处理器。 FPU – Floating Processing Unit 浮点计算单元，通用处理器中的浮点运算模块。 GPU – Graphics Processing Unit, 图形处理器，采用多线程SIMD架构，为图形处理而生。 HPU – Holographics Processing Unit 全息图像处理器， 微软出品的全息计算芯片与设备。 IPU – Intelligence Processing Unit， Deep Mind投资的Graphcore公司出品的AI处理器产品。 MPU/MCU – Microprocessor/Micro controller Unit， 微处理器/微控制器，一般用于低计算应用的RISC计算机体系架构产品，如ARM-M系列处理器。 NPU – Neural Network Processing Unit，神经网络处理器，是基于神经网络算法与加速的新型处理器总称，如中科院计算所/寒武纪公司出品的diannao系列。 RPU – Radio Processing Unit, 无线电处理器， Imagination Technologies 公司推出的集合集Wifi/蓝牙/FM/处理器为单片的处理器。 TPU – Tensor Processing Unit 张量处理器， Google 公司推出的加速人工智能算法的专用处理器。目前一代TPU面向Inference，二代面向训练。 VPU – Vector Processing Unit 矢量处理器，Intel收购的Movidius公司推出的图像处理与人工智能的专用芯片的加速计算核心。 WPU – Wearable Processing Unit， 可穿戴处理器，Ineda Systems公司推出的可穿戴片上系统产品，包含GPU/MIPS CPU等IP。 XPU – 百度与Xilinx公司在2017年Hotchips大会上发布的FPGA智能云加速，含256核。 ZPU – Zylin Processing Unit, 由挪威Zylin 公司推出的一款32位开源处理器。 ","date":"2023-02-09","objectID":"/posts/embedded/aichip/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AI 芯片 XPU 简介","uri":"/posts/embedded/aichip/"},{"categories":["Embedded"],"content":"AR9201","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 SDK编译 toolchain 的安装 Build server 环境的建立 编译 SDK 解压文件 修改编译 其他问题 SDK编译 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"toolchain 的安装 1 2 3 4 5 sudo mkdir /opt/toolchain sudo tar -xvf gcc-linaro-5.4.1-2017.05-x86_64_arm-linux-gnueabihf.tar.xz -C /opt/toolchain sudo tar -jxvf gcc-arm-none-eabi-5_2-2015q4-20151219-linux.tar.bz2 -C /opt/toolchain ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:1:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"Build server 环境的建立 1 2 3 4 5 6 7 8 9 sudo dpkg-reconfigure dash : choose \"no\". sudo apt-get update sudo apt-get install fakeroot zlib1g-dev libmagickwand-dev python-pip vim lib32z1 lib32ncurses5 sudo apt-get install libbz2-1.0:i386 lib32stdc++6 squashfs-tools mtd-utils git autoconf automake texinfo autopoint bison flex sudo apt-get install liblz4-tool u-boot-tools tree sudo pip install Wand ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:2:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"编译 SDK ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:3:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"解压文件 1 2 3 4 5 6 7 # 解压SDK 到想要的工程目录 sudo tar -zxvf sdk34_dual.tar.gz # 删除SDK 中编译残留的中间文件 find ./ -type f -name *.d | xargs rm -rf find ./ -type f -name *.o | xargs rm -rf find ./ -type f -name *.depend | xargs rm -rf ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:3:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"修改编译 选择编译选项 xxx/AR_SDK/sdk-artosyn-ar-sirius-evb-hdmi-sirius-001-d-0.0.0.34/.product_profile 1 2 3 4 5 6 7 8 gCUSTOMER_BUILD = y ifeq (x$(gCUSTOMER_BUILD), xy) gCUSTOMER_BUILD_UBOOT = y gCUSTOMER_BUILD_KERNEL = y gCUSTOMER_BUILD_A7FW = y gCUSTOMER_BUILD_CEVA = y UBOOT : uboot KERNEL : linux kernel A7FW : free rtos CEVA : DSP binary 添加user app xxx/AR_SDK/sdk-artosyn-ar-sirius-evb-hdmi-sirius-001-d-0.0.0.34/app/artosyn/usr_test 创建.c、.h 源文件和 Makefile 文件 xxx/AR_SDK/sdk-artosyn-ar-sirius-evb-hdmi-sirius-001-d-0.0.0.34/.product_profile 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #====================================================================== #== User Test #====================================================================== gUSER_TEST_LIST = test_sample gUSER_TEST_LIST += test_ion #gUSER_TEST_LIST += test_vcodec gUSER_TEST_LIST += test_icc gUSER_TEST_LIST += test_spi gUSER_TEST_LIST += test_icc_proxy_rpc_src gUSER_TEST_LIST += test_icc_proxy_sink gUSER_TEST_LIST += test_cam_src #gUSER_TEST_LIST += test_dzoom gUSER_TEST_LIST += test_isp_output_format #gUSER_TEST_LIST += test_yuv_multi_input #gUSER_TEST_LIST += test_yuv_pipeline_ctl #gUSER_TEST_LIST += test_yuv_pipeline_client #gUSER_TEST_LIST += test_yuv_isp gUSER_TEST_LIST += test_crypto #gUSER_TEST_LIST += test_ar_gui #gUSER_TEST_LIST += test_ar_gui_random gUSER_TEST_LIST += test_mem_watch gUSER_TEST_LIST += test_send_data gUSER_TEST_LIST += test_hid_service #gUSER_TEST_LIST += test_yuv_sensor #gUSER_TEST_LIST += test_pseudo_yuv_multi_input #gUSER_TEST_LIST += test_pseudo_multi_input_hevc #gUSER_TEST_LIST += test_pipeline #gUSER_TEST_LIST += test_comp_osd #gUSER_TEST_LIST += test_pipe_onoff gUSER_TEST_LIST += test_framebuffer #gUSER_TEST_LIST += test_yuv_framebuffer gUSER_TEST_LIST += test_ipcam gUSER_TEST_LIST += test_mouse_read #gUSER_TEST_LIST += 1.ico #gUSER_TEST_LIST +=cam_raw_test gUSER_TEST_LIST += test_remote_i2c #gUSER_TEST_LIST += test_get_af_info gUSER_TEST_LIST += test_pwm gUSER_TEST_LIST += test_axi_dma gUSER_TEST_LIST += hello gUSER_TEST_LIST += $(gCUSTOMER_USER_TEST_LIST) 编译 1 make img ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:3:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"其他问题 中文ubuntu 需要替换文件(xxx/AR_SDK/sdk-artosyn-ar-sirius-evb-hdmi-sirius-001-d-0.0.0.34/makery)： ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/ar9201/ar9201/:4:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201","uri":"/posts/embedded/developmentboard/ar9201/ar9201/"},{"categories":["Embedded"],"content":"AR9201\u0026RK3399Pro","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 AR9201 Application Processor Core MCU core CEVA DSP core Video Codec Format Video Codec Performance ISP Audio Encoding/Decoding Security Engine Video Interfaces Video input Video output Baseband Analog Peripherals External Memory Interfaces DDR4/DDR3/LPDDR3 interface SPI NOR flash interface eMMC 5.1 interface with 64GB max capacity Physical Specification Power consumption Operating voltages Package JEDEC Manu ID RK3399Pro CPU GPU NPU VPU RGA 内存 存储 EMMC 显示 音频 无线网络 以太网 摄像头接口 USB接口 PCI-E接口 AR9201 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Application Processor Core  1.5GHz ARM Cortex-A7 quad-core, each core with 32KB I-cache, 32KB D-cache  512KB L2 cache  Neon acceleration and double precision FPU  Embedded Trace data interface (16KB ETB) for ARM-DS5 debugger  DVFS control： 动态电压与频率调节 降低功耗 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:1:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"MCU core  500MHz CPU, 16Kbyte I-cache, 16KB D-cache  128KB ITCM and 64KB DTCM  Double precision FPU ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:2:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"CEVA DSP core  4 x high performance CEVA XM4 Cores at 1000MHz  2M-Byte shared on-chip SRAM ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:3:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Video Codec Format  H.264 BP/MP/HP encoding and decoding  H.265 MAIN/MAIN10 @L5.0 High-tier encoding and decoding  MJPEG/JPEG Extended Sequential encoding and decoding ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:4:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Video Codec Performance  Software configurable video codec, either as encoder or as decoder  Real-time multi-stream H.264/H.265 encoding or decoding:  H.264: 1080P@60fps  4Kx2K@30fps+1080p@30fps  MJPEG/JPEG encoding/decoding at 4Kx2K@30fps  MJPEG/JPEG encoding and decoding ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:5:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"ISP  Input Video resolution ranging from 4152x2174@ 60fps to 480x240  Max 600M pixels processing per second  Both spatial denoising and temporal denoising  Adjustable 3A functions  Digital WDR and tone mapping support  Lens Shading correction  Green Imbalance correction  Bayer RAW data input with max 14bit-width  3 different resolution video outputs from the single source ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:6:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Audio Encoding/Decoding  I2S interface for external audio input  Software support for Voice/music encoding/decoding complying with multiple protocols such asG.711, ADPCM, G.726 and MP3. ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:7:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Security Engine  AES and DES encryption and decryption algorithms implemented by using hardware  RSA1024/2048/4096 signature verification algorithm implemented by using hardware  Hash MD5, SHA-1, SHA-256, SHA-512 and SHA-512/256 tamper proofing algorithms implemented by using hardware  ARM TrustZone solution for hardware-based security  Security CPU solution for secure boot and secure storage. ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:8:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Video Interfaces ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:9:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Video input  2 BT-656 or BT-1120 digital parallel input interfaces, up to 1080p@60fps  8 MIPI CSI-RX input ports, 2 data-lane for each port, up to 4Kx2K@30fps  1 HDMI 1.4 RX interface up to 4Kx2K@30fps compatible with EDID 1.1 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:9:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Video output  1 DisplayPort output interface up to 4Kx2K@30fps  1 BT-1120 digital parallel output interface up to 1080p@60fps, sharing pins with BT-1120 input interface  1 MIPI CSI-TX output interface up to 4Kx2K@30fps ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:9:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Baseband  2T4R with 2.5MHz/5MHz/10MHz/20MHz/40MHz bandwidth  BPSK/QPSK/16QAM/64QAM/256QAM modulation  LDPC encoder with 1/2, 2/3, 3/4 code rate  Max down link rate at 100Mbps  2.4G/5.8G uplink/downlink communication  One AP support max to four nodes ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:10:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Analog  One 8-1 10bit SAR ADC  Two 10bit SAR ADCs  Four 12bit DACs  Eight 12bit ADCs ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:11:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Peripherals  9 UARTs  2 Watch dog timers  20 timers,10 of which have PWM output  4 CAN bus interface  5 I2C interfaces, can be configured as either master or slave by software  4 SPI masters(2x1-1, 2x1-5), 2 SPI slave  4 I2S 4bit interfaces  147 GPIO, shared with other functions.  2 AXI DMA controller  One AHB DMA controller  USB 3.0 DRD controller and PHY.  USB 3.0 /Type-C / DisplayPort combo interface  10/100/1000M Ethernet RGMII interface  2-lane PCIe 2.0, can be configured as EP or RC mode ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:12:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"External Memory Interfaces ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:13:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"DDR4/DDR3/LPDDR3 interface  16/32/64-bit DDR4 interface up to DDR4 2400  16/32/64-bit DDR3L interface up to DDR3L 2133  32/64-bit LPDDR3 interface up to LPDDR3 2133 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:13:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"SPI NOR flash interface  1-/2-/4-wire mode  3-byte or 4-byte address mode  Maximum capacity of 256 MB NOR flash or MCP SPI NOR+NAND flash ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:13:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"eMMC 5.1 interface with 64GB max capacity Secure Boot from internal ROM with eMMC flash or SPI NOR flash. ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:13:3","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Physical Specification ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:14:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Power consumption  3W typical power consumption in the 4Kx2K scenario  Multiple power domains for power saving ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:14:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Operating voltages  0.9V core voltage  1.8V I/O voltage  1.2V/1.2V/1.5V for DDR4/LPDDR3/DDR3(L)  3.3V I/O voltage ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:14:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"Package  FCBGA  Body size of 19mm x19mm  Ball pitch of 0.65mm ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:14:3","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"JEDEC Manu ID  JEP-106 Manufacture ID number : 47 decimal (bank 10) RK3399Pro ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:14:4","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"CPU 六核ARM 64位处理器（双核Cortex-A72+四核Cortex-A53），主频高达1.8GHz ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:15:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"GPU 四核ARM Mali-T860 MP4 GPU 支持OpenGL ES1.1/2.0/3.0/3.1, OpenVG1.1, OpenCL, DX11；支持AFBC（帧缓冲压缩） ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:16:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"NPU 支持8bit/16bit运算，支持TensorFlow、Caffe模型，运算性能高达3.0TOPs ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:17:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"VPU 支持4K VP9 and 4K 10bits H265/H264 视频解码，高达60fps 1080P 多格式视频解码 (WMV, MPEG-1/2/4, VP8)，支持6路1080P@30fps解码 1080P 视频编码，支持H.264，VP8格式，支持2路1080P@30fps编码 视频后期处理器：反交错、去噪、边缘/细节/色彩优化 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:18:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"RGA 支持实时图像缩放、裁剪、格式转换、旋转等功能 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:19:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"内存 3GB/6GB LPDDR3 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:20:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"存储 TF-card ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:21:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"EMMC 16GB/32GB eMMC ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:22:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"显示 1路HDMI2.0(Type-A)接口，支持4K/60fps输出 1路DP1.2(Type-A)接口，支持4K@60fps输出 1路MIPI接口，支持1920*1080@60fps输出 1路eDP1.3接口,支持2K@60fps输出 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:23:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"音频 1路HDMI或DP音频输出 1路Speaker，喇叭输出 1路耳麦，用于音频输入输出 1路麦克风，板载音频输入 1路8通道I2S，支持麦克风阵列 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:24:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"无线网络 板载WIFI模块： 支持2.4G WiFi，支持802.11b/g/n协议 Bluetooth4.2（支持BLE） ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:25:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"以太网 10/100/1000Mbps以太网 ( Realtek RTL8211E ) ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:26:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"摄像头接口 2路MIPI-CSI摄像头接口（最高支持单13Mpixel或双8Mpixel） ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:27:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"USB接口 2路USB2.0 Host(Type-A)接口 1路USB3.0 Host(Type-A)接口 1路USB3.0 OTG(Type-C)接口 ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:28:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"PCI-E接口 1路MiNi PCIe接口，用于LTE，可外接3G/4G通讯模块 1路PCIe x4标准接口，支持基于PICe 高速WIFI、存储等设备的扩展 SIM 1路SIM卡座，用于配合MiNi PCIe接口扩展LTE模块 LED灯 1路电源指示灯 1路工作状态灯（三色灯显示） 按键 1路Reset按键 1路Power按键 1路Recovery按键 1路Maskrom按键 串口 1路RS232接口 调试 1路调试串口（Micro USB接口） 扩展接口 40pin扩展接口包括： 8通道I2S接口（支持麦克风阵列） 1路SPI接口 2路ADC接口 2路I2C接口 4个GPIO口，支持中断编程 3路直流电源（12V、3.3V、5V）） 电源 DC 12V/2A 系统 支持Android和Linux双系统，支持双系统启动和一键切换功能 PCB尺寸 145mm×106mm 芯片 处理器 GPU/NPU Memory Multimedia 外设 RK3399 双核Cortex-A72及四核Cortex-A53 ARM Mali-T860MP4 GPU 双通道DDR3-1866/DDR3L-1866/LPDDR3-1866/LPDDR4-1866；支持eMMC 5.1, SDIO 3.0 with HS200 4K VP9和4K 10位H.265/H.264视频解码器，高达60fps；1080p其他视频解码器(VC1，MPEG1/2/4，VP8) AR9201 4核 1.5GHz ARM Cortex-A7 quad-core, 32KB I-cache, 32KB D-cache, 512KB L2 cache CEVA DSP 4 核， 最高1GHz（折算约~1 T ops） 解码：4路 1080p高清，ISP 最大 4K 60fps 处理能力，8路mipi CSI， 单路最大 4K 30fps，支持 MIPI out/display port/ HDMI Tegra K1 四核 Cortex A15 核主频高达 2.2 GHz 192个CUDA核心 2G运行内存 16G emmc 存储空间 千兆以太网、PCIe、SATA 和 USB 3.0 等高速接口 hi3559A 双核ARM Cortex A73@1.8GHz+双核ARM Cortex A53@1.2GHz+单核ARM Cortex A53@1.2GHz 双核ARM Mali G71@900MHz，支持OpenCL 1.1/1.2/2.0，支持OpenGL ES 3.0/3.1/3.2智能视频分析： 提供视觉计算处理能力 四核 DSP@700MHz，32K I-Cache /32K IRAM/512KB DRAM 双核 NNIE@840MHz 神经网络加速引擎 4G Bytes 64bit DDR4 16G Bytes eMMC 支持8K@30+1080P@30或者4K@120+1080P@30，H.265编码 支持2×4K@60或4×4K@30或8×1080P@30视频录制，支持机内硬化拼接 RV1126 四核 ARM Cortex-A7 and RISC-V MCU 2.0Tops, support INT8/ INT16 • 32bit DDR3/DDR3L/LPDDR3/DDR4/LPDDR4 • 支持eMMC 4.51, SPI Flash, Nand Flash • 支持快速开机 • 1400万 ISP 2.0 with 3帧 HDR(Line-based/Frame-based/DCG) • 同时支持2组MIPI CSI /LVDS/sub LVDS和一组16-bit并口输入 • 4K H.264/H.265 30fps 视频编码 -3840 x 2160@30 fps+720p@30 fps encoding • 4K H.264/H.265 30fps 视频解码 -3840 x 2160@30 encoding + 3840 x 2160@30 fps decoding • 千兆以太网接口，具有TSO(TCP Segmentation Offload)网络加速 • USB 2.0 OTG and USB 2.0 host • 两个 SDIO 3.0 接口for Wi-Fi and SD卡 • 8通道 I2S with TDM/PDM, 2通道I2S ","date":"2023-02-09","objectID":"/posts/embedded/ar9201rk3399pro/:29:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:AR9201\u0026RK3399Pro","uri":"/posts/embedded/ar9201rk3399pro/"},{"categories":["Embedded"],"content":"BeagleBone black","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 常规参数 AM335x处理器 板载内存 板载接口 按键\u0026灯 系统框图 设备驱动 资源 开发环境搭建 串口工具 查看系统信息 板载闪存 以太网 交叉编译 arm-eabi arm-linux-gnueabihf 安装 简介 BeagleBone Black Rev.C是一款基于AM335x处理器的开发套件，它集成了ARM Cortex™-A8内核，处理速度高达1GHz，并有丰富的外设。可扩展的接口有以太网、USB、OTG、TF卡、串口、JTAG、D型HDMI、ADC、I2C、SPI、PWM及LCD。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"常规参数 ·尺寸： 86.36 mm×54.61mm ·工作温度：0 ~ 70℃ ·工作湿度：20% ~ 90% (Non-Condensing) ·供电电压5V/0.35A ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:1:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"AM335x处理器 ·集成 1GHz ARM Cortex™-A8内核 ·集成 NEON™ SIMD 协处理器 ·集成 SGX530图形引擎 ·集成实时可编程子系统单元 ·集成32KB指令缓存和32KB数据缓存具有一位奇偶校验位 ·集成256KB带错误检测码的第二层快速存储器 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:2:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"板载内存 • 4GB 8-位eMMC 板载闪存 • 512MB DDR3 SDRAM ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:3:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"板载接口 • 1个D型HDMI接口(16位颜色与音频输出) • 1个LCD接口 (24-bit输出, P8接口输出) • 1个10/100M以太网接口 (RJ45 接头) • 1个带PHY的高速USB 2.0 OTG接口(Mini USB type-B 接头) • 1个带PHY的高速USB 2.0 HOST接口 (USB type-A 接头) • 1个TF卡槽(SD/MMC) • 1个3线调试串口(6引脚 2.54接头) • 1个D型HDMI接口 • 1 个扩展接口，可接LCD、 UART、eMMC、ADC、I2C、SPI及PWM • 1 个JTAG 接口 (可选，20引脚标准接口, 默认不焊接) ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:4:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"按键\u0026灯 • 1个开机选择按键 • 1个电源开关 • 1个重启开关 • 1个LED电源指示灯 • 4个常规指示灯 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:5:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"系统框图 操作系统： Debian, Angstrom, Ubuntu, Android ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:6:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"设备驱动 Uart：Uart 驱动 Ehternet：10/100 IEEE1588 显示器：HDMI Driver mmc/sd：SD 2.0 /eMMC 驱动 USB：高速USB驱动 Led：用户 LED驱动 支持Debian系统，带有驱动和源代码。 支持TISDK系统，带有驱动和源代码。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:7:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"资源 Beagleboard:BeagleBoneBlack Beagleboard:BeagleBoneBlack Debian 开发环境搭建 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:8:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"串口工具 sudo apt-get install minicom 启动并配置minicom sudo minicom -s 查看USB串口设备 ls /dev/ttyUSB* minicom退出 crtl + a + z + x ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:9:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"查看系统信息 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:10:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"板载闪存 1 2 3 4 5 6 7 8 9 10 root@BBB-2:~# df -h Filesystem Size Used Avail Use% Mounted on rootfs 3.4G 2.0G 1.3G 60% / udev 10M 0 10M 0% /dev tmpfs 100M 520K 99M 1% /run /dev/disk/by-uuid/b74cd3fe-800f-4a18-a50e-598d20a512fd 3.4G 2.0G 1.3G 60% / tmpfs 249M 0 249M 0% /dev/shm tmpfs 249M 0 249M 0% /sys/fs/cgroup tmpfs 5.0M 0 5.0M 0% /run/lock tmpfs 100M 0 100M 0% /run/user ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:10:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"以太网 ifconfig eth0 1 2 3 4 5 6 7 8 9 eth0 Link encap:Ethernet HWaddr b0:d5:cc:f9:e3:11 inet addr:192.168.101.217 Bcast:192.168.101.255 Mask:255.255.254.0 inet6 addr: fe80::b2d5:ccff:fef9:e311/64 Scope:Link UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1 RX packets:1537 errors:0 dropped:0 overruns:0 frame:0 TX packets:352 errors:0 dropped:0 overruns:0 carrier:0 collisions:0 txqueuelen:1000 RX bytes:217702 (212.5 KiB) TX bytes:109929 (107.3 KiB) Interrupt:40 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:10:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"交叉编译 arm-eabi :是用于编译裸机程序的，当然也包括Bootloader arm-linux-gnueabihf :适用于编译运行于嵌入式linux的程序 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:11:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"arm-eabi arm：指的是arm内核的处理器； eabi：指的是嵌入式应用二进制接口（Embedded application binary interface）。 交叉编译工具链在windows上面运行的时候需要配合mingw32使用，可以直接下载gcc-linaro-7.4.1-2019.02-i686-mingw32_arm-eabi.tar.xz版本。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:11:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"arm-linux-gnueabihf arm：指的是arm内核的处理器； linux：表示用于运行在linux上的程序的编译； gnueabihf：The GNU C compiler for armhf architecture，hf表示使用hard硬件浮点模式。 交叉编译工具链在windows上面运行的时候需要配合mingw32使用，可以直接下载gcc-linaro-7.4.1-2019.02-i686-mingw32_arm-linux-gnueabihf.tar.xz版本。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:11:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"安装 安装32位软件支持 1 2 3 sudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 zlib1g:i386 将交叉编译工具软件包解压到自己想要安装的目录（最好不要有中文）。将解压后的bin目录添加到环境变量。 测试 输入 1 arm-linux-gnueabihf-gcc -v 输出 1 2 3 4 5 6 7 使用内建 specs。 COLLECT_GCC=arm-linux-gnueabihf-gcc COLLECT_LTO_WRAPPER=/opt/tegra-linux/x86-arm/arm-linux-gnueabihf/bin/../libexec/gcc/arm-linux-gnueabihf/4.8.3/lto-wrapper 目标：arm-linux-gnueabihf 配置为：/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/src/gcc-linaro-4.8-2014.04/configure --build=i686-build_pc-linux-gnu --host=i686-build_pc-linux-gnu --target=arm-linux-gnueabihf --prefix=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/install --with-sysroot=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/install/arm-linux-gnueabihf/libc --enable-languages=c,c++,fortran --enable-multilib --with-arch=armv7-a --with-tune=cortex-a9 --with-fpu=vfpv3-d16 --with-float=hard --with-pkgversion='crosstool-NG linaro-1.13.1-4.8-2014.04 - Linaro GCC 4.8-2014.04' --with-bugurl=https://bugs.launchpad.net/gcc-linaro --enable-__cxa_atexit --enable-libmudflap --enable-libgomp --enable-libssp --with-gmp=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --with-mpfr=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --with-mpc=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --with-isl=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --with-cloog=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --with-libelf=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/.build/arm-linux-gnueabihf/build/static --enable-threads=posix --disable-libstdcxx-pch --enable-linker-build-id --enable-gold --with-local-prefix=/cbuild/slaves/oorts/crosstool-ng/builds/arm-linux-gnueabihf-linux/install/arm-linux-gnueabihf/libc --enable-c99 --enable-long-long --with-mode=thumb --with-float=hard 线程模型：posix gcc 版本 4.8.3 20140401 (prerelease) (crosstool-NG linaro-1.13.1-4.8-2014.04 - Linaro GCC 4.8-2014.04) ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/:11:3","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black","uri":"/posts/embedded/developmentboard/beagleboneblack/beaglebone-black/"},{"categories":["Embedded"],"content":"BeagleBone black 镜像制作","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 beaglebone black启动方式 BeagleBone 启动 准备Linux镜像 安装交叉编译器 下载并编译uboot 下载编译linux内核 下载文件系统rootfs Debian8 ubuntu16.04 烧录Linux镜像到SD卡中 准备烧写sd卡 安装固件 安装u-boot 增加新分区 挂载分区 安装linux 内核和文件系统 其他配置 参考 beaglebone black启动方式 BeagleBone 的核心处理器是 AM3358，AM335x 有四个不同的启动阶段： （1）ROM Code（处理器内部固化代码） （2）SPL（Secondary Program Loader） （3）U-BOOT （4）Linux Kernel 为什么 AM335x 有多个启动阶段呢？直接从启动源加载 U-Boot 启动不是很方便？ 一个全功能的U-Boot可能会超过400KB，因此不可能直接将它加载进内部RAM中直接运行，因此要分阶段。首先，第一步的 ROM Code （固化代码）不可能太复杂，ROM大小是一个限制，最重要的还是因为其所能获取的系统信息太少，所以处理器只能使用简单的方法去寻找能完成复杂功能的代码，而后将处理器初始化工作交给它来完成。其次，SPL （MLO）也不能很复杂，因为 ROM Code 只能将它加载到处理器内部 RAM 中运行，一般处理器的内部 RAM 都要小于128KB，其大小注定其不能完成很复杂的功能，所以 SPL 需要初始化 DDR 再加更复杂的代码加载到 DDR 中运行。到了在 DDR RAM 中执行的 Bootloader（U-Boot），其功能就比较完善了，此时就可以启动操作系统了。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"BeagleBone 启动 BBB 板子上的 AM3335x 处理器上可以通过配置选择不同的接口启动，如数据手册 第二十六章所写。BBB 通过 S2 这个按键选择不同的启动顺序，默认情况下（S2 没有按下）启动过程如下： （1）MMC1（板载 eMMC） （2）MMC0（microSD） （3）UART0 （4）USB0 如果按下 S2 按钮，启动过程如下： （1）SPI0 （2）MMC0（microSD） （3）UART0 （4）USB0 准备Linux镜像 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:1:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"安装交叉编译器 安装交叉编译器 1 sudo apt-get install gcc-arm-linux-gnueabihf 安装完后可以查看交叉编译器版本 1 arm-linux-gnueabihf-gcc -v 本文交叉编译器版本为gcc version 7.5.0 (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:2:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"下载并编译uboot 以下假设所有的文件和操作路径都是在**/mnt/DATA/bb-linux**下 1 sudo mkdir /mnt/DATA/bb-linux/ 下载u-boot,并把文件传进ubuntu 编译 1 2 3 git clone git@git.zhlh6.cn:u-boot/u-boot.git cd u-boot git checkout v2017.03-rc2 -b bbb_uboot 下载相应的patch 路径：/mnt/DATA/bb-linux/u-boot 1 2 3 4 wget -c https://rcn-ee.com/repos/git/u-boot-patches/v2017.03-rc2/0001-am335x_evm-uEnv.txt-bootz-n-fixes.patch wget -c https://rcn-ee.com/repos/git/u-boot-patches/v2017.03-rc2/0002-U-Boot-BeagleBone-Cape-Manager.patch patch -p1 \u003c 0001-am335x_evm-uEnv.txt-bootz-n-fixes.patch patch -p1 \u003c 0002-U-Boot-BeagleBone-Cape-Manager.patch 编译u-boot 路径：/mnt/DATA/bb-linux/u-boot 1 2 3 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- am335x_boneblack_defconfig make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- 编译完成后在目录下能看到MLO （是一个引导加载程序，用于加载u-boot.img到SDRAM）和 u-boot.img （可以直接写入Flash的二进制可执行文件，直接被运行）这两个文件。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:3:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"下载编译linux内核 下载编译内核 下载linux内核源码，本文的源码版本是4.4.49，并把压缩包传进到指定路径下 1 2 3 4 5 6 git clone git@git.zhlh6.cn:beagleboard/linux.git cd linux git checkout 4.4.49-ti-rt-r89 -b bbb_linux cp arch/arm/configs/bb.org_defconfig .config make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage dtbs 编译完成后在./arch/arm/boot/下有zImage文件以及dts文件夹 编译内核模块 因为在后续的使用过程中发现，spi1和sound card的口冲突了导致spi1不能用，所以在编译之前取消sound card模块的加载 1 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig 选择Device Drivers —\u003e \u003c M \u003e Sound card support — 使用空格键取消,变成\u003c \u003e Sound card support — 然后保存退出，编译ls 1 make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:4:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"下载文件系统rootfs ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:5:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"Debian8 User Password debian temppwd root root 路径：/mnt/DATA/bb-linux 下载debian8系统 1 2 wget -c https://rcn-ee.com/rootfs/eewiki/minfs/debian-8.7-minimal-armhf-2017-01-14.tar.xz wget -c https://rcn-ee.com/rootfs/eewiki/minfs/debian-8.7-minimal-armhf-2017-01-14.tar.xz.sha256sum 验证sha256sum 1 2 zyh@002237:/mnt/DATA/bb-linux$ sha256sum debian-8.7-minimal-armhf-2017-01-14.tar.xz 5cca3d448432557d275fac694d50f708338d1aa621976ea3fa40fb71d44ba024 debian-8.7-minimal-armhf-2017-01-14.tar.xz 解压 1 tar xf debian-8.7-bare-armhf-2017-01-14.tar.xz 解压后进入目录可以看到下面的文件 1 2 zyh@002237 debian-8.7-minimal-armhf-2017-01-14 $ ls armhf-rootfs-debian-jessie.tar image-builder.project user_password.l 其中user_password.list中存放的是用户名和密码 1 2 zyh@002237 debian-8.7-minimal-armhf-2017-01-14 $ cat user_password.list debian:temppwd ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:5:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"ubuntu16.04 可以下载 1 2 3 wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04-minimal-armhf-2018-07-14.tar.xz wget -c https://rcn-ee.com/rootfs/eewiki/minfs/ubuntu-18.04-minimal-armhf-2018-07-14.tar.xz.sha256sum 校验一下 1 sha256sum ubuntu-18.04-minimal-armhf-2018-07-14.tar.xz 校验的结果如下： 1 2e401950d75cbf5a6250b8c29a0fbf935f31c49c5373daca77d15903fdbcdb3c ubuntu-18.04-minimal-armhf-2018-07-14.tar.xz 解压即可 1 tar xf ubuntu-18.04-minimal-armhf-2018-07-14.tar.xz 在ubuntu上可以使用输入用户名Ubuntu,密码temppwd即可。 烧录Linux镜像到SD卡中 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:5:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"准备烧写sd卡 查看microSD卡 插上tf／sd卡之前： 1 2 zyh@002237 ~ $ ls /dev/sd* /dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdb1 /dev/sdb2 插上tf／sd卡之后： 1 2 zyh@002237 ~ $ ls /dev/sd* /dev/sda /dev/sda1 /dev/sda2 /dev/sdb /dev/sdb1 /dev/sdb2 /dev/sdc /dev/sdc1 SD卡有两个分区 /dev/sdc 和 /dev/sdc1 或者使用 lsblk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 zyh@002237 rootfs $ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT loop0 7:0 0 65.1M 1 loop /snap/gtk-common-themes/1515 loop1 7:1 0 40K 1 loop /snap/cpufetch/31 loop2 7:2 0 64.8M 1 loop /snap/gtk-common-themes/1514 loop3 7:3 0 548K 1 loop /snap/gnome-logs/103 loop5 7:5 0 2.2M 1 loop /snap/gnome-system-monitor/157 loop6 7:6 0 2.5M 1 loop /snap/gnome-system-monitor/163 loop8 7:8 0 61.7M 1 loop /snap/core20/1026 loop9 7:9 0 2.5M 1 loop /snap/gnome-calculator/884 loop10 7:10 0 4M 1 loop /snap/gnome-calculator/406 loop11 7:11 0 276K 1 loop /snap/gnome-characters/708 loop12 7:12 0 55.5M 1 loop /snap/core18/1997 loop13 7:13 0 99.2M 1 loop /snap/core/10958 loop14 7:14 0 219M 1 loop /snap/gnome-3-34-1804/66 loop16 7:16 0 162.9M 1 loop /snap/gnome-3-28-1804/145 loop17 7:17 0 99.4M 1 loop /snap/core/11316 loop18 7:18 0 55.5M 1 loop /snap/core18/2074 loop19 7:19 0 548K 1 loop /snap/gnome-logs/106 loop20 7:20 0 704K 1 loop /snap/gnome-characters/726 loop21 7:21 0 219M 1 loop /snap/gnome-3-34-1804/72 loop22 7:22 0 243.9M 1 loop /snap/gnome-3-38-2004/39 loop23 7:23 0 164.8M 1 loop /snap/gnome-3-28-1804/161 sda 8:0 0 931.5G 0 disk ├─sda1 8:1 0 100G 0 part └─sda2 8:2 0 831.5G 0 part /mnt/DATA sdb 8:16 0 111.8G 0 disk ├─sdb1 8:17 0 512M 0 part /boot/efi └─sdb2 8:18 0 111.3G 0 part / 打开TF卡查看数据 1 sudo hexdump -n 1048576 /dev/sdc 擦除microSD卡 1 sudo dd if=/dev/zero of=/dev/sdc bs=1M count=10 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:6:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"安装固件 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"安装u-boot 1 2 sudo dd if=/mnt/DATA/bb-linux/u-boot/MLO of=/dev/sdb count=1 seek=1 bs=128k sudo dd if=/mnt/DATA/bb-linux/u-boot/u-boot.img of=/dev/sdb count=2 seek=1 bs=384k ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:1","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"增加新分区 检查sfdisk的版本 1 2 sudo sfdisk --version #sfdisk from util-linux 2.31.1 ​ 如果sfdisk \u003e=2.26.x 1 2 3 sudo sfdisk /dev/sdc \u003c\u003c-__EOF__ 4M,,L,* __EOF__ ​ 如果sfdisk \u003c=2.25.x 1 2 3 sudo sfdisk --unit M /dev/sdc \u003c\u003c-__EOF__ 4M,,L,* __EOF__ 如果命令过程中出现 1 2 3 4 5 Checking that no-one is using this disk right now ... FAILED This disk is currently in use - repartitioning is probably a bad idea. Umount all file systems, and swapoff all swap partitions on this disk. Use the --no-reread flag to suppress this check. sfdisk: Use the --force flag to overrule all checks. ​ 那么先卸载 1 sudo umount /dev/sdc1 格式化分区 因为mkfs.ext4 1.43的原因 ，必须确保关掉metadata_csum和64bit 1 2 3 sudo mkfs.ext4 -V #mke2fs 1.42.13 (17-May-2015) #使用 EXT2FS Library version 1.42.13 ​ 如果mkfs.ext4 \u003e=1.43 1 sudo mkfs.ext4 -L rootfs -O ^metadata_csum,^64bit /dev/sdc1 ​ 如果mkfs.ext4 \u003c=1.42 1 sudo mkfs.ext4 -L rootfs /dev/sdc1 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:2","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"挂载分区 1 2 sudo mkdir -p /media/rootfs/ sudo mount /dev/sdc1 /media/rootfs/ 备份一下u-boot 1 2 3 sudo mkdir -p /media/rootfs/opt/backup/uboot/ sudo cp -v /mnt/DATA/bb-linux/u-boot/MLO /media/rootfs/opt/backup/uboot sudo cp -v /mnt/DATA/bb-linux/u-boot/u-boot.img /media/rootfs/opt/backup/uboot 如果想清除在eMMC里旧的u-boot,那么增加u-Env.txt一下内容 uEnv.txt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ##This will work with: Angstrom's 2013.06.20 u-boot. loadaddr=0x82000000 fdtaddr=0x88000000 rdaddr=0x88080000 initrd_high=0xffffffff fdt_high=0xffffffff #for single partitions: mmcroot=/dev/mmcblk0p1 loadximage=load mmc 0:1 ${loadaddr} /boot/vmlinuz-${uname_r} loadxfdt=load mmc 0:1 ${fdtaddr} /boot/dtbs/${uname_r}/${fdtfile} loadxrd=load mmc 0:1 ${rdaddr} /boot/initrd.img-${uname_r}; setenv rdsize ${filesize} loaduEnvtxt=load mmc 0:1 ${loadaddr} /boot/uEnv.txt ; env import -t ${loadaddr} ${filesize}; loadall=run loaduEnvtxt; run loadximage; run loadxfdt; mmcargs=setenv bootargs console=tty0 console=${console} ${optargs} ${cape_disable} ${cape_enable} root=${mmcroot} rootfstype=${mmcrootfstype} ${cmdline} uenvcmd=run loadall; run mmcargs; bootz ${loadaddr} - ${fdtaddr}; 然后拷贝进 1 sudo cp ./uEnv.txt /media/rootfs/ ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:3","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"安装linux 内核和文件系统 为了bbb用户知道用的是什么版本的系统，那么作如下操作,x为具体的版本号，Z为型号 1 2 3 export kernel_version=4.4.x.Z export kernel_version=4.4.49-ti-rt-r89 拷贝文件系统 1 2 3 4 sudo tar xfvp /mnt/DATA/bb-linux/*-*-*-armhf-*/armhf-rootfs-*.tar -C /media/rootfs/ sync sudo chown root:root /media/rootfs/ sudo chmod 755 /media/rootfs/ 在/boot/uEnv.txt里设置uname_r 1 sudo sh -c \"echo 'uname_r=${kernel_version}' \u003e\u003e /media/rootfs/boot/uEnv.txt\" 拷贝内核镜像 1 sudo cp -v /mnt/DATA/bb-linux/linux/arch/arm/boot/zImage /media/rootfs/boot/vmlinuz-${kernel_version} 拷贝内核 Device Tree Binaries(dts) 1 2 sudo mkdir -p /media/rootfs/boot/dtbs/${kernel_version}/ sudo cp /mnt/DATA/bb-linux/linux/arch/arm/boot/dts/am335x-boneblack.dtb /media/rootfs/boot/dtbs/${kernel_version}/ 拷贝内核模块Kernel Modules 1 2 cd /mnt/DATA/bb-linux/linux/ sudo make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- modules_install INSTALL_MOD_PATH=/media/rootfs File Systems Table(/etc/fstab) 1 sudo sh -c \"echo '/dev/mmcblk0p1 / auto errors=remount-ro 0 1' \u003e\u003e /media/rootfs/etc/fstab\" ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:4","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"其他配置 网络设置 1 sudo vim /media/rootfs/etc/network/interfaces 增加以下内容： /media/rootfs/etc/network/interfaces 1 2 3 4 5 auto lo iface lo inet loopback auto eth0 iface eth0 inet dhcp 为了使能Ethernet为eth0 1 sudo vim /media/rootfs/etc/udev/rules.d/70-persistent-net.rules 增加以下内容： /media/rootfs/etc/udev/rules.d/70-persistent-net.rules 1 2 # BeagleBone: net device () SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", ATTR{dev_id}==\"0x0\", ATTR{type}==\"1\", KERNEL==\"eth*\", NAME=\"eth0\" 更新microSD卡系统的源 1 sudo vim /media/rootfs/etc/apt/source.list 更改为以下内容 1 2 3 4 5 6 deb http://mirrors.ustc.edu.cn/debian jessie main contrib non-free deb-src http://mirrors.ustc.edu.cn/debian jessie main contrib non-free deb http://mirrors.ustc.edu.cn/debian jessie-proposed-updates main contrib non-free deb-src http://mirrors.ustc.edu.cn/debian jessie-proposed-updates main contrib non-free deb http://mirrors.ustc.edu.cn/debian jessie-updates main contrib non-free deb-src http://mirrors.ustc.edu.cn/debian jessie-updates main contrib non-free 同步microSD卡，让文件写入microSD卡,并且卸载microSD卡，至此，系统基本能跑通了。 1 2 sync sudo umount /media/rootfs 参考 beaglebone AI环境搭建与运行 BeagleBone Black的内核移植-从零开始制作镜像 BeagleBoneBlack学习（1）——启动流程与u-boot编译 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/:7:5","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:BeagleBone black 镜像制作","uri":"/posts/embedded/developmentboard/beagleboneblack/beagleboneblac%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"},{"categories":["Embedded"],"content":"RK3399 RKNN","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 RKNN RKNN API RKNN 模型转换工具 RKNN-Toolkit API 使用 TB-RK1808S0 工作模式 使用问题 版本问题 论坛提问 其他 RKNN ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:0:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"RKNN API 应用程序只需要包含该头文件和动态库,就可以编写相关的 AI 应用。 RKNNAPI 的 定 义 在 ：rknn_api_sdk/rknn_api/include/rknn_api.h RKNN API 的 动 态 库 路 径 为：rknn_api_sdk/rknn_api/lib64/librknn_api.so ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:1:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"RKNN 模型转换工具 《RKNN-Toolkit 使用指南》 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:2:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"RKNN-Toolkit RKNN-Toolkit 是为用户提供在 PC、RK3399Pro、RK1808 或 RK3399Pro Linux 开发板上进行模型转换、推理和性能评估的开发套件,用户通过提供的 python 接口可以便捷地完成以下功能: 模型转换:支持 Caffe、TensorFlow、TensorFlow Lite、ONNX、Darknet 模型转成 RKNN模型,支持 RKNN 模型导入导出,后续能够在硬件平台上加载使用。 模型推理:能够在 PC 上模拟运行模型并获取推理结果;也可以在指定硬件平台 RK3399Pro(或 RK3399Pro Linux 开发板)、RK1808 上运行模型并获取推理结果。 性能评估:能够在 PC 上模拟运行并获取模型总耗时及每一层的耗时信息;也可以通过联机调试的方式在指定硬件平台 RK3399Pro、RK1808 上运行模型,或者直接在 RK3399Pro Linux 开发板上运行,以获取模型在硬件上完整运行一次所需的总时间和每一层的耗时情况。 获取模型运行时的内存使用情况:通过联机调试的方式获取模型在指定硬件平台RK3399Pro、RK1808或RK3399ProLinux开发板上运行时的内存使用情况。 API 使用 1 2 intr knn_init(rknn_context*context,void*model,uint32_tsize,uint32_tflag); int rknn_init2(rknn_context*context,void*model,uint32_tsize,uint32_tflag,rknn_init_extend*extend); adb devices 进行查询 devices ID 1 2 3 4 5 char* device_id = \"7d58b18e7599c7a4\"; rknn_init_extend temp; temp.device_id = device_id; // ======================== Init model =========================== ret = rknn_init2(\u0026ctx, model, model_len, RKNN_FLAG_PRIOR_MEDIUM,\u0026temp); 封装函数,先判断lsusb 结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool exeShellCmd(const string \u0026cmd, vector\u003cstring\u003e \u0026results) { int bufferSize = 10240; //10KB应该是非常充足了 char *buffer = new char[bufferSize]; FILE *pFile = NULL; if (NULL == (pFile = popen(cmd.c_str(), \"r\"))) { printf(\"execute shell command error \\n\"); return false; } while (NULL != fgets(buffer, bufferSize, pFile)) { buffer[strlen(buffer) - 1] = '\\0'; //fgets() 会自动在末尾加入换行符，linux 下换行符就是 \\r(CR)，这里把自动添加的换行符去掉 results.emplace_back(buffer); } delete[] buffer; pclose(pFile); return true; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 FILE *p_file = NULL; string cmd = \"lsusb | grep 2207:0018\"; vector\u003cstring\u003e cmd_results; if (exeShellCmd(cmd, cmd_results)) { if (cmd_results.size()) { printf(\"\u003e\u003e External TB-RK1808S0 Attached !\\n\"); rknn_devices_id rknn_devices; rknn_find_devices(\u0026rknn_devices); init_extend.device_id = rknn_devices.ids[0]; printf(\"--\u003e %d \", rknn_devices.n_devices); printf(\"-- %s \", rknn_devices.types[0]); printf(\"-- %s \", rknn_devices.ids[0]); printf(\"\\n\"); } else { init_extend.device_id = NULL; printf(\"\u003e\u003e NO External TB-RK1808S0 !\\n\"); } } else { init_extend.device_id = NULL; printf(\"\u003e\u003e NO External TB-RK1808S0 !\\n\"); } // ======================== Init model =========================== ret = rknn_init2(\u0026ctx, model, model_len, RKNN_FLAG_PRIOR_MEDIUM, ((NULL == init_extend.device_id) ? (NULL) : (\u0026init_extend))); TB-RK1808S0 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:2:1","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"工作模式 1、被动模式，arm平台只限制RK公司的rk3399和rk3399pro两颗芯片平台；其它arm芯片不支持。建议采用主动模式； 2、主动模式采用socket通信，上位机linux能支持rndis即可，如果不支持，内核配置一下rndis，如附图。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:3:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"使用问题 在http://repo.rock-chips.com/rk1808/rknn-api/链接下，有供上位机 C 编程使用的库文件和头文件。 C 编程的具体开发使用请参见《Rockchip_User_Guide_RKNN_API》。 上 位 机 在 执 行 编 译 出 来 的 C 语 言 的 可 执 行 程 序 前 ， 需 要 先 运 行npu_transfer_proxy 和计算棒进行通信,npu_transfer_proxy 的下载链接为http://repo.rock-chips.com/rk1808/npu_transfer_proxy/。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:4:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"版本问题 RKNN-Toolkit ：模型转换工具，算法在用版本 1.4.0 RKNN API : 程序调用API (librknn_api.so)，当前vega 所用版本为1.4.0 （后续直接集成vega） RKNN DRV : 设备驱动，当前RK3399PRO 和 1808 版本不一致,需注意，即RK3399PRO 版本为1.5.0,1808 为 1.4.0 论坛提问 被动模式多计算棒无法使用 RK3399pro + TB-RK1808S0 rknn_find_devices 问题咨询 TB-RK1808S0被动模式咨询 其他 1 2 3 4 5 6 7 8 char devices[512]; find_devices = popen(\"adb devices\", \"r\"); while (fgets(devices, 100, find_devices) != NULL) { printf(\"%s\", devices); } printf(\"\\n\"); 1 sudo mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo/rknn_demo /home/toybrick/Rockchip/zyh/rknn_demo ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/rknn/:5:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 RKNN","uri":"/posts/embedded/developmentboard/rk3399/rknn/"},{"categories":["Embedded"],"content":"RK3399 Thermal (温度控制)","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Thermal 是什么 配置⽅法 Menuconfig配置 Tsadc配置 CPU \u0026 GPU配置 Termal zone 配置 ⽤⼾态接口 常用设置 获取当前温度 关闭温度控制功能 参考 Thermal 是什么 Thermal是内核开发者定义的⼀套⽀持根据指定governor控制系统温度，以防⽌芯⽚过热的框架模型。Thermal framework由governor、core、cooling device、sensor driver组成，软件架构如下： Thermal governor：⽤于决定cooling device是否需要降频，降到什么程度。⽬前Linux4.4内核中包含了如下⼏种governor： power_allocator：引⼊PID（⽐例-积分-微分）控制，根据当前温度，动态给各cooling device分配power，并将power转换为频率，从而达到根据温度限制频率的效果。 step_wise ：根据当前温度，cooling device逐级降频。 fair share ：频率档位⽐较多的cooling device优先降频。 userspace：不限制频率。 Thermal core： 对thermal governors和thermal driver进⾏了封装和抽象，并定义了清晰的接口。 Thermal sensor driver：sensor驱动，⽤于获取温度，⽐如tsadc。 Thermal cooling device：发热源或者可以降温的设备，⽐如CPU、GPU、DDR等。 配置⽅法 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:0:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"Menuconfig配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003c*\u003e Generic Thermal sysfs driver ---\u003e --- Generic Thermal sysfs driver [*] APIs to parse thermal data out of device tree [*] Enable writable trip points Default Thermal governor ( power_allocator ) ---\u003e /* default thermal governor */ [ ] Fair -share thermal governor [ ] Step_wise thermal governor /* step_wise governor */ [ ] Bang Bang thermal governor [*] User_space thermal governor /* user_space governor */ -*- Power allocator thermal governor /* power_allocator governor */ [*] generic cpu cooling support /* cooling device */ [ ] Generic clock cooling support [*] Generic device cooling support /* cooling device */ [ ] Thermal emulation mode support \u003c \u003e Temperature sensor driver for Freescale i.MX SoCs \u003c*\u003e Rockchip thermal driver /* thermal sensor driver */ \u003c \u003e rk_virtual thermal driver \u003c*\u003e rk3368 thermal driver legacy /* thermal sensor driver */ 通过“Default Thermal governor”配置项，可以选择温控策略，开发者可以根据实际产品需求进⾏修改。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:1:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"Tsadc配置 Tsadc在温控中作为thermal sensor，⽤于获取温度，通常需要在DTSI和DTS都做配置。 以RK3399为例，DTSI包括如下配置： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 tsadc : tsadc@ff260000 { compatible = \"rockchip,rk3399-tsadc\" ; reg = \u003c0x0 0xff260000 0x0 0x100 \u003e; /* 寄存器基地址和寄存器地址总⻓度 */ interrupts = \u003cGIC_SPI 97 IRQ_TYPE_LEVEL_HIGH 0\u003e; /* 中断号及中断触发⽅式 */ assigned -clocks = \u003c\u0026 cru SCLK_TSADC \u003e; /* ⼯作时钟，750KHz */ assigned -clock -rates = \u003c750000 \u003e; clocks = \u003c\u0026 cru SCLK_TSADC \u003e, \u003c\u0026 cru PCLK_TSADC \u003e; /* ⼯作时钟和配置时钟 */ clock -names = \"tsadc\" , \"apb_pclk\" ; resets = \u003c\u0026 cru SRST_TSADC \u003e; /* 复位信号 */ reset -names = \"tsadc-apb\" ; rockchip ,grf = \u003c\u0026 grf \u003e; /* 引⽤grf 模块，部分平台需要 */ rockchip ,hw -tshut -temp = \u003c120000 \u003e; /* 过温重启阀值，120 摄⽒度 */ /* tsadc 输出引脚配置，⽀持两种模式：gpio 和otpout */ pinctrl -names = \"gpio\" , \"otpout\" ; pinctrl -0 = \u003c\u0026 otp_gpio \u003e; pinctrl -1 = \u003c\u0026 otp_out \u003e; /* * thermal sensor 标识，表⽰tsadc 可以作为⼀个thermal sensor ， * 并指定了引⽤tsadc 节点的时候需要带⼏个参数。 * 如果SoC ⾥⾯只有⼀个tsadc ，可以设置为0，超过⼀个必须设置为1。 */ #thermal-sensor-cells = \u003c1\u003e; status = \"disabled\" ; }; /* IO 口配置 */ pinctrl : pinctrl { ... tsadc { /* 配置为gpio 模式 */ otp_gpio : otp -gpio { rockchip ,pins = \u003c1 6 RK_FUNC_GPIO \u0026pcfg_pull_none \u003e; }; /* 配置为over temperature protection 模式 */ otp_out : otp -out { rockchip ,pins = \u003c1 6 RK_FUNC_1 \u0026pcfg_pull_none \u003e; }; }; .... } DTS的配置，主要⽤于选择通过CRU复位还是GPIO复位，低电平复位还是⾼电平复位。需要特别注意的是如果配置成GPIO复位，硬件上需要否把tsadc输出引脚连到PMIC的复位脚，否则只能配置成CRU复位。 1 2 3 4 5 \u0026tsadc { rockchip ,hw -tshut -mode = \u003c1\u003e; /* tshut mode 0:CRU 1:GPIO */ rockchip ,hw -tshut -polarity = \u003c1\u003e; /* tshut polarity 0:LOW 1:HIGH */ status = \"okay\" ; }; ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:2:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"CPU \u0026 GPU配置 CPU在温控中作为cooling device，节点中需要包含#cooling-cells、dynamic-power-coefficient属性。 以RK3399为例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 cpu_l0 : cpu@0 { device_type = \"cpu\" ; compatible = \"arm,cortex-a53\" , \"arm,armv8\" ; reg = \u003c0x0 0x0 \u003e; enable -method = \"psci\" ; #cooling-cells = \u003c2\u003e; /* cooling device 标识，表⽰该设备可以作为⼀个cooling device */ clocks = \u003c\u0026 cru ARMCLKL \u003e; cpu -idle -states = \u003c\u0026 CPU_SLEEP \u0026CLUSTER_SLEEP \u003e; dynamic -power -coefficient = \u003c100 \u003e; /* 动态功耗常数C，动态功耗公式为Pdyn=C*V^2*F */ }; ... cpu_b0 : cpu@100 { device_type = \"cpu\" ; compatible = \"arm,cortex-a72\" , \"arm,armv8\" ; reg = \u003c0x0 0x100 \u003e; enable -method = \"psci\" ; #cooling-cells = \u003c2\u003e; /* cooling device 标识，表⽰该设备可以作为⼀个cooling device */ clocks = \u003c\u0026 cru ARMCLKB \u003e; cpu -idle -states = \u003c\u0026 CPU_SLEEP \u0026CLUSTER_SLEEP \u003e; dynamic -power -coefficient = \u003c436 \u003e; /* ⽤于计算动态功耗的参数 */ }; GPU在温控中作为cooling device，节点需要包含#cooling-cells属性和power_model⼦节点。 以RK3399为例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 gpu : gpu@ff9a0000 { compatible = \"arm,malit860\" ,\"arm,malit86x\" ,\"arm,malit8xx\" , \"arm,mali-midgard\" ; reg = \u003c0x0 0xff9a0000 0x0 0x10000 \u003e; interrupts = \u003cGIC_SPI 19 IRQ_TYPE_LEVEL_HIGH 0\u003e, \u003cGIC_SPI 20 IRQ_TYPE_LEVEL_HIGH 0\u003e, \u003cGIC_SPI 21 IRQ_TYPE_LEVEL_HIGH 0\u003e; interrupt -names = \"GPU\" , \"JOB\" , \"MMU\" ; clocks = \u003c\u0026 cru ACLK_GPU \u003e; clock -names = \"clk_mali\" ; #cooling-cells = \u003c2\u003e; /* cooling device 标识，表⽰该设备可以作为⼀个cooling device */ power -domains = \u003c\u0026 power RK3399_PD_GPU \u003e; power -off -delay -ms = \u003c200 \u003e; status = \"disabled\" ; gpu_power_model : power_model { compatible = \"arm,mali-simple-power-model\" ; static -coefficient = \u003c411000 \u003e; /* ⽤于计算静态功耗的参数 */ dynamic -coefficient = \u003c733 \u003e; /* ⽤于计算动态功耗的参数 */ ts = \u003c32000 4700 ( -80 ) 2\u003e; /* ⽤于计算静态功耗的参数 */ thermal -zone = \"gpu-thermal\" ; /* 从gpu-thermal 获取温度，⽤于计算静态功耗 */ }; }; ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:3:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"Termal zone 配置 Termal zone节点主要⽤于配置温控策略相关的参数并⽣成对应的⽤⼾态接口。 以RK3399为例： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 thermal_zones : thermal -zones { /* ⼀个节点对应⼀个thermal zone ，并包含温控策略相关参数 */ soc_thermal : soc -thermal { /* 温度⾼于trip-point-0 指定的值，每隔20ms 获取⼀次温度 */ polling -delay -passive = \u003c20 \u003e; /* milliseconds */ /* 温度低于trip-point-0 指定的值，每隔1000ms 获取⼀次温度 */ polling -delay = \u003c1000 \u003e; /* milliseconds */ /* 温度等于trip-point-1 指定的值时，系统分配给cooling device 的能量 */ sustainable -power = \u003c1000 \u003e; /* milliwatts */ /* 当前thermal zone 通过tsadc0 获取温度 */ thermal -sensors = \u003c\u0026 tsadc 0\u003e; /* trips 包含不同温度阀值，不同的温控策略，配置不⼀定相同 */ trips { /* * 温控阀值，超过该值温控策略开始⼯作，但不⼀定⻢上限制频率， * power 小到⼀定程度才开始限制频率 */ threshold : trip -point -0 { /* 超过70 摄⽒度，温控策略开始⼯作，并且70 摄⽒度也是tsadc 触发中断的⼀个阀值 */ temperature = \u003c70000 \u003e; /* millicelsius */ /* 温度低于temperature-hysteresis 时触发中断，当前未实现，但是框架要求必须填 */ hysteresis = \u003c2000 \u003e; /* millicelsius */ type = \"passive\" ; /* 表⽰超过该温度值时，使⽤polling-delay-passive */ }; /* 温控⽬标温度，期望通过降频使得芯⽚不超过该值 */ target : trip -point -1 { /* 期望通过降频使得芯⽚不超过85 摄⽒度，并且85 摄⽒度也是tsadc 触发中断的⼀个阀值 */ temperature = \u003c85000 \u003e; /* millicelsius */ /* 温度低于temperature-hysteresis 时触发中断，当前未实现，但是框架要求必须填 */ hysteresis = \u003c2000 \u003e; /* millicelsius */ type = \"passive\" ; /* 表⽰超过该温度值时，使⽤polling-delay-passive */ }; /* 过温保护阀值，如果降频后温度仍然上升，那么超过该值后，让系统重启 */ soc_crit : soc -crit { /* 超过115 摄⽒度重启，并且115 摄⽒度也是tsadc 触发中断的⼀个阀值 */ temperature = \u003c115000 \u003e; /* millicelsius */ /* 温度低于temperature-hysteresis 时触发中断，当前未实现，但是框架要求必须填 */ hysteresis = \u003c2000 \u003e; /* millicelsius */ type = \"critical\" ; /* 表⽰超过该温度值时，重启 */ }; }; /* cooling device 配置节点，每个⼦节点代表⼀个cooling device */ cooling -maps { map0 { /* * 表⽰在target trip 下，该cooling device 才起作⽤， * 对于power allocater 策略必须填target */ trip = \u003c\u0026 target \u003e; /* A53 做为cooloing device ， THERMAL_NO_LIMIT 不起作⽤，但必须填 */ cooling -device = \u003c\u0026 cpu_l0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT \u003e; contribution = \u003c4096 \u003e; /* 计算功耗时乘以4096/1024 倍，⽤于调整降频顺序和尺度 */ }; map1 { /* * 表⽰在target trip 下，该cooling device 才起作⽤， * 对于power allocater 策略必须填target */ trip = \u003c\u0026 target \u003e; /* A72 做为cooloing device ， THERMAL_NO_LIMIT 不起作⽤，但必须填 */ cooling -device = \u003c\u0026 cpu_b0 THERMAL_NO_LIMIT THERMAL_NO_LIMIT \u003e; contribution = \u003c1024 \u003e;/* 计算功耗时乘以1024/1024 倍，⽤于调整降频顺序和尺度 */ }; map2 { /* * 表⽰在target trip 下，该cooling device 才起作⽤， * 对于power allocater 策略必须填target */ trip = \u003c\u0026 target \u003e; /* GPU 做为cooloing device ， THERMAL_NO_LIMIT 不起作⽤，但必须填 */ cooling -device = \u003c\u0026 gpu THERMAL_NO_LIMIT THERMAL_NO_LIMIT \u003e; contribution = \u003c4096 \u003e;/* 计算功耗时乘以4096/1024 倍，⽤于调整降频顺序和尺度 */ }; }; }; /* ⼀个节点对应⼀个thermal zone ，并包含温控策略相关参数，当前thermal zone 只⽤于获取温度 */ gpu_thermal : gpu -thermal { /* 包含温控策略配置的情况下才起作⽤，架要求必须填 */ polling -delay -passive = \u003c100 \u003e; /* milliseconds */ /* 每隔1000ms 获取⼀次温度 */ polling -delay = \u003c1000 \u003e; /* milliseconds */ /* 当前thermal zone 通过tsadc1 获取温度 */ thermal -sensors = \u003c\u0026 tsadc 1\u003e; }; }; ⽤⼾态接口 ⽤⼾态接口在/sys/class/thermal/⽬录下，具体内容和DTSI中thermal zone节点的配置对应。有的平台thermalzone节点下只有⼀个⼦节点，对应/sys/class/thermal/⽬录下也只有thermal_zone0⼦⽬录；有的平台有两个⼦节点，对应/sys/class/thermal/⽬录下就会有thermal_zone0和thermal_zone1⼦⽬录。通过⽤⼾态接口可以切换温控策略，查看当前温度等。 以RK3399为例⼦，/sys/class/thermal/thermal_zone0/⽬录下包含如下常⽤的信息： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 temp /* 当前温度 */ available_policies /* ⽀持的温控策略 */ policy /* 当前使⽤的温控策略 */ sustainable_power /* 期望的最⾼温度下对应的power 值 */ integral_cutoff /* PID 算法中I的触发条件：当前温度-期望的最⾼温度\u003cintegral_cutoff */ k_d /* PID 算法中计算D的时候⽤的参数 */ k_i /* PID 算法中计算I的时候⽤的参数 */ k_po /* PID 算法中计算P的时候⽤的参数 */ k_pu /* PID 算法中计算P的时候⽤的参数 */ mode /* enabled ：⾃带定时获取温度，判断是否需要降频。disabled 关闭该功能 */ type /* 当前thermal zone 的类型 */ /* 不同的温度阀值，对应trips 节点的配置 */ trip_point_0_hyst trip_point_0_temp trip_point_0_type trip_point_1_hyst trip_point_1_temp trip_point_1_type trip_point_2_hyst trip_point_2_temp trip_point_2_type /* 不同cooling devic 的状态，对应cooling-maps 节点的配置 */ cdev","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:4:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"获取当前温度 直接查看⽤⼾态接口thermal_zone0或者thermal_zone1⽬录下的temp节点即可。 以RK3399为例，获取CPU温度，在串口中输⼊如下命令： 1 cat /sys /class /thermal /thermal_zone0 /temp 获取GPU温度，在串口中输⼊如下命令： 1 cat /sys /class /thermal /thermal_zone1 /temp ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:5:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"关闭温度控制功能 ⽅法⼀：menuconfig中默认温控策略设置为user_space。 1 2 3 4 5 \u003c*\u003e Generic Thermal sysfs driver ---\u003e --- Generic Thermal sysfs driver [*] APIs to parse thermal data out of device tree [*] Enable writable trip points Default Thermal governor ( user_space ) ---\u003e /* power_allocator 改为user_space */ ⽅法⼆：开机后通过命令关温控。 ⾸先，把温控策略切换到user_space，即把⽤⼾态接口下的policy节点改成user_space；或者把mode设置成 disabled状态；然后，解除频率限制，即将⽤⼾态接口下的所有cdev的cur_state设置为0。 以RK3399为例，策略切换到user_space： 1 echo user_space \u003e /sys /class /thermal /thermal_zone0 /policy 或者把mode设置成disabled状态： 1 echo disabled \u003e /sys /class /thermal /thermal_zone0 /mode 解除频率限制： 1 2 3 4 /* 具体有多少个cdev ，根据实际情况修改 */ echo 0 \u003e /sys /class /thermal /thermal_zone0 /cdev0 /cur_state echo 0 \u003e /sys /class /thermal /thermal_zone0 /cdev1 /cur_state echo 0 \u003e /sys /class /thermal /thermal_zone0 /cdev2 /cur_state 参考 Thermal开发指南 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rk3399/thermal/thermal/:6:0","tags":["Embedded","芯片\u0026开发板","RK3399"],"title":"Embedded:RK3399 Thermal (温度控制)","uri":"/posts/embedded/developmentboard/rk3399/thermal/thermal/"},{"categories":["Embedded"],"content":"RV1126 camera调试常用命令","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126_camera%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera调试常用命令","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126_camera%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 查看图像数据的端点信息 查看系统当前DRM情况 media-ctl 反编译 dtb 文件 查看图像数据的端点信息 1 grep '' /sys/class/video4linux/video*/name ISP： rkisp_mainpath：视频输出 rkisp_selfpath：视频输出 rkisp-statistics：3A 统计 rkisp-input-params：3A 参数设置 查看系统当前DRM情况 1 modetest 输出信息（部分）： 1 2 3 4 5 6 Connectors: id encoder status name size (mm) modes encoders 56 55 connected DSI-1 68x121 1 55 modes: name refresh (Hz) hdisp hss hse htot vdisp vss vse vtot) 720x1280 60 720 768 776 828 1280 1296 1302 1317 65000 flags: nhsync, nvsync; type: preferred, driver Connectors，有1个，代表可以接1个屏幕输出，ID是56。该显示输出的最大分辨率是720x1280，刷新频率60hz； 1 2 3 4 CRTCs: id fb pos size 53 57 (0,0) (720x1280) 720x1280 60 720 768 776 828 1280 1296 1302 1317 65000 flags: nhsync, nvsync; type: preferred, driver CRTCs，有1个，ID是53； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Planes: id crtc fb CRTC x,y x,y gamma size possible crtcs 52 53 57 0,0 0,0 0 0x00000001 formats: XR24 AR24 XB24 AB24 RG24 BG24 RG16 BG16 props: 8 type: flags: immutable enum enums: Overlay=0 Primary=1 Cursor=2 value: 1 50 FEATURE: flags: immutable bitmask values: scale=0x1 alpha=0x2 hdr2sdr=0x4 sdr2hdr=0x8 afbdc=0x10 value: 2 54 0 0 0,0 0,0 0 0x00000001 formats: XR24 AR24 XB24 AB24 RG24 BG24 RG16 BG16 NV12 NV16 NV24 props: 8 type: flags: immutable enum enums: Overlay=0 Primary=1 Cursor=2 value: 0 50 FEATURE: flags: immutable bitmask values: scale=0x1 alpha=0x2 hdr2sdr=0x4 sdr2hdr=0x8 afbdc=0x10 value: 3 Planes，有2个，代表有2个图层，ID分别是52、54。 plane 52当前type值是1，代表是Primary层；plane 54当前type值是0，代表是Overlay层； 可以用指令测试屏幕输出显示： 1 modetest -s 56@53:720x1280@RG24 57，对应Connectors ID； 54，对应CRTCs ID； 720x1280，输出最大分辨率； RG24，代表RGB888，每个像素点24bit，R/G/B各8bit； media-ctl media-ctl 命令找到 ISPP 节点 rkispp_scale0 1 media-ctl -p -d /dev/media2 | grep \"rkispp_scale0\" 反编译 dtb 文件 1 dtc -I dtb -O dts -o rv1126-evb-test.dts rv1126-evb-ddr3-v13-uvc.dtb ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126_camera%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera调试常用命令","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126_camera%E8%B0%83%E8%AF%95%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["Embedded"],"content":"RV1126 camera驱动相关阅读笔记","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ISP20应用开发参考 RKISP 驱动 CIS(cmos image sensor)驱动 VCM驱动 FlashLight驱动 FOCUS ZOOM P-IRIS驱动 DC-IRIS驱动 RK-IRCUT驱动 ISP 系统调优 线性模式图像质量调优 HDR 模式图像质量调优 其他 文档地址：/rv1126_rv1109_linux_201230/docs/RV1126_RV1109/Camera ISP20应用开发参考 文档：Rockchip_Instruction_Linux_Application_ISP20_CN.pdf ISP20 源码路径： camera_engine_rkaiq/hwi/isp20 介绍如何获取Camera数据流以及RkAiq 3A Server独立进程。 ISP20可以输出四路数据流 entity name video id max width support output fmt rkispp_m_bypass /dev/video13 不支持设置分辨率,不支持缩放 NV12/NV16/YUYV/FBC0/FBC2/ rkispp_scale0 /dev/video14 max width: 3264, 最大支持 8 倍缩放 NV12/NV16/YUYV rkispp_scale1 /dev/video15 max width: 1280, 最大支持 8 倍缩放 NV12/NV16/YUYV rkispp_scale2 /dev/video16 max width: 1280, 最大支持 8 倍缩放 NV12/NV16/YUYV RKISP 驱动 文档： 视频： RKISP驱动主要是依据v4l2 / media framework实现硬件的配置、中断处理、控制 buffer轮转,以及控制subdevice(如 mipi dphy及sensor)的上下电等功能。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"CIS(cmos image sensor)驱动 多sensor 注册 sensor0-\u003ecsi_dphy0-\u003ecsi2-\u003ecif-\u003eisp0-\u003eispp0 sensor1-\u003ecsi_dphy1-\u003eisp1-\u003eispp1 实例参考arch/arm/boot/dts/rv1109-evb-ddr3-v12-facial-gate.dts gc2053-\u003ecsi_dphy0-\u003ecsi2-\u003ecif-\u003eisp1-\u003eispp1 ov2718-\u003ecsi_dphy1-\u003eisp0-\u003eispp0 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"VCM驱动 VCM： 即音圈电机，利用法拉第定律，通过改变马达线圈电流的大小，改变产生的电磁力大小，来控制弹簧片的拉伸位置，从而带动LENSE的运动。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"FlashLight驱动 闪光灯 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"FOCUS ZOOM P-IRIS驱动 P-IRIS是通过控制P-IRIS镜头中的步进电机动态精确的控制光圈大小。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"DC-IRIS驱动 自动光圈能够根据光线亮度的变化自动调节光圈孔。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"RK-IRCUT驱动 IR-CUT双滤镜是指在摄像头镜头组里内置了一组滤镜，当镜头外的红外感应点侦测到光线的强弱变化后，内置的IR-CUT自动切换滤镜能够根据外部光线的强弱随之自动切换，使图像达到最佳效果。 ISP 系统调优 文档 ：Rockchip_Tuning_Guide_ISP2x_CN_v1.5.0.pdf ISP模块支持标准的Sensor图像数据处理,包括自动白平衡,自动曝光,Demosaic,坏点矫正及镜头阴影矫正等基本功能,也支持HDR、去雾、降噪等高级处理功能。 Demosaic模块 Sensor输出RAW数据后，需要经过Demosaic模块（ISP中）将其转成RGB图像。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:6:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"线性模式图像质量调优 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:7:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"HDR 模式图像质量调优 其他 ISP（Image Signal Process） （1）BLC（Black Level Correction）/ Black Level Compensate (OBC) ：黑电平校正。 （2）DPC/BPD（Defect Pixel Correction/Bad Pixel Detect）：坏点校正/坏点检测。 （3）FPN（Fix Pattern Noise）：固定模式噪声。 （4）LSC（Lens Shading Correction）/Color Shading ：阴影校正。 （5）Flare offset：光学上称Flare也叫stray light,耀斑补偿。 （6）AE（Auto Exposure）：自动曝光。 （7）AF（Auto Focus）：自动对焦。 （8）AWB（Auto White Balance ）：自动白平衡。解决环境光不同色温导致整幅图片偏色的情况。 （9）DM（Demosaicing/Color Filter Array Interpolation/CFA插值）：CMOS Sensor出来的RawData是Bayer格式的图像，每个像素只有一个通道的信息。DM是将Bayer格式的图像恢复成每个像素用RGB三通道表示的方式。 （10）CCM（Color Correction Matrix/ DSC color calibration）：颜色校正矩阵。 （11）NR（Noise Reduction/Denoise）：去噪。采用特定的LPF（Low Pass Filter）对图片进行滤波，滤除图像的噪声成分，而Bilateral filtering即双边滤波器，它是一种保护边缘的平滑滤波器，这样既可以滤除噪声，edge又可以保留下来。 （12）EE（Edge Enhancement/Edge Sharpening）：锐化，边缘增强。通过滤波器获取图像的高频分量，按照一定的比例将高频部分和原图进行加权求和获取锐化后的图像。 （13）DRC/HDR（Dynamic Range Compression/ High-Dynamic Range）：宽动态。高动态图像的拍摄出来的结果通常会有，亮部太亮，暗部太暗的问题。DRC是调整图像暗部亮度使之变亮，调整亮部亮度使之变暗，而且保持图像的对比度。 （14）PCA/VDE：Hue，Saturation，Contrast，Brightness调试。单独针对Hue，Saturation，Contrast，Brightness各图像分量进行调节。 （15）Histogram：直方图均衡化。重新分布图片的亮度。使图片的亮度分布更加均匀。 （16）FlashLight Control：闪光灯控制 （17）Cross talk：Optical cross-talk是当主光线进光角度过大，导致光线不能有效地进入本像素的Microlens内，而是进入相邻像素单元或其他无效区域内的现象。 （18）Gradation Control（GDC）：可能是对图像数据精度进行的操作 （19）Scaler：对图像进行缩放，缩放的过程中采样和插值直接影响图像的细节质量。 （20）Adaptive tone scale：(这个没有办法处理多种场景)进来的影像，根据histogram，可以调节，让其明暗亮度的曲线比较好看。 （21）Dynamic Range Compression：就是把暗的地方变亮一些，亮的地方变暗一些。AE的主要目的是避免亮度饱和的pixels，其余exposure的pixel可以通过DRC校准回来。 镜头的结构 Lens-\u003eVCM音圈马达-\u003e底座支架-\u003eSensor-\u003eDriver IC-\u003eoutput interface AF模组通常由镜头，VCM，Sensor，底座，驱动IC以及电源构成。 镜头： 由几片透镜组成，通常有玻璃透镜和塑料透镜 VCM： 即音圈电机，利用法拉第定律，通过改变马达线圈电流的大小，改变产生的电磁力大小，来控制弹簧片的拉伸位置，从而带动LENSE的运动。 Sensor：一般有CCD和CMOS两种，CMOS和CCD相比在制造工艺，能耗水平和成本方面都有优势，业内使用的比较多，CCD在低ISO时对图像细节的刻画比较好，但只有少数厂家生产使用。 底座：用于固定模组; 驱动芯片：用于控制和通信； 电源：常用的有3.3V和2.5V，在使用AF模组时要注意根据说明提供电源。 IR-CUT双滤镜（Infrared-CUT） IR-CUT双滤镜是指在摄像头镜头组里内置了一组滤镜，当镜头外的红外感应点侦测到光线的强弱变化后，内置的IR-CUT自动切换滤镜能够根据外部光线的强弱随之自动切换，使图像达到最佳效果。也就是说，在白天或黑夜下，双滤光片能够自动切换滤镜，因此不论是在白天还是黑夜下，都能得到最佳成像效果。 IR CUT双滤光片切换器的驱动方式和机构多种多样，主要分电感线圈式和电机式： A、电感线圈式又分线圈运动或磁铁运动。线圈驱动方式的体积小，造价低，但驱动力小，自锁能力差，线圈运动的寿命很短，而磁铁运动的寿命很长，钟摆运动方式的相对自锁能力较好，但不能驱动大尺寸滤光片的。 B、电机式又分齿轮齿条式、蜗轮蜗杆式和螺旋副式等。螺旋副式的结构紧凑，动力大，自锁力强，是一种较好的选择。 DC-IRIS 和 P-IRIS DC-IRIS原理及问题： 自动光圈能够根据光线亮度的变化自动调节光圈孔。早期的DC-IRIS只是单纯的根据光线亮度来调节光圈，并没有考虑光圈对其他图像因素（光圈）的影响。DC-IRIS只知道根据光线亮度来打开或关闭光圈，不能提供给摄像机光圈的位置，因此无法有效控制光圈大小以优化图像质量。 P-IRIS工作原理： P-IRIS是通过控制P-IRIS镜头中的步进电机动态精确的控制光圈大小。与DC-IRIS的主要任务是不停的调节光圈大小不同，P-IRIS的主要目的是设置最佳光圈位置，以便大部分镜头中心及效果最佳的部分得到使用，在此位置光学误差大大减小，从而提高图像质量。 P-IrIS需要与增益和曝光时间相配合来管理光线的微小变化从而进一步优化图像质量，使最佳光圈位置保留尽可能长的时间。但超过增益和曝光时间的调节能力时，P-IRIS再调节光圈到不同位置。 HDR模式 HDR是指高动bai态光照渲染（High-Dynamic Range，简称HDR）图像du，相zhi比普通的图像，可以dao提供更多的动态范围zhuan和图像细节，利shu用每个曝光时间相对应最佳细节的LDR图像来合成最终HDR图像，能够更好地反映出真实环境中的视觉效果。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:8:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 camera驱动相关阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/04_camera%E9%A9%B1%E5%8A%A8%E7%9B%B8%E5%85%B3%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"RV1126 USB_Camera应用代码阅读笔记","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 USB Camera 产品 软件框架 smart_display_service mediaserver Mediaserver 介绍 rkmedia uvc_app 其他 USB Camera 产品 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"软件框架 1.main app 对应 /app/smart_display_service :负责 RNDIS 服务端功能实现,命令处理, NN 数据转发等操作; 2.AI app 对应 /app/mediaserver :负责将一路 camera 数据送到 NPU 做对应 NN 算法处理,通过共享内存机制传递给 main app ; 3.uvc app 对应 /external/uvc_app: :负责 UVC camera 完整功能的实现和控制。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"smart_display_service 代码调用逻辑（以调用mediaserver 为例） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 void aiserver_start_nn(char *mode, int value) { int retry_cnt = 0; char *ret; struct UserData* userdata; userdata = dbus_connection(); retry: printf(\"%s: %s \\n\", __FUNCTION__, mode); if (value == 0) { dbus_method_call(userdata-\u003econnection, MEDIASERVER, MEDIASERVER_PATH, MEDIASERVER_INTERFACE, \"Stop\", populate_set, userdata, append_path, mode); } else { dbus_method_call(userdata-\u003econnection, MEDIASERVER, MEDIASERVER_PATH, MEDIASERVER_INTERFACE, \"Start\", populate_set, userdata, append_path, mode); } if (dbus_async(userdata) == -1 \u0026\u0026 retry_cnt++ \u003c 5) goto retry; ret = userdata-\u003ejson_str;smart_display_service dbus_deconnection(userdata); return ret; } 1 2 3 4 5 6 7 8 9 10 11 12 #ifdef USE_MEDIASERVER #define MEDIASERVER \"rockchip.mediaserver.control\" #define MEDIASERVER_PATH \"/rockchip/mediaserver/control/feature\" #define MEDIASERVER_INTERFACE \"rockchip.mediaserver.control.feature\" #endif #define USE_AISERVER \"ON\" #ifdef USE_AISERVER #define MEDIASERVER \"rockchip.aiserver.control\" #define MEDIASERVER_PATH \"/rockchip/aiserver/control/graph\" #define MEDIASERVER_INTERFACE \"rockchip.aiserver.control.graph\" #endif ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"mediaserver ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"Mediaserver 介绍 文档路径：rv1126_rv1109_linux_201230/docs/RV1126_RV1109/ApplicationNote/Rockchip_Instructions_Linux_MediaServer_CN.pdf mediaserver 建立pipe的概念,对单个或者多个通路的media stream进行配置重组,同时提供IPC通信接口,可与web等界面交互。 开发者可通过简单配置,实现下面这些功能的排列组合: 文本流读取、摄像头设备采集、音频设备采集。 音频/视频频编码。 rtsp/rtmp/阿里云推流、云对讲功能、图片上传。 视频文件录制、拍照、音频播放。 支持rockface、rockx、rga等filter插件。 可与web交互 使用方法： 1 2 3 4 5 6 mediaserver [-c config] [-d / -D] [-s / -S] [-h] -c:指定通路配置文件路径 -d:表示不使用dbserver -D:表示使用dbserver里面的默认配置 -s:表示dbus注册在system bus上 -S:表示dbus注册在session bus上 示例: 使用IPC产品,带屏显:mediaserver -c /oem/usr/shared/mediaserver/rv1109/ipc-display.conf 使用IPC产品,不带屏显:mediaserver -c /oem/usr/shared/mediaserver/rv1109/ipc.conf ipc-display.conf 文件路径：rv1126_rv1109_linux_201230/app/mediaserver/src/conf/rv1109/ipc-display.conf 配置文件使用json格式。 Pipe表示一路独立的多媒体通道。 Flow表示一路多媒体通道中的一个Source/IO/Sink单元。 Stream表示FLow使用的处理方法。 Mediaserver 代码分析 USB Camera 中使用相应的config （）文件创建Mediaserver， s卖弄mart_display_service 使用 debus 向 Mediaserver 发送处理指令。 Mediaserver 具有独立的处理能力包含通过V4L2获取图图像，编码和AI处理等。参见上述 ipc-display.conf 中所诉功能。 构建数据处理流 Mediaserver 中配置文件加载路径如下： 1 #define FLOWS_CONF \"/usr/share/mediaserver/mediaserver.conf\" 基于配置文件生成数据处理流的逻辑见： 媒体管道构建 SHM_SERVER 使用共享内存方式将结果（face detect result）同步给main app (smart_display_service)。 在flow 设置回调函数，获取结果。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #ifdef ENABLE_SHM_SERVER auto camera_pipe = GetFlowPipe(0, StreamType::CAMERA); if (camera_pipe) { auto link_flow = camera_pipe-\u003eGetFlow(StreamType::LINK); if (link_flow) link_flow-\u003eSetUserCallBack(nullptr, ShmControl::PushUserHandler); auto rockx_filter = camera_pipe-\u003eGetFlow(StreamType::FILTER, RKMEDIA_FILTER_ROCKX_FILTER); LOG(\"RegisterCallBack ***********rockx_filter=%p\\n\", rockx_filter); if (rockx_filter) rockx_filter-\u003eControl(easymedia::S_NN_CALLBACK, ShmControl::PushUserHandler); } auto file_pipe = GetFlowPipe(0, StreamType::FILE); if (file_pipe) { auto link_flow = file_pipe-\u003eGetFlow(StreamType::LINK); if (link_flow) link_flow-\u003eSetUserCallBack(nullptr, ShmControl::PushUserHandler); } #endif **Mediaserver Dbus 通信 ** 代码位置：rv1126_rv1109_linux_201230/app/mediaserver/src/dbus InitDbusServer mediaserver/src/mediaserver.cpp ： MediaServer::MediaServer() -\u003e InitDbusServer(); DBusServer::RegisteredDBusAdaptor 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int DBusServer::RegisteredDBusAdaptor() { DbusDispatcher(100); DBus::Connection conn = session_ ? DBus::Connection::SessionBus() : DBus::Connection::SystemBus(); conn.request_name(MEDIA_CONTROL_BUS_NAME); media_control_-\u003eConnectDBusServer(conn); if (need_dbserver_) { dbserver_proxy_ = std::make_shared\u003cDBusDbServer\u003e(conn, DBSERVE_PATH, DBSERVE_BUS_NAME); dbserver_listen_.reset(new DBusDbListen(conn)); dbevent_proxy_ = std::make_shared\u003cDBusDbEvent\u003e(conn, DBSERVE_PATH, DBSERVE_BUS_NAME); dbevent_listen_.reset(new DBusDbEventListen(conn)); strorage_proxy_ = std::make_shared\u003cDBusStorageManager\u003e( conn, STORAGE_MANAGER_PATH, STORAGE_MANAGER_BUS_NAME); strorage_listen_.reset(new DBusStorageManagerListen(conn)); ispserver_proxy_ = std::make_shared\u003cDBusIspserver\u003e( conn, ISPSERVER_PATH, ISPSERVER_BUS_NAME); } return 0; } ￼ ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:3:1","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"rkmedia 文档位置：/rv1126_rv1109_linux_201230/docs/RV1126_RV1109/Multimedia/Rockchip_Developer_Guide_Linux_RKMedia_CN.pdf ​ /rv1126_rv1109_linux_201230/docs/RV1126_RV1109/Multimedia/Rockchip_Instructions_Linux_Rkmedia_CN.pdf 代码位置：/rv1126_rv1109_linux_201230/external/rkmedia Mediaserver 和 rkmedia 的关系 Mediaserver 使用 flow 创建多媒体数据流，将音视频的采集，编码，处理能功能模块串联在一起形成应用处理的数据流，实际处理模块的实现是在rkmedia中。 rkmedia 提供了音视频处理相关的接口，包含了VI(输入视频捕获)、VENC(H.265/H.264/JPEG/MJPEG 编码)、VDEC(H.265/H.264/JPEG、MJPEG 解码)、VO(视频输出显示)、RGA视频处理(包括旋转、缩放、裁剪)、AI(音频采集)、AO(音频输出)、AENC(音频编码)、ADEC(音频解码)、MD(移动侦测)、OD(遮挡侦测)等。 flow_manager-\u003eCreatePipes(); CreateFlows 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 int FlowPipe::RegisterCallBack() { auto encoder_flow = GetFlow(StreamType::VIDEO_ENCODER, RKMEDIA_STREAM_NAME_RKMPP); auto draw_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_DRAW_FILTER); if (encoder_flow \u0026\u0026 draw_flow) draw_flow-\u003eControl(easymedia::S_NN_DRAW_HANDLER, encoder_flow.get()); auto detect_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_ROCKFACE_DETECT); if (detect_flow) detect_flow-\u003eControl(easymedia::S_NN_CALLBACK, FlowCallBack); auto body_detect_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_ROCKFACE_BODYDETECT); if (body_detect_flow) body_detect_flow-\u003eControl(easymedia::S_NN_CALLBACK, FlowCallBack); auto face_capture_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_FACE_CAPTURE); if (face_capture_flow) face_capture_flow-\u003eControl(easymedia::S_NN_CALLBACK, FlowCallBack); auto face_recognize_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_ROCKFACE_RECOGNIZE); if (face_recognize_flow) face_recognize_flow-\u003eControl(easymedia::S_NN_CALLBACK, FlowCallBack); auto rockx_flow = GetFlow(StreamType::FILTER, RKMEDIA_FILTER_ROCKX_FILTER); if (rockx_flow) rockx_flow-\u003eControl(easymedia::S_NN_CALLBACK, FlowCallBack); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 void FlowPipe::CreateFlow(std::shared_ptr\u003cFlowUnit\u003e flow_unit) { std::string param; std::string flow_name = flow_unit-\u003eGetFlowName(); std::string flow_param = flow_unit-\u003eFlowParamMapToStr(); std::string stream_param = flow_unit-\u003eStreamParamMapToStr(); auto type = flow_unit-\u003eGetStreamType(); if (type == StreamType::MUXER) { std::string vid_param = \"\"; std::string aud_param = \"\"; std::string flow_index_name = flow_unit-\u003eGetFlowIndexName(); std::string upflow_index_name = flow_unit-\u003eGetUpFlowIndexName(); auto v = SplitStringToVector(upflow_index_name); for (auto name : v) { int upflow_index = GetFlowIndex(name); auto flow_unit = GetFlowunit(upflow_index); StreamType type = flow_unit-\u003eGetStreamType(); if (type == StreamType::VIDEO_ENCODER) vid_param = GetStreamParam(StreamType::VIDEO_ENCODER); else if (type == StreamType::AUDIO_ENCODER) aud_param = GetStreamParam(StreamType::AUDIO_ENCODER); } param = easymedia::JoinFlowParam(flow_param, 2, aud_param, vid_param); } else { param = easymedia::JoinFlowParam(flow_param, 1, stream_param); } LOG_DEBUG(\"flow_name :%s\\n\", flow_name.c_str()); LOG_DEBUG(\"flow_param :\\n%s\\n\", param.c_str()); int reopen_pipe_index = flow_unit-\u003eGetOpenPipeId(); int reopen_flow_index = flow_unit-\u003eGetOpenFlowId(); if (reopen_pipe_index \u003e= 0 \u0026\u0026 reopen_flow_index \u003e= 0) { flow_unit-\u003eSetFlow(nullptr); return; } auto flow = easymedia::REFLECTOR(Flow)::Create\u003ceasymedia::Flow\u003e( flow_name.c_str(), param.c_str()); if (!flow) { LOG_ERROR(\"Create flow %s failed\\n\", flow_name.c_str()); LOG_ERROR(\"flow param :\\n%s\\n\", param.c_str()); exit(EXIT_FAILURE); } if (type == StreamType::VIDEO_ENCODER \u0026\u0026 enable_encoder_debug) easymedia::video_encoder_enable_statistics(flow, 1); flow-\u003eRegisterEventHandler(flow, FlowEventProc); flow_unit-\u003eSetFlow(flow); } mediaserver/src/flows/flow_pipe.cpp 529: auto flow = easymedia::REFLECTOR(Flow)::Createeasymedia::Flow( ​ flow_name.c_str(), param.c_str()); ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:4:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"uvc_app 命令： 查看RNDIS 虚拟网口IP地址 1 ifconfig usb0 其他 RNDIS rndis既是RemoteNDIS，既是远程网络驱动接口规范。 protected: templateprotected: templateRemote Network Driver Interface Specification，既是RemoteNDIS，既是远程网络驱动接口规范。基于USB实现RNDIS实际上就是TCP/IP over USB，就是在USB设备上跑TCP/IP，让USB设备看上去像一块网卡。 ISP ISP(Image Signal Processor)， 即图像信号处理， 主要作用是对前端图像传感器输出的信号做后期处理， 依赖于 ISP 才能在不同的光学条件下都能较好的还原现场细节。 Cmos YUV sensor 的 ISP 处理流程如图所示： 工具： callgraph -f main -d ./main.cpp callgraph -f rndis_initialize_tcp -d ./net/tcp_control.cpp 20171214140255352 callgraph -f handle_callback -d ./event/event_handle.cpp callgraph -f main -d ./mediaserver.cpp callgraph -f main -d ./mediaserver.cpp RegisteredDBusAdaptorprotected: template https://blog.csdn.net/weixin_43503508/category_10257454.html ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/:5:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 USB_Camera应用代码阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/02_usb_camera%E5%BA%94%E7%94%A8%E4%BB%A3%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"},{"categories":["Embedded"],"content":"RV1126 媒体管道构建","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 媒体管道构建 Flow介绍 Flow 类型 Flow 连接管理 连接模式 Flow 枚举 媒体管道构建 文档路径：/rv1126_rv1109_linux_201230/docs/RV1126_RV1109/Multimedia/Rockchip_Instructions_Linux_Rkmedia_CN.pdf : 14.12媒体管道构建 代码路径：/rv1126_rv1109_linux_201230/external/rkmedia/src/flow.cc ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"Flow介绍 Flow是作为media功能模块的再次封装,便于实现模块间的数据通信。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"Flow 类型 Flow可以分为Source类型、IO类型、Sink类型。 Source类型:作为数据源,获取数据(读文件/V4L2节点等)封装为MediaBuff,然后送给下级Flow。不存在上级Flow。如:file_read_flow、source_stream等。 IO类型:对输入的MediaBuff进行处理,然后输出给下级Flow。支持多个入口和多个出口。如:file_write_flow、output_stream Sink类型:作为数据通路的最后一级Flow,此类型Flow无下级Flow。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"Flow 连接管理 Flow 连接： Flow使用如下接口将多个Flow串联成一个数据管道(Pipeline)。 1 bool AddDownFlow(std::shared_ptr\u003cFlow\u003e down, int out_slot_index,int in_slot_index_of_down); 参数说明: down:下级Flow指针 out_slot_index:当前Flow输出接口ID,比如Flow有两个入口,那么ID分别为0,1 in_slot_index_of_down:下级Flow出入接口ID,比如Flow有3个入口,那么ID分别为0,1,2 函数说明: 该接口建立Flow之间的出口与入口绑定关系,通过out_slot_index指定当前Flow选择哪个出口,通过in_slot_index_of_down选择下级Flow的哪个入口,然后将二者连接起来。连接后数据将按照既定连接传递数据。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:3:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"连接模式 一对一模式 FileSourceFlow -\u003e FileSinkFlow 1 2 // 将file_src_flow的0出口绑定到file_sink_flow的0入口 file_src_flow-\u003eAddDownFlow(file_sink_flow, 0, 0); VideoEncoderFlow -\u003e MuxerFlow; AudioEncoderFlow -\u003e MuxerFlow 1 2 3 4 5 6 // 将video_enc_flow的0出口绑定到muxer_flwo的0入口 // MuxerFlow的0入口为视频码流输入口。 video_enc_flow-\u003eAddDownFlow(muxer_flwo, 0, 0); // 将audio_enc_flow的0出口绑定到muxer_flwo的1入口 // MuxerFlow的1入口为音频码流输入口。 audeo_enc_flow-\u003eAddDownFlow(muxer_flwo, 0, 1); 一对多模式 一个FileSourceFlow接两个FileSinkFlow 1 2 3 4 // 将file_src_flow的0出口绑定到file_sink_flow0的0入口 file_src_flow-\u003eAddDownFlow(file_sink_flow0, 0, 0); // 将file_src_flow的0出口绑定到file_sink_flow1的0入口 file_src_flow-\u003eAddDownFlow(file_sink_flow1, 0, 0); 这种模式下,FileSourceFlow仅发送一个MediaBuff给下级Flow,下级的两个FileSinkFlow拿到的是同一个MediaBuff,MediaBuff的引用加一。上图使用场景,下级Flow生成了两个相同的上级Flow的副本。 Flow 断开连接： 1 void RemoveDownFlow(std::shared_ptr\u003cFlow\u003e down); 参数说明: down:下级Flow的指针。 注:Flow连接时,为避免丢失数据,最好是最后连接数据源Flow;Flow断开连接时,最好优先断开数据源头Flow。 比如FileSourceFlow -\u003e VideoEncFLow -\u003e FileSinkFlow连接: 连接: 1 2 3 VideoEncFLow-\u003eAddDownFlow(FileSinkFlow, 0, 0); // 最后连接数据源头 FileSourceFlow -\u003eAddDownFlow(VideoEncFLow, 0, 0); 断开: 1 2 3 // 优先断开数据源头 FileSourceFlow-\u003eRemoveDownFlow(VideoEncFLow); VideoEncFLow-\u003eRemoveDownFlow(FileSinkFlow); Flow传输模式: Flow的模式决定了Flow数据传递是否启用线程。支持如下传输模式: 同步模式(SYNC) Flow内部不会创建线程,上级Flow递交数据给当前Flow时,会等待当前Flow处理完毕后才返回。 异步模式(ASYNCCOMMON) Flow内部会创建线程,上级Flow递交的数据直接放当前Flow的输入缓冲区就立即返回。当前Flow创建的线程将从输入缓冲区获取数据,处理后在发给下级Flow。 固定时长异步模式(ASYNCATOMIC) 与“异步模式”类似,但是输入缓冲区只有一个,当前Flow内部的线程会固定时间间隔从输入缓冲区取数据。 多数Flow的传输模式是固定的,少数Flow可通过创建Flow时,指定KEK_THREAD_SYNC_MODEL来选择,比如创建Flow的字符串中加入:“KEK_THREAD_SYNC_MODEL=asynccommon” ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:3:1","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"Flow 枚举 audio_enc 功能:音频编码器封装,支持vorbis/aac/mp2/g711a/g711u/g726 源码:audio_encoder_flow.cc 范例:audio_encoder_flow_test.cc 类型:IO 类型,1入1出 file_read_flow 功能:读本地文件 源码:file_flow.cc 范例:video_encoder_flow_test.cc 类型:Source类型,0入1出。 file_write_flow 功能:写本地文件。 源码:file_flow.cc 范例:video_encoder_flow_test.cc 类型:Sink类型,1入0出 filter 功能:一种IO类型的Flow,对输入数据处理后发送给后级的Flow,支持rga/rknn等 源码:filter_flow.cc 范例:rga_filter_flow_test.cc 类型:IO类型,支持多入多出(根据实际使用场景来定) live555_rtsp_server 功能:基于live555构建的rtsp服务器 源码:rtsp_server.cc 范例:rtsp_multi_server_test.cc# USB Camera 产品 源码:move_detection_flow.cc 范例:move_detection_flow_test.cc 类型:Sink类型,1入0出 muxer_flow 功能:媒体封装,支持MP4/AVI/MPEG-PS/MPEG-TS/FLV/MKV源码:muxer_flow.cc 范例:muxer_flow_test.cc 类型:IO类型,2入1出 output_stream 功能:封装所有输出源,比如drm_output_stream、alsa_playback_stream等 源码:output_stream_flow.cc 范例:drm_display_test.cc 类型:Sink类型,1入0出。 source_stream 功能:封装所有数据发生源,比如alsa_capture_stream、v4l2_capture_stream等 源码:source_stream_flow.cc 范例:audio_loop_test.cc 类型:Source类型,0入1出 video_dec 功能:视频解码,支持H265/H264/JPEG 源码:decoder_flow.cc 范例:video_decoder_flow_test.cc 类型:IO类型,1入1出 video_enc 功能:视频编码,支持H265/H264/JPEG 源码:video_encoder_flow.cc 范例:video_encoder_flow_test.cc 类型:IO类型,1入1出 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/:4:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 媒体管道构建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/03_%E5%AA%92%E4%BD%93%E7%AE%A1%E9%81%93%E6%9E%84%E5%BB%BA/"},{"categories":["Embedded"],"content":"RV1126 开发板使用记录","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 开发环境搭建 FTP 下载 RV1126/RV1109 Linux SDK ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"搭建编译环境 1 2 3 4 5 6 7 8 9 sudo apt-get install repo git-core gitk git-gui gcc-arm-linux-gnueabihf \\ u-boot-tools device-tree-compiler gcc-aarch64-linux-gnu mtools parted \\ libudev-dev libusb-1.0-0-dev python-linaro-image-tools linaro-image-tools \\ autoconf autotools-dev libsigsegv2 m4 intltool libdrm-dev curl sed make \\ binutils build-essential gcc g++ bash patch gzip gawk bzip2 perl tar \\ cpio python unzip rsync file bc wget libncurses5 libqt4-dev libglib2.0-dev \\ libgtk2.0-dev libglade2-dev cvs git mercurial rsync openssh-client \\ subversion asciidoc w3m dblatex graphviz python-matplotlib libc6:i386 \\ libssl-dev expect fakeroot cmake flex bison liblz4-tool libtool keychain 1 sudo apt-get install lib32gcc-7-dev g++-7 libstdc++-7-dev 编译 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"编译问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 2021-03-08T14:35:37 --2021-03-08 14:35:37-- https://www.openssl.org/source/openssl-1.1.1h.tar.gz 2021-03-08T14:35:37 Connecting to 127.0.0.1:46635... failed: Connection refused. 2021-03-08T14:35:37 --2021-03-08 14:35:37-- http://sources.buildroot.net/openssl-1.1.1h.tar.gz 2021-03-08T14:35:37 Connecting to 127.0.0.1:46635... failed: Connection refused. 2021-03-08T14:35:37 package/pkg-generic.mk:166: recipe for target '/mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/build/host-libopenssl-1.1.1h/.stamp_downloaded' failed 2021-03-08T14:35:37 make[1]: *** [/mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/build/host-libopenssl-1.1.1h/.stamp_downloaded] Error 1 2021-03-08T14:35:37 /mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/Makefile:16: recipe for target '_all' failed 2021-03-08T14:35:37 make: *** [_all] Error 2 Command exited with non-zero status 1 you take 29:55.47 to build builroot ERROR: Running build_buildroot failed! ERROR: exit code 1 from line 348: /usr/bin/time -f \"you take %E to build builroot\" $COMMON_DIR/mk-buildroot.sh $BOARD_CONFIG zyh@zyh rv1126_rv1109_linux_201230 $ cat /etc/profile 这里是代理问题的锅 1 2 3 4 5 $ env|grep -I proxy http_proxy=http://127.0.0.1:8118 ftp_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 我们需要把/etc/profile中的代理注释掉在进行 以下操作 1 2 3 unset http_proxy unset ftp_proxy unset https_proxy 重新编译 部分buildroot 修改（非必要） ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"修改HOSTNAME device/rockchip/rv1126_rv1109/BoardConfig-uvcc.mk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Kernel defconfig export RK_KERNEL_DEFCONFIG=rv1126_defconfig # Kernel defconfig fragment export RK_KERNEL_DEFCONFIG_FRAGMENT= # EMMC EVB BOARD Kernel dts export RK_KERNEL_DTS=rv1126-evb-ddr3-v13 # Logic/npu/vepu merge emmc board kernel dts #export RK_KERNEL_DTS=rv1126-ai-cam-ddr3-v1 # NPU 800m+ logic separate from npu/vepu emmc board kernel dts #export RK_KERNEL_DTS=rv1126-ai-cam-plus # boot image type export RK_BOOT_IMG=zboot.img # kernel image path export RK_KERNEL_IMG=kernel/arch/arm/boot/zImage # parameter for GPT table export RK_PARAMETER=parameter-buildroot-fit.txt # Buildroot config export RK_CFG_BUILDROOT=rockchip_rv1126_rv1109_uvcc ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:3:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"其他修改 kernel/arch/arm/configs/rv1126_defconfig 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 zyh@zyh kernel (default) $ git diff arch/arm/configs/rv1126_defconfig diff --git a/arch/arm/configs/rv1126_defconfig b/arch/arm/configs/rv1126_defconfig old mode 100644 new mode 100755 index e70409b5a527..78f0aef08ac0 --- a/arch/arm/configs/rv1126_defconfig +++ b/arch/arm/configs/rv1126_defconfig @@ -211,6 +211,10 @@ CONFIG_MEDIA_SUPPORT=y CONFIG_MEDIA_CAMERA_SUPPORT=y CONFIG_MEDIA_CONTROLLER=y CONFIG_VIDEO_V4L2_SUBDEV_API=y +CONFIG_MEDIA_USB_SUPPORT=y +CONFIG_USB_VIDEO_CLASS=y +CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y +CONFIG_USB_GSPCA=m CONFIG_V4L_PLATFORM_DRIVERS=y CONFIG_VIDEO_ROCKCHIP_CIF=y CONFIG_VIDEO_ROCKCHIP_ISP=y buildroot/configs/rockchip/rv1126_rv1109_arm.config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 zyh@zyh rockchip (default) $ git diff rv1126_rv1109_arm.config diff --git a/configs/rockchip/rv1126_rv1109_arm.config b/configs/rockchip/rv1126_rv1109_arm.config old mode 100644 new mode 100755 index 640c11c663..20ea5f1084 --- a/configs/rockchip/rv1126_rv1109_arm.config +++ b/configs/rockchip/rv1126_rv1109_arm.config @@ -2,7 +2,7 @@ #include \"gcc8.config\" BR2_TARGET_GENERIC_GETTY_PORT=\"ttyFIQ0\" BR2_TARGET_GENERIC_GETTY_BAUDRATE_1500000=y -BR2_TARGET_GENERIC_HOSTNAME=\"RV1126_RV1109\" +BR2_TARGET_GENERIC_HOSTNAME=\"DeepGlint\" BR2_TARGET_GENERIC_ISSUE=\"Welcome to RV1126_RV1109 Buildroot\" BR2_PACKAGE_RV1126_RV1109=y BR2_ROOTFS_OVERLAY=\"board/rockchip/rv1126_rv1109/fs-overlay/\" camera驱动调试 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:4:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"主要参考文档 Rockchip Linux Camera 开发指南 Rockchip Linux4.4 Camera Trouble Shooting CN Rockchip_Driver_Guide_ISP2x_CN ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:5:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"sensor 框架图 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:6:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"DTSI 配置实现 目前实现： ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:7:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"debug 记录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 [root@DeepGlint:/]# media-ctl -p /dev/media0 Media controller API version 4.19.111 Media device information ------------------------ driver rkcif model rkcif_mipi_lvds serial bus info hw revision 0x0 driver version 4.19.111 Device topology - entity 1: stream_cif_mipi_id0 (1 pad, 4 links) type Node subtype V4L flags 0 device node name /dev/video0 pad0: Sink \u003c- \"rockchip-mipi-csi2\":1 [ENABLED] \u003c- \"rockchip-mipi-csi2\":2 [] \u003c- \"rockchip-mipi-csi2\":3 [] \u003c- \"rockchip-mipi-csi2\":4 [] - entity 5: stream_cif_mipi_id1 (1 pad, 4 links) type Node subtype V4L flags 0 device node name /dev/video1 pad0: Sink \u003c- \"rockchip-mipi-csi2\":1 [] \u003c- \"rockchip-mipi-csi2\":2 [ENABLED] \u003c- \"rockchip-mipi-csi2\":3 [] \u003c- \"rockchip-mipi-csi2\":4 [] - entity 9: stream_cif_mipi_id2 (1 pad, 4 links) type Node subtype V4L flags 0 device node name /dev/video2 pad0: Sink \u003c- \"rockchip-mipi-csi2\":1 [] \u003c- \"rockchip-mipi-csi2\":2 [] \u003c- \"rockchip-mipi-csi2\":3 [ENABLED] \u003c- \"rockchip-mipi-csi2\":4 [] - entity 13: stream_cif_mipi_id3 (1 pad, 4 links) type Node subtype V4L flags 0 device node name /dev/video3 pad0: Sink \u003c- \"rockchip-mipi-csi2\":1 [] \u003c- \"rockchip-mipi-csi2\":2 [] \u003c- \"rockchip-mipi-csi2\":3 [] \u003c- \"rockchip-mipi-csi2\":4 [ENABLED] - entity 17: rockchip-mipi-csi2 (5 pads, 17 links) type V4L2 subdev subtype Unknown flags 0 device node name /dev/v4l-subdev1 pad0: Sink [fmt:SBGGR10_1X10/2688x1520 field:none crop.bounds:(0,0)/2688x1520 crop:(0,0)/2688x1520] \u003c- \"rockchip-mipi-dphy-rx\":1 [ENABLED] pad1: Source [fmt:SBGGR10_1X10/2688x1520 field:none crop.bounds:(0,0)/2688x1520 crop:(0,0)/2688x1520] -\u003e \"stream_cif_mipi_id0\":0 [ENABLED] -\u003e \"stream_cif_mipi_id1\":0 [] -\u003e \"stream_cif_mipi_id2\":0 [] -\u003e \"stream_cif_mipi_id3\":0 [] pad2: Source [fmt:SBGGR10_1X10/2688x1520 field:none crop.bounds:(0,0)/2688x1520 crop:(0,0)/2688x1520] -\u003e \"stream_cif_mipi_id0\":0 [] -\u003e \"stream_cif_mipi_id1\":0 [ENABLED] -\u003e \"stream_cif_mipi_id2\":0 [] -\u003e \"stream_cif_mipi_id3\":0 [] pad3: Source [fmt:SBGGR10_1X10/2688x1520 field:none crop.bounds:(0,0)/2688x1520 crop:(0,0)/2688x1520] -\u003e \"stream_cif_mipi_id0\":0 [] -\u003e \"stream_cif_mipi_id1\":0 [] -\u003e \"stream_cif_mipi_id2\":0 [ENABLED] -\u003e \"stream_cif_mipi_id3\":0 [] pad4: Source [fmt:SBGGR10_1X10/2688x1520 field:none crop.bounds:(0,0)/2688x1520 crop:(0,0)/2688x1520] -\u003e \"stream_cif_mipi_id0\":0 [] -\u003e \"stream_cif_mipi_id1\":0 [] -\u003e \"stream_cif_mipi_id2\":0 [] -\u003e \"stream_cif_mipi_id3\":0 [ENABLED] - entity 23: rockchip-mipi-dphy-rx (2 pads, 2 links) type V4L2 subdev subtype Unknown flags 0 device node name /dev/v4l-subdev2 pad0: Sink [fmt:SBGGR10_1X10/2688x1520@10000/302834 field:none] \u003c- \"m01_f_os04a10 1-0036-1\":0 [ENABLED] pad1: Source [fmt:SBGGR10_1X10/2688x1520@10000/302834 field:none] -\u003e \"rockchip-mipi-csi2\":0 [ENABLED] - entity 28: rkcif-mipi-luma (0 pad, 0 link) type Node subtype V4L flags 0 device node name /dev/video4 - entity 31: m01_f_os04a10 1-0036-1 (1 pad, 1 link) type V4L2 subdev subtype Sensor flags 0 device node name /dev/v4l-subdev3 pad0: Source [fmt:SBGGR10_1X10/2688x1520@10000/302834 field:none] -\u003e \"rockchip-mipi-dphy-rx\":0 [ENABLED] - entity 35: m01_f_ircut (0 pad, 0 link) type V4L2 subdev subtype Lens flags 1 device node name /dev/v4l-subdev4 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 [root@DeepGlint:/]# media-ctl -p /dev/media3 Media controller API version 4.19.111 Media device information ---------------","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:8:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"疑问 目前的实现方式 csi2-\u003ecif 是什么？ sensor0-\u003ecsi_dphy0-\u003ecsi2-\u003ecif-\u003eisp0-\u003eispp0 sensor1-\u003ecsi_dphy1-\u003eisp1-\u003eispp1 两路mipi sensor 接口如下实现是否可以？ sensor-\u003ecsi_dphy0-\u003eisp0-\u003eispp0 sensor-\u003ecsi_dphy1-\u003eisp1-\u003eispp1 参考 Buildroot简单总结与添加本地APP rk3399 camera驱动开发 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/:9:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发板使用记录","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126%E5%BC%80%E5%8F%91/"},{"categories":["Embedded"],"content":"RV1126 开发环境搭建","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 开发环境搭建 搭建编译环境 编译 编译问题 部分buildroot 修改（非必要） 修改HOSTNAME 其他修改 开发环境搭建 FTP 下载 RV1126/RV1109 Linux SDK ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":"搭建编译环境 1 2 3 4 5 6 7 8 9 sudo apt-get install repo git-core gitk git-gui gcc-arm-linux-gnueabihf \\ u-boot-tools device-tree-compiler gcc-aarch64-linux-gnu mtools parted \\ libudev-dev libusb-1.0-0-dev python-linaro-image-tools linaro-image-tools \\ autoconf autotools-dev libsigsegv2 m4 intltool libdrm-dev curl sed make \\ binutils build-essential gcc g++ bash patch gzip gawk bzip2 perl tar \\ cpio python unzip rsync file bc wget libncurses5 libqt4-dev libglib2.0-dev \\ libgtk2.0-dev libglade2-dev cvs git mercurial rsync openssh-client \\ subversion asciidoc w3m dblatex graphviz python-matplotlib libc6:i386 \\ libssl-dev expect fakeroot cmake flex bison liblz4-tool libtool keychain 1 sudo apt-get install lib32gcc-7-dev g++-7 libstdc++-7-dev 编译 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":"编译问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 2021-03-08T14:35:37 --2021-03-08 14:35:37-- https://www.openssl.org/source/openssl-1.1.1h.tar.gz 2021-03-08T14:35:37 Connecting to 127.0.0.1:46635... failed: Connection refused. 2021-03-08T14:35:37 --2021-03-08 14:35:37-- http://sources.buildroot.net/openssl-1.1.1h.tar.gz 2021-03-08T14:35:37 Connecting to 127.0.0.1:46635... failed: Connection refused. 2021-03-08T14:35:37 package/pkg-generic.mk:166: recipe for target '/mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/build/host-libopenssl-1.1.1h/.stamp_downloaded' failed 2021-03-08T14:35:37 make[1]: *** [/mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/build/host-libopenssl-1.1.1h/.stamp_downloaded] Error 1 2021-03-08T14:35:37 /mnt/DG/DATA/Partners/Rockchip/rv1126/code/rv1126_rv1109_linux_201230/buildroot/output/rockchip_rv1126_rv1109_uvcc/Makefile:16: recipe for target '_all' failed 2021-03-08T14:35:37 make: *** [_all] Error 2 Command exited with non-zero status 1 you take 29:55.47 to build builroot ERROR: Running build_buildroot failed! ERROR: exit code 1 from line 348: /usr/bin/time -f \"you take %E to build builroot\" $COMMON_DIR/mk-buildroot.sh $BOARD_CONFIG zyh@zyh rv1126_rv1109_linux_201230 $ cat /etc/profile 这里是代理问题的锅 1 2 3 4 5 $ env|grep -I proxy http_proxy=http://127.0.0.1:8118 ftp_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 我们需要把/etc/profile中的代理注释掉在进行 以下操作 1 2 3 unset http_proxy unset ftp_proxy unset https_proxy 重新编译 部分buildroot 修改（非必要） ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":"修改HOSTNAME device/rockchip/rv1126_rv1109/BoardConfig-uvcc.mk 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # Kernel defconfig export RK_KERNEL_DEFCONFIG=rv1126_defconfig # Kernel defconfig fragment export RK_KERNEL_DEFCONFIG_FRAGMENT= # EMMC EVB BOARD Kernel dts export RK_KERNEL_DTS=rv1126-evb-ddr3-v13 # Logic/npu/vepu merge emmc board kernel dts #export RK_KERNEL_DTS=rv1126-ai-cam-ddr3-v1 # NPU 800m+ logic separate from npu/vepu emmc board kernel dts #export RK_KERNEL_DTS=rv1126-ai-cam-plus # boot image type export RK_BOOT_IMG=zboot.img # kernel image path export RK_KERNEL_IMG=kernel/arch/arm/boot/zImage # parameter for GPT table export RK_PARAMETER=parameter-buildroot-fit.txt # Buildroot config export RK_CFG_BUILDROOT=rockchip_rv1126_rv1109_uvcc ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":"其他修改 kernel/arch/arm/configs/rv1126_defconfig 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 zyh@zyh kernel (default) $ git diff arch/arm/configs/rv1126_defconfig diff --git a/arch/arm/configs/rv1126_defconfig b/arch/arm/configs/rv1126_defconfig old mode 100644 new mode 100755 index e70409b5a527..78f0aef08ac0 --- a/arch/arm/configs/rv1126_defconfig +++ b/arch/arm/configs/rv1126_defconfig @@ -211,6 +211,10 @@ CONFIG_MEDIA_SUPPORT=y CONFIG_MEDIA_CAMERA_SUPPORT=y CONFIG_MEDIA_CONTROLLER=y CONFIG_VIDEO_V4L2_SUBDEV_API=y +CONFIG_MEDIA_USB_SUPPORT=y +CONFIG_USB_VIDEO_CLASS=y +CONFIG_USB_VIDEO_CLASS_INPUT_EVDEV=y +CONFIG_USB_GSPCA=m CONFIG_V4L_PLATFORM_DRIVERS=y CONFIG_VIDEO_ROCKCHIP_CIF=y CONFIG_VIDEO_ROCKCHIP_ISP=y buildroot/configs/rockchip/rv1126_rv1109_arm.config 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 zyh@zyh rockchip (default) $ git diff rv1126_rv1109_arm.config diff --git a/configs/rockchip/rv1126_rv1109_arm.config b/configs/rockchip/rv1126_rv1109_arm.config old mode 100644 new mode 100755 index 640c11c663..20ea5f1084 --- a/configs/rockchip/rv1126_rv1109_arm.config +++ b/configs/rockchip/rv1126_rv1109_arm.config @@ -2,7 +2,7 @@ #include \"gcc8.config\" BR2_TARGET_GENERIC_GETTY_PORT=\"ttyFIQ0\" BR2_TARGET_GENERIC_GETTY_BAUDRATE_1500000=y -BR2_TARGET_GENERIC_HOSTNAME=\"RV1126_RV1109\" +BR2_TARGET_GENERIC_HOSTNAME=\"DeepGlint\" BR2_TARGET_GENERIC_ISSUE=\"Welcome to RV1126_RV1109 Buildroot\" BR2_PACKAGE_RV1126_RV1109=y BR2_ROOTFS_OVERLAY=\"board/rockchip/rv1126_rv1109/fs-overlay/\" ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 开发环境搭建","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["Embedded"],"content":"RV1126 文档阅读笔记","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 文档阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 一、RV1126/RV1109 Linux SDK 快速入门 v1.9.3 笔记 SDK 目录说明 RV1109/RV1126 模块代码目录说明 文档版本：docs_210126 文档索引： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 ├── docs │ │ │ ├── Kernel (内核驱动相关文档,RV1126/RV1109平台可以参考) │ │ │ ├── Linux (Rockchip Linux系统通用文档,RV1126/RV1109平台可以参考)│ │ │ │ │ ├── Multimedia │ │ │ ├── camera (camera相关文档,RV1126/RV1109平台可以参考) │ │ │ ├── Rockchip_Developer_Guide_MPP_CN.pdf (编解码接口开发指南, 适用于RV1126/RV1109平台) │ │ │ │ │ │ └── Rockchip_Developer_Guide_MPP_EN.pdf │ │ ├── Recovery (升级相关文档, 适用于RV1126/RV1109平台) │ │ │ ├── Rockchip_Developer_Guide_Linux_Recovery_CN.pdf │ │ │ ├── Rockchip_Developer_Guide_Linux_Recovery_EN.pdf │ │ │ ├── Rockchip_Developer_Guide_Linux_Upgrade_CN.pdf │ │ │ └── Rockchip_Developer_Guide_Linux_Upgrade_EN.pdf │ │ │ │ │ ├── Security (加密相关文档, 适用于RV1126/RV1109平台) │ │ │ │ │ │ │ │ └── Wifibt (WiFi和蓝牙相关文档, 适用于RV1126/RV1109平台) │ │ ├── AP模组RF测试文档 │ │ │ ├── BT RF Test Commands for Linux-v05.pdf │ │ │ └── Wi-Fi RF Test Commands for Linux-v03.pdf │ │ ├── REALTEK模组RF测试文档 │ │ │ ├── 00014010-WS-170731-RTL8723D_COB_MP_FLOW_R04.pdf │ │ │ ├── MP tool user guide for linux20180319.pdf │ │ │ └── Quick_Start_Guide_V6.txt │ │ ├── RK平台_RTL8723DS_AIRKISS配网说明.pdf │ │ ├── Rockchip_Developer_Guide_DeviceIo_Bluetooth_CN.pdf │ │ ├── Rockchip_Developer_Guide_Linux_WIFI_BT_CN.pdf │ │ ├── Rockchip_Developer_Guide_Linux_WIFI_BT_EN.pdf │ │ ├── Rockchip_Developer_Guide_Network_Config_CN.pdf │ │ └── WIFI性能测试PC工具 │ │ │ │ │ └── RV1126_RV1109 └── Rockchip_Developer_Guide_TEE_Secure_SDK_CN.pdf └── iperf-2.0.5-2-win32.zip │ ├── ApplicationNote (Rockchip应用开发框架介绍、网页端开发指南) │ │ ├── Rockchip_Developer_Guide_Linux_Application_Framework_CN.pdf │ │ ├── Rockchip_Developer_Guide_Linux_Application_Framework_EN.pdf │ │ ├── Rockchip_Instructions_Linux_CGI_API_CN.pdf │ │ ├── Rockchip_Instructions_Linux_MediaServer_CN.pdf │ │ ├── Rockchip_Instructions_Linux_MediaServer_EN.pdf │ │ ├── Rockchip_Instructions_Linux_Web_Configuration_CN.pdf │ │ └── Rockchip_Instructions_Linux_Web_Configuration_EN.pdf │ │ │ ├── Camera (ISP开发指南) │ │ ├── Camera_External_FAQ_v1.0.pdf │ │ ├── Rockchip_Color_Optimization_Guide_ISP2x_V1.1.0.pdf │ │ ├── Rockchip_Development_Guide_ISP2x_CN_v1.2.0.pdf │ │ ├── Rockchip_Driver_Guide_ISP2x_CN_v0.1.0.pdf │ │ ├── Rockchip_Instruction_Linux_Appliction_ISP20_CN.pdf │ │ ├── Rockchip_IQ_Tools_Guide_ISP2x_CN_v1.0.0.pdf │ │ ├── Rockchip_RV1109_RV1126_Developer_Guide_Linux_Ispserver_CN.pdf │ │ └── Rockchip_Tuning_Guide_ISP2x_CN_v1.0.0.pdf │ │ │ ├── Multimedia │ │ ├── Rockchip_Developer_Guide_Linux_RKMedia_CN.pdf │ │ └── Rockchip_Instructions_Linux_Rkmedia_CN.pdf (多媒体接口开发指南) │ │ │ ├── Rockchip_RV1126_RV1109_EVB_User_Guide_V1.0_CN.pdf (硬件开发指南) │ ├── Rockchip_RV1126_RV1109_EVB_User_Guide_V1.0_EN.pdf│ ├── Rockchip_RV1126_RV1109_Instruction_Linux_Separate_Building_EN.pdf (独立编译U-Boot/Kernel/Rootfs说明文档) │ ├── Rockchip_RV1126_RV1109_Linux_SDK_V1.1.1_20200711_CN.pdf (SDK发布说明) │ ├── Rockchip_RV1126_RV1109_Linux_SDK_V1.1.1_20200711_EN.pdf │ ├── Rockchip_RV1126_RV1109_Quick_Start_Linux_CN.pdf (快速开发指南) │ ├── Rockchip_RV1126_RV1109_Quick_Start_Linux_EN.pdf │ ├── RV1109 Multimedia Codec Benchmark v1.2.pdf │ ├── RV1126 Multimedia Codec Benchmark v1.1.pdf │ └── RV1126_RV1109_Release_Note.txt │ └── external ├── rknn-toolkit (模型转换、推理和性能评估的开发套件文档) │ └── doc │ ├── Rockchip_Developer_Guide_RKNN_Toolkit_Custom_OP_V1.3.2_CN.pdf │ ├── Rockchip_Developer_Guide_RKNN_Toolkit_Custom_OP_V1.3.2_EN.pdf │ ├── Rockchip_Quick_Start_RKNN_Toolkit_V1.3.2_CN.pdf │ ├── Rockchip_Quick_Start_RKNN_Toolkit_V1.3.2_EN.pdf │ ├── Rockchip_Trouble_Shooting_RKNN_Toolkit_V1.3.2_CN.pdf │ ├── Rockchip_Trouble_Shooting_RKNN_Toolkit_V1.3.2_EN.pdf │ ├── Rockchip_User_Guide_RKNN_Toolkit_V1.3.2_CN.pdf │ ├── Rockchip_User_Guide_RKNN_Toolkit_V1.3.2_EN.pdf │ ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 文档阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/"},{"categories":["Embedded"],"content":"SDK 目录说明 buildroot:定制根文件系统。 app:存放上层应用程序。 external:相关库,包括音频、视频等。 kernel:kernel代码。 device/rockchip:存放每个平台的一些编译和打包固件的脚本和预备文件。 docs:存放开发指导文件、平台支持列表、工具使用文档、Linux 开发指南等。 prebuilts:存放交叉编译工具链。 rkbin:存放固件和工具。 rockdev:存放编译输出固件。 tools:存放一些常用工具。 u-boot:U-Boot代码。 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/:1:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 文档阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/"},{"categories":["Embedded"],"content":"RV1109/RV1126 模块代码目录说明 部分模块代码目录路径 模块功能描述 external/recovery recovery external/rkwifibt Wi-Fi和BT external/libdrm DRM接口 external/rk_pcba_test PCBA测试代码 external/isp2-ipc 图像信号处理服务端 external/mpp 编解码代码 external/rkmedia Rockchip 多媒体封装接口 external/rkupdate Rockchip升级代码 external/camera_engine_rkaiq 图像处理算法模块 external/rknpu NPU驱动 external/rockface 人脸识别代码 external/CallFunIpc 应用进程间通信代码 external/common_algorithm其他 音视频通用算法库 external/rknn-toolkit 模型转换、推理和性能评估的开发套件 app/libIPCProtocol 基于dbus,提供进程间通信的函数接口 app/mediaserver 提供多媒体服务的主应用 app/ipc-daemon 系统守护服务 app/dbserver 数据库服务 app/netserver 网络服务 app/storage_manager 存储管理服务 app/ipcweb-backend web后端 app/librkdb 数据库接口 app/ipcweb-ng web前端,采用Angular 8框架 ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/:2:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126 文档阅读笔记","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126/01_rv1126%E6%96%87%E6%A1%A3%E7%9B%AE%E5%BD%95/"},{"categories":["Embedded"],"content":"RV1126 开发板使用记录","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%AF%B9%E6%AF%94/","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126\u0026RV1109对比","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%AF%B9%E6%AF%94/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 RV1126/RV1109 对比 RV1126/RV1109 是瑞芯微 一款用于工控机或人工智能视觉应用的高性能机器视觉处理器SoC。 RV1126/RV1109 对比 RV1126 RV1109 CPU 四核 ARM Cortex-A7 RISC-V MCU 双核 ARM Cortex-A7 RISC-V MCU NPU 2.0Tops, support INT8/ INT16 1.2Tops, support INT8/ INT16 内存 32bit DDR3/DDR3L/LPDDR3/DDR4/LPDDR4 支持 eMMC 4.51, SPI Flash, Nand Flash 支持快速开机 32bit DDR3/DDR3L/LPDDR3/DDR4/LPDDR4 支持 eMMC 4.51, SPI Flash, Nand Flash 支持快速开机 显示 MIPI-DSI/RGB 接口,最大 1080P60fps MIPI-DSI/RGB 接口,1080P@60FPS 图形加速引擎 支持旋转, x/y 镜像 支持 alpha 图层混合 支持放大、缩小 支持旋转, x/y 镜像 支持 alpha 图层混合 支持放大、缩小 多媒体 1400 万 ISP 2.0 with 3 帧 HDR(Line-based/Frame-based/DCG) 同时支持 2 组 MIPI CSI /LVDS/sub LVDS 和一组 16-bit 并口输入 4K H.264/H.265 30fps 视频编码-3840 x 2160@30 fps+720p@30 fps encoding 4K H.264/H.265 30fps 视频解码-3840 x 2160@30 encoding + 3840 x 2160@30 fps decoding 500 万 ISP 2.0 with 3 帧 HDR(Line-based/Frame-based/DCG) 同时支持 2 组 MIPI CSI /LVDS/sub LVDS 和一组 16-bit 并口输入 H.264/H.265 编码能力: - 2688 x 1520@30 fps+1280 x 720@30 fps- 3072 x 1728@30 fps+1280 x 720@30 fps- 2688 x 1944@30 fps+1280 x 720@30fps 外围接口 千兆以太网接口,具有 TSO(TCP Segmentation Offload)网络加速 USB 2.0 OTG and USB 2.0 host 两个 SDIO 3.0 接口 for Wi-Fi and SD 卡 8 通道 I2S with TDM/PDM, 2 通道 I2 千兆以太网接口,具有 TSO(TCP Segmentation Offload)网络加速 USB 2.0 OTG and USB 2.0 host 两个 SDIO 3.0 接口 for Wi-Fi and SD 卡 8 通道 I2S with TDM/PDM, 2 通道 I2S ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%AF%B9%E6%AF%94/:0:0","tags":["Embedded","芯片\u0026开发板","RV1126"],"title":"Embedded:RV1126\u0026RV1109对比","uri":"/posts/embedded/developmentboard/rv1126rv1109/rv1126rv1109%E5%AF%B9%E6%AF%94/"},{"categories":["Embedded"],"content":"地平线旭日X3","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:地平线旭日X3","uri":"/posts/embedded/developmentboard/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/"},{"categories":["Embedded"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 网址 2. 产品规格 1. 网址 官网 2. 产品规格 CPU ARM® Cortex®-A53，4xCore, 1.2G BPU (Bernoulli Arch) 2×Core，up to 1.0G, ~5Tops 内存与存储 2G/4G Byte LPDDR4 接口 Sensor接口 MIPI CSI 2lane *2 USB Host USB Type-A 3.0 *1 USB Type-A 2.0 *2 串口 UART 0 Debug USB Device Micro USB 2.0 *1 无线网络 2.4G Wi-Fi *1，支持802.11 b/g/n 蓝牙 Bluetooth 4.1 显示接口 HDMI 1 (up to 1920x1080)zh MIPI-DSI1 (up to 1920x1080) 有线网络接口 千兆以太网 *1，RJ45接口 40PIN接口 GPIO\u0026I2C\u0026UART\u0026SPI\u0026I2S\u0026PWM 电 源 电源输入 USB Type-C，5V-2A 系统支持 OS Ubuntu 20.04 其他 尺寸 85MM x 56MM x 20MM 工作温度 -25度~95度（X3M芯片温度） ","date":"2023-02-09","objectID":"/posts/embedded/developmentboard/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/:0:0","tags":["Embedded","芯片\u0026开发板"],"title":"Embedded:地平线旭日X3","uri":"/posts/embedded/developmentboard/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/%E5%9C%B0%E5%B9%B3%E7%BA%BF%E6%97%AD%E6%97%A5x3/"},{"categories":["network"],"content":"HTTPS实现","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 HTTPS 介绍 HTTPS 简史 HTTPS 工作流程 搭建https服务 首先确认安装OpenSSL 自建CA 创建服务器公私钥 使用 CA key 对服务器证书签名 搭建https工程 参考 测试工程 HTTPS 介绍 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:0:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"HTTPS 简史 在早期HTTP诞生的这几年间，1990年~·1994年，HTTP作为一个应用层协议，它是这样工作的： 后来网景公司开发了SSL（Secure Sockets Layer）技术，然后它就变成了这样的HTTP，也就是HTTPS了： 后来爆发了与IE的世纪大战，网景败北，SSL移交给了IETF（Internat Engineering Task Force）互联网工程任务组，标准化之后变成了现在的TLS，现在一般会把它们两个放在一起称为SSL/TLS。本篇并不关注SSL/TLS具体是如何工作的，只是抽象的解释下HTTPS的一个工作流程。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:1:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"HTTPS 工作流程 Client发起一个HTTPS（https:/demo.linianhui.dev）的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。 Server把事先配置好的公钥证书（public key certificate）返回给客户端。 Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。 Client使用伪随机数生成器生成加密所使用的会话密钥，然后用证书的公钥加密这个会话密钥，发给Server。 Server使用自己的私钥（private key）解密这个消息，得到会话密钥。至此，Client和Server双方都持有了相同的会话密钥。 Server使用会话密钥加密“明文内容A”，发送给Client。 Client使用会话密钥解密响应的密文，得到“明文内容A”。 Client再次发起HTTPS的请求，使用会话密钥加密请求的“明文内容B”，然后Server使用会话密钥解密密文，得到“明文内容B”。 搭建https服务 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:2:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"首先确认安装OpenSSL 确定OpenSSL版本： 1 $openssl version 如果版本低于1.0.1f，建议升级，因为1.0.1f版本之下的OpenSSL有一个Heartbleed漏洞。 安装OpenSSL： 1 $sudo apt-get install openssl ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:3:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"自建CA 因为向CA申请签名是需要收费的，所以我们选择自己搭建一个CA来完成这个实验过程。 首先建立myCA目录用于存放CA相关信息 1 cd \u0026\u0026 mkdir -p myCA/signedcerts \u0026\u0026 mkdir myCA/private \u0026\u0026 cd myCA myCA 用于存放 CA 根证书，证书数据库，以及后续服务器生成的证书，密钥以及请求 signedcerts:保存签名证书的 copy private: 包含私钥 之后配置myCA相关参数，在myCA目录下进行 1 echo '01'\u003eserial \u0026\u0026 touch index.txt 然后创建 caconfig.cnf 文件 1 vim ~/myCA/caconfig.cnf caconfig.cnf文件内容如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 # My sample caconfig.cnf file. # # Default configuration to use when one is not provided on the command line. # [ ca ] default_ca = local_ca # # # Default location of directories and files needed to generate certificates. # [ local_ca ] dir = /home/didi/myCA # 这里要将username替换为你的用户名 certificate = $dir/cacert.pem database = $dir/index.txt new_certs_dir = $dir/signedcerts private_key = $dir/private/cakey.pem serial = $dir/serial # # # Default expiration and encryption policies for certificates. # default_crl_days = 365 default_days = 1825 default_md = SHA256 # policy = local_ca_policy x509_extensions = local_ca_extensions # # # Default policy to use when generating server certificates. The following # fields must be defined in the server certificate. # [ local_ca_policy ] commonName = supplied stateOrProvinceName = supplied countryName = supplied emailAddress = supplied organizationName = supplied organizationalUnitName = supplied # # # x509 extensions to use when generating server certificates. # [ local_ca_extensions ] subjectAltName = DNS:localhost basicConstraints = CA:false nsCertType = server # # # The default root certificate generation policy. # [ req ] default_bits = 2048 default_keyfile = /home/didi/myCA/private/cakey.pem # 这里要将username替换为你的用户名 default_md = SHA256 # prompt = no distinguished_name = root_ca_distinguished_name x509_extensions = root_ca_extensions # # # Root Certificate Authority distinguished name. Change these fields to match # your local environment! # [ root_ca_distinguished_name ] commonName = MyOwn Root Certificate Authority # CA机构名 stateOrProvinceName = BJ # CA所在省份 countryName = CN # CA所在国家（仅限2个字符） emailAddress = XXXX@XXX.com # 邮箱 organizationName = XXX # organizationalUnitName = XXX # # [ root_ca_extensions ] basicConstraints = CA:true 生成 CA 根证书和密钥 1 2 export OPENSSL_CONF=~/myCA/caconfig.cnf #该命令用于给环境变量 OPENSSL_CONF 赋值为caconfig.cnf。 openssl req -x509 -newkey rsa:2048 -out cacert.pem -outform PEM -days 1825 # 生成 CA 根证书和密钥 该命令需要用户设置密码。不要忘记。 以上步骤生成了 CA 自签名根证书，和 RSA 公/私密钥对。证书的格式是 PEM，有效期是1825天。 /myCA/cacert.pem: CA 根证书 /myCA/private/cakey.pem： CA 私钥 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:4:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"创建服务器公私钥 生成服务器配置文件exampleserver.cnf 1 vim ~/myCA/exampleserver.cnf exampleserver.cnf文件内容如下 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # # exampleserver.cnf # [ req ] prompt = no distinguished_name = server_distinguished_name [ server_distinguished_name ] commonName = localhost # 服务器域名 stateOrProvinceName = BJ # 服务器所在省份 countryName = CN # 服务器所在国家（仅限2个字符） emailAddress = XXXX@XXX.com # 邮箱 organizationName = XXX # organizationalUnitName = XXX # 生成服务器证书和密钥 1 2 export OPENSSL_CONF=~/myCA/exampleserver.cnf # 该命令设置环境变量 OPENSSL_CONF，使得 openssl 更换配置文件。 openssl req -newkey rsa:1024 -keyout tempkey.pem -keyform PEM -out tempreq.pem -outform PEM 同样的，需要输入密码短语。 之后，有2种对临时秘钥的操作，选择其一即可 1.将临时私钥转换为 unencrypted key，即秘钥不加密状态。 1 openssl rsa -in tempkey.pem -out server_key.pem 需要输入密码短语。 2.如果希望将 key 保持为加密状态，直接改名 1 mv tempkey.pem server_key.pem 两者的区别是，第二种需要在服务器启动时输入私钥的密码短语，否则会导致服务器启动失败，但第二种安全性高于第一种，可以更好的保护秘钥。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:5:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"使用 CA key 对服务器证书签名 1 2 export OPENSSL_CONF=~/myCA/caconfig.cnf openssl ca -in tempkey.pem -out server_crt.pem 这里提示： 1 2 3 Can't open /home/shawn/myCA/index.txt.attr for reading, No such file or directory 140344032040704:error:02001002:system library:fopen:No such file or directory:crypto/bio/bss_file.c:74:fopen('/home/shawn/myCA/index.txt.attr','r') 140344032040704:error:2006D080:BIO routines:BIO_new_file:no such file:crypto/bio/bss_file.c:81: 是Openssl的bug，在myCA目录下再touch一个index.txt.attr即可 删除临时证书和密码文件 1 rm -f tempkey.pem \u0026\u0026 rm -f tempreq.pem 现在，自签名的服务器证书和密钥对便产生了： server_crt.pem : 服务器证书文件 server_key.pem : 服务器密钥文件 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:6:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"搭建https工程 基于 cpp-httplib搭建工程 ， 工程地址 ：http-https server 端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 #include \u003chttplib.h\u003e #include \u003cfstream\u003e #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std::placeholders; class TEST { private: httplib::Server *m_svr; void recvGetHelloHandle(const httplib::Request \u0026req, httplib::Response \u0026res); public: TEST(); ~TEST() { delete m_svr; } void start(int port) { m_svr-\u003elisten(\"0.0.0.0\", port); } }; TEST::TEST() { m_svr = new httplib::Server; httplib::Server::Handler getHello_cb = std::bind(\u0026TEST::recvGetHelloHandle, this, _1, _2); m_svr-\u003eGet(\"/hello\", getHello_cb); } void TEST::recvGetHelloHandle(const httplib::Request \u0026req, httplib::Response \u0026res) { if (!req.has_header(\"token\")) { res.set_content(\"fail\", \"text/plain\"); return; } std::string token = req.get_header_value(\"token\"); std::cout \u003c\u003c \"token : \" \u003c\u003c token \u003c\u003c std::endl; } class TESTHTTPS { private: httplib::SSLServer *m_svr; void recvGetHelloHandle(const httplib::Request \u0026req, httplib::Response \u0026res); public: TESTHTTPS(); ~TESTHTTPS() { delete m_svr; } void start(int port) { m_svr-\u003elisten(\"localhost\", port); } }; TESTHTTPS::TESTHTTPS() { m_svr = new httplib::SSLServer(\"./data/server_crt.pem\", \"./data/server_key.pem\"); httplib::SSLServer::Handler getHello_cb = std::bind(\u0026TESTHTTPS::recvGetHelloHandle, this, _1, _2); m_svr-\u003eGet(\"/dd/hello\", getHello_cb); } void TESTHTTPS::recvGetHelloHandle(const httplib::Request \u0026req, httplib::Response \u0026res) { if (!req.has_header(\"token\")) { res.set_content(\"fail\", \"text/plain\"); return; } std::string token = req.get_header_value(\"token\"); std::cout \u003c\u003c \"token : \" \u003c\u003c token \u003c\u003c std::endl; } int main(void) { TESTHTTPS test; test.start(8887); } client 端代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include \u003chttplib.h\u003e #include \u003cfstream\u003e #include \u003ciostream\u003e #include \u003cstring\u003e class TESTHTTP { private: httplib::Client *m_cli; public: TESTHTTP() { m_cli = new httplib::Client(\"https://localhost:8887\"); } ~TESTHTTP() { delete m_cli; } c++ void testGetHello(); }; void TESTHTTP::testGetHello() { httplib::Params params = {{\"params\", \"test\"}}; httplib::Headers headers = {{\"version\", \"0.0.0.1\"}, {\"token\", \"V66n56XJBD/4LTMsGDqE0dlRPtkVmQ0hlIQNwcBMZkU4bQeDTBlMEUluqnha1g/ZsEMK/0JHKtEBwHH2Ko9iEA==\"}}; auto res = m_cli-\u003eGet(\"/dd/hello\", params, headers); std::cout \u003c\u003c httplib::to_string(res.error()) \u003c\u003c std::endl; std::cout \u003c\u003c res-\u003ebody \u003c\u003c std::endl; } class TESTHTTPS { private: httplib::Client *m_cli; public: TESTHTTPS() { m_cli = new httplib::Client(\"https://localhost:8887\"); m_cli-\u003eset_ca_cert_path(\"./data/cacert.pem\"); m_cli-\u003eenable_server_certificate_verification(true); } ~TESTHTTPS() { delete m_cli; } void testGetHello(); }; void TESTHTTPS::testGetHello() { httplib::Params params = {{\"params\", \"test\"}}; httplib::Headers headers = {{\"version\", \"0.0.0.1\"}, {\"token\", \"V66n56XJBD/4LTMsGDqE0dlRPtkVmQ0hlIQNwcBMZkU4bQeDTBlMEUluqnha1g/ZsEMK/0JHKtEBwHH2Ko9iEA==\"}}; auto res = m_cli-\u003eGet(\"/dd/hello\", params, headers); std::cout \u003c\u003c httplib::to_string(res.error()) \u003c\u003c std::endl; std::cout \u003c\u003c res-\u003ebody \u003c\u003c std::endl; } int main(void) { // TESTHTTP T; // T.testPostPush(); TESTHTTPS T; T.testGetHello(); } 参考 信安实践——自建CA证书搭建https服务器 HTTPS工作流程 测试工程 http-https ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/:7:0","tags":["network","HTTP"],"title":"HTTP:HTTPS实现","uri":"/posts/basic_knowledge/network/http/https%E5%AE%9E%E7%8E%B0/"},{"categories":["network"],"content":"HTTP介绍","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 HTTP HTTP 相关概念 互联网与http 浏览器 Web 服务器 CDN 爬虫 HTML/WebService/WAF TCP/IP DNS URI/URL HTTPS 代理 网络分层模型 TCP/IP 网络分层模型 OSI 网络分层模型 两个分层模型的映射关系 TCP/IP 协议栈的工作方式 域名解析 HTTP HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写。用于从WWW服务器传输超文本到本地浏览器的传送协议。 HTTP 相关概念 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:0:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"互联网与http 互联网的正式名称是 Internet，里面存储着无穷无尽的信息资源，我们通常所说的“上网”实际上访问的只是互联网的一个子集“万维网”（World Wide Web），它基于 HTTP 协议，传输 HTML 等超文本资源，能力也就被限制在 HTTP 协议之内。 互联网上还有许多万维网之外的资源，例如常用的电子邮件、BT 和 Magnet 点对点下载、FTP 文件下载、SSH 安全登录、各种即时通信服务等等，它们需要用各自的专有协议来访问。不过由于 HTTP 协议非常灵活、易于扩展，而且“超文本”的表述能力很强，所以很多其他原本不属于 HTTP 的资源也可以“包装”成 HTTP 来访问，这就是我们为什么能够总看到各种“网页应用”——例如“微信网页版”“邮箱网页版”——的原因。 综合起来看，现在的互联网 90% 以上的部分都被万维网，也就是 HTTP 所覆盖，所以把互联网约等于万维网或 HTTP 应该也不算大错。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:1:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"浏览器 在 HTTP 协议里，浏览器的角色被称为“User Agent”即“用户代理”，意思是作为访问者的“代理”来发起 HTTP 请求。不过在不引起混淆的情况下，我们通常都简单地称之为“客户端”。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:2:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"Web 服务器 硬件含义: 物理形式或“云”形式的机器，在大多数情况下它可能不是一台服务器，而是利用反向代理、负载均衡等技术组成的庞大集群。但从外界看来，它仍然表现为一台机器，但这个形象是“虚拟的”。 软件含义: 指提供 Web 服务的应用程序，通常会运行在硬件含义的服务器上。它利用强大的硬件能力响应海量的客户端 HTTP 请求，处理磁盘上的网页、图片等静态文件，或者把请求转发给后面的 Tomcat、Node.js 等业务应用，返回动态的信息。 Apache 是老牌的服务器，到今天已经快 25 年了，功能相当完善，相关的资料很多，学习门槛低，是许多创业者建站的入门产品。 Nginx 是 Web 服务器里的后起之秀，特点是高性能、高稳定，且易于扩展。自 2004 年推出后就不断蚕食 Apache 的市场份额，在高流量的网站里更是不二之选。 此外，还有 Windows 上的 IIS、Java 的 Jetty/Tomcat 等，因为性能不是很高，所以在互联网上应用得较少。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:3:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"CDN CDN：Content Delivery Network 内容分发网络。它应用了 HTTP 协议里的缓存和代理技术，代替源站响应客户端的请求。 “君子协定”robots.txt，约定哪些该爬，哪些不该爬。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:4:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"爬虫 “爬虫”（Crawler），是一种可以自动访问 Web 资源的应用程序。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:5:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"HTML/WebService/WAF HTML ： HTTP 协议传输的主要内容之一，它描述了超文本页面，用各种“标签”定义文字、图片等资源和排版布局，最终由浏览器“渲染”出可视化页面。 Web Service ： 由 W3C 定义的应用服务开发规范，使用 client-server 主从架构，通常使用 WSDL 定义服务接口，使用 HTTP 协议传输 XML 或 SOAP 消息，也就是说，它是一个基于 Web（HTTP）的服务架构技术，既可以运行在内网，也可以在适当保护后运行在外网。 WAF : 意思是“网络应用防火墙”。与硬件“防火墙”类似，它是应用层面的“防火墙”，专门检测 HTTP 流量，是防护 Web 应用的安全技术。WAF 通常位于 Web 服务器之前，可以阻止如 SQL 注入、跨站脚本等攻击，目前应用较多的一个开源项目是 ModSecurity，它能够完全集成进 Apache 或 Nginx。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:6:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"TCP/IP IP 协议是“Internet Protocol”的缩写，主要目的是解决寻址和路由问题，以及如何在两点间传送数据包。 TCP 协议是“Transmission Control Protocol”的缩写，意思是“传输控制协议”，它位于 IP 协议之上，基于 IP 协议提供可靠的、字节流形式的通信，是 HTTP 协议得以实现的基础。 互联网上的 HTTP 协议就运行在了 TCP/IP 上，HTTP 也就可以更准确地称为“HTTP over TCP/IP”。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:7:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"DNS DNS:（Domain Name System 域名系统） 在 DNS 中，“域名”（Domain Name）又称为“主机名”（Host），为了更好地标记不同国家或组织的主机，让名字更好记，所以被设计成了一个有层次的结构。域名用“.”分隔成多个单词，级别从左到右逐级升高，最右边的被称为“顶级域名”。对于顶级域名，可能你随口就能说出几个，例如表示商业公司的“com”、表示教育机构的“edu”，表示国家的“cn”“uk”等。 1 www.12306.cn 要使用 TCP/IP 协议来通信仍然要使用 IP 地址，所以需要把域名做一个转换，“映射”到它的真实 IP，这就是所谓的“域名解析”。 目前全世界有 13 组根 DNS 服务器，下面再有许多的顶级 DNS、权威 DNS 和更小的本地 DNS，逐层递归地实现域名查询。HTTP 协议中并没有明确要求必须使用 DNS，但实际上为了方便访问互联网上的 Web 服务器，通常都会使用 DNS 来定位或标记主机名，间接地把 DNS 与 HTTP 绑在了一起。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:8:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"URI/URL URI（Uniform Resource Identifier 统一资源标识符）使用它就能够唯一地标记互联网上资源。 URI 另一个更常用的表现形式是 URL（Uniform Resource Locator）， 统一资源定位符，也就是我们俗称的“网址”，它实际上是 URI 的一个子集，不过因为这两者几乎是相同的，差异不大，所以通常不会做严格的区分。 1 http://nginx.org/en/download.html URI 主要有三个基本的部分构成： 协议名：即访问该资源应当使用的协议，在这里是“http”； 主机名：即互联网上主机的标记，可以是域名或 IP 地址，在这里是“nginx.org”； 路径：即资源在主机上的位置，使用“/”分隔多级目录，在这里是“/en/download.html”。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:9:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"HTTPS HTTPS : HTTP over SSL/TLS (HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”)。 SSL 的全称是“Secure Socket Layer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“Transport Layer Security”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。 SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:10:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"代理 代理（Proxy）是 HTTP 协议中请求方和应答方中间的一个环节，作为“中转站”，既可以转发客户端的请求，也可以转发服务器的应答。 常见的代理种类： 匿名代理：完全“隐匿”了被代理的机器，外界看到的只是代理服务器； 透明代理：顾名思义，它在传输过程中是“透明开放”的，外界既知道代理，也知道客户端； 正向代理：靠近客户端，代表客户端向服务器发送请求； 反向代理：靠近服务器端，代表服务器响应客户端的请求。 CDN，实际上就是一种代理，它代替源站服务器响应客户端的请求，通常扮演着透明代理和反向代理的角色。 代理的常见作用： 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化； 内容缓存：暂存上下行的数据，减轻后端的压力； 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器； 数据处理：提供压缩、加密等额外的功能。 关于 HTTP 的代理还有一个特殊的“代理协议”（proxy protocol），它由知名的代理软件 HAProxy 制订，但并不是 RFC 标准。 网络分层模型 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:11:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"TCP/IP 网络分层模型 第一层叫“链接层”（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC 层。 第二层叫“网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为 IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代 MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。 第三层叫“传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输，是 TCP 协议工作的层次，另外还有它的一个“小伙伴”UDP。TCP 是一个有状态的协议，需要先与对方建立连接然后才能发送数据，而且保证数据不丢失不重复。而 UDP 则比较简单，它无状态，不用事先建立连接就可以任意发送数据，但不保证数据一定会发到对方。两个协议的另一个重要区别在于数据的形式。TCP 的数据是连续的“字节流”，有先后顺序，而 UDP 则是分散的小数据包，是顺序发，乱序收。 第四层叫“应用层”（application layer），由于下面的三层把基础打得非常好，所以在这一层就“百花齐放”了，有各种面向具体应用的协议。例如 Telnet、SSH、FTP、SMTP 等等，当然还有我们的 HTTP。 MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:12:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"OSI 网络分层模型 第一层：物理层，网络的物理形式，例如电缆、光纤、网卡、集线器等等； 第二层：数据链路层，它基本相当于 TCP/IP 的链接层； 第三层：网络层，相当于 TCP/IP 里的网际层； 第四层：传输层，相当于 TCP/IP 里的传输层； 第五层：会话层，维护网络中的连接状态，即保持会话和同步； 第六层：表示层，把数据转换为合适、可理解的语法和语义； 第七层：应用层，面向具体的应用传输数据。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:13:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"两个分层模型的映射关系 第一层：物理层，TCP/IP 里无对应； 第二层：数据链路层，对应 TCP/IP 的链接层； 第三层：网络层，对应 TCP/IP 的网际层； 第四层：传输层，对应 TCP/IP 的传输层； 第五、六、七层：统一对应到 TCP/IP 的应用层。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:14:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"TCP/IP 协议栈的工作方式 HTML –\u003e HTTP 协议为它加一个 HTTP 专用附加数据 –\u003e TCP 层给数据再次打包，加上了 TCP 头 –\u003e IP 层、MAC 层对 TCP 数据包加上了 IP 头、MAC 头 –\u003e 传输 二层转发：设备工作在链路层，帧在经过交换机设备时，检查帧的头部信息，拿到目标mac地址，进行本地转发和广播 三层路由：设备工作在ip层，报文经过有路由功能的设备时，设备分析报文中的头部信息，拿到ip地址，根据网段范围，进行本地转发或选择下一个网关 四层负载均衡：工作在传输层上，基于TCP/IP协议的特性，例如Ip地址，端口号等实现对后端服务器的负载均衡 七层负载均衡：工作在应用层上，看到的是HTTP协议，解析HTTP报文里的URI、主机名、资源类型等数据，再用适当的策略转发给后端服务器 凡是由操作系统负责处理的就是四层或四层以下，否则，凡是需要由应用程序（也就是你自己写代码）负责处理的就是七层。 域名解析 总结如下： 浏览器缓存-\u003e操作系统dnscache -\u003ehosts文件-\u003e非权威域名服务器-\u003e根域名服务器-\u003e顶级域名服务器-\u003e二级域名服务器-\u003e权威域名服务器。 其中非权威域名服务器还包括LDNS（企业内网DNS服务器），三大营运商DNS，谷歌公开的DNS，微软公开的DNS等。 另外DNS请求有两种方式：递归查询和迭代查询。LDNS往后面查询一般是递归查询，因为公司内网是有防火墙的，全部请求通过LDNS来递归查询然后把结果给内网用户。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http/:15:0","tags":["network","HTTP"],"title":"HTTP:HTTP介绍","uri":"/posts/basic_knowledge/network/http/http/"},{"categories":["network"],"content":"HTTP协议","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/","tags":["network","HTTP"],"title":"HTTP:HTTP协议","uri":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/"},{"categories":["network"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. HTTP 简介 1.1. HTTP 工作原理 2. HTTP 请求方法 3. HTTP 响应头信息 4. HTTP状态码 4.1. HTTP状态码分类 5. HTTP content-type 5.1. HTTP content-type 对照表 1. HTTP 简介 HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。 HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/:0:0","tags":["network","HTTP"],"title":"HTTP:HTTP协议","uri":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/"},{"categories":["network"],"content":"1.1. HTTP 工作原理 HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。 Web服务器有：Apache服务器，IIS服务器（Internet Information Services）等。 Web服务器根据接收到的请求后，向客户端发送响应信息。 HTTP默认端口号为80，但是你也可以改为8080或者其他端口。 HTTP三点注意事项： HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。 HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 2. HTTP 请求方法 根据 HTTP 标准，HTTP 请求可以使用多种请求方法。 HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD 方法。 HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。 序号 方法 描述 1 GET 请求指定的页面信息，并返回实体主体。 2 HEAD 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 3 POST 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 4 PUT 从客户端向服务器传送的数据取代指定的文档的内容。 5 DELETE 请求服务器删除指定的页面。 6 CONNECT HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 7 OPTIONS 允许客户端查看服务器的性能。 8 TRACE 回显服务器收到的请求，主要用于测试或诊断。 9 PATCH 是对 PUT 方法的补充，用来对已知资源进行局部更新 3. HTTP 响应头信息 HTTP请求头提供了关于请求，响应或者其他的发送实体的信息。 在本章节中我们将具体来介绍HTTP响应头信息。 应答头 说明 Allow 服务器支持哪些请求方法（如GET、POST等）。 Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。 Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入 ByteArrayOutputStream，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。 Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。 Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。 Expires 应该在什么时候认为文档已经过期，从而不再缓存它？ Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。 Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=http://host/path”)让浏览器读取指定的页面。 注意这种功能通常是通过设置HTML页面HEAD区的＜META HTTP-EQUIV=“Refresh” CONTENT=“5;URL=http://host/path\"＞实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。 注意Refresh的意义是\"N秒之后刷新本页面或访问指定页面”，而不是\"每隔N秒刷新本页面或访问指定页面\"。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是＜META HTTP-EQUIV=“Refresh” …＞。 注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。 Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。 WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=＼“executives＼”\")。 注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。 4. HTTP状态码 当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 HTTP状态码的英文为HTTP Status Code。 下面是常见的HTTP状态码： 200 - 请求成功 301 - 资源（网页等）被永久转移到其它URL 404 - 请求的资源（网页等）不存在 500 - 内部服务器错误 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/:1:0","tags":["network","HTTP"],"title":"HTTP:HTTP协议","uri":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/"},{"categories":["network"],"content":"4.1. HTTP状态码分类 HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型： 分类 分类描述 1** 信息，服务器收到请求，需要请求者继续执行操作 2** 成功，操作被成功接收并处理 3** 重定向，需要进一步的操作以完成请求 4** 客户端错误，请求包含语法错误或无法完成请求 5** 服务器错误，服务器在处理请求的过程中发生了错误 HTTP状态码列表: 状态码 状态码英文名称 中文描述 100 Continue 继续。客户端应继续其请求 101 Switching Protocols 切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议 200 OK 请求成功。一般用于GET与POST请求 201 Created 已创建。成功请求并创建了新的资源 202 Accepted 已接受。已经接受请求，但未处理完成 203 Non-Authoritative Information 非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本 204 No Content 无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档 205 Reset Content 重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域 206 Partial Content 部分内容。服务器成功处理了部分GET请求 300 Multiple Choices 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 301 Moved Permanently 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 302 Found 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI 303 See Other 查看其它地址。与301类似。使用GET和POST请求查看 304 Not Modified 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 305 Use Proxy 使用代理。所请求的资源必须通过代理访问 306 Unused 已经被废弃的HTTP状态码 307 Temporary Redirect 临时重定向。与302类似。使用GET请求重定向 400 Bad Request 客户端请求的语法错误，服务器无法理解 401 Unauthorized 请求要求用户的身份认证 402 Payment Required 保留，将来使用 403 Forbidden 服务器理解请求客户端的请求，但是拒绝执行此请求 404 Not Found 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置\"您所请求的资源无法找到\"的个性页面 405 Method Not Allowed 客户端请求中的方法被禁止 406 Not Acceptable 服务器无法根据客户端请求的内容特性完成请求 407 Proxy Authentication Required 请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权 408 Request Time-out 服务器等待客户端发送的请求时间过长，超时 409 Conflict 服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突 410 Gone 客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置 411 Length Required 服务器无法处理客户端发送的不带Content-Length的请求信息 412 Precondition Failed 客户端请求信息的先决条件错误 413 Request Entity Too Large 由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息 414 Request-URI Too Large 请求的URI过长（URI通常为网址），服务器无法处理 415 Unsupported Media Type 服务器无法处理请求附带的媒体格式 416 Requested range not satisfiable 客户端请求的范围无效 417 Expectation Failed 服务器无法满足Expect的请求头信息 500 Internal Server Error 服务器内部错误，无法完成请求 501 Not Implemented 服务器不支持请求的功能，无法完成请求 502 Bad Gateway 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 503 Service Unavailable 由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中 504 Gateway Time-out 充当网关或代理的服务器，未及时从远端服务器获取请求 505 HTTP Version not supported 服务器不支持请求的HTTP协议的版本，无法完成处理 5. HTTP content-type Content-Type（内容类型），一般是指网页中存在的 Content-Type，用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件，这就是经常看到一些 PHP 网页点击的结果却是下载一个文件或一张图片的原因。 Content-Type 标头告诉客户端实际返回的内容的内容类型。 语法格式： 1 2 Content-Type: text/html; charset=utf-8 Content-Type: multipart/form-data; boundary=something 常见的媒体格式类型如下： text/html ： HTML格式 text/plain ：纯文本格式 text/xml ： XML格式 image/gif ：gif图片格式 image/jpeg ：jpg图片格式 image/png：png图片格式 以application开头的媒体格式类型： application/xhtml+xml ：XHTML格式 application/xml： XML数据格式 application/atom+xml ：Atom XML聚合格式 application/json： JSON数据格式 application/pdf：pdf格式 application/msword ： Word文档格式 application/octet-stream ： 二进制流数据（如常见的文件下载） application/x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式） 另外一种常见的媒体格式是上传文件之时使用的： multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/:2:0","tags":["network","HTTP"],"title":"HTTP:HTTP协议","uri":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/"},{"categories":["network"],"content":"5.1. HTTP content-type 对照表 文件扩展名 Content-Type(Mime-Type) 文件扩展名 Content-Type(Mime-Type) .*（ 二进制流，不知道下载文件类型） application/octet-stream .tif image/tiff .001 application/x-001 .301 application/x-301 .323 text/h323 .906 application/x-906 .907 drawing/907 .a11 application/x-a11 .acp audio/x-mei-aac .ai application/postscript .aif audio/aiff .aifc audio/aiff .aiff audio/aiff .anv application/x-anv .asa text/asa .asf video/x-ms-asf .asp text/asp .asx video/x-ms-asf .au audio/basic .avi video/avi .awf application/vnd.adobe.workflow .biz text/xml .bmp application/x-bmp .bot application/x-bot .c4t application/x-c4t .c90 application/x-c90 .cal application/x-cals .cat application/vnd.ms-pki.seccat .cdf application/x-netcdf .cdr application/x-cdr .cel application/x-cel .cer application/x-x509-ca-cert .cg4 application/x-g4 .cgm application/x-cgm .cit application/x-cit .class java/* .cml text/xml .cmp application/x-cmp .cmx application/x-cmx .cot application/x-cot .crl application/pkix-crl .crt application/x-x509-ca-cert .csi application/x-csi .css text/css .cut application/x-cut .dbf application/x-dbf .dbm application/x-dbm .dbx application/x-dbx .dcd text/xml .dcx application/x-dcx .der application/x-x509-ca-cert .dgn application/x-dgn .dib application/x-dib .dll application/x-msdownload .doc application/msword .dot application/msword .drw application/x-drw .dtd text/xml .dwf Model/vnd.dwf .dwf application/x-dwf .dwg application/x-dwg .dxb application/x-dxb .dxf application/x-dxf .edn application/vnd.adobe.edn .emf application/x-emf .eml message/rfc822 .ent text/xml .epi application/x-epi .eps application/x-ps .eps application/postscript .etd application/x-ebx .exe application/x-msdownload .fax image/fax .fdf application/vnd.fdf .fif application/fractals .fo text/xml .frm application/x-frm .g4 application/x-g4 .gbr application/x-gbr . application/x- .gif image/gif .gl2 application/x-gl2 .gp4 application/x-gp4 .hgl application/x-hgl .hmr application/x-hmr .hpg application/x-hpgl .hpl application/x-hpl .hqx application/mac-binhex40 .hrf application/x-hrf .hta application/hta .htc text/x-component .htm text/html .html text/html .htt text/webviewhtml .htx text/html .icb application/x-icb .ico image/x-icon .ico application/x-ico .iff application/x-iff .ig4 application/x-g4 .igs application/x-igs .iii application/x-iphone .img application/x-img .ins application/x-internet-signup .isp application/x-internet-signup .IVF video/x-ivf .java java/* .jfif image/jpeg .jpe image/jpeg .jpe application/x-jpe .jpeg image/jpeg .jpg image/jpeg .jpg application/x-jpg .js application/x-javascript .jsp text/html .la1 audio/x-liquid-file .lar application/x-laplayer-reg .latex application/x-latex .lavs audio/x-liquid-secure .lbm application/x-lbm .lmsff audio/x-la-lms .ls application/x-javascript .ltr application/x-ltr .m1v video/x-mpeg .m2v video/x-mpeg .m3u audio/mpegurl .m4e video/mpeg4 .mac application/x-mac .man application/x-troff-man .math text/xml .mdb application/msaccess .mdb application/x-mdb .mfp application/x-shockwave-flash .mht message/rfc822 .mhtml message/rfc822 .mi application/x-mi .mid audio/mid .midi audio/mid .mil application/x-mil .mml text/xml .mnd audio/x-musicnet-download .mns audio/x-musicnet-stream .mocha application/x-javascript .movie video/x-sgi-movie .mp1 audio/mp1 .mp2 audio/mp2 .mp2v video/mpeg .mp3 audio/mp3 .mp4 video/mpeg4 .mpa video/x-mpg .mpd application/vnd.ms-project .mpe video/x-mpeg .mpeg video/mpg .mpg video/mpg .mpga audio/rn-mpeg .mpp application/vnd.ms-project .mps video/x-mpeg .mpt application/vnd.ms-project .mpv video/mpg .mpv2 video/mpeg .mpw application/vnd.ms-project .mpx application/vnd.ms-project .mtx text/xml .mxp application/x-mmxp .net image/pnetvue .nrf application/x-nrf .nws message/rfc822 .odc text/x-ms-odc .out application/x-out .p10 application/pkcs10 .p12 application/x-pkcs12 .p7b application/x-pkcs7-certificates .p7c application/pkcs7-mime .p7m application/pkcs7-mime .p7r application/x-pkcs7-certreqresp ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/:3:0","tags":["network","HTTP"],"title":"HTTP:HTTP协议","uri":"/posts/basic_knowledge/network/http/http%E5%8D%8F%E8%AE%AE/"},{"categories":["network"],"content":"常用网络工具(linux)","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["network"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 nc命令测试带宽 FTP服务器 vsftpd FRP 内网穿透 frps.ini 配置 frpc.ini 配置 配置自启动服务 nc命令测试带宽 nc命令会建立两个服务器的TCP连接，通过传输文件块来测试传输速度 阿里云服务器 : —.—.—.— ./ssh_authorize.sh root@—.—.—.— 服务端： 1 nc -l 1567 \u003e /dev/null 客户端： 1 dd if=/dev/zero bs=1MB count=1 |nc 47.105.71.251 1567 结果输出： 1 2 3 记录了1+0 的读入 记录了1+0 的写出 1000000 bytes (1.0 MB, 977 KiB) copied, 0.700114 s, 1.4 MB/s FTP服务器 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/:0:0","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["network"],"content":"vsftpd 提示：需要以管理员身份来操作 1 su root 检查vsftpd 是否已经安装 1 ls /usr/sbin/vsftpd 安装 vsftpd 1 apt install vsftpd 修改vsftpd.conf 配置 1 2 cp /etc/vsftpd.conf /etc/vsftpd.conf.2 先备份一下 gedit /etc/vsftpd.conf 在文本编辑器里，找到这一行，并去掉这一行前面的#号 1 write_enable=YES 注意: (1) Linux的系统配置文件，一般都放在 /etc 下面 (2) Linux的配置文件一般都是这个风格: key=value 关闭系统的防火墙 1 ufw disable 启动服务 FTP服务器 1 2 3 4 5 service vsftpd start 同理，相关的命令还有： service vsftpd status 查看服务状态 service vsftpd stop 停止 service vsftpd restart 重启 FRP 内网穿透 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/:1:0","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["network"],"content":"frps.ini 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [common] # frp监听的端口，默认是7000，可以改成其他的 bind_port = 7000 # 授权码，请改成更复杂的 token = ZYH123 # frp管理后台端口，请按自己需求更改 dashboard_port = 7500 # frp管理后台用户名和密码，请改成自己的 dashboard_user = zyh dashboard_pwd = ZYH123 enable_prometheus = true # frp日志配置 log_file = /var/log/frps.log log_level = info log_max_days = 3 执行 1 ./frps -c frps.ini ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/:2:0","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["network"],"content":"frpc.ini 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [common] server_addr = ---.---.---.--- # 与frps.ini的bind_port一致 server_port = 7000 # 与frps.ini的token一致 token = ZYH123 # 配置ssh服务 [ssh] type = tcp local_ip = 127.0.0.1 local_port = 22 # 这个自定义，之后再ssh连接的时候要用 remote_port = 6000 执行 1 ./frpc -c frpc.ini 服务器端防火墙开启常见端口 1 2 udo firewall-cmd --permanent --add-port=6000/tcp sudo firewall-cmd --reload ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/:3:0","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["network"],"content":"配置自启动服务 编辑 /etc/systemd/system/frp.service 1 sudo vim /etc/systemd/system/frp.service 内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [Unit] Description=frps daemon After=syslog.target network.target Wants=network.target [Service] Type=simple ExecStart=/root/frp/frps -c /root/frp/frps.ini Restart= always RestartSec=1min [Install] WantedBy=multi-user.target 刷新服务列表： 1 systemctl daemon-reload 设置开机自启 1 systemctl enable frp 关闭开机自启 1 systemctl disable frp 启动服务 1 systemctl start frp 停止服务 1 systemctl stop frp ","date":"2023-02-09","objectID":"/posts/basic_knowledge/network/network/network/:4:0","tags":["network","网络工具"],"title":"network:常用网络工具(linux)","uri":"/posts/basic_knowledge/network/network/network/"},{"categories":["ubus"],"content":"ubus介绍","date":"2023-02-09","objectID":"/posts/basic_knowledge/ubus/ubus/","tags":["ubus"],"title":"ubus:ubus介绍","uri":"/posts/basic_knowledge/ubus/ubus/"},{"categories":["ubus"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 简介 2. ubus的实现框架 3. ubus的实现原理 4. ubus的应用场景和局限性 5. ubus源码简析 5.1. ubusd工作流程 5.2. client的工作流程 1. 简介 ubus为openwrt平台开发中的进程间通信提供了一个通用的框架。 它让进程间通信的实现变得非常简单，并且ubus具有很强的可移植性，可以很方便的移植到其他linux平台上使用。本文描述了ubus的实现原理和整体框架。 ubus源码可通过Git库 git://nbd.name/luci2/ubus.git 获得，其依赖的ubox库的git库：git://nbd.name/luci2/ubox.git。 2. ubus的实现框架 ubus实现的基础是unix socket，即本地socket，它相对于用于网络通信的inet socket 更高效，更具可靠性。unix socket客户端和服务器的实现方式和网络socket类似，读者如果还不太熟悉可查阅相关资料。 我们知道实现一个简单的unix socket服务器和客户端需要做如下工作： 建立一个socket server端，绑定到一个本地socket文件，并监听clients的连接。 建立一个或多个socket client端，连接server。 client和server相互发送消息。 client或server收到对方消息后，针对具体消息进行相应处理。 ubus同样实现了上述组件，并对socket连接以及消息传输和处理进行了封装： ubus提供了一个socket server：ubusd。因此开发者不需要自己实现server端。 ubus提供了创建socket client端的接口，并且提供了三种现成的客户端供用户直接使用： 为shell脚本提供的client端。 为lua脚本提供的client接口。 为C语言提供的client接口。 可见ubus对shell和lua增加了支持，后面会介绍这些客户端的用法。 ubus对client和server之间通信的消息格式进行了定义：client和server都必须将消息封装成json消息格式。 ubus对client端的消息处理抽象出“对象（object）”和“方法（method）”的概念。一个对象中包含多个方法，client需要向server注册收到特定json消息时的处理方法。对象和方法都有自己的名字，发送请求方只需在消息中指定要调用的对象和方法的名字即可。 使用ubus时需要引用一些动态库，主要包括： libubus.so：ubus向外部提供的编程接口，例如创建socket，进行监听和连接，发送消息等接口函数。 libubox.so：ubus向外部提供的编程接口，例如等待和读取消息。 libblobmsg.so，libjson.so：提供了封装和解析json数据的接口，编程时不需要直接使用libjson.so，而是使用libblobmsg.so提供的更灵活的接口函数。 ubus中各组件的关系如下图所示： 使用ubus进行进程间通信不需要编写大量代码，只需按照固定模式调用ubus提供的API即可。 在ubus源码中examples目录下有一些例子可以参考。在我的另一篇文章中， 通过代码实例说明了ubus提供的三种进程间通信的方式 点击打开链接 3. ubus的实现原理 下面以一个例子说明ubus的工作原理： 下图中，client2试图通过ubus修改ip地址，而修改ip地址的函数在client1中定义。 client2进行请求的整个过程为： client1向ubusd注册了两个对象：“interface”和“dotalk”，其中“interface”对象中注册了两个 method：“getlanip”和“setlanip”，对应的处理函数分别为func1()和func2()。 “dotalk”对象中注册了两个method：“sayhi”和“saybye”，对应的处理函数分别为func3()和func4()。 接着创建一个client2用来与client1通信，注意，两个client之间不能直接通信，需要经ubusd（server）中转。 client2就是在前面讲到的shell/lua/C客户端。假设这里使用shell客户端，在终端输入以下命令： ubus call interface setlanip ‘{“ip”:“10.0.0.1”, “mask”:24}’ ubus的call命令带三个参数：请求的对象名，需要调用的方法名，要传给方法的参数。 消息发到server后，server根据对象名找到应该将请求转发给client1，然后将消息发送到client1， client1进而调用func2()接受参数并处理，如果处理完成后需要回复client2，则发送回复消息。 接下来介绍一下上述过程中，ubus内部的处理机制，虽然使用ubus进行进程间通信不需要关注这些实现细节， 但有助于加深对ubus实现原理的理解。 下图中，client1注册对象和方法，其实可认为是服务提供端，只不过对于ubusd来讲是一个socket client。client2去调用client1注册的方法 4. ubus的应用场景和局限性 ubus可用于两个进程之间的通信，并以类似json格式进行数据交互。ubus的常见场景为： “客户端–服务器”形式的交互，即进程A注册一系列的服务，进程B去调用这些服务。 ubus支持以“订阅 – 通知”的方式进行进程通信，即进程A提供订阅服务， 其他进程可以选择订阅或退订该服务，进程A可以向所有订阅者发送消息。 由于ubus实现方式的限制，在一些场景中不适宜使用ubus： ubus用于少量数据的传输，如果数据量很大或是数据交互很频繁，则不宜用ubus。经过测试， 当ubus一次传输数据量超过60KB，就不能正常工作了。 ubus对多线程支持的不好，例如在多个线程中去请求同一个服务，就有可能出现不可预知的结果。 不建议递归调用ubus，例如进程A去调用进程B的服务，而B的该服务需要调用进程C的服务， 之后C将结果返回给B，然后B将结果返回给A。如果不得不这样做，需要在调用过程中避免全局变量的重用问题。 5. ubus源码简析 下面介绍一下ubusd和ubus client工作时的代码流程，这里为了便于理解，只介绍大致的流程， 欲了解详细的实现请读者自行阅读源码。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/ubus/ubus/:0:0","tags":["ubus"],"title":"ubus:ubus介绍","uri":"/posts/basic_knowledge/ubus/ubus/"},{"categories":["ubus"],"content":"5.1. ubusd工作流程 ubusd 的初始化所做的工作如下： epoll_create(32)创建出一个poll_fd。 创建一个UDP unix socket，并添加到poll_fd的监听队列。 进行epoll_wait()等待消息。收到消息后的处理函数定义如下： 1 2 3 static struct uloop_fd server_fd = { .cb = server_cb, }; 即调用server_cb()函数。 server_cb()函数中的工作为： 进行accept()，接受client连接，并为该连接生成一个client_fd。 为client分配一个client id，用于ubusd区分不同的client。 向client发送一个HELLO消息作为连接建立的标志。 将client_fd添加到poll_fd的监听队列中，用于监听client发过来的消息，消息处理函数为client_cb()。 也就是说ubusd监听两种消息，一种是新client的连接请求，一种是现有的每个client发过来的数据。 当ubusd收到一个client的数据后，调用client_cb()函数的处理过程： 先检查一下是否有需要向这个client回复的数据（可能是上一次请求没处理完），如果有，先发送这些遗留数据。 读取socket上的数据，根据消息类型（数据中都指定了消息类型的）调用相应的处理函数，消息类型和处理函数定义如下： 1 2 3 4 5 6 7 8 9 10 11 12 static const ubus_cmd_cb handlers[__UBUS_MSG_LAST] = { [UBUS_MSG_PING] = ubusd_send_pong, [UBUS_MSG_ADD_OBJECT] = ubusd_handle_add_object, [UBUS_MSG_REMOVE_OBJECT] = ubusd_handle_remove_object, [UBUS_MSG_LOOKUP] = ubusd_handle_lookup, [UBUS_MSG_INVOKE] = ubusd_handle_invoke, [UBUS_MSG_STATUS] = ubusd_handle_response, [UBUS_MSG_DATA] = ubusd_handle_response, [UBUS_MSG_SUBSCRIBE] = ubusd_handle_add_watch, [UBUS_MSG_UNSUBSCRIBE] = ubusd_handle_remove_watch, [UBUS_MSG_NOTIFY] = ubusd_handle_notify, }; 例如，如果收到invoke消息，就调用ubusd_handle_invoke()函数处理。 这些处理函数可能是ubusd处理完后需要回发给client数据，或者是将消息转发给另一个client （如果发送请求的client需要和另一个client进行通信）。 处理完成后，向client发送处理结果，例如UBUS_STATUS_OK。（注意，client发送数据是UBUS_MSG_DATA类型的） ","date":"2023-02-09","objectID":"/posts/basic_knowledge/ubus/ubus/:1:0","tags":["ubus"],"title":"ubus:ubus介绍","uri":"/posts/basic_knowledge/ubus/ubus/"},{"categories":["ubus"],"content":"5.2. client的工作流程 ubus call obj method的工作流程： 创建一个unix socket(UDP)连接ubusd，并接收到server发过来的HELLO消息。 ubus call命令由ubus_cli_call()函数进行处理，先向ubusd发送lookup消息请求obj的id。 然后向ubusd发送invoke消息来调用obj的method方法。 创建epoll_fd并将client的fd添加到监听列表中等待消息。 client收到消息后的处理函数为ubus_handle_data()，其中UBUS_MSG_DATA类型的数据 receive_call_result_data()函数协助解析。 被call的client的工作流程： 和ubus客户端的流程相似，只是变成了接受请求并调用处理函数。 ","date":"2023-02-09","objectID":"/posts/basic_knowledge/ubus/ubus/:2:0","tags":["ubus"],"title":"ubus:ubus介绍","uri":"/posts/basic_knowledge/ubus/ubus/"},{"categories":["bash"],"content":"shell脚本记录:比较拷贝文件","date":"2023-02-03","objectID":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/","tags":["shell脚本"],"title":"shell脚本记录:比较拷贝文件","uri":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 功能 脚本 功能 比较参数1，2两个路径中到文件，把参数1路径多出到文件，按完整路径，拷贝到result目录下 脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 ```bash #!/bin/bash # 使用示例： # source to_find_prop_files.sh ~/workspace/org_source_code/out ~/workspace/tsrc_code/out ~/workspace/to_vrz_src_code/out # 参数1的源包含主要文件和更多的库 # 参数2的源不包含vendor路径。 # 结果将保存在当前目录的result文件夹中。 dir=\"result\" dir1=$1 dir2=$2 # 如果result文件夹存在，则先删除旧的result目录，并重新创建一个新的result目录。 if [ -e $dir ]; then rm -rf $dir fi mkdir $dir # 为result目录创建日志文件 touch $dir/same_path.log touch $dir/props_files.log function find_props() { for element in $(ls \"$1\"); do dir1_or_file=\"$1/$element\" if [ -d \"$dir1_or_file\" ]; then dir2_or_file=\"$2/$element\" if [ -e \"$dir2_or_file\" ]; then find_props \"$dir1_or_file\" \"$dir2_or_file\" else sub_path=\"$dir/$2\" mkdir -p \"$sub_path\" cp -rf \"$dir1_or_file\" \"$sub_path\" echo \"$dir1_or_file\" \u003e\u003e$dir/props_files.log fi else file2=\"$2/$element\" if [ -e \"$file2\" ]; then echo \"$file2\" \u003e\u003e$dir/same_path.log else sub_path=\"$dir/$2\" mkdir -p \"$sub_path\" cp -rf \"$dir1_or_file\" \"$sub_path\" echo \"$dir1_or_file\" \u003e\u003e$dir/props_files.log fi fi done } find_props \"$dir1\" \"$dir2\" ``` ","date":"2023-02-03","objectID":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/:0:0","tags":["shell脚本"],"title":"shell脚本记录:比较拷贝文件","uri":"/posts/program/bash/%E8%84%9A%E6%9C%AC%E8%AE%B0%E5%BD%95%E6%AF%94%E8%BE%83%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6/"},{"categories":["program"],"content":"sql查询语句","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 基础语法 样例 sql的书写规则 注释的使用 运算符 字符串模糊查询 在线网站 基础语法 ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":"样例 1 2 3 4 5 6 7 8 9 10 select ... # 列名1,列名2,列名N 查询需要输出的内容；最后顺序运行 name as 姓名 , distinct name as 姓名 # 进行去重 from ... # 从什么表中查询 where ... # 满足某种条件的内容 name is not null # 姓名不是空 number == '002' # 指定学号 ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:1:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":"sql的书写规则 以英文分号 ; 结尾； 所有的符合必须在英文状态输入； 关键字不区分大小写（一般显示蓝色的），如select和SELECT 一样； 但列名等非关键字区分大小写。 每一列的列名及字段名不可以加单引号；且列名不可以有空格（姓名OK，但姓 名不行；） 语句之间不能有空格行； ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:2:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":"注释的使用 单行注释用“— XXX”线后面有一个空格； 多行注释用“/**/” ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:3:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":"运算符 算术运算符：+、-、*、/—-加减乘除； 所有数据和NULL运算为空； 例如 5+null =null; 比较运算符： \u003e、\u003e=、\u003c、\u003c=、\u003c\u003e(不等于）; 字符串的比较，从头开始一个个比较，例如 字符串 ‘10’\u003c ‘2’; 逻辑运算符： and（且）、or（或）、in(在。。间），in是OR的简写版； between and (在什么 区间）； ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:4:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["program"],"content":"字符串模糊查询 % 代表任意字符串 where 姓名 like ‘猴%’——查找第一一个字是猴 where 姓名 like ‘%猴’——查找最后一个字是猴的 where 姓名 like ‘%猴%’——查找中间包含一个字是猴的 _ 1个下划线表示任意一个字符，几个下划线就几个字符 where 姓名 like ‘猴__’——查找第一一个字是猴且包含3个字的 在线网站 SELECT 1 2 3 4 5 6 7 8 9 10 select name as 名称, gdp as GDP , area as 面积 from world where name != 'France'and gdp \u003e 2029812000000 and area in (242900, 377930) ","date":"2023-02-03","objectID":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:5:0","tags":["sql"],"title":"sql:sql查询语句","uri":"/posts/program/sql/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["开源软件"],"content":"CGraph 语法解释","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++ ()和{} CGraph 中使用 [[nodiscard]] friend class 友元函数 友元类 友元类的应用场景 CGraph 中使用 std::enable_if \u0026 std::enable_if_t SFINAE std::enable_if enable_if_t CGraph 中使用 C++ ()和 cppreference.com : Punctuation （）用来表示函数调用，包括普通函数和构建函数，以及可以给内建类型初始化 1 int *p = new int[1000](); // 内建类型圆括号初始化是语法，是标准 {} 提供列表初始化的功能，最终调用的是构造函数 1 2 Point{} // 调用的是Point::Point()构造函数 Point{x, y} // 嗲用的是Point::Point(x, y)构造函数 构造一个匿名的类直接使用Point{}即可，它调用构造函数，但是是临时的，并没有名字指向它，调用完之后再无法找到这个匿名类。 ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:0:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"CGraph 中使用 1 2 3 /* 定义GElementPtr类型的变量 */ GElementPtr a, b, c, d = nullptr; status += pipeline-\u003eregisterGElement\u003cMyNode2\u003e(\u0026d, {b, c}, \"nodeD\"); // 将名为nodeD，依赖{b,c}执行的node信息，注册入pipeline中 函数原型： 1 2 3 4 5 template\u003ctypename T, CLevel level, c_enable_if_t\u003cstd::is_base_of\u003cGElement, T\u003e::value, int\u003e\u003e CStatus GPipeline::registerGElement(GElementPtr *elementRef, const GElementPtrSet \u0026dependElements, const std::string \u0026name, CSize loop) GElementPtrSet 定义： 1 using GElementPtrSet = std::set\u003cGElementPtr\u003e; 所以这里 pipeline-\u003eregisterGElement\u003cMyNode2\u003e(\u0026d, {b, c}, \"nodeD\"); 是使用 b, c 直接构造了 GElementPtrSet 作为函数参数。 [[nodiscard]] C++17引入了[[nodiscard]]属性。 当用于描述函数的返回值时，如果调用函数的地方没有获取返回值时，编译器会给予警告 当用于描述类或枚举类时，如果函数的返回值是该类或枚举类的对象时（引用或指针不可以），如果该返回值没有被获取，编译器给予警告。 friend class ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:1:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"友元函数 在友元函数内部就可以访问该类对象的私有成员。 将全局函数声明为友元的写法如下： 1 friend 返回值类型 函数名(参数表); 将其他类的成员函数声明为友元的写法如下： 1 friend 返回值类型 其他类的类名::成员函数名(参数表); 但是，不能把其他类的私有成员函数声明为友元。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u003ciostream\u003e using namespace std; class CCar; //提前声明CCar类，以便后面的CDriver类使用 class CDriver { public: void ModifyCar(CCar* pCar); //改装汽车 }; class CCar { private: int price; friend int MostExpensiveCar(CCar cars[], int total); //声明友元 friend void CDriver::ModifyCar(CCar* pCar); //声明友元 }; void CDriver::ModifyCar(CCar* pCar) { pCar-\u003eprice += 1000; //汽车改装后价值增加 } int MostExpensiveCar(CCar cars[], int total) //求最贵气车的价格 { int tmpMax = -1; for (int i = 0; i\u003ctotal; ++i) if (cars[i].price \u003e tmpMax) tmpMax = cars[i].price; return tmpMax; } int main() { return 0; } ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:2:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"友元类 一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有和保护的成员，把类B叫做类A的友元。在类定义中声明友元类的写法如下： 1 friend class 类名; 来看如下例程： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class CCar { private: int price; friend class CDriver; //声明 CDriver 为友元类 }; class CDriver { public: CCar myCar; void ModifyCar() //改装汽车 { myCar.price += 1000; //因CDriver是CCar的友元类，故此处可以访问其私有成员 } }; int main() { return 0; } 一般来说，类 A 将类 B 声明为友元类，则类 B 最好从逻辑上和类 A 有比较接近的关系。例如上面的例子，CDriver 代表司机，CCar 代表车，司机拥有车，所以 CDriver 类和 CCar 类从逻辑上来讲关系比较密切，把 CDriver 类声明为 CCar 类的友元比较合理。 友元关系在类之间不能传递，即类 A 是类 B 的友元，类 B 是类 C 的友元，并不能导出类 A 是类 C 的友元。“咱俩是朋友，所以你的朋友就是我的朋友”这句话在 C++ 的友元关系上 不成立。 ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:3:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"友元类的应用场景 假设我们要设计一个模拟电视机和遥控器的程序。大家都之道，遥控机类和电视机类是不相包含的，而且，遥控器可以操作电视机，但是电视机无法操作遥控器，这就比较符合友元的特性了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 #include \u003ciostream\u003e using namespace std; class TV { public : friend class Tele; TV():on_off(off),volume(20),channel(3),mode(tv){} private : enum {on,off}; enum {tv,av}; enum {minve,maxve=100}; enum {mincl,maxcl=60}; bool on_off; int volume; int channel; int mode; }; class Tele { public : void OnOFF(TV\u0026t){t.on_off=(t.on_off==t.on)?t.off:t.on;} void SetMode(TV\u0026t){t.mode=(t.mode==t.tv)?t.av:t.tv;} bool VolumeUp(TV\u0026t); bool VolumeDown(TV\u0026t); bool ChannelUp(TV\u0026t); bool ChannelDown(TV\u0026t); void show(TV\u0026t) const ; }; bool Tele::VolumeUp(TV\u0026t) { if (t.volume\u003ct.maxve) { t.volume++; return true ; } else { return false ; } } bool Tele::VolumeDown(TV\u0026t) { if (t.volume\u003et.minve) { t.volume--; return true ; } else { return false ; } } bool Tele::ChannelUp(TV\u0026t) { if (t.channel\u003ct.maxcl) { t.channel++; return true ; } else { return false ; } } bool Tele::ChannelDown(TV\u0026t) { if (t.channel\u003et.mincl) { t.channel--; return true ; } else { return false ; } } void Tele::show(TV\u0026t) const { if (t.on_off==t.on) { cout\u003c\u003c \"电视现在\" \u003c\u003c(t.on_off==t.on? \"开启\" : \"关闭\" )\u003c\u003cendl; cout\u003c\u003c \"音量大小为：\" \u003c\u003ct.volume\u003c\u003cendl; cout\u003c\u003c \"信号接收模式为：\" \u003c\u003c(t.mode==t.av? \"AV\" : \"TV\" )\u003c\u003cendl; cout\u003c\u003c \"频道为：\" \u003c\u003ct.channel\u003c\u003cendl; } else { cout\u003c\u003c \"电视现在\" \u003c\u003c(t.on_off==t.on? \"开启\" : \"关闭\" )\u003c\u003cendl; } } int main() { Tele t1; TV t2; t1.show(t2); t1.OnOFF(t2); t1.show(t2); cout\u003c\u003c \"调大声音\" \u003c\u003cendl; t1.VolumeUp(t2); cout\u003c\u003c \"频道+1\" \u003c\u003cendl; t1.ChannelUp(t2); cout\u003c\u003c \"转换模式\" \u003c\u003cendl; t1.SetMode(t2); t1.show(t2); return 0; } ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:4:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"CGraph 中使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class GElement : public GElementObject { .... protected: explicit GElement(); ~GElement() override; virtual CStatus beforeRun(); ..... protected: CBool done_ { false }; // 判定被执行结束 CBool linkable_ { false }; // 判定是否可以连通计算 ..... friend class GNode; friend class GCluster; ..... }; GNode ,GCluster 等可以使用 GElement 中私有或者收保护的变量和方法。 std::enable_if \u0026 std::enable_if_t C++ SFINAE简介和std::enable_if_t的简单使用 从模板特化开始 函数模版 What’s the meaning of std::enable_if_t = 0 测试代码 ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:5:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"SFINAE SFINAE : Substitution failure is not an error (匹配失败不是错误) ,我们使用模板函数时编译器会根据传入的参数来推导适配最合适的模板函数，在某些情况下，推导过程会发现某一个或者某几个模板函数推导起来其实是无法编译通过的，但只要有一个可以正确推导并编译出来，则那些推导得到的可能产生编译错误的模板函数就并不会引发编译错误，即匹配失败不是错误。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u003ciostream\u003e struct testA { int data; testA(int val) : data(val){}; }; struct testB : testA { typedef double value; testB(int val) : testA(val){}; }; template \u003ctypename T\u003e typename T::value add(T t1, T t2) // Definition #1 { return t1.data + t2.data; } int add(testA t1, testA t2) // Definition #2 { return t1.data + t2.data; } int main() { testA a(1), b(2); testB c(3), d(4); add(a, b); // Call #2. Without error (even though there is no testA::value) thanks to SFINAE. add(c, d); // Call #1 return 0; } ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:6:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"std::enable_if std::enable_if顾名思义，满足条件时类型有效。 基本实现方式： 1 2 3 4 5 template\u003cbool B, class T = void\u003e struct enable_if {}; template\u003cclass T\u003e struct enable_if\u003ctrue, T\u003e { typedef T type; }; 主要在于第一个参数是否为true，当第一个模板参数为false的时候并不会定义type，只有在第一模板参数为true的时候才会定义type。 1 2 3 4 typename std::enable_if\u003ctrue, int\u003e::type t; //正确，type等同于int typename std::enable_if\u003ctrue\u003e::type; //可以通过编译，没有实际用处，推导的模板是偏特化版本，第一模板参数是true，第二模板参数是通常版本中定义的默认类型即void，但是一般也用不上它。 typename std::enable_if\u003cfalse\u003e::type; //无法通过编译，type类型没有定义 typename std::enable_if\u003cfalse, int\u003e::type t2; //无法通过编译，type类型没有定义 例子： 偏特化 std::is_trivial 判断是不是有默认构造函数，如果是使用默认构造函数，std::is_trivial\u003cT\u003e::value = true . 1 2 3 4 5 6 7 8 9 10 11 template \u003ctypename T\u003e typename std::enable_if\u003cstd::is_trivial\u003cT\u003e::value\u003e::type SFINAE_test(T value) { std::cout\u003c\u003c\"T is trival\"\u003c\u003cstd::endl; } template \u003ctypename T\u003e typename std::enable_if\u003c!std::is_trivial\u003cT\u003e::value\u003e::type SFINAE_test(T value) { std::cout\u003c\u003c\"T is none trival\"\u003c\u003cstd::endl; } 校验函数模版 1 2 3 4 5 6 7 8 9 template \u003ctypename T\u003e typename std::enable_if\u003cstd::is_integral\u003cT\u003e::value, bool\u003e::type is_odd(T t) { return bool(t % 2); } template \u003ctypename T, typename = typename std::enable_if\u003cstd::is_integral\u003cT\u003e::value\u003e::type\u003e bool is_even(T t) { return !is_odd(t); } ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:7:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"enable_if_t 1 2 template \u003cbool _Test, class _Ty = void\u003e using enable_if_t = typename enable_if\u003c_Test, _Ty\u003e::type; 可以直接拿来作为类型来使用 作为函数参数或返回值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u003ctypename T\u003e struct Check1 { // 如果T的类型是int，则定义函数 int read(void* = nullptr) template \u003ctypename U = T\u003e U read(typename std::enable_if_t\u003cstd::is_same_v\u003cU, int\u003e\u003e * = nullptr) { return 42; } // 如果T的类型是double，则定义函数 double read() template \u003ctypename U = T\u003e typename std::enable_if_t\u003cstd::is_same_v\u003cU, double\u003e, U\u003e read() { return 3.14; } }; 作为模板参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 template \u003ctypename T\u003e struct Check2 { // 如果T的类型是int，则定义函数 int read() template \u003ctypename U = T, typename std::enable_if_t\u003cstd::is_same_v\u003cU, int\u003e, int\u003e = 0\u003e U read() { return 42; } // 如果T的类型是double，则定义函数 double read() template \u003ctypename U = T, typename std::enable_if_t\u003cstd::is_same_v\u003cU, double\u003e\u003e * = nullptr\u003e U read() { return 3.14; } }; 类型偏特化 1 2 3 4 5 6 7 // T是其它类型 template \u003ctypename T, typename = void\u003e struct zoo; // 如果T是整型（我从网上扒代码时原文这里写的浮点，我觉得应该是整型吧， // 这里的std::is_integral_v应该是C++新标准里的特性，但也类似于std::is_integral\u003cT\u003e::value，据说在C++17标准之后了。） template \u003ctypename T\u003e struct zoo\u003cT, std::enable_if_t\u003cstd::is_integral_v\u003cT\u003e\u003e\u003e {}; ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:8:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"CGraph 中使用 1 2 3 // 兼容 std::enable_if_t 的语法 template\u003cbool B, typename T = void\u003e using c_enable_if_t = typename std::enable_if\u003cB, T\u003e::type; 1 2 3 template\u003ctypename T, CUint capacity = CGRAPH_DEFAULT_RINGBUFFER_SIZE, c_enable_if_t\u003cstd::is_base_of\u003cGMessageParam, T\u003e::value, int\u003e = 0\u003e class GMessage : public GMessageObject {} 1 2 c_enable_if_t\u003cstd::is_base_of\u003cGMessageParam, T\u003e::value, int\u003e = 0 // 如果 T 为 GMessageParam 的字类，第三个参数为 int ,否则在编译期报错 ","date":"2023-02-01","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:9:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["计算机视觉"],"content":"ffmpeg介绍及使用","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 安装 测试 应用 ffmpeg 使用 ffmpeg 常用脚本 H264 转 PNG/jpg PNG/jpg 转 MP4 按帧数剪切视频 按赛时间剪切视频 视频转换 提取视频 视频和合成 修改帧率 提取音频 码率控制 安装 安装 1 2 3 4 5 sudo add-apt-repository ppa:mc3man/trusty-media sudo apt-get update sudo apt-get dist-upgrade sudo apt-get install ffmpeg 查看版本 1 ffmpeg -version 输出 1 2 3 4 5 6 7 8 9 10 11 12 ffmpeg version 3.4.8-0ubuntu0.2 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 7 (Ubuntu 7.5.0-3ubuntu1~18.04) configuration: --prefix=/usr --extra-version=0ubuntu0.2 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --enable-gpl --disable-stripping --enable-avresample --enable-avisynth --enable-gnutls --enable-ladspa --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librubberband --enable-librsvg --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-omx --enable-openal --enable-opengl --enable-sdl2 --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-chromaprint --enable-frei0r --enable-libopencv --enable-libx264 --enable-shared libavutil 55. 78.100 / 55. 78.100 libavcodec 57.107.100 / 57.107.100 libavformat 57. 83.100 / 57. 83.100 libavdevice 57. 10.100 / 57. 10.100 libavfilter 6.107.100 / 6.107.100 libavresample 3. 7. 0 / 3. 7. 0 libswscale 4. 8.100 / 4. 8.100 libswresample 2. 9.100 / 2. 9.100 libpostproc 54. 7.100 / 54. 7.100 测试 1 ffmpeg -i GstTest.mp4 output.avi 输出： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ffmpeg version 4.2.4-1ubuntu0.1 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 9 (Ubuntu 9.3.0-10ubuntu2) configuration: --prefix=/usr --extra-version=1ubuntu0.1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --arch=amd64 --enable-gpl --disable-stripping --enable-avresample --disable-filter=resample --enable-avisynth --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librsvg --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-nvenc --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared libavutil 56. 31.100 / 56. 31.100 libavcodec 58. 54.100 / 58. 54.100 libavformat 58. 29.100 / 58. 29.100 libavdevice 58. 8.100 / 58. 8.100 libavfilter 7. 57.100 / 7. 57.100 libavresample 4. 0. 0 / 4. 0. 0 libswscale 5. 5.100 / 5. 5.100 libswresample 3. 5.100 / 3. 5.100 libpostproc 55. 5.100 / 55. 5.100 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'GstTest.mp4': Metadata: major_brand : mp42 minor_version : 0 compatible_brands: mp42isom creation_time : 2020-07-26T12:09:43.000000Z Duration: 00:00:09.17, start: 0.000000, bitrate: 900 kb/s Stream #0:0(und): Audio: aac (LC) ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:0:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"ffmpeg 使用 1 2 3 4 5 6 7 8 9 10 ffmpeg {1} {2} -i {3} {4} {5} ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ... $ ffmpeg \\ [全局参数] \\ [输入文件参数] \\ -i [输入文件] \\ [输出文件参数] \\ [输出文件] ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:1:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"ffmpeg 常用脚本 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"H264 转 PNG/jpg 1 2 3 4 5 ffmpeg -i ../20200910162907037_dir.h264 -r 10 -f image2 h264_%03d.png ffmpeg -i ../20200910162907037_dir.h264 -r 10 -f image2 h264_%03d.jpg ffmpeg -i ../20200909145247237_dir.h264 -r 25 -f image2 h264_%03d.jpg ffmpeg -i ../*.h264 -r 25 -f image2 h264_%03d.png ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:1","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"PNG/jpg 转 MP4 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash # Convert a series of png images to into an mp4 movie. # # On OSX you can use \"brew install ffmpeg\" to install ffmpeg # -r 10 means 10 fps # -crf 20 determines the quality 0 = lossless, 23 = default # -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" is to deal with widths and heights not divisible by 2 # -pix_fmt yuv420p is for compatibility with QuickTime and other old players. Drop it if you only use VLC or something modern. # -i \"movie%04d.png\" is a placeholder for movie0000.png, movie0001.png, ... ffmpeg -r 10 -i \"movie%04d.png\" -c:v libx264 -crf 20 -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -pix_fmt yuv420p imovie2.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:2","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"按帧数剪切视频 1 2 3 ffmpeg -i ./20200909080831116_dir.h264 -vf \"select=between(n\\,1150\\,1450)\" -y -acodec copy ./output.h264 # \"select=between(n\\,1150\\,1450)\" 1150 起始帧 1450 结束帧 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:3","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"按赛时间剪切视频 1 2 3 # 下面的命令，可以从时间为00:00:15开始，截取5秒钟的视频。 ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4 # -ss表示开始切割的时间，-t表示要切多少。上面就是从15秒开始，切5秒钟出来。 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:4","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"视频转换 1 2 3 ffmpeg -i output.h264 -vcodec copy -f mp4 test.mp4 ffmpeg -i input.avi output.mp4 ffmpeg -i input.mp4 output.ts ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:5","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"提取视频 1 ffmpeg -i input.mp4 -vcodec copy -an output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:6","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"视频和合成 1 ffmpeg -i output.h264 -i T1-OUT.oni.h264 -filter_complex \"[0:v]pad=iw*2:ih*1[a];[a][1:v]overlay=w\" out.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:7","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"修改帧率 1 ffmpeg -i input.mp4 -vcodec copy -an output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:8","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"提取音频 1 2 3 ffmpeg -i test.mp4 -acodec copy -vn output.aac # 上面的命令，默认mp4的audio codec是aac,如果不是，可以都转为最常见的aac。 ffmpeg -i test.mp4 -acodec aac -vn output.aac ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:9","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"码率控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。 那么，什么是码率？很简单： bitrate = file size / duration 比如一个文件20.8M，时长1分钟，那么，码率就是： biterate = 20.8M bit/60s = 20.8*1024*1024*8 bit/60s= 2831Kbps 一般音频的码率只有固定几种，比如是128Kbps， 那么，video的就是 video biterate = 2831Kbps -128Kbps = 2703Kbps。 那么ffmpeg如何控制码率。 ffmpg控制码率有3种选择，-minrate -b:v -maxrate -b:v主要是控制平均码率。 比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。 ffmpeg -i input.mp4 -b:v 2000k output.mp4 上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。 不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize -bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好） ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4 -minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。 ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:10","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["cpp"],"content":"C++ 并行开发介绍","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 参考资料 code 并发与并行 多进程并发 多线程并发 C++中的并发与多线程 thread std::thread std:🧵:join std:🧵:joinable std:🧵:detach ~thread()分析 Mutex Mutex 系列类(四种) Lock 类（两种） 其他类型 mutex函数 std::recursive_mutex std::time_mutex std::recursive_timed_mutex lock_guard / unique_lock std::lock_guard std::unique_lock 注意 多线程下生产者消费者模型 单生产者-单消费者模型 单生产者-多消费者模型 多生产者-单消费者模型 多生产者-多消费者模型 future std::future 资料 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:0:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"参考资料 C++11并发之std::thread 基于C++11并发库的线程池与消息队列多线程框架——std::thread类 C++11 并发指南一(C++11 多线程初探) [c++11]多线程编程(五)——unique_lock ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:1:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"code CplusParallel 并发与并行 并发：同一时间段内可以交替处理多个操作 并行：同一时间段内同时处理多个操作 如果程序的结构设计为可以并发执行的，那么在支持并行的机器上，程序可以并行地执行。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:2:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多进程并发 多个进程独立地运行，它们之间通过进程间常规的通信渠道传递讯息（信号，套接字，文件，管道等），这种进程间通信不是设置复杂就是速度慢，这是因为为了避免一个进程去修改另一个进程，操作系统在进程间提供了一定的保护措施，当然，这也使得编写安全的并发代码更容易。运行多个进程也需要固定的开销：进程的启动时间，进程管理的资源消耗。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:3:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多线程并发 在当个进程中运行多个线程也可以并发。线程就像轻量级的进程，每个线程相互独立运行，但它们共享地址空间，所有线程访问到的大部分数据如指针、对象引用或其他数据可以在线程之间进行传递，它们都可以访问全局变量。进程之间通常共享内存，但这种共享通常难以建立且难以管理，缺少线程间数据的保护。因此，在多线程编程中，我们必须确保每个线程锁访问到的数据是一致的。 C++中的并发与多线程 C++11标准提供了一个新的线程库，内容包括了管理线程、保护共享数据、线程间的同步操作、低级原子操作等各种类。 1 2 3 4 5 \u003cthread\u003e : 包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在该头文件中有声明； \u003catomic\u003e :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数； \u003cmutex\u003e ：包含了与互斥量相关的类以及其他类型的函数； \u003cfuture\u003e: 包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数； \u003ccondition_variable\u003e : 包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any thread ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:4:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::thread 1 2 3 4 5 int n = 0; std::thread t1; // t1 is not a thread std::thread t2(f1, n + 1); // pass by value std::thread t3(f2, std::ref(n)); // pass by reference std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:5:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:join join 是让当前主线程等待所有的子线程执行完，才能退出。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:6:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:joinable 用于检测线程是否有效,true : 代表该线程是可执行线程 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:7:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:detach 线程 detach 脱离主线程的绑定，主线程挂了，子线程不报错，子线程执行完自动退出。 线程 detach以后，子线程会成为孤儿线程，线程之间将无法通信。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:8:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"~thread()分析 1 2 3 4 ~thread() _NOEXCEPT { // 析构函数 if (joinable()) // 线程是可结合的(可执行线程)，析构异常（也就是说只能析构不可结合的线程） _XSTD terminate(); // terminate会调用abort()来终止程序 } joinable() = false : 空线程 move后的线程，即move(t),则t是不可结合的 join后的线程 detach后的线程 Mutex std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:9:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"Mutex 系列类(四种) 1 2 3 4 std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:10:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"Lock 类（两种） 1 2 std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。 std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:11:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"其他类型 1 2 3 4 std::once_flag std::adopt_lock_t std::defer_lock_t std::try_to_lock_t ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:12:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"mutex函数 构造函数 std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 std::try_lock 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::lock 可以同时对多个互斥量上锁。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::unlock 解锁，释放对互斥量的所有权。 std::call_once 如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:13:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::recursive_mutex std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:14:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::time_mutex std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数 接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数 接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:15:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::recursive_timed_mutex 和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:16:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"lock_guard / unique_lock ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::lock_guard 与 Mutex RAII 相关，方便线程对互斥量上锁。 其原理是：声明一个局部的lock_guard对象，在其构造函数中进行加锁，在其析构函数中进行解锁。最终的结果就是：在定义该局部对象的时候加锁（调用构造函数），出了该对象作用域的时候解锁（调用析构函数）。 使用方法: 首先需要包含mutex头文件 然后创建一个锁 std::mutex mutex 在需要被加锁的作用域内 将mutex传入到创建的std::lock_guard局部对象中 1 2 3 4 5 6 7 8 9 10 11 12 #include \u003cmutex\u003e /*std::mutex、 std::lock_guard*/ std::mutex mutex; void func() { //lock_guard 互斥锁 作用域内不可拷贝构造 { std::lock_guard\u003cstd::mutex\u003e lg(m_mutex); //函数内容 } } ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:1","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::unique_lock 与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 互斥锁保证了线程间的同步，但是却将并行操作变成了串行操作，这对性能有很大的影响，所以我们要尽可能的减小锁定的区域，也就是使用细粒度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class LogFile { std::mutex _mu; ofstream f; public: LogFile() { f.open(\"log.txt\"); } ~LogFile() { f.close(); } void shared_print(string msg, int id) { { std::lock_guard\u003cstd::mutex\u003e guard(_mu); //do something 1 } //do something 2 { std::lock_guard\u003cstd::mutex\u003e guard(_mu); // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; } } }; 上面的代码中，一个函数内部有两段代码需要进行保护，这个时候使用lock_guard就需要创建两个局部对象来管理同一个互斥锁（其实也可以只创建一个，但是锁的力度太大，效率不行），修改方法是使用unique_lock。它提供了lock()和unlock()接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁（lock_guard就一定会解锁）。上面的代码修改如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class LogFile { std::mutex _mu; ofstream f; public: LogFile() { f.open(\"log.txt\"); } ~LogFile() { f.close(); } void shared_print(string msg, int id) { std::unique_lock\u003cstd::mutex\u003e guard(_mu); //do something 1 guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; // 结束时析构guard会临时解锁 // 这句话可要可不要，不写，析构的时候也会自动执行 // guard.ulock(); } }; 上面的代码可以看到，在无需加锁的操作时，可以先临时释放锁，然后需要继续保护的时候，可以继续上锁，这样就无需重复的实例化lock_guard对象，还能减少锁的区域。同样，可以使用std::defer_lock设置初始化的时候不进行默认的上锁操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void shared_print(string msg, int id) { std::unique_lock\u003cstd::mutex\u003e guard(_mu, std::defer_lock); //do something 1 guard.lock(); // do something protected guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; // 结束时析构guard会临时解锁 } 这样使用起来就比lock_guard更加灵活！然后这也是有代价的，因为它内部需要维护锁的状态，所以效率要比lock_guard低一点，在lock_guard能解决问题的时候，就是用lock_guard，反之，使用unique_lock。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:2","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"注意 unique_lock和lock_guard都不能复制，lock_guard不能移动，但是unique_lock可以。 1 2 3 4 5 6 7 8 9 // unique_lock 可以移动，不能复制 std::unique_lock\u003cstd::mutex\u003e guard1(_mu); std::unique_lock\u003cstd::mutex\u003e guard2 = guard1; // error std::unique_lock\u003cstd::mutex\u003e guard2 = std::move(guard1); // ok // lock_guard 不能移动，不能复制 std::lock_guard\u003cstd::mutex\u003e guard1(_mu); std::lock_guard\u003cstd::mutex\u003e guard2 = guard1; // error std::lock_guard\u003cstd::mutex\u003e guard2 = std::move(guard1); // error 多线程下生产者消费者模型 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:3","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"单生产者-单消费者模型 单生产者-单消费者模型中只有一个生产者和一个消费者，生产者不停地往产品库中放入产品，消费者则从产品库中取走产品，产品库容积有限制，只能容纳一定数目的产品，如果生产者生产产品的速度过快，则需要等待消费者取走产品之后，产品库不为空才能继续往产品库中放置新的产品，相反，如果消费者取走产品的速度过快，则可能面临产品库中没有产品可使用的情况，此时需要等待生产者放入一个产品后，消费者才能继续工作。 code:SingleProducer-SingleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:18:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"单生产者-多消费者模型 与单生产者和单消费者模型不同的是，单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。所以除了保护产品库在多个读写线程下互斥之外，还需要维护消费者取走产品的计数器。 code:SingleProducer-MultipleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:19:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多生产者-单消费者模型 与单生产者和单消费者模型不同的是，多生产者-单消费者模型中可以允许多个生产者同时向产品库中放入产品。所以除了保护产品库在多个读写线程下互斥之外，还需要维护生产者放入产品的计数器。 code:MultipleProducer-SingleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:20:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多生产者-多消费者模型 该模型可以说是前面两种模型的综合，程序需要维护两个计数器，分别是生产者已生产产品的数目和消费者已取走产品的数目。另外也需要保护产品库在多个生产者和多个消费者互斥地访问。 code:MultipleProducer-MultipleConsumer future thread对象，它是C++11中提供异步创建多线程的工具。但是我们想要从线程中返回异步任务结果，一般需要依靠全局变量；从安全角度看，有些不妥；为此C++11提供了std::future类模板，future对象提供访问异步操作结果的机制，很轻松解决从异步任务中返回结果。 在C++标准库中，有两种“期望”，使用两种类型模板实现: 唯一期望(unique futures，std::future\u003c\u003e) std::future的实例只能与一个指定事件相关联。 共享期望(shared futures)(std::shared_future\u003c\u003e) std::shared_future的实例就能关联多个事件。 future 头文件中包含了以下几个类和函数： Providers 类：std::promise, std::package_task Futures 类：std::future, shared_future. Providers 函数：std::async() 其他类型：std::future_error, std::future_errc, std::future_status, std::launch. ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:21:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::future 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //通过async来获取异步操作结果 std::future\u003cint\u003e result = std::async([](){ std::this_thread::sleep_for(std::chrono::milliseconds(500)); return 8; }); std::cout \u003c\u003c \"the future result : \" \u003c\u003c result.get() \u003c\u003c std::endl; std::cout \u003c\u003c \"the future status : \" \u003c\u003c result.valid() \u003c\u003c std::endl; try { result.wait(); //或者 result.get() ,会异常 //因此std::future只能用于单线程中调用 ，多线程调用使用std::share_future(); } catch (...) { std::cout \u003c\u003c \"get error....\\n \"; } ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:22:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"C++部分编译几运行期的错误收集","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/","tags":["cpp"],"title":"C++:错误收集","uri":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 basic_string::_M_construct 1 2 3 terminate called after throwing an instance of 'std::logic_error' what(): basic_string::_M_construct null not valid Aborted (core dumped) string构造不能传入空指针xxx，即在xxx为空时会报上面错误，保证func返回不为空即可。 多态失效问题的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class vehicle{ public: void run(){ std::cout\u003c\u003c\"from vehicle:run\"\u003c\u003cstd::endl; } }; class car:public vehicle{ public: void run(){ std::cout\u003c\u003c\"from car:public vehicle:run\"\u003c\u003cstd::endl; } }; void call_fun(vehicle *pvehicle){ pvehicle-\u003erun(); } int main(){ vehicle *_pvehicle = new vehicle(); car *_pcar = new car(); call_fun(_pvehicle); call_fun(_pcar); delete _pvehicle; delete _pcar; return 0; } 输出 1 2 from vehicle:run from vehicle:run 在C++中，如果在基类和派生类中对同一个函数都进行了定义时，通过基类和派生类指针对象调用成员函数时具体是执行哪一个类实例的成员函数是根据接口函数的参数类型而定，而不是实际的类实例指针对象。 C++ const函数返回值必须为const引用 参考： C++ const函数返回值必须为const引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u003ciostream\u003e class MyString { public: MyString(std::string T):text(T){} const char\u0026 operator[](std::size_t position) const // operator[] for const 对象 { return text[position]; } char\u0026 operator[](std::size_t position) // operator[] for non-const 对象 { return text[position]; } private: std::string text; }; int main(){ MyString ms(\"coding\"); // non-const 对象 MyString test(\"testing\"); std::cout \u003c\u003c ms[0]\u003c\u003c std::endl; // 调用 non-const MyString::operator[] ms[0] = 'x'; // 没问题，写一个 non-const MyString const MyString cms(\"coding\"); // const 对象 std::cout \u003c\u003c cms[0]\u003c\u003cstd::endl; // 调用 const MyString::operator[] //cms[0] = 'x'; // 错误！ 写一个 const MyString } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/:0:0","tags":["cpp"],"title":"C++:错误收集","uri":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"},{"categories":["开源软件"],"content":"CGraph 名词解释","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 扇入扇出 DAG 调度 Aspect(切面) AOP 检索算法 HNSW算法 ANNS算法 扇入扇出 在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。 按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。 扇入： 是指直接调用该模块的上级模块的个数；扇入大表示模块的复用程序高。 扇出： 是指该模块直接调用的下级模块的个数；扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好； 扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块； 扇出太小时可以把下级模块进一步分解成若干个子功能模块， 或者合并到它的上级模块中去。 DAG 调度 DAG : Directed acyclic graph (有向无环图)。 图中TaskB 算子输入参数依赖TaskA算子输出参数，Task C与 TaskA/TaskB算子相互独立可并行执行，最终所有计算结果在End处执行。 Aspect(切面) Aspect表示切面，给业务方法增加的功能，叫做切面。切面一般都是非业务功能，而且切面功能一般都是可以复用的。例如日志功能，事务功能，权限检查，参数检查，统计信息等等 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:0:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"AOP AOP：Aspect Oriented Programming（面向切面编程） Aspect：切面，指给业务方法增加的功能 JoinPoint：连接点，连接切面的业务方法，在这个业务方法执行时会同时执行切面的功能 Poingcut：切入点，是一个或多个连接点的集合，表示这些方法执行时都能增加切面的功能。。表示切面执行的位置(这里的位置不是指具体业务逻辑里执行切面的位置，是指哪些方法需要执行切面的位置) target：目标对象，给哪个对象增加切面的功能，这个对象就是目标对象 Advice：通知(增强)，表示切面的执行时间。在目标方法之前执行切面，还是目标方法之后执行切面 检索算法 程序员王同学 CSDN ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:1:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"HNSW算法 一文看懂HNSW算法理论的来龙去脉 HNSW算法—-Hierarchcal Navigable Small World graphs 。 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:2:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"ANNS算法 向量检索算法（ANNS）优化思路之我见 ANNS（Approximate Nearest Neighbor Search）算法，向量检索算法的。 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:3:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 认识 lambda Lambda 语法分析 [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u003e 返回值类型 {函数体} 示例 示例 1 示例 2 示例 3 总结 资料 代码及编译 认识 lambda C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。 Lambda 的语法形式如下： 1 [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u003e 返回值类型 {函数体} 可以看到，Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-\u003e 返回值类型、{函数体}. Lambda 语法分析 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"[函数对象参数] 标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造 函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量(包括 Lambda 所在类的 this)。函数对象参数有以下形式： 空。没有任何函数对象参数。 =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 \u0026。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。 this。函数体内可以使用 Lambda 所在类中的成员变量。 a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要 修改传递进来的拷贝，可以添加 mutable 修饰符。 \u0026a。将 a 按引用进行传递。 a，\u0026b。将 a 按值传递，b 按引用进行传递。 =，\u0026a，\u0026b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。 \u0026，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"(操作符重载函数参数) 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (\u0026a, \u0026b)) 两种方式进行传递。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"mutable 或 exception 声明 这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"-\u003e 返回值类型 标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"{函数体} 标识函数的实现，这部分不能省略，但函数体可以为空。 示例 1 2 3 4 [] (int x, int y) { return x + y; } // 隐式返回类型 [] (int\u0026 x) { ++x; } // 没有 return 语句 -\u003e Lambda 函数的返回类型是 'void' [] () { ++global_x; } // 没有参数，仅访问某个全局变量 [] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数) 可以像下面这样显示指定返回类型： 1 [] (int x, int y) -\u003e int { int z = x + y; return z; } 在这个例子中创建了一个临时变量 z 来存储中间值。和普通函数一样，这个中间值不会保存到下次调用。什么也不返回的Lambda 函数可以省略返回类型，而不需要使用 -\u003e void 形式。 Lambda 函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在 Lambda 表达式声明中的方括号 [] 内。这个机制允许这些变量被按值或按引用捕获。如下例子： 1 2 3 4 5 6 [] //未定义变量.试图在Lambda内使用任何外部变量都是错误的. [x, \u0026y] //x 按值捕获, y 按引用捕获. [\u0026] //用到的任何外部变量都隐式按引用捕获 [=] //用到的任何外部变量都隐式按值捕获 [\u0026, x] //x显式地按值捕获. 其它变量按引用捕获 [=, \u0026z] //z按引用捕获. 其它变量按值捕获 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 1 1 2 3 4 5 6 7 std::vector\u003cint\u003e some_list; int total = 0; for (int i = 0; i \u003c 5; ++i) some_list.push_back(i); std::for_each(begin(some_list), end(some_list), [\u0026total](int x) { total += x; }); 此例计算 list 中所有元素的总和。变量 total 被存为 Lambda 函数闭包的一部分。因为它是栈变量（局部变量）total 引用，所以可以改变它的值。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:6:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 2 1 2 3 4 5 6 7 std::vector\u003cint\u003e some_list; int total = 0; int value = 5; std::for_each(begin(some_list), end(some_list), [\u0026, value, this](int x) { total += x * value * this-\u003esome_func(); }); 此例中 total 会存为引用, value 则会存一份值拷贝。对 this 的捕获比较特殊，它只能按值捕获。this 只有当包含它的最靠近它的函数不是静态成员函数时才能被捕获。对 protect 和 private 成员来说，这个 Lambda 函数与创建它的成员函数有相同的访问控制。如果 this 被捕获了，不管是显式还是隐式的，那么它的类的作用域对 Lambda 函数就是可见的。访问 this 的成员不必使用 this-\u003e 语法，可以直接访问。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:7:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 3 泛型的 lambda在 C++14 里，lambda 表达式又多了一项新本领，可以实现“泛型化”，相当于简化了的模板函数，具体语法还是利用了“多才多艺”的 auto： 1 2 3 4 5 6 7 8 9 10 auto f = [](const auto\u0026 x) // 参数使用auto声明，泛型化 { return x + x; }; cout \u003c\u003c f(3) \u003c\u003c endl; // 参数类型是int cout \u003c\u003c f(0.618) \u003c\u003c endl; // 参数类型是double string str = \"matrix\"; cout \u003c\u003c f(str) \u003c\u003c endl; // 参数类型是string 这个新特性在写泛型函数的时候非常方便，摆脱了冗长的模板参数和函数参数列表。如果你愿意的话，可以尝试在今后的代码里都使用 lambda 来代替普通函数，能够少写很多代码。 总结 不同编译器的具体实现可以有所不同，但期望的结果是: 按引用捕获的任何变量，Lambda 函数实际存储的应该是这些变量在创建这个 Lambda 函数的函数的栈指针，而不是 Lambda 函数本身栈变量的引用。不管怎样，因为大多数 Lambda 函数都很小且在局部作用中，与候选的内联函数很类似，所以按引用捕获的那些变量不需要额外的存储空间。 因为 lambda 表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“就地”定义函数，限制它的作用域和生命周期，实现函数的局部化。 如果一个闭包含有局部变量的引用，在超出创建它的作用域之外的地方被使用的话，这种行为是未定义的! Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 std::function 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 lambda 函数, 1 2 auto my_lambda_func = [\u0026](int x) { /* ... */ }; auto my_onheap_lambda_func = new auto([=](int x) { /* ... */ }); 这里有一个例子, 把匿名函数存储在变量、数组或 vector 中,并把它们当做命名参数来传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u003cfunctional\u003e #include \u003cvector\u003e #include \u003ciostream\u003e double eval(std::function \u003cdouble(double)\u003e f, double x = 2.0) { return f(x); } int main() { //explicit type std::function\u003cdouble(double)\u003e f0 = [](double x){return 1;}; //auto (deduced) type same as before auto f1 = [](double x){return x;}; decltype(f0) fa[3] = {f0,f1,[](double x){return x*x;}}; //Something like NSt3__18functionIFddEEE std::cout \u003c\u003c typeid(decltype(f0)).name() \u003c\u003c std::endl; std::vector\u003cdecltype(f0)\u003e fv = {f0,f1}; fv.push_back ([](double x){return x*x;}); for(int i=0;i\u003cfv.size();i++) std::cout \u003c\u003c fv[i](2.0) \u003c\u003c std::endl; for(int i=0;i\u003c3;i++) std::cout \u003c\u003c fa[i](2.0) \u003c\u003c std::endl; for(auto \u0026f : fv) std::cout \u003c\u003c f(2.0) \u003c\u003c std::endl; for(auto \u0026f : fa) std::cout \u003c\u003c f(2.0) \u003c\u003c std::endl; std::cout \u003c\u003c eval(f0) \u003c\u003c std::endl; std::cout \u003c\u003c eval(f1) \u003c\u003c std::endl; std::cout \u003c\u003c eval([](double x){return x*x;}) \u003c\u003c std::endl; return 0; } 一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的: 1 2 3 auto a_lambda_func = [](int x) { /* ... */ }; void (*func_ptr)(int) = a_lambda_func; func_ptr(4); // calls the lambda 资料 C++之Lambda表达式 罗剑锋的C++实战笔记 C语言实现C++多态——函数指针 代码及编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u003cfunctional\u003e #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; //lambda表达式简单案例 int main(){ //[函数对象参数]、(操作符重载函数参数)、mutable或exception声明、-\u003e返回值类型、{函数体 } auto fun1 = []()-\u003e int{cout \u003c\u003c\"hellochina\"\u003c\u003cendl; return 0;}; fun1(); auto fun2 = [](int a,int b){return a +b; }; cout \u003c\u003cfun2(10, 9) \u003c\u003cendl; std::cin.get(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include\u003cfunctional\u003e #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; //lambda表达式简单案例 int main() { class __lambda_11_15 { public: inline int operator()() const { std::operator\u003c\u003c(std::cout, \"hellochina\").operator\u003c\u003c(std::endl); return 0; } using retType_11_15 = auto (*)() -\u003e int; inline operator retType_11_15 () const noexcept { return __invoke; }; private: static inline int __invoke() { std::operator\u003c\u003c(std::cout, \"hellochina\").operator\u003c\u003c(std::endl); return 0; } public: // inline /*constexpr */ __lambda_11_15(__lambda_11_15 \u0026\u0026) noexcept = default; }; __lambda_11_15 fun1 = __lambda_11_15(__lambda_11_15{}); fun1.operator()(); class __lambda_14_15 { public: inline int operator()(int a, int b) const { return a + b; } using retType_14_15 = int (*)(int, int); inline operator retType_14_15 () const noexcept { return __invoke; }; private: static inline int __invoke(int a, int b) { return a + b; } public: // inline /*constexpr */ __lambda_14_15(__lambda_14_15 \u0026\u0026) noexcept = default; }; __lambda_14_15 fun2 = __lambda_14_15(__lambda_14_15{}); std::cout.operator\u003c\u003c(fun2.operator()(10, 9)).operator\u003c\u003c(std::endl","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:8:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["计算机视觉"],"content":"深度学习开发环境搭建","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 硬件环境 深度学习开发环境搭建 更改系统软件源 安装Python和pip 安装Nvidia显卡驱动 安装CUDA 安装CuDNN 安装Conda环境 什么是Conda 安装conda conda 简单使用 测试一下GPU训练 硬件环境 处理器：AMD® Ryzen 5 3600 6-core processor × 12 显卡：NVIDIA Corporation TU104 [GeForce RTX 2060] 内存：16G DDR4 硬盘：1T SSD 系统：Ubuntu 20.04.1 LTS 深度学习开发环境搭建 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"更改系统软件源 备份原来的源： 1 cp /etc/apt/sources.list /etc/apt/sources.list.bak 将源的内容设置为阿里云镜像： 1 sudo vim /etc/apt/sources.list 内容改为： 1 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新软件列表： 1 2 sudo apt update sudo apt upgrade ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Python和pip Ubuntu系统默认自带python，有版本需求的话也可以自己安装一下 1 sudo apt install python3sudo apt install python3-pip 不管是不是自己安装的python，替换python的pip源建议是一定操作一下的，pip安装速度会快很多： 1 cd ~mkdir .pip 直接新建并编辑pip.conf： 1 sudo vim ~/.pip/pip.conf 改为以下内容（这里用的清华源，也可以试一下阿里、豆瓣等源）： 1 [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ [install]trusted-host = pypi.tuna.tsinghua.edu.cn 更改默认python版本，python目录默认链接的是python2，而现在基本都是用python3开发了 1 sudo apt install python-is-python3 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Nvidia显卡驱动 打开软件和更新 选择安装Nvidia官方驱动（第二个是开源驱动） 禁止nouveau 驱动 1 sudo gedit /etc/modprobe.d/blacklist.conf 添加 1 2 3 4 5 blacklist nouveau blacklist lbm-nouveau options nouveau modeset=0 alias nouveau off alias lbm-nouveau off 执行如下命令，更新系统，来禁用nouveau 1 sudo update-initramfs -u 重启完之后更新一下软件： 1 2 sudo apt update sudo apt upgrade 查看驱动 1 nvidia-smi 输出： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.102.04 Driver Version: 450.102.04 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 GeForce RTX 2060 Off | 00000000:26:00.0 On | N/A | | 0% 41C P8 7W / 160W | 675MiB / 5931MiB | 7% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | 0 N/A N/A 908 G /usr/lib/xorg/Xorg 53MiB | | 0 N/A N/A 1457 G /usr/lib/xorg/Xorg 219MiB | | 0 N/A N/A 1585 G /usr/bin/gnome-shell 178MiB | | 0 N/A N/A 31707 G ...cent\\WeChat\\WeChatApp.exe 10MiB | | 0 N/A N/A 37422 G ...AAAAAAAA== --shared-files 36MiB | | 0 N/A N/A 42882 G ...AAAAAAAAA= --shared-files 48MiB | | 0 N/A N/A 44445 G ...AAAAAAAAA= --shared-files 104MiB | | 0 N/A N/A 45053 G gnome-control-center 3MiB | +-----------------------------------------------------------------------------+ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装CUDA 去官网下载cuda安装包：CUDA Toolkit 11.0 Download | NVIDIA Developer 运行下面的命令进行安装： 1 2 3 wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.run chmod +x cuda_11.0.2_450.51.05_linux.run sudo sh ./cuda_11.0.2_450.51.05_linux.run 根据上图提示需要配置环境变量： 1 gedit ~/.bashrc 再文件最后加入以下语句： 1 2 3 export CUDA_HOME=/usr/local/cuda-11.0 export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 export PATH=${CUDA_HOME}/bin:${PATH} 然后使其生效： 1 source ~/.bashrc 可以使用命令nvcc -V查看安装的版本信息： 1 2 3 4 5 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Thu_Jun_11_22:26:38_PDT_2020 Cuda compilation tools, release 11.0, V11.0.194 Build cuda_11.0_bu.TC445_37.28540450_0 也可以编译一个程序测试安装是否成功 找到 NVIDIA_CUDA-11.0_Samples 安装位置 1 locate NVIDIA_CUDA-11.0_Samples 1 2 3 cd NVIDIA_CUDA-11.0_Samples/1_Utilities/deviceQuery make ./deviceQuery 输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking) Detected 1 CUDA Capable device(s) Device 0: \"GeForce RTX 2060\" CUDA Driver Version / Runtime Version 11.0 / 11.0 CUDA Capability Major/Minor version number: 7.5 Total amount of global memory: 5931 MBytes (6219563008 bytes) (30) Multiprocessors, ( 64) CUDA Cores/MP: 1920 CUDA Cores GPU Max Clock rate: 1695 MHz (1.70 GHz) Memory Clock rate: 7001 Mhz Memory Bus Width: 192-bit L2 Cache Size: 3145728 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 1024 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 3 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Managed Memory: Yes Device supports Compute Preemption: Yes Supports Cooperative Kernel Launch: Yes Supports MultiDevice Co-op Kernel Launch: Yes Device PCI Domain ID / Bus ID / location ID: 0 / 38 / 0 Compute Mode: \u003c Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) \u003e deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 11.0, CUDA Runtime Version = 11.0, NumDevs = 1 Result = PASS ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装CuDNN 进入到CUDNN的下载官网： cuDNN Download | NVIDIA Developer，登陆下载 下载之后是一个压缩包，对它进行解压，命令如下： 1 tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz 使用以下两条命令复制这些文件到CUDA目录下： 1 sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/ sudo cp cuda/include/* /usr/local/cuda-11.0/include/ 拷贝完成之后，可以使用以下命令查看CUDNN的版本信息： 1 cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 输出 1 2 3 4 5 6 7 #define CUDNN_MAJOR 8 #define CUDNN_MINOR 0 #define CUDNN_PATCHLEVEL 4 -- #define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL) #endif /* CUDNN_VERSION_H */ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Conda环境 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"什么是Conda Conda是Python中用于管理包和环境的一大利器。使用Conda，我们还可以非常便利的使用数据科学相关的包。Conda可以帮助我们创建虚拟环境，从而方便的应用于多个项目中。 Anaconda实际上是一个软件的发行版，附带了Conda、python和150多个科学软件包及其相关的包。Conda是一个包和环境管理器。Anaconda是一个本身很大（大约500M），因为它附带了Python中最常见的数据科学包。如果您不需要所有的软件包，或者需要节省带宽或存储空间，那么也有miniconda，一个只包含conda和python的发行版。我们同样可以用Conda安装任何可用的软件包。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:1","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装conda 在Anaconda官网下载Linux安装包：Anaconda | Individual Edition 运行下面的命令安装： 1 2 chmod +x Anaconda3-2020.11-Linux-x86_64.sh ./Anaconda3-2020.11-Linux-x86_64.sh 一路按ENTER确认，然后根据提示输入yes，这里我为了目录整洁不安装在默认路径，设置为下面的路径：/home/zyh/app/anaconda3 然后会询问你是否要初始化conda，输入yes确认，重开终端窗口之后，就可以看到conda环境可用了 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:2","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"conda 简单使用 **包管里 ** 当我们成功安装anaconda后，我们可以很容易的使用conda来进行包管理。例如： 1 conda install numpy 除了每次安装一个包外，我们还可以一次性安装多个包，例如： 1 conda install numpy pandas 此外，我们还可以安装某个指定版本的包： 1 conda install numpy=1.10 Ps：使用conda安装指定包时，conda可以自动处理相关的包依赖。假设本身没有安装numpy时，若我们使用conda install scipy，则此时conda会自动安装numpy，因为scipy本身依赖numpy。 此外，conda还有一些其他的常用命令： 删除某个包：conda remove package_name 升级某个包：conda upgrade package_name 升级全部包：conda upgrade --all 查看包列表：conda list 模糊查询包：conda search 'keywords' **环境管里 ** conda可以用于创建多个环境而从进行项目隔离。 创建一个新的环境的格式如下： 1 conda create -n env_name list_of_packages 其中，-n后的参数env_name表示环境名称。 接着可以跟着0个或多个包名称。 一个示例如下： 1 conda create -n my_env numpy 表示创建了一个新的环境：my_env。并同时在该环境中安装一个包：numpy。 此外，在创建环境时，我们可以指定Python的版本。例如： 1 conda create -n my_env python=2.7 其中，我们可以在conda命令中，增加python=x的信息用于指定Python的版本号。 此时，我们可以轻松的实现在一台机器上兼容Python2和Python3了。 当我们使用conda创建了一个新的环境后，可以使用如下命令进入该环境： 1 conda activate env_name 此时，当我们进行该环境后，可以看命令行中的引导符中已经提示出了当前所属的conda环境： 1 conda list 想要离开当前环境时，则只需要执行如下命令即可： 1 conda deactivate 环境的保存与加载 对于conda环境，其有着一个如下特性：环境共享。 通过以配置文件的形式可以保存环境相关的全部信息。 我们可以使用如下命令将相关的环境信息保存在一个yaml文件中： 1 conda env export \u003e env.yaml 此时，我们已经将当前环境相关的信息全部存储在env.yaml文件中。当我们希望在其他机器中创建一个相同的环境时，可以直接执行如下命令： 1 conda env create -f env.yaml 当你不记得在当前机器上存在哪些conda环境时，可以执行如下命令列出全部环境： 1 conda env list 此时，*号所在的行表示当前所属的环境。 当某个环境我们不再需要时，可以直接执行如下命令来删除该环境： 1 conda env remove -n env_name 测试一下GPU训练 本地Conda环境方式 用conda新建一个python3.8+pytorch1.7+cuda11.0的虚拟环境： 1 conda create --name python_38-pytorch_1.7.0 python=3.8 1 2 3 4 5 6 7 8 # # To activate this environment, use # # $ conda activate python_38-pytorch_1.7.0 # # To deactivate an active environment, use # # $ conda deactivate 进入环境 1 conda activate python_38-pytorch_1.7.0 检查一下是否切换到所需环境了 1 which pip 如果看到使用的确实是我们设置的环境目录中的pip的话说明就ok。 接下来在环境中安装pytorch，可以参考官网的安装命令：Start Locally | PyTorch 输入以下命令进行安装： 1 pip install torch==1.7.0+cu110 torchvision==0.8.1+cu110 torchaudio===0.7.0 -f https://download.pytorch.org/whl/torch_stable.html 环境配置就完成了，下面新建一个简单的测试脚本验证功能，新建mnist_train.py，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 import argparse import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) def train(args, model, device, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % args.log_interval == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) def test(args, model, device, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) # sum up batch loss test_loss += F.nll_loss(output, target, reduction='sum').item() # get the index of the max log-probability pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format( t","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:3","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"深度学习开发环境搭建","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 硬件环境 深度学习开发环境搭建docker Docker NVIDIA Docker 安装 Docker基本使用 启动已停止运行的容器 停止一个容器 进入容器 导出和导入容器 删除容器 docker 训练模型 硬件环境 处理器：AMD® Ryzen 5 3600 6-core processor × 12 显卡：NVIDIA Corporation TU104 [GeForce RTX 2060] 内存：16G DDR4 硬盘：1T SSD 系统：Ubuntu 20.04.1 LTS 深度学习开发环境搭建docker ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:0:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"Docker Docker 是一个开源的应用容器引擎，基于 go语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:1:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"NVIDIA Docker 安装 docker安装 官网上有详细的介绍：Install Docker Engine on Ubuntudocs.docker.com 或者运行下面的命令安装： 1 2 3 4 sudo apt-get updatesudo apt-get install docker.io systemctl start docker systemctl enable docker 可以运行这条命令检查是否安装成功： 1 docker version 安装NVIDIA Container Toolkit NVIDIA/nvidia-docker 1 2 3 4 #首先要确保已经安装了 nvidia driver # 2. 添加源 distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list # 2. 安装并重启 sudo apt-get update \u0026\u0026 sudo apt-get install -y nvidia-container-toolkit sudo systemctl restart docker 1 sudo docker run -it --name test_nvidia_docker --gpus all nvidia/cuda:11.0-base 其中最后的参数nvidia/cuda:11.0-base 是Nvidia官方的镜像，需要根据工作站主机中实际安装的cuda版本进行修改，版本可以用nvcc -V查看。 进入容器之后可以跑一下nvidia-smi命令看看： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Mon Jan 18 22:59:37 2021 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.102.04 Driver Version: 450.102.04 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 GeForce RTX 2060 Off | 00000000:26:00.0 On | N/A | | 0% 41C P8 8W / 160W | 947MiB / 5931MiB | 5% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| +-----------------------------------------------------------------------------+ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:2:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"Docker基本使用 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"启动已停止运行的容器 查看所有的容器命令如下： 1 $ docker ps -a 点击图片查看大图： 1 2 3 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e8240c787e2f nvidia/cuda:11.0-base \"/bin/bash\" 26 minutes ago Exited (0) 52 seconds ago train_mnist ae3d00922c08 nvidia/cuda:11.0-base \"/bin/bash\" 37 hours ago Exited (0) 37 hours ago test_nvidia_docker 使用 docker start 启动一个已停止的容器： 1 $ docker start ae3d00922c08 1 2 zyh@zyh:~$ sudo docker start ae3d00922c08 ae3d00922c08 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:1","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"停止一个容器 停止容器的命令如下： 1 $ docker stop \u003c容器 ID\u003e 停止的容器可以通过 docker restart 重启： 1 $ docker restart \u003c容器 ID\u003e ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:2","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"进入容器 在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。 attach 命令 下面演示了使用 docker attach 命令。 1 $ docker attach e8240c787e2f 注意： 如果从这个容器退出，会导致容器的停止。 exec 命令 下面演示了使用 docker exec 命令。 1 docker exec -it e8240c787e2f /bin/bash 注意： 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 docker exec 的原因。 更多参数说明请使用 docker exec –help 命令查看。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:3","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"导出和导入容器 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 1 $ docker export e8240c787e2f \u003e train_mnist.tar 导出容器 e8240c787e2f 快照到本地文件 train_mnist.tar。 这样将导出容器快照到本地文件。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1: 1 $ cat docker/train_mnist.tar | docker import - test/train_mnist:v1 此外，也可以通过指定 URL 或者某个目录来导入，例如： 1 $ docker import http://example.com/exampleimage.tgz example/imagerepo ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:4","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"删除容器 删除容器使用 docker rm 命令： 1 $ docker rm -f ae3d00922c08 下面的命令可以清理掉所有处于终止状态的容器。 1 $ docker container prune 拷贝本地文件到docker 查找容器 1 docker ps -a 1 2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e8240c787e2f nvidia/cuda:11.0-base \"/bin/bash\" 42 minutes ago Up 8 minutes train_mnist 确定我们的容器名，并获取容器长ID 1 docker inspect -f '{{.ID}}' train_mnist 1 2 zyh@zyh:~/temp$ sudo docker inspect -f '{{.ID}}' train_mnist e8240c787e2fde06a3f1066db71bc63cb52514c3cb0175d51713f248a2e2b56c 复制文件 1 sudo docker cp /home/zyh/temp/cuda_11.0.2_450.51.05_linux.run e8240c787e2fde06a3f1066db71bc63cb52514c3cb0175d51713f248a2e2b56c:/home/zyh docker 训练模型 创建docker 1 2 3 4 5 sudo docker run -it --name train_mnist \\ -v /etc/timezone:/etc/timezone \\ -v /etc/localtime:/etc/localtime \\ -v /home/zyh/WorkSpace/_share:/home/workspace/_share \\ --gpus all nvidia/cuda:11.0-base 查看 nvidia 驱动 1 nvidia-smi 安装 cuda 1 sudo sh ./cuda_11.0.2_450.51.05_linux.run 配置环境变量 1 2 3 4 5 6 7 vim ~/.bashrc export CUDA_HOME=/usr/local/cuda-11.0 export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 export PATH=${CUDA_HOME}/bin:${PATH} source ~/.bashrc 查看安装版本 1 nvcc -V 安装 CuDNN 1 2 3 4 tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/ sudo cp cuda/include/* /usr/local/cuda-11.0/include/ 查看 CUDNN的版本 1 cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 安装conda 1 2 3 chmod +x Anaconda3-2020.11-Linux-x86_64.sh ./Anaconda3-2020.11-Linux-x86_64.sh 测试 创建 python3.8+pytorch1.7+cuda11.0的虚拟环境 1 conda create --name python_38-pytorch_1.7.0 python=3.8 进入环境 1 conda activate python_38-pytorch_1.7.0 安装pytorch 1 pip install torch==1.7.0+cu110 torchvision==0.8.1+cu110 torchaudio===0.7.0 -f https://download.pytorch.org/whl/torch_stable.html 测试文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 import argparse import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) def train(args, model, device, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % args.log_interval == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) def test(args, model, device, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) # sum up batch loss test_loss += F.nll_loss(output, target, reduction='sum').item() # get the index of the max log-probability pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) def main(): parser = argparse.ArgumentParser(description='PyTorch MNIST Example') parser.add_argument('--batch-size', type=int, default=64, metavar='N', help='","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:5","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"realsense(D450)深度对齐优化","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/","tags":["camera"],"title":"camera:realsense(D450)深度对齐优化","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 SDK 中的对齐实现 转化为opencv Mat格式 realsense 对齐流程 SDK 中的对齐实现 源码位置 align_z_to_other 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void align::align_z_to_other(rs2::video_frame\u0026 aligned, const rs2::video_frame\u0026 depth, const rs2::video_stream_profile\u0026 other_profile, float z_scale) { byte* aligned_data = reinterpret_cast\u003cbyte*\u003e(const_cast\u003cvoid*\u003e(aligned.get_data())); auto aligned_profile = aligned.get_profile().as\u003crs2::video_stream_profile\u003e(); memset(aligned_data, 0, aligned_profile.height() * aligned_profile.width() * aligned.get_bytes_per_pixel()); auto depth_profile = depth.get_profile().as\u003crs2::video_stream_profile\u003e(); auto z_intrin = depth_profile.get_intrinsics(); auto other_intrin = other_profile.get_intrinsics(); auto z_to_other = depth_profile.get_extrinsics_to(other_profile); auto z_pixels = reinterpret_cast\u003cconst uint16_t*\u003e(depth.get_data()); auto out_z = (uint16_t *)(aligned_data); align_images(z_intrin, z_to_other, other_intrin, [z_pixels, z_scale](int z_pixel_index) { return z_scale * z_pixels[z_pixel_index]; }, [out_z, z_pixels](int z_pixel_index, int other_pixel_index) { out_z[other_pixel_index] = out_z[other_pixel_index] ? std::min((int)out_z[other_pixel_index], (int)z_pixels[z_pixel_index]) : z_pixels[z_pixel_index]; }); } align_images 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 template\u003cclass GET_DEPTH, class TRANSFER_PIXEL\u003e void align_images(const rs2_intrinsics\u0026 depth_intrin, const rs2_extrinsics\u0026 depth_to_other, const rs2_intrinsics\u0026 other_intrin, GET_DEPTH get_depth, TRANSFER_PIXEL transfer_pixel) { // Iterate over the pixels of the depth image #pragma omp parallel for schedule(dynamic) for (int depth_y = 0; depth_y \u003c depth_intrin.height; ++depth_y) { int depth_pixel_index = depth_y * depth_intrin.width; for (int depth_x = 0; depth_x \u003c depth_intrin.width; ++depth_x, ++depth_pixel_index) { // Skip over depth pixels with the value of zero, we have no depth data so we will not write anything into our aligned images if (float depth = get_depth(depth_pixel_index)) { // Map the top-left corner of the depth pixel onto the other image float depth_pixel[2] = { depth_x - 0.5f, depth_y - 0.5f }, depth_point[3], other_point[3], other_pixel[2]; rs2_deproject_pixel_to_point(depth_point, \u0026depth_intrin, depth_pixel, depth); rs2_transform_point_to_point(other_point, \u0026depth_to_other, depth_point); rs2_project_point_to_pixel(other_pixel, \u0026other_intrin, other_point); const int other_x0 = static_cast\u003cint\u003e(other_pixel[0] + 0.5f); const int other_y0 = static_cast\u003cint\u003e(other_pixel[1] + 0.5f); // Map the bottom-right corner of the depth pixel onto the other image depth_pixel[0] = depth_x + 0.5f; depth_pixel[1] = depth_y + 0.5f; rs2_deproject_pixel_to_point(depth_point, \u0026depth_intrin, depth_pixel, depth); rs2_transform_point_to_point(other_point, \u0026depth_to_other, depth_point); rs2_project_point_to_pixel(other_pixel, \u0026other_intrin, other_point); const int other_x1 = static_cast\u003cint\u003e(other_pixel[0] + 0.5f); const int other_y1 = static_cast\u003cint\u003e(other_pixel[1] + 0.5f); if (other_x0 \u003c 0 || other_y0 \u003c 0 || other_x1 \u003e= other_intrin.width || other_y1 \u003e= other_intrin.height) continue; // Transfer between the depth pixels and the pixels inside the rectangle on the other image for (int y = other_y0; y \u003c= other_y1; ++y) { for (int x = other_x0; x \u003c= other_x1; ++x) { transfer_pixel(depth_pixel_index, y * other_intrin.width + x); } } } } } } 目的：将深度坐标系下的点转换到彩色坐标系下 基本步骤： （1）将深度图的像素点还原到深度坐标系下 （2）深度坐标系下的深度点还原到世界坐标系 （3）世界坐标系的深度点转换到彩色坐标系下 （4）彩色坐标系的深度点映射到Z=1的平面上，即与彩色图像的像素点对应起来 由目标像素坐标和深度值（使用内参INTRINSICS）获取目标点的真实坐标原理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 //深度图对齐到彩色图函数 Mat align_Depth2Color(Mat depth,Mat color,rs2::p","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/:0:0","tags":["camera"],"title":"camera:realsense(D450)深度对齐优化","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/"},{"categories":["计算机视觉"],"content":"单目相机标定","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 相机标定内容 相机标定步骤 提取角点 棋盘格角点检测 对粗提取的角点进行精确化 亚像素检测 棋盘格角点的绘制 相机标定 生成 objectPoints 求相机的内参外参 相机矫正 - 计算无畸变和修正转换映射 remap 代码工程 相机标定内容 相机标定即获取相机的内参,外参和畸变矩阵等相机参数 内参 相机内参矩阵是相机自身的属性，内参分别为： f:焦距，单位毫米； fx:使用像素来描述x轴方向焦距的长度； fy:使用像素来描述y轴方向焦距的长度 u0,v0: 主点坐标（相对于成像平面），单位也是像素； γ:为坐标轴倾斜参数，理想情况下为0； 外参 相机的旋转矩阵R和平移向量t 旋转矩阵：描述了世界坐标系的坐标轴相对于摄像机坐标轴的方向 平移矩阵：描述了在摄像机坐标系下，空间原点的位置 畸变参数 畸变参数：k1,k2,k3径向畸变系数，p1,p2是切向畸变系数。径向畸变发生在相机坐标系转图像物理坐标系的过程中。而切向畸变是发生在相机制作过程，其是由于感光元平面跟透镜不平行。径向畸变，即由于透镜的不同区域的焦距的不同而引起的畸变，分为枕形畸变和桶形畸变如下图所示，越靠近镜头边缘畸变越明显。 相机内参和外参的解释 相机内参的标定方法 相机标定步骤 https://docs.opencv.org/3.4.0/d9/d0c/group__calib3d.html ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:0:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"提取角点 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"棋盘格角点检测 1 2 3 4 5 bool findChessboardCorners( InputArray image, Size patternSize, OutputArray corners, int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE ); 第一个参数是输入的棋盘格图像（可以是8位单通道或三通道图像）； 第二个参数是棋盘格内部的角点的行列数（注意：不是棋盘格的行列数，如棋盘格的行列数分别为4、8，而内部角点的行列数分别是3、7，因此这里应该指定为cv::Size(3, 7)）； 第三个参数是检测到的棋盘格角点，类型为std::vectorcv::Point2f。 第四个参数flag，用于指定在检测棋盘格角点的过程中所应用的一种或多种过滤方法，可以使用下面的一种或多种，如果都是用则使用OR： cv::CALIB_CB_ADAPTIVE_THRESH：使用自适应阈值将图像转化成二值图像 cv::CALIB_CB_NORMALIZE_IMAGE：归一化图像灰度系数(用直方图均衡化或者自适应阈值) cv::CALIB_CB_FILTER_QUADS：在轮廓提取阶段，使用附加条件排除错误的假设 cv::CALIB_CV_FAST_CHECK：快速检测 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:1","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"对粗提取的角点进行精确化 1 2 3 bool find4QuadCornerSubpix( InputArray img, InputOutputArray corners, Size region_size ); image源图像 corners，提供角点的初始坐标 region_size： 搜索窗口的一般尺寸\\ ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:2","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"亚像素检测 1 2 3 4 5 void cornerSubPix( InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria ); image源图像 corners，提供角点的初始坐标，返回更加精确的点 winSize，搜索窗口的一般尺寸，如果winSize=Size(5,5),则search windows为11*11 winSize,死区的一般尺寸，用来避免自相关矩阵的奇点，(-1,-1)表示没有死区 criteria，控制迭代次数和精度 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:3","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"棋盘格角点的绘制 1 2 3 4 void drawChessboardCorners( InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound ); image为8-bit，三通道图像 patternSize，每一行每一列的角 corners，已经检测到的角 patternWasFound，findChessboardCorners的返回值 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:4","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"相机标定 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"生成 objectPoints 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void CCalibration::init3DPoints(cv::Size boardSize, cv::Size squareSize, vector\u003ccv::Point3f\u003e \u0026singlePatternPoint) { for (int i = 0; i \u003c boardSize.height; i++) { for (int j = 0; j \u003c boardSize.width; j++) { cv::Point3f tempPoint; //单个角点的三维坐标 tempPoint.x = float(i * squareSize.width); tempPoint.y = float(j * squareSize.height); tempPoint.z = 0; singlePatternPoint.push_back(tempPoint); } } } ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:1","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"求相机的内参外参 1 2 3 4 5 6 7 8 9 double calibrateCamera( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) ); objectPoints，世界坐标，用vector，输入x,y坐标，z坐标为0 imagePoints，图像坐标，vector imageSize，图像的大小用于初始化标定摄像机的image的size cameraMatrix，内参数矩阵 distCoeffs，畸变矩阵 rvecs，位移向量 tvecs，旋转向量 flags，可以组合： CV_CALIB_USE_INTRINSIC_GUESS：使用该参数时，将包含有效的fx,fy,cx,cy的估计值的内参矩阵cameraMatrix，作为初始值输入，然后函数对其做进一步优化。如果不使用这个参数，用图像的中心点初始化光轴点坐标(cx, cy)，使用最小二乘估算出fx，fy（这种求法好像和张正友的论文不一样，不知道为何要这样处理）。注意，如果已知内部参数（内参矩阵和畸变系数），就不需要使用这个函数来估计外参，可以使用solvepnp()函数计算外参数矩阵。 CV_CALIB_FIX_PRINCIPAL_POINT：在进行优化时会固定光轴点，光轴点将保持为图像的中心点。当CV_CALIB_USE_INTRINSIC_GUESS参数被设置，保持为输入的值。 CV_CALIB_FIX_ASPECT_RATIO：固定fx/fy的比值，只将fy作为可变量，进行优化计算。当 CV_CALIB_USE_INTRINSIC_GUESS没有被设置，fx和fy的实际输入值将会被忽略，只有fx/fy的比值被计算和使用。 CV_CALIB_ZERO_TANGENT_DIST：切向畸变系数（P1，P2）被设置为零并保持为零。 CV_CALIB_FIX_K1,…,CV_CALIB_FIX_K6：对应的径向畸变系数在优化中保持不变。如果设置了CV_CALIB_USE_INTRINSIC_GUESS参数，就从提供的畸变系数矩阵中得到。否则，设置为0。 CV_CALIB_RATIONAL_MODEL（理想模型）：启用畸变k4，k5，k6三个畸变参数。使标定函数使用有理模型，返回8个系数。如果没有设置，则只计算其它5个畸变参数。 CALIB_THIN_PRISM_MODEL （薄棱镜畸变模型）：启用畸变系数S1、S2、S3和S4。使标定函数使用薄棱柱模型并返回12个系数。如果不设置标志，则函数计算并返回只有5个失真系数。 CALIB_FIX_S1_S2_S3_S4 ：优化过程中不改变薄棱镜畸变系数S1、S2、S3、S4。如果cv_calib_use_intrinsic_guess设置，使用提供的畸变系数矩阵中的值。否则，设置为0。 CALIB_TILTED_MODEL （倾斜模型）：启用畸变系数tauX and tauY。标定函数使用倾斜传感器模型并返回14个系数。如果不设置标志，则函数计算并返回只有5个失真系数。 CALIB_FIX_TAUX_TAUY ：在优化过程中，倾斜传感器模型的系数不被改变。如果cv_calib_use_intrinsic_guess设置，从提供的畸变系数矩阵中得到。否则，设置为0。 相机矫正 参考： 相机标定（4） 矫正畸变 undistort()和initUndistortRectifyMap() initUndistortRectifyMap ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:2","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"计算无畸变和修正转换映射 1 2 3 4 5 6 7 8 9 CV_EXPORTS_W void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2 ); //! initializes maps for cv::remap() for wide-angle CV_EXPORTS_W float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, int projType = PROJ_SPHERICAL_EQRECT, double alpha = 0); 1.cameraMatrix：输入相机矩阵 2.distCoeffs：输入参数，相机的畸变系数： (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τ**x,τ**y]]]]) ，有4，5,8,12或14个元素。如果这个向量是空的，就认为是零畸变系数。 3.R：可选的修正变换矩阵，是个3*3的矩阵。通过stereoRectify计算得来的R1或R2可以放在这里。如果这个矩阵是空的，就假设为单位矩阵。在cvInitUndistortMap中，R被认为是单位矩阵。 4.newCameraMatrix：新的相机矩阵 5.size：未畸变的图像尺寸。 6.m1type：第一个输出的映射的类型，可以为 CV_32FC1, CV_32FC2或CV_16SC2，参见cv::convertMaps。 7.map1：第一个输出映射。 8.map2：第二个输出映射。 这个函数用于计算无畸变和修正转换关系，为了重映射，将结果以映射的形式表达。无畸变的图像看起来就像原始的图像，就像这个图像是用内参为newCameraMatrix的且无畸变的相机采集得到的。 在单目相机例子中，newCameraMatrix一般和cameraMatrix相等，或者可以用cv::getOptimalNewCameraMatrix来计算，获得一个更好的有尺度的控制结果。 在双目相机例子中，newCameraMatrix一般是用cv::stereoRectify计算而来的，设置为P1或P2。 此外，根据R，新的相机在坐标空间中的取向是不同的。例如，它帮助配准双目相机的两个相机方向，从而使得两个图像的极线是水平的，且y坐标相同（在双目相机的两个相机谁水平放置的情况下）。 该函数实际上为反向映射算法构建映射，供反向映射使用。也就是，对于在已经修正畸变的图像中的每个像素(u,v)，该函数计算原来图像（从相机中获得的原始图像）中对应的坐标系。 函数输出得到map1和map2,然后使用remap()函数 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:3","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"remap 1 2 3 4 void remap( InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar\u0026 borderValue=Scalar()); 第一个参数：输入图像，即原图像，需要单通道8位或者浮点类型的图像 第二个参数：输出图像，即目标图像，需和原图形一样的尺寸和类型 第三个参数：它有两种可能表示的对象：（1）表示点（x,y）的第一个映射；（2）表示CV_16SC2，CV_32FC1等 第四个参数：它有两种可能表示的对象：（1）若map1表示点（x,y）时，这个参数不代表任何值；（2）表示 CV_16UC1，CV_32FC1类型的Y值 第五个参数：插值方式，有四种插值方式： （1）INTER_NEAREST——最近邻插值 （2）INTER_LINEAR——双线性插值（默认） （3）INTER_CUBIC——双三样条插值（默认） （4）INTER_LANCZOS4——lanczos插值（默认） 第六个参数：边界模式，默认BORDER_CONSTANT 第七个参数：边界颜色，默认Scalar()黑色 代码工程 完整代码工程（包含标定图片）： camera-calibration ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:3:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"深度相机realsense(D450)介绍","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 D455/450技术规格 参数表 Invalid Depth Band Depth Quality Specification 软件开发 sdk 及开发者文档 PC 安装realsense SDK realsense 获取深度、彩色相机内参外参 realsense 设置laser开关 原理 Interl RealSence D4×× 系列，都是采用经典的双目视觉的方式测量深度。尽管具有红外投射器，但并不是采用红外反射测距。它的作用仅仅是投射不可见的固定的红外纹理样式，提高在纹理不明显的1环境中（例如白墙）的深度计算精度，辅助双目视觉测距。左右两个相机将图像数据送入内置的深度处理器，在其中基于双目测距的原理计算每个像素的深度值。 D455/450技术规格 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:0:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"参数表 特性 使用环境： 室内/室外 深度快门类型： 全局快门，3μm × 3μm 像素大小 推荐范围： 0.6-6 米 惯性量测单元： Bosch BMI055 深度 深度技术： 主动 IR 立体 最小深度距离 (Min-Z)： ~0.52 米 深度精度 \u003c2% 位于4 米1 深度视场 (FOV)： 86° × 57° (±3°) 深度输出分辨率： 高达 1280 x 720 深度帧率： 高达 90 帧/秒 RGB RGB帧分辨率： 高达 1280 × 800 RGB 帧速率： 30 帧/秒 RGB 传感器技术： 全局快门 RGB 传感器 FOV (H × V)： 90° × 65° (±3) RGB传感器分辨率: 1 MP 主要组件 摄像头模块： 英特尔实感模块 D450 计算处理器板： 英特尔实感视觉处理器 D4 物理 外形： 摄像头外设 长度 × 深度 × 高度： 124 毫米 × 26 毫米 × 29 毫米 接头： USB‑C* 3.1 Gen 1* 安装机构： – 一个 1/4‑20 UNC 螺纹安装点。 – 两个 M3 螺纹安装点。 – 三脚架 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:1:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"Invalid Depth Band The depth data generated with stereo vision uses the left imager as the reference for stereo matching resulting in a non-overlap region in the field of view of left and right imagers where we will not have depth data at the left edge of the frame. Closer scenes result in a wider invalid depth band than scenes at larger distances. ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:2:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"Depth Quality Specification FOV 80% 做评估 METRIC DEFINITION Depth Accuracy ： 深度精度 测量相对于地面真实表面的有效像素的差异。 Fill Rate：Fill Rate 具有有效深度值的像素百分比。 Depth Standard Deviation ：深度标准差 测量每个有效像素相对于最佳拟合平面的总空间噪声。 Pixel Temporal Noise：像素时间噪声 测量相对于最佳拟合平面的每个有效像素的总时间噪声。 软件开发 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:3:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"sdk 及开发者文档 开发者支持 Linux/Ubuntu - RealSense SDK 2.0 Build Guide List of Intel RealSense SDK 2.0 Examples API How To ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:4:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"PC 安装realsense SDK Ubuntu下Realsense SDK的安装 下载源码 1 git clone https://github.com/IntelRealSense/librealsense.git 安装依赖环境 1 sudo apt-get install libusb-1.0-0-dev libglfw3-dev libgtk-3-dev libusb是一个USB设备访问接口库 gtk是一个图形工具包 glfw是一个OpenGL应用框架 将英特尔服务器添加到存储库列表中 1 echo 'deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main' | sudo tee /etc/apt/sources.list.d/realsense-public.list 注册服务器的公钥 1 sudo apt-key adv --keyserver keys.gnupg.net --recv-key 6F3EFCDE 刷新apt列表 1 sudo apt-get update 安装相关包 1 2 sudo apt-get install librealsense2-dkms sudo apt-get install librealsense2-utils dkms是内核驱动包，utils是工具包 检查安装 1 modinfo uvcvideo | grep \"version:\" 终端会返回相关版本信息 比如我的电脑上会返回 1 2 3 zyh@zyh ~ $ modinfo uvcvideo | grep \"version:\" version: 1.1.1 srcversion: 32217DB1DE9B0BC725EDF5D 编译 1 2 3 4 5 6 cd librealsense mkdir build cd build cmake .. make -j8 sudo make install ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:5:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"realsense 获取深度、彩色相机内参外参 1 2 3 4 rs2_intrinsics depth_intrin = depth_profile.as\u003crs2::video_stream_profile\u003e().get_intrinsics(); rs2_intrinsics color_intrin = color_profile.as\u003crs2::video_stream_profile\u003e().get_intrinsics(); rs2_extrinsics depth_extrin_to_color = depth_profile.as\u003crs2::video_stream_profile\u003e().get_extrinsics_to(color_profile); rs2_extrinsics color_extrin_to_depth = color_profile.as\u003crs2::video_stream_profile\u003e().get_extrinsics_to(depth_profile); rs2_intrinsics: 1 2 3 4 5 6 7 8 9 10 11 12 /** \\brief Video stream intrinsics. */ typedef struct rs2_intrinsics { int width; /**\u003c Width of the image in pixels */ int height; /**\u003c Height of the image in pixels */ float ppx; /**\u003c Horizontal coordinate of the principal point of the image, as a pixel offset from the left edge */ float ppy; /**\u003c Vertical coordinate of the principal point of the image, as a pixel offset from the top edge */ float fx; /**\u003c Focal length of the image plane, as a multiple of pixel width */ float fy; /**\u003c Focal length of the image plane, as a multiple of pixel height */ rs2_distortion model; /**\u003c Distortion model of the image */ float coeffs[5]; /**\u003c Distortion coefficients. Order for Brown-Conrady: [k1, k2, p1, p2, k3]. Order for F-Theta Fish-eye: [k1, k2, k3, k4, 0]. Other models are subject to their own interpretations */ } rs2_intrinsics; rs2_extrinsics: 1 2 3 4 5 6 /** \\brief Cross-stream extrinsics: encodes the topology describing how the different devices are oriented. */ typedef struct rs2_extrinsics { float rotation[9]; /**\u003c Column-major 3x3 rotation matrix */ float translation[3]; /**\u003c Three-element translation vector, in meters */ } rs2_extrinsics; ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:6:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"realsense 设置laser开关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 rs2::pipeline pipe; rs2::pipeline_profile selection = pipe.start(); rs2::device selected_device = selection.get_device(); auto depth_sensor = selected_device.first\u003crs2::depth_sensor\u003e(); if (depth_sensor.supports(RS2_OPTION_EMITTER_ENABLED)) { depth_sensor.set_option(RS2_OPTION_EMITTER_ENABLED, 1.f); // Enable emitter depth_sensor.set_option(RS2_OPTION_EMITTER_ENABLED, 0.f); // Disable emitter } if (depth_sensor.supports(RS2_OPTION_LASER_POWER)) { // Query min and max values: auto range = depth_sensor.get_option_range(RS2_OPTION_LASER_POWER); depth_sensor.set_option(RS2_OPTION_LASER_POWER, range.max); // Set max power depth_sensor.set_option(RS2_OPTION_LASER_POWER, 0.f); // Disable laser } ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:7:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"图像及视频等相关基础知识","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 视频编码 运动静止图像专家组的 M-JPEG 国际标准化组织(ISO)运动图像专家组的 MPEG 系列标准 国际电联(ITU-T)的 H.26X 音频编码 常见的多媒体框架及解决方案 颜色空间 RGB24/RGB32/I420(YUV) I420/YV12 YUV420 图像色彩模式 位图模式 灰度模式 RGB模式 CMYK模式 HSB模式 YUV格式 帧率 分辨率 刷新率 编码格式 封装格式 码率 采样率 量化精度 声道 部分参考资料 视频编码 而编码主要从两个维度压缩数据: 1、单一图像某一个区域的相邻像素相似，如一片红色区域只记录红色的色值以及区域，不记录这个区域的每一个像素点。 2、相邻的的两张图像比较相似，对图像方法的第一帧进行编码，然后用某种方式描述接下来的帧相对于附近的帧有什么区别。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"运动静止图像专家组的 M-JPEG M-JPEG 是一种图像压缩编码标准，是 Motion-JPEG 的简称，JPEG 标准主要是用来处理静止图像，而 M-JPEG 把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，M-JPEG 只对帧内的空间冗余进行压缩，不对帧间的时间冗余进行压缩，故压缩效率不高。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"国际标准化组织(ISO)运动图像专家组的 MPEG 系列标准 由ISO（国际标准组织机构）下属的MPEG（运动图象专家组）开发 视频编码方面主要是Mpeg1（vcd）、Mpeg2（DVD）、Mpeg4（DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（mp3）、MPEG-2 AAC 、MPEG-4 AAC等。注意：DVD音频没有采用Mpeg的。 MPEG 标准的视频压缩编码技术主要利用了具有运动补偿的帧间压缩编码技术以减小时间冗余度，利用 DCT 技术以减小图像的空间冗余度，利用熵编码则在信息表示方面减小了统计冗余度。这几种技术的综合运用，大大增强了压缩性能。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"国际电联(ITU-T)的 H.26X H.261：第一个实用的数字视频解码标准，采用的压缩算法是运动补偿帧间预测与分块 DCT 相结合的混合编码，其运动补偿使用用全像素精度和环路滤波，支持 CIF 和 QCIF 两种分辨率。 H.263：H.263 与 H.261 编码算法一样，但是做了一点改善，使得 H.263 标准在低码率下能够提供比 H.261 更好的图像效果，其运动补偿使用半像素精度，支持 CIF、QCIF 、SQCIF、4CIF和16CIF 五种分辨率。 H.264：H.264则是由两个组织 ISO 和 ITU-T 联合组建的联合视频组（JVT）共同制定的新数字视频编码标准，所以它既是 ITU-T 的H.264，又是 ISO/IEC 的 MPEG-4 高级视频编码（Advanced Video Coding，AVC）的第 10 部分，因此，不论是MPEG-4 AVC、MPEG-4 Part 10，还是 ISO/IEC 14496-10，都是指 H.264，H.264 是基于传统框架的混合编码系统，做了局部优化，注重编码效率和可靠性。H.264 在具有高压缩比的同时还拥有高质量流畅的图像，经过 H.264 压缩的视频数据，在网络传输过程中所需要的带宽更少，是压缩率最高的视频压缩标准。 音频编码 常见的音频编解码标准如下： ITU：G.711、G.729 等 MPEG：MP3、AAC 等 3GPP：AMR、AMR-WB、AMR-WB+等 还有企业制定的标准，如 Dolby AC-3、DTS 、WMA 等 常见的介绍如下： MP3（MPEG-1 audio layer 3）：一种音频压缩技术，它被设计用来大幅度地降低音频数据量，利用 MPEG Audio Layer 3 的技术，将音乐以 1:10 甚至 1:12 的压缩率，压缩成容量较小的文件，而对于大多数用户来说重放的音质与最初的不压缩音频相比没有明显的下降，它是利用人耳对高频声音信号不敏感的特性，将时域波形信号转换成频域信号，并划分成多个频段，对不同的频段使用不同的压缩率，对高频加大压缩比（甚至忽略信号），对低频信号使用小压缩比，保证信号不失真，这样就相当于抛弃人耳基本听不到的高频声音，只保留能听到的低频部分，从而对音频进行一定压缩，此外 MP3 属于有损压缩的文件格式。 AAC：Advanced Audio Coding 的缩写，最初是基于 MPEG-2 的音频编码技术，MPEG-4 出现后，AAC 重新集成了其特性，且加入了SBR 技术和 PS 技术，为了区别于传统的 MPEG-2 AAC 又称为MPEG-4 AAC，AAC 是一种专为声音数据设计的文件压缩格式，相较 MP3，AAC 格式的音质更佳，文件更小，但是 AAC 是一种有损压缩格式，随着大容量设备的出现，其优势将越来越小。 WMA：Windows Media Audio 的缩写，是微软公司开发的一系列音频编解码器，也指相应的数字音频编码格式，WMA 包括四种不同的编解码器：WMA，原始的WMA编解码器，作为 MP3 和 RealAudio 编解码器的竞争者；WMA Pro，支持更多声道和更高质量的音频[；WMA Lossless，无损编解码器；WMA Voice，用于储存语音，使用的是低码率压缩。一些使用 Windows Media Audio 编码格式编码其所有内容的纯音频 ASF 文件也使用 WMA 作为扩展名，其特点是支持加密，非法拷贝到本地是无法播放的，WMA 也属于有损压缩的文件格式。 常见的多媒体框架及解决方案 常见的多媒体框架及解决方案有 VLC 、 FFmpeg 、 GStream 等，具体如下： VLC ：即 Video LAN Client，是一款自由、开源的跨平台多媒体播放器及框架 。 FFmpeg：多媒体解决方案，不是多媒体框架，广泛用于音视频开发中。 GStreamer ：一套构建流媒体应用的开源多媒体框架 。 颜色空间 YUV：一种颜色编码方法，一般使用在在影像处理组件中，YUV 在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽，其中 Y 表示明亮度、U 表示色度、V 表示浓度，Y′UV、YUV、YCbCr、YPbPr 所指涉的范围，常有混淆或重叠的情况。从历史的演变来说，其中 YUV 和 Y’UV 通常用来编码电视的模拟信号，而 YCbCr 则是用来描述数字的影像信号，适合视频与图片压缩以及传输，例如 MPEG、JPEG，现在 YUV 通常已经在电脑系统上广泛使用。 RGB：原色光模式，又称 RGB 颜色模型或红绿蓝颜色模型，是一种加色模型，将红（Red）、绿（Green）、[蓝（Blue）三原色的色光以不同的比例相加，以合成产生各种色彩光，目前的大多数显示器都采用 RGB 这种颜色标准。 YUV 主要用于优化彩色视频信号的传输，使其向后相容老式黑白电视，与 RGB 视频信号传输相比，它最大的优点在于只需占用极少的带宽。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"RGB24/RGB32/I420(YUV) 一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width× heighth ×3 Byte，RGB32的size＝width× heighth ×4，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width× heighth ×1.5 Byte。 X264在进行编码的时候需要标准的YUV（4：2：0）。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"I420/YV12 YV12和I420基本上是一样的，就是UV的顺序不同。 YV12 ： 亮度（行×列） ＋ V（行×列/4) + U（行×列/4） I420 ： 亮度（行×列） ＋ U（行×列/4) + V（行×列/4） ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"YUV420 YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。 “Y”表示明亮度（Luminance或Luma），也就是灰阶值，“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 YUV420格式是指，每个像素都保留一个Y（亮度）分量，而在水平方向上，不是每行都取U和V分量，而是一行只取U分量，则其接着一行就只取V分量，以此重复(即4:2:0, 4:0:2, 4:2:0, 4:0:2 …….)，所以420不是指没有V，而是指一行采样只取U，另一行采样只取V。在取U和V时，每两个Y之间取一个U或V。但从4x4矩阵列来看，每4个矩阵点Y区域中，只有一个U和V，所以它们的比值是4:1。所以对于一个像素，RGB需要8 * 3 = 24位，即占3个字节；而YUV420P，8 + 8/4 + 8/4 = 12位，即占2个字节，其中8指Y分量，8/4指U和V分量。 图像色彩模式 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:6:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"位图模式 位图模式是图像中最基本的格式，图像只有黑色和白色像素，是色彩模式中占有空间最小的，同样也叫做黑白图，它包含的信息量最少，无法包含图像中的细节，相当于只有0或者1 一副彩色图如果要转换成黑白模式，则一般不能直接转换，需要首先将图像转换成灰度模式 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:7:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"灰度模式 灰度模式即使用单一色调来表示图像，与位图模式不同，不像位图只有0和1，使用256级的灰度来表示图像，一个像素相当于占用8为一个字节，每个像素值使用0到255的亮度值代表，其中0为黑色，255为白色，相当于从黑-\u003e灰-\u003e白的过度，通常我们所说的黑白照片就是这种模式，与位图模式相比，能表现出一定的细节，占用空间也比位图模式较大 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:8:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"RGB模式 RGB模式为我们经常见到的，被称为真色彩。RGB模式的图像有3个颜色通道，分布为红（Red）,绿（Green）和蓝（Bule），每个都占用8位一个字节来表示颜色信息，这样每个颜色的取值范围为0~255，那么就三种颜色就可以有多种组合 当三种基色的值相等是，表现出为灰色，三种颜色都为255即为白色，三种颜色都为0，即为黑色 RGB模式的图像占用空间要比位图，灰度图都要大，但表现出的细节更加明显 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:9:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"CMYK模式 CMYK模式被称为印刷色彩模式，主要是来源于印刷行业，以打印油墨在纸张上的光线吸收特性为基础，与RGB类似，也是使用三种颜色，分别为青色（Cyan）,品红色（Magenta）,黄色（Yellow）,以及黑色（Black） 与RGB不同的是：RGB模式依靠的是自身发光的色彩模式，而CMYK是一种依靠反光的色彩模式。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:10:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"HSB模式 是根据日常生活中人眼的视觉对色彩的观察得而制定的一套色彩模式，最接近与人类对色彩的辨认的思考方式，所有的颜色都是用色彩三属性来描述 H:(色相）：是指从物体反射或透过物体传播的颜色 S:(饱和度)：是指颜色的强度或纯度，表示色相中灰色成分所占的比例 B:(亮度)：是指颜色对相对明暗程度，通常 100%定义为白色；0%为黑色 除了上述以上之外，还有索引模式，多通道模式等等不再介绍 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:11:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"YUV格式 除了上述图像模式之外，由于历史原因大部分摄像头输入的图片格式都是YUV格式，开始主要用于电视系统以及模拟视频领域。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。如果没用UV信息，只有Y信息，也可以进行成像不过只是黑白的，这样就能很好解决彩色电视与黑白电视的兼容问题，与RGB相比，YUV占用带宽较少，目前摄像头输出格式普遍采用YUV格式。 而在图像的处理过程中，其实很少使用YUV格式，一般都需要转成RGB格式或者灰度图格式进行转换，而opencv的cvtColor()函数支持这种转换 帧率 帧率是用于测量显示帧数的量度。单位为「每秒显示帧数」（Frame per Second，FPS）或「赫兹，Hz」，表示每秒的帧数（FPS）或者说帧率表示图形处理器处理场时每秒钟能够更新的次数，高的帧率可以得到更流畅、更逼真的动画，一般来说 30fps 就是可以接受的，但是将性能提升至 60fps 则可以明显提升交互感和逼真感，但是一般来说超过 75fps 一般就不容易察觉到有明显的流畅度提升了，如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过刷新率的帧率就浪费掉了。 分辨率 视频分辨率是指视频成像产品所形成的图像大小或尺寸，常见的 1080P、4K 等有代表什么呢，P 本身的含义是逐行扫描，表示视频像素的总行数，1080P 表示总共有 1080 行的像素数，而 K 表示视频像素的总列数，4K 表示有 4000 列的像素数，通常来说，1080P 就是指 1080 x 1920 的分辨率，4 k 指 3840 x 2160 的分辨率。 刷新率 刷新率就是屏幕每秒画面被刷新的次数，刷新率分为垂直刷新率和水平刷新率，一般提到的刷新率通常指垂直刷新率，垂直刷新率表示屏幕的图象每秒钟重绘多少次，也就是每秒钟屏幕刷新的次数，以 Hz（赫兹）为单位，刷新率越高越好，图象就越稳定，图像显示就越自然清晰，对眼睛的影响也越小，刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快，一般来说，如能达到 80Hz 以上的刷新频率就可完全消除图像闪烁和抖动感，眼睛也不会太容易疲劳。 编码格式 针对音视频来说，编码格式对应的就是音频编码和视频编码，对照前面的音频编码标准和视频编码标准，每种编码标准都对应的编码算法，其目的是通过一定编码算法实现数据的压缩、减少数据的冗余。 封装格式 直接看下百度百科的关于封装格式的介绍，封装格式（也叫容器），就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中，也就是说仅仅是一个外壳，或者大家把它当成一个放视频轨和音频轨的文件夹也可以，说得通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个碗，或者一个锅，用来盛放饭菜的容器。 码率 码率，也就是比特率（Bit rate），指单位时间内传输或处理的比特的数量，单位为 bps（bit per second）也可表示为 b/s，比特率越高，单位时间传送的数据量（位数）越大，多媒体行业在指音频或视频在单位时间内的数据传输率时通常使用码率，单位是 kbps，一般来说，如果是 1M 的宽带，在网上只能看码流不超过 125kbps 的视频，超过 125kbps 的视频只能等视频缓冲才能顺利观看。 码率一般分为固定码率和可变码率： 固定码率会保证码流的码率恒定，但是会牺牲视频质量，比如为了保证码率恒定，某些图像丰富的内容就是失去某些图像细节而变得模糊。 可变码率指的是输出码流的码率是可变的，因为视频信源本身的高峰信息量是变化的，从确保视频传输质量和充分利用信息的角度来说，可变码率视频编码才是最合理的。 码率的高低与视频质量和文件提交成正比，但当码率超过一定数值后，对视频质量没有影响。 采样率 采样率，表示每秒从连续信号中提取并组成离散信号的采样个数，用赫兹（Hz）来表示，采样率是指将模拟信号转换成数字信号时的采样频率，人耳能听到的声音一般在 20Hz~20KHz 之间，根据采样定理，采样频率大于信号中最高频率的 2 倍时，采样之后的数字信号便能完整的反应真实信号，常见的采样率如下： 8000 Hz：电话所用采样率, 对于人的说话已经足够 11025 Hz：AM调幅广播所用采样率 22050 Hz 和 24,000 Hz：FM调频广播所用采样率 44100Hz：音频CD，常用于 MPEG-1 音频（VCD，SVCD，MP3）所用采样率 47,250 Hz：商用 PCM 录音机所用采样率 48,000 Hz：miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率 CD 音乐的标准采样频率为 44.1KHz，这也是目前声卡与计算机作业间最常用的采样频率，目前比较盛行的蓝光的采样率就相当的高，达到了 192kHz。而目前的声卡，绝大多数都可以支持 44.1kHz、48kHz、96kHz，高端产品可支持 192kHz 甚至更高，总之，采样率越高，获得的声音文件质量越好，占用存储空间也就越大。 量化精度 声波在转换为数字信号的过程中不只有采样率影响原始声音的完整性，还有一个重要影响因素是量化精度，采样频率针对的是每秒钟所采样的数量，而量化精度则是对于声波的振幅进行切割，切割的数量是以最大振幅切成 2 的 n 次方计算，n 就是 bit 数，而 bit 数就是音频分辨率。 另外，bit 的数目还决定了声波振幅的范围（即动态范围，最大音量与最小音量的差距），如果这个位数越大，则能够表示的数值越大，描述波形更精确，每一个 Bit 的数据可以记录约等于 6dB 动态的信号，一般来说，16Bit 可以提供最大 96dB 的动态范围（加高频颤动后 只有 92dB），据此可以推断出 20Bit 可以达到 120dB 的动态范围，动态范围大了，会有什么好处呢？动态范围是指系统的输出噪音功率和最大不失真音量功率的比值，这个值越大，则系统可以承受很高的动态。 声道 声道指声音在录制或播放时在不同空间位置采集或回放的相互独立的音频信号，所以声道数也就是声音录制时的音源数量或回放时相应的扬声器数量，常见声道有单声道、立体声道、4 声道、5.1 声道、7.1 声道等 ，具体如下： 单声道：设置一个扬声器。 立体声道：把单声道一个扬声器扩展为左右对称的两个扬声器，声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果，这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自何方，从而使音乐更富想象力，更加接近临场感受。立体声技术广泛应用于自 Sound Blaster Pro 以后的大量声卡，成为了 影响深远的音频标准。 4 声道：4 声道环绕规定了 4 个发音点，分别是前左、前右、后左、后右，听众则被包围在中间，同时还建议增加一个低音音箱，以加强对低频信号的回放处理，这也就是如今 4.1 声道音箱系统广泛流行的原因，就整体效果而言，4 声道系统可以为听众带来来自多个不 同方向的声音环绕，可以获得身 临各种不同环境的昕觉感受，给用户以全新的体验。 5.1 声道：其实 5.1 声道系统来源于 4.1 声道系统，将环绕声道一分为二，分为左环绕和右环绕，中央位置增加重低音效果。 7.1 声道：7.1 声道系统在 5.1 声道系统的基础上又增加了中左和中右两个发音点，简单来说就是在听者的周围建立起一套前后相对平衡的声场，增加了 后中声场声道。 部分参考资料 音视频基本概念 视频格式基础知识：让你了解MKV、MP4、H.265、码率、色深等等 图片格式之YUV420 转RGB格式 fourcc ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:12:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["cpp"],"content":"整理部分现代C++作用在函数后的关键字","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 标识符/语句/表达式 标识符 在声明中 在表达式中 无限定标识符 有限定标识符 名字 语句 表达式语句 复合语句 选择语句 迭代语句 跳转语句 声明语句 try块 表达式 初等表达式 不求值表达式 弃值表达式 常量表达式 code const 作用 const 的指针与引用 使用 static 作用 静态成员 静态成员函数 this 指针 inline 内联函数 特征 使用 编译器对 inline 函数的处理步骤 优缺点 虚函数（virtual）可以是内联函数（inline）吗？ volatile assert() sizeof() #pragma pack(n) pragma pack(n) 使用 位域 extern “C” struct 和 typedef struct C 中 C++ 中 C++ 中 struct 和 class 区别 类的默成员函数 union 联合 C 实现 C++ 类 explicit（显式）关键字 friend 友元类和友元函数 using using 声明 构造函数的 using 声明 using 指示 尽量少使用 using 指示 污染命名空间 :: 范围解析运算符 分类 enum 枚举类型 限定作用域的枚举类型 不限定作用域的枚举类型 decltype 推导出表达式类型 与using/typedef合用，用于定义类型 重用匿名类型 泛型编程中结合auto，用于追踪函数的返回值类型 decltype推导四规则 引用 左值引用 右值引用 引用折叠 宏 成员初始化列表 initializer_list 列表初始化 面向对象 封装 继承 多态 静态多态（编译期/早绑定） 动态多态（运行期期/晚绑定） 虚析构函数 纯虚函数 虚函数、纯虚函数 虚函数指针、虚函数表 虚继承 虚继承、虚函数 模板类、成员模板、虚函数 抽象类、接口类、聚合类 内存分配和管理 malloc、calloc、realloc、alloca malloc、free new、delete 定位 new delete this 合法吗？ 如何定义一个只能在堆上（栈上）生成对象的类？ 只能在堆上 只能在栈上 智能指针 C++ 标准库（STL）中 C++ 98 C++ 11 shared_ptr weak_ptr unique_ptr auto_ptr auto_ptr 与 unique_ptr 比较 强制类型转换运算符 static_cast dynamic_cast const_cast reinterpret_cast bad_cast 运行时类型信息 (RTTI) dynamic_cast typeid type_info 参考资料 标识符/语句/表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:0:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"标识符 标识符实际上是由一组字符组成的任意长度的字符串，规定是以非数字开头，以下划线字母Unicode开头，非关键字的字符串即可，但是要主要的是虽然引入了对Unicode字符的支持，但是各实现任是不定的，对于Unicode的处理，我们在翻译的第一阶段就知道了，映射成了一个通用转移序列开头的字符。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"在声明中 对于标识符在标准中也是有一定规定的，通常有两个下划线或一个下划线一个大写字母的标识符是被保留的，以一个下划线开头的标识符在全局作用域中是保留的，这里的保留的意思就是说，这写标识符可能都被声明或是被空白#define过的用于内部使用不对外给使用者使用，即使有些功能是已知的，但是具体实现，特性等都是未知的，故使用这类标识符是UB，同样，不能对关键字进行#define #undef 如果这么做的话则也是UB。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"在表达式中 一个命名函数，变量，枚举项的标识符是一个表达式，当这个标识符单独作为一个表达式时，表达式的结果是这个标识符所命名的实体，如果这个标识符指名的是变量，函数，模板形参对象，数据成员，那么这个表达式的值类别就是左值，否则就是纯右值。一个表达式的类型确定通常有规定，通常情况下表达式的类型就是它指名的实体类型，如果表达式是一个非静态局部变量并且在其作用域外被指名则会导致造成这个形式的lambda对象以复制捕获，那么这个表达式的类型就是其最内层穿插的lambda表达式的闭包对象捕获声明的一个非静态数据成员的成员访问表达式的类型。在非静态成员函数内，每个指名数据成员的都被隐式的转换成类成员表达式(this→mumber)。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"无限定标识符 无限定标识符除了上述声明了的标识符外还有以下标识表达式可以被用在表达式中： 函数写法的重载运算符名字 用户定义类型转换的函数名字 用户定义的字面量运算符的名字 带有实参表的模板名字 ～字符随类名 ～字符随decltype 这些都符号和标识符组合在一起成为无限定的标志表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"有限定标识符 有限定标识符则是在无限定标识符前加作用域解析符，或是以作用域解析副分隔的一系列枚举，类，名称空间的名字或者decltyle表达式。对于有限定标识符，可能会存在要求用templata来消除依赖的模板名的歧义。 //ToDo在代码中添加消除依赖相关内容 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"名字 名字可以代表一个实体或是一个标签 名字通常是一个标识符 或者是在无限定标识符中（实际上有无限定均属）详细说明的代名字的标志表达式 一个代表实体的名字是通过声明引入的，代表标签的则是可以通过goto或由标号标签（case）引入 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:2:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"语句 语句的大格式是： 1 attr statement 即在语句前可以用一系列属性对语句做修饰 语句是顺序执行C++程序片段，任意函数体是语句的序列，一个语句通常可以是： ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"表达式语句 一个表达式后跟随一个分号即可（只有跟随分号的一个最终表达式是表达式语句语句） ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"复合语句 当期望一个语句但是又要求这个语句内包含多个顺序执行的语句序列时就使用一个复合语句 复合语句需要由一对花括号包括，并引入一个块作用域，在复合语句结束后，声明于块内变量被销毁。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"选择语句 选择语句是if constexpr，switch，其中从C++17起，if可带初始化语句，其会被改编为 1 2 3 4 { 初始化语句 if constexpr（可选）… } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"迭代语句 迭代语句是for（包括C++11起的范围for) while do…while ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"跳转语句 continue break return goto ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:5","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"声明语句 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:6","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"try块 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:7","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"表达式 表达式是由运算符和运算数组成的一个序列。可对表达式求值产生结果，一个表达式也可以产生副作用。一表达式求值，可以推得一个值类别，同时，表达式遵循一个求值顺序规则来求得实参和子表达式的值作为表达式的中间值。 表达式的运算符包括： 所有支持的运算符 类型转换 分配内存 其他 其中一个表达式可以分为： ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"初等表达式 表达式通常是一个初等表达式和一个子表达式递归形成一个初等表达式可以是： 常量 字面量 标识符 lambda表达式 折叠表达式 括号内的表达式被当作一个初等表达式看待（所以在进行表达式求值即存在运算符时，通常会求得初等表达式的值，所以可以保证括号内的表达式被优先求值）。 字面量介绍： 字面量可以是:常数字面量，字符字面量，字符串字面量，nullptr，浮点字面量，bool字面量，用户定字面量。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"不求值表达式 一个不求值表达式通常是在运算符:sizeof/sizeof…/decltype/typeid/noexpect 之后的表达式，但是要注意两点： 如果tepeid的运算数是一个多态对象则会对该表达式求值，以确定其具体所属类型 一个不求值表达式是一个完全表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"弃值表达式 弃置表达式表明，只处理表达式相应的副作用，不对表达式求得的值做处理，所有的表达式语句和逗号运算符的左实参都是弃值表达式，即，非弃值表达式只会存在于子表达式中，由于表达式的值被抛弃（不使用）所以不会对其进行常规转换（规定上的）数组不会自动转为指针，函数不会自动转为函数的指针。弃值表达式可以是： 标识符表达式（单独有一个标识符构成的表达式） 成员访问表达式（使用到成员访问运算符系的） 成员指针操作 条件表达式（三目） 逗号表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"常量表达式 概述而言，常量表达式是可以在编译期确定（求）其值的表达式，以此来确定一些编译器必须被确定的数据。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \u003ciostream\u003e #include \"AllCore.h\" NS_STAT_IDENT static bool test_bool() { return true; } bool main_statement() { //一个语句可以是: [[]] int foo1,foo2; //声明语句 [[]] foo1 = foo2 = 2; //表达式语句 // 此处为了介绍，语句的基本格式实际上是attr(可选)所需求语句 //即，在语句前可以指定一个属性序列，对这条语句进行修饰 [[]]flag:int foo3 = 1; //或是在switch中的 //case constexpr： ... //default: ... //以上是标号，任何语句都可以有一个标号 ////注意标号和属性，如果属性出现在标号前，则这个属性应用到的是这个标号 //出现在标号后表明这个属性应用到语句 //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- if(int a = 2;a == foo1 == foo2); else std::cout\u003c\u003c\"Print!\"\u003c\u003cstd::endl; if (int foo32 = 1;test_bool()); if constexpr (1); //选择语句 //在C++17之后出现了可选带初始化语句的if语句和constexpr if //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- //以下包含了： int a[10][10]; for(int i = 0;i\u003c1;++i) { //迭代语句\u0026\u0026复合语句块 break; //跳转语句 for (int j = 0; j \u003c 1; ++j) a[i][j]; } for(int (\u0026it)[10]:a) //C++11的范围for迭代语句 for(int \u0026it1:it) { //复合语句块 it1; continue; //跳转语句 } try { //try块 while (1) { static int jd = 1; if (jd == 2) throw jd; ++jd; } } catch (int ct) { std::cout\u003c\u003c\"Catch!\"\u003c\u003cct\u003c\u003cstd::endl; goto ret; //跳转语句 } ret:return true; //标签+跳转语句 } //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- //标识符在声明中 enum E1{EM1,EM2}; struct C1{int member;}; namespace N1{} template\u003cclass ... _Tys\u003e struct TC1{TC1(_Tys ... _args){}}; static void func1(){} int a,_a,_87,中文; //以_，英文字母，通用转移序列\\uxxxx开头的都可以 //对于一个声明的规则如下: //以下划线+大写字母，+下划线，或在全局范围内的标识符，都是被保留的 //标识符可以命名，名称空间，枚举，枚举项，类，类成员，变量，模板，模板特化，参数包 bool main_identifier() { sg: //goto标签等其他实体 //对关键字进行#define or #undef 行为未定义 int esp = 4; //标识符在表达式中 a;_a;_87;中文; EM1;EM2; func1; //标识符命名了枚举项，变量，函数，则这个标识符就是表达式 //并且，当当前表达式（表达式可以嵌套）单独为当前标识符时，这个表达式代表的是标识符命名的实体 [=](){esp;}; //esp在其生存期外被lambda闭包对象捕获，此时，这个esp单独这个表达式的类型实际上时一个 //出现在其出现的最内存的lambda闭包对象的成员访问表达式的类型 //无限定标识符，有限定标识符，名字，请看本人简书，绪论。 return true; } //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- template\u003cclass ...T\u003e auto fun(T ... args)-\u003eint {return (...+args);}; //初等表达式之一，折叠表达式 bool main_expression() { C1 Ca,*Cb = new C1(); int C1::*p_member = \u0026C1::member; //表达式的概念，在本人简书内有叙述，此处不再做陈述。 //初等表达式： //初等表达式存在在表达式嵌套中，作为表达式求值的基本单位 int j; 1; //字面量 j; //对一个实体命名的名字 [](){}; //lanbda表达式 fun(1,2,3,4,5,6); //使用了折叠表达式返回，这里的折叠表达式是初定表达式 (1+2+3); //括号内的表达式，整个括号当作一个初等表达式 //解释：为什么括号优先计算 //因为一个表达式通常都是由运算数和运算符组成 //表达式可以是一堆初等表达式嵌套，之后顺序执行，所以，我们需要知道每个初等表达式的值即可 //因此，括号内的值回在所结合的运算符进行表达式求值之前被求值 //不求值表达式： sizeof(std::cout\u003c\u003c1); decltype(std::cout\u003c\u003c2); typeid(j += 4); //以及noexpect和求包大小的sizeof //不求值表达式的意义就在于，在编译期获得一个数据，并不在运行时对运算数求值，以上的表达式都是运算符 //特例，typeid在存对存在多态的对行求类型时，回求动态类型，此时会对表达式求值 //弃值表达式 //概念，弃值表达式实际上就是表明，当前表达式的值不被运算符所需要而被丢弃 j; //一个大的表达式，单独由一个标识符的 Ca.member; Cb-\u003emember; Ca.*p_member; Cb-\u003e*p_member; //对于这一类的成员访问表达式 j == 2?1:2; //条件表达式 1,2,3,4; //逗号表达式 //表达式语句 //表达式语句，即所有以;结尾的表达式，是C++顺序执行的程序片段 //常量表达式，在简书中描述这里不再赘述。 return true; } bool main_statement_identifier_expression() { return main_statement() \u0026\u0026 main_identifier() \u0026\u0026 main_expression(); } const ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:5:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:6:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:7:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"使用 const 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026a; // 指针变量，指向常对象 const A \u0026q = a; // 指向常对象的引用 // 指针 char greeting[] = \"Hello\"; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026 Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:8:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 c++规定const静态类成员可以直接初始化，其他非const的静态类成员需要在类外初始化，且不能使用static关键字。 我们一般选择在类的实现文件中实现它。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:9:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态成员 C++中静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存 static成员变量属于类（被存放在数据段中），不属于某个具体的对象（具体对象的内存是分配在堆中的），即使创建多个对象，也只为该变量分配一次内存，所有对象使用的都是这份内存中的数据。 若它为public类型，当某个对象修改了它，也会影响到其他对象，所有对象都是“同甘共苦的” ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:10:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态成员函数 态成员函数的出现就是为了处理静态成员变量的 当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针，不能访问本类中的非静态成员。 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 \u0026this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:11:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:12:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"使用 inline 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 声明1（加 inline，建议使用） inline int functionName(int first, int second,...); // 声明2（不加 inline） int functionName(int first, int second,...); // 定义 inline int functionName(int first, int second,...) {/****/}; // 类内定义，隐式内联 class A { int doA() { return 0; } // 隐式内联 } // 类外定义，需要显式内联 class A { int doA(); } inline int A::doA() { return 0; } // 需要显式内联 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:13:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:14:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"优缺点 优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:15:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"虚函数（virtual）可以是内联函数（inline）吗？ Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u003ciostream\u003e using namespace std; class Base { public: inline virtual void who() { cout \u003c\u003c \"I am Base\\n\"; } virtual ~Base() {} }; class Derived : public Base { public: inline void who() // 不写inline时隐式内联 { cout \u003c\u003c \"I am Derived\\n\"; } }; int main() { // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-\u003ewho(); // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(\"pause\"); return 0; } volatile 1 volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile assert() 断言，是宏，而非函数。assert 宏的原型定义在 \u003cassert.h\u003e（C）、\u003ccassert\u003e（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include \u003cassert.h\u003e 之前。 assert() 使用 1 2 3 4 #define NDEBUG // 加上这行，则 assert 不可用 #include \u003cassert.h\u003e assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n) 设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1 2 3 4 5 6 7 8 9 10 11 #pragma pack(push) // 保存对齐状态 #pragma pack(4) // 设定为 4 字节对齐 struct test { char m1; double m4; int m3; }; #pragma pack(pop) // 恢复对齐状态 位域 1 Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（\u0026）不能作用于位域，任何指针都无法指向类的位域 extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和链接的 extern \"C\" 的作用是让 C++ 编译器将 extern \"C\" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern “C” 使用 1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \"C\" { #endif void *memset(void *, int, size_t); #ifdef __cplusplus } #endif struct 和 typedef struct ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:16:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C 中 1 2 3 4 // c typedef struct Student { int age; } S; 等价于 1 2 3 4 5 6 // c struct Student { int age; }; typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:17:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 中 由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 1 2 3 4 5 6 // cpp struct Student { int age; }; void f( Student me ); // 正确，\"struct\" 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct Student { int age; } S; void Student() {} // 正确，定义后 \"Student\" 只代表此函数 //void S() {} // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名 int main() { Student(); struct Student me; // 或者 \"S me\"; return 0; } C++ 中 struct 和 class 结构体和类都是是一种构造类型。 C语言中的 struct 只能包含变量(包括函数指针)。 C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。 类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的零件，要有地方来存放，才会占用内存空间。 在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的实例化，因此也称对象是类的一个实例（Instance）。有些资料也将类的成员变量称为属性（Property），将类的成员函数称为方法（Method）。 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:18:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 类的默成员函数 union 联合 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u003ciostream\u003e union UnionTest { UnionTest() : i(10) {}; int i; double d; }; static union { int i; double d; }; int main() { UnionTest u; union { int i; double d; }; std::cout \u003c\u003c u.i \u003c\u003c std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout \u003c\u003c ::i \u003c\u003c std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout \u003c\u003c i \u003c\u003c std::endl; // 输出局部匿名联合的 30 return 0; } C 实现 C++ 类 C 实现 C++ 的面向对象特性（封装、继承、多态） 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同 Can you write object-oriented code in C? [closed] explicit（显式）关键字 explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 explicit 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 struct A { A(int) { } operator bool() const { return true; } }; struct B { explicit B(int) {} explicit operator bool() const { return true; } }; void doA(A a) {} void doB(B b) {} int main() { A a1(1); // OK：直接初始化 A a2 = 1; // OK：复制初始化 A a3{ 1 }; // OK：直接列表初始化 A a4 = { 1 }; // OK：复制列表初始化 A a5 = (A)1; // OK：允许 static_cast 的显式转换 doA(1); // OK：允许从 int 到 A 的隐式转换 if (a1); // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a6（a1）; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a7 = a1; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a8 = static_cast\u003cbool\u003e(a1); // OK ：static_cast 进行直接初始化 B b1(1); // OK：直接初始化 B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化 B b3{ 1 }; // OK：直接列表初始化 B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 B b5 = (B)1; // OK：允许 static_cast 的显式转换 doB(1); // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 bool b8 = static_cast\u003cbool\u003e(b1); // OK：static_cast 进行直接初始化 return 0; } friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 using ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:19:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"using 声明 一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1 using namespace_name::name; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:20:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"构造函数的 using 声明 在 C++11 中，派生类能够重用其直接基类定义的构造函数。 1 2 3 4 5 class Derived : Base { public: using Base::Base; /* ... */ }; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1 Derived(parms) : Base(args) { } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:21:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"using 指示 using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1 using namespace_name name; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:22:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1 using namespace std; 应该多使用 using 声明 1 2 3 int x; std::cin \u003e\u003e x ; std::cout \u003c\u003c x \u003c\u003c std::endl; 或者 1 2 3 4 5 6 using std::cin; using std::cout; using std::endl; int x; cin \u003e\u003e x; cout \u003c\u003c x \u003c\u003c endl; :: 范围解析运算符 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:23:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int count = 11; // 全局（::）的 count class A { public: static int count; // 类 A 的 count（A::count） }; int A::count = 21; void fun() { int count = 31; // 初始化局部的 count 为 31 count = 32; // 设置局部的 count 的值为 32 } int main() { ::count = 12; // 测试 1：设置全局的 count 的值为 12 A::count = 22; // 测试 2：设置类 A 的 count 为 22 fun(); // 测试 3 return 0; } enum 枚举类型 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:24:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"限定作用域的枚举类型 1 enum class open_modes { input, output, append }; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:25:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"不限定作用域的枚举类型 1 2 enum color { red, yellow, green }; enum { floatPrec = 6, doublePrec = 10 }; decltype decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。 语法： 1 decltype ( expression ) decltype 使用 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:26:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"推导出表达式类型 1 2 int i = 4; decltype(i) a; //推导结果为int。a的类型为int。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:27:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"与using/typedef合用，用于定义类型 1 2 3 4 5 6 7 8 9 10 using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型 using ptrdiff_t = decltype((int*)0 - (int*)0); using nullptr_t = decltype(nullptr); vector\u003cint \u003evec; typedef decltype(vec.begin()) vectype; for (vectype i = vec.begin; i != vec.end(); i++) { //... } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:28:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"重用匿名类型 1 2 3 4 5 struct { int d ; doubel b; }anon_s; 而借助decltype，我们可以重新使用这个匿名的结构体： 1 decltype(anon_s) as ;//定义了一个上面匿名的结构体 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:29:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"泛型编程中结合auto，用于追踪函数的返回值类型 这也是decltype最大的用途 1 2 3 4 5 template \u003ctypename _Tx, typename _Ty\u003e auto multiply(_Tx x, _Ty y)-\u003edecltype(x*y) { return x*y; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 尾置返回允许我们在参数列表之后声明返回类型 template \u003ctypename It\u003e auto fcn(It beg, It end) -\u003e decltype(*beg) { // 处理序列 return *beg; // 返回序列中一个元素的引用 } // 为了使用模板参数成员，必须用 typename template \u003ctypename It\u003e auto fcn2(It beg, It end) -\u003e typename remove_reference\u003cdecltype(*beg)\u003e::type { // 处理序列 return *beg; // 返回序列中一个元素的拷贝 } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:30:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"decltype推导四规则 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T\u0026\u0026 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T\u0026。 否则，假设e的类型是T，则decltype（e）为T。 标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如： 1 int arr[4] 则arr为一个标记符表达式，而arr[3]+0不是。 我们来看下面这段代码： 1 2 3 int i=10; decltype(i) a; //a推导为int decltype((i))b=i;//b推导为int\u0026，必须为其初始化，否则编译错误 仅仅为i加上了()，就导致类型推导结果的差异。这是因为，i是一个标记符表达式，根据推导规则1，类型被推导为int。而(i)为一个左值表达式，所以类型被推导为int\u0026。 通过下面这段代码可以对推导四个规则作进一步了解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int i = 4; int arr[5] = { 0 }; int *ptr = arr; struct S{ double d; }s ; void Overloaded(int); void Overloaded(char);//重载的函数 int \u0026\u0026 RvalRef(); const bool Func(int); //规则一：推导为其类型 decltype (arr) var1; //int 标记符表达式 decltype (ptr) var2;//int * 标记符表达式 decltype(s.d) var3;//doubel 成员访问表达式 //decltype(Overloaded) var4;//重载函数。编译错误。 //规则二：将亡值。推导为类型的右值引用。 decltype (RvalRef()) var5 = 1; //规则三：左值，推导为类型的引用。 decltype ((i))var6 = i; //int\u0026 decltype (true ? i : i) var7 = i; //int\u0026 条件表达式返回左值。 decltype (++i) var8 = i; //int\u0026 ++i返回i的左值。 decltype(arr[5]) var9 = i;//int\u0026. []操作返回左值 decltype(*ptr)var10 = i;//int\u0026 *操作返回左值 decltype(\"hello\")var11 = \"hello\"; //const char(\u0026)[9] 字符串字面常量为左值，且为const左值。 //规则四：以上都不是，则推导为本类型 decltype(1) var12;//const int decltype(Func(1)) var13=true;//const bool decltype(i++) var14 = i;//int i++返回右值 这里需要提示的是，字符串字面值常量是个左值，且是const左值，而非字符串字面值常量则是个右值。 这么多规则，对于我们写代码的来说难免太难记了，特别是规则三。我们可以利用C++11标准库中添加的模板类is_lvalue_reference来判断表达式是否为左值： 1 cout \u003c\u003c is_lvalue_reference\u003cdecltype(++i)\u003e::value \u003c\u003c endl; 结果1表示为左值，结果为0为非右值。 同样的，也有is_rvalue_reference这样的模板类来判断decltype推断结果是否为右值。 引用 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:31:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"左值引用 常规引用，一般表示对象的身份。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:32:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"右值引用 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:33:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"引用折叠 X\u0026 \u0026、X\u0026 \u0026\u0026、X\u0026\u0026 \u0026 可折叠成 X\u0026 X\u0026\u0026 \u0026\u0026 可折叠成 X\u0026\u0026 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表 好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 initializer_list 列表初始化 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cinitializer_list\u003e template \u003cclass T\u003e struct S { std::vector\u003cT\u003e v; S(std::initializer_list\u003cT\u003e l) : v(l) { std::cout \u003c\u003c \"constructed with a \" \u003c\u003c l.size() \u003c\u003c \"-element list\\n\"; } void append(std::initializer_list\u003cT\u003e l) { v.insert(v.end(), l.begin(), l.end()); } std::pair\u003cconst T*, std::size_t\u003e c_arr() const { return {\u0026v[0], v.size()}; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list } }; template \u003ctypename T\u003e void templated_fn(T) {} int main() { S\u003cint\u003e s = {1, 2, 3, 4, 5}; // 复制初始化 s.append({6, 7, 8}); // 函数调用中的列表初始化 std::cout \u003c\u003c \"The vector size is now \" \u003c\u003c s.c_arr().second \u003c\u003c \" ints:\\n\"; for (auto n : s.v) std::cout \u003c\u003c n \u003c\u003c ' '; std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"Range-for over brace-init-list: \\n\"; for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作 std::cout \u003c\u003c x \u003c\u003c ' '; std::cout \u003c\u003c '\\n'; auto al = {10, 11, 12}; // auto 的特殊规则 std::cout \u003c\u003c \"The list bound to auto has size() = \" \u003c\u003c al.size() \u003c\u003c '\\n'; // templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式， // 它无类型，故 T 无法推导 templated_fn\u003cstd::initializer_list\u003cint\u003e\u003e({1, 2, 3}); // OK templated_fn\u003cstd::vector\u003cint\u003e\u003e({1, 2, 3}); // 也 OK } 面向对象 面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。 public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问 继承 基类（父类）——\u003e 派生类（子类） 多态 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。 多态是以封装和继承为基础的。 C++ 多态分类及实现： 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 子类型多态（Subtype Polymorphism，运行期）：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换 The Four Polymorphisms in C++ ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:34:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态多态（编译期/早绑定） 函数重载 1 2 3 4 5 6 class A { public: void do(int a); void do(int a, int b); }; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:35:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"动态多态（运行期期/晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Shape // 形状类 { public: virtual double calcArea() { ... } virtual ~Shape(); }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; class Rect : public Shape // 矩形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-\u003ecalcArea(); // 调用圆形类里面的方法 shape2-\u003ecalcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0; } 虚析构函数 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Shape { public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数 }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); shape1-\u003ecalcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0； } 纯虚函数 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1 virtual int A() = 0; 虚函数、纯虚函数 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚基类是虚继承中的基类，具体见下文虚继承。 CSDN . C++ 中的虚函数、纯虚函数区别和联系 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 C++中的虚指针与虚函数表 虚继承 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:36:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:37:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"malloc、free 用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 1 2 char *str = (char*) malloc(100); assert(str != nullptr); 释放内存后指针置空 1 2 free(p); p = nullptr; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:38:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"new、delete new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 1 2 3 4 5 6 int main() { T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0; } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:39:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"定位 new 定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。 1 2 3 4 new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] { braced initializer list } place_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？ Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？ 如何定义一个只能在堆上（栈上）生成对象的类? ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:40:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"只能在堆上 方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:41:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"只能在栈上 方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:42:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 标准库（STL）中 头文件：#include \u003cmemory\u003e ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:43:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 98 1 std::auto_ptr\u003cstd::string\u003e ps (new std::string(str))； ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:44:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"shared_ptr 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符 MSDN . 强制转换运算符 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:5","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -\u003e int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:46:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:47:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:48:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:49:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 1 2 3 4 5 6 try { Circle\u0026 ref_circle = dynamic_cast\u003cCircle\u0026\u003e(ref_shape); } catch (bad_cast b) { cout \u003c\u003c \"Caught: \" \u003c\u003c b.what(); } 运行时类型信息 (RTTI) ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:50:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"dynamic_cast 用于多态类型的转换 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:51:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:52:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u003ciostream\u003e using namespace std; class Flyable // 能飞的 { public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落 }; class Bird : public Flyable // 鸟 { public: void foraging() {...} // 觅食 virtual void takeoff() {...} virtual void land() {...} virtual ~Bird(){} }; class Plane : public Flyable // 飞机 { public: void carry() {...} // 运输 virtual void takeoff() {...} virtual void land() {...} }; class type_info { public: const char* name() const; bool operator == (const type_info \u0026 rhs) const; bool operator != (const type_info \u0026 rhs) const; int before(const type_info \u0026 rhs) const; virtual ~type_info(); private: ... }; void doSomething(Flyable *obj) // 做些事情 { obj-\u003etakeoff(); cout \u003c\u003c typeid(*obj).name() \u003c\u003c endl; // 输出传入对象类型（\"class Bird\" or \"class Plane\"） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 { Bird *bird = dynamic_cast\u003cBird *\u003e(obj); // 对象转化 bird-\u003eforaging(); } obj-\u003eland(); } int main(){ Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0; } 参考资料 C++：默认成员函数和this指针 C++类和对象的总结，拿去做笔记吧 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:53:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"Effective Cplus 摘要笔记","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 让自己习惯C++ 构造/析构/赋值运算 资源管理 设计与声明 实现 继承与面向对象设计 模板与泛型编程 定制new和delete 杂项讨论 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:0:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"让自己习惯C++ 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。 尽量以const，enums，inline替换#define 对于单纯常量，最好以const对象或enums替换#defines； 对于形似函数的宏（macros），最好改用inline函数替换#defines。 尽可能使用const 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体； 编译器强制实施bitwise constness，当你编写程序时应该使用“概念上的常量性”（conceptual constness） 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。 确定对象被使用前已先被初始化 为内置性对象进行手工初始化，因为C++不保证初始化它们； 构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同； 为免除“跨编译单元值初始化次序”问题，轻易local static对象替换non-local static对象。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:1:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"构造/析构/赋值运算 了解C++默默编写并调用哪些函数 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。 若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予以实现。 为多态基类声明virtual析构函数 polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数； Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。 别让异常逃离析构函数 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，然后吐下它们（不传播）或结束程序； 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。 绝不在构造和析构过程中调用virtual函数 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。 令operator=返回一个reference to *this 令赋值（assignment）操作符返回一个reference to *this。 在operator=中处理“自我赋值” 确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源图像”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap； 确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，其行为仍然正确。 复制对象时勿忘其每一个成分 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”； 不要尝试以某个copying函数实现另一个copying函数。应该讲共同机能放进第三个函数中，并由两个copying函数共同调用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:2:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"资源管理 以对象管理资源 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源； 两个常常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它（被复制物）指向null。 在资源管理类中小心copying行为 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为； 普遍而常见的RAII class copying行为是：抑制copying、施行引入计数法（reference counting）。不过其他行为也都可能被实现。 在资源管理类中提供对原始资源的访问 APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法； 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。 成对使用new和delete时要采取相同的形式 如果你在new表达式中使用[]，必须在相应的delete表达式中也是用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 以独立语句将newed对象置入智能指针 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:3:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"设计与声明 让接口容易被正确使用，不容易被误用 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质； “阻止误用”的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理任务； tr1::shared_ptr支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexes）等等。 设计class犹如设计type Class的设计就是type的设计。在定义一个新type之前，请确定考虑新type对象的创建和销毁、对象的初始化和赋值、合法值、继承关系等。 宁以pass-by-reference-to-const替换pass-by-value 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题； 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。 必须返回对象时，别妄想返回其reference 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。 将成员变量声明为private 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分的实现弹性； protected并不比public更具封装性。 宁以non-member、non-friend替换member函数 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性（packaging flexibility）和机能扩充性。 若所有参数皆需类型转换，请以此采用non-member函数 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。 考虑写出一个不抛出异常的swap函数 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常； 如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请特化std::swap； 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”； 为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:4:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"实现 尽可能延后变量定义式的出现时间 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 尽量少做转型动作 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计； 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内； 宁可使用C++ style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。 避免返回handles指向对象内部成分 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。 为“异常安全”而努力是值得的 异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型； “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义； 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。 透彻了解inlining的里里外外 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化； 不要只因为function templates出现在头文件，就将它们声明为inline。 将文件间的编译依存关系降至最低 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes； 程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及templates都适用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:5:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"继承与面向对象设计 确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。 避免遮蔽继承而来的名称 derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此； 为了让被遮掩的名称再见天日，可使用using声明式或转交函数（forwarding functions)。 区分接口继承和实现继承 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口； pure virtual函数只具体指定接口继承； 简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承； non-virtual函数具体指定接口继承以及强制性实现继承。 考虑virtual函数以外的其他选择 virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式； 将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员； tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式（target signature）兼容”的所有可调用物（callable entities）。 绝不重定义继承而来的non-virtual函数 绝不要重新定义继承而来的non-virtual函数。 绝不重新定义继承而来的缺省参数值 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。 通过复合塑模出has-a或“根据某物出现” 复合（composition）的意义和public继承完全不同； 在应用域（application domain），复合意味has-a（有一个）。在实现域（implementation domain），复合意味着is-implemented-in-terms-of（根据某物实现出）。 明智而审慎地使用private继承 Private继承意味着is-implement-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的； 和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序开发者而言，可能很重要。 明智而审慎地使用多重继承 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要； virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况； 多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:6:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"模板与泛型编程 了解隐式接口和编译器多态 classes和template都支持接口（interfaces）和多态（polymorphism）； 对classes而言接口是显示的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期； 对templates参数而言，接口是隐式的（implicit），奠基与有效表达式。对态则是通过template具现化和函数重载解析（function overloading resolution）发生于编译期。 了解typename的双重意义 声明template参数时，前缀关键字class和typename可互换； 请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。 学习处理模板化基类内的名称 可在derived class templates内通过“this-\u003e”指涉base class templates内的成员名称，或籍由一个明白写出的“base class资格修饰符”完成。 将与参数无关的代码抽离 Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系； 因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数； 因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示（binary representations）的具现类型（instantiation types）共享实现码。 运用成员函数模板接受所有兼容类型 请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数； 如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。 需要类型转换时请为模板定义非成员函数 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。 请使用traits classes表现类型信息 Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现； 整个重载技术（overloading）后，traits classes有可能在编译期对类型执行if…else测试。 认识template元编程 Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率； TMP可被用来生成“基于政策选择组合”（based on combinations of pilicy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:7:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"定制new和delete 了解new-handler的行为 set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用； Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。 了解new和delete的合理替换时机 有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。 编写new和delete时需固守常规 operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的（错误）申请； operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请。 写了placement new也要写placement delete 当你写一个placement operator new，请确定它也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄露； 当声明placement new和placement delete，请确定不要无意识（非故意）地遮盖了它们的正常版本。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:8:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"杂项讨论 不要请勿编译器的警告 严肃对待编译器发生的警告信息。努力在你的编译器的最高（最苛刻）警告级别下争取“无任何警告”的荣誉； 不要过度依赖编译器的报警功能，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 让自己熟悉包括TR1在内的标准程序库 C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库； TR1添加了只能指针（如tr1::shared_ptr）、一般化函数指针（tr1::function）、hash-based容器、正则表达式（regular expression）以及另外10个组件的支持； TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是Boost。 让自己熟悉Boost Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演具有影响力的角色； Boost提供许多TR1组件实现品，以及其他许多程序库。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:9:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"Effective Modern Cplus 摘要笔记","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 类型推导 auto 移步现代C++ 智能指针 右值引用，移动语意，完美转发 Lambda表达式 并发API 微调 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:0:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"类型推导 理解模板类型推导 理解auto类型推导 理解decltype 学会查看类型推导结果 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:1:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"auto 优先考虑auto而非显式类型声明 auto推导若非己愿，使用显式类型初始化惯用法 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:2:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"移步现代C++ 区别使用()和{}创建对象 优先考虑nullptr而非0和NULL 优先考虑别名声明而非typedefs 优先考虑限域枚举而非未限域枚举 优先考虑使用delete而非使用未定义的私有声明 使用override声明重载函数 优先考虑const_iterator而非iterator 如果函数不抛出异常请使用noexcept 尽可能的使用constexpr 确保const成员函数线程安全 理解特殊成员函数函数的生成 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:3:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"智能指针 对于占有性资源使用std::unique_ptr 对于共享性资源使用std::shared_ptr 对于类似于std::shared_ptr的指针使用std::weak_ptr可能造成悬置 优先考虑使用std::make_unique和std::make_shared而非new 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:4:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"右值引用，移动语意，完美转发 理解std::move和std::forward 区别通用引用和右值引用 对于右值引用使用std::move，对于通用引用使用std::forward 避免重载通用引用 熟悉重载通用引用的替代品 理解引用折叠 认识移动操作的缺点 熟悉完美转发失败的情况 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:5:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"Lambda表达式 避免使用默认捕获模式 使用初始化捕获来移动对象到闭包中 对于std::forward的auto\u0026\u0026形参使用decltype 有限考虑lambda表达式而非std::bind ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:6:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"并发API 优先考虑基于任务的编程而非基于线程的编程 如果有异步的必要请指定std::launch::threads 从各个方面使得std::threads unjoinable 知道不同线程句柄析构行为 考虑对于单次事件通信使用void 对于并发使用std::atomic，volatile用于特殊内存区 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:7:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"微调 对于那些可移动总是被拷贝的形参使用传值方式 考虑就地创建而非插入 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:8:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"More Effective Cplus","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 基础议题 运算符 异常 效率 技巧 杂项 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:0:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"基础议题 区分指针和引用 优先考虑C++风格的类型转换 决不要把多态用于数组 避免不必要的默认构造函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:1:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"运算符 小心用户自定义的转换函数 区分自增运算符和自减运算符的前缀形式与后缀形式 不要重载\"\u0026\u0026\"||“和”,\" 理解new和delete在不同情形下的含义 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:2:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"异常 使用析构函数防止资源泄漏 防止构造函数里的资源泄漏 阻止异常传递到析构函数以外 理解抛出异常与传递参数或者调用虚函数之间的不同 通过引用捕获异常 审慎地使用异常规格 理解异常处理所付出的代价 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:3:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"效率 记住80-20准则 考虑使用延迟计算 分期摊还预期的计算开销 了解临时对象的来源 协助编译器实现返回值优化 通过函数重载避免隐式类型转换 考虑使用op=来取代单独的op运算符 考虑使用其他等价的程序库 理解虚函数、多重继承、虚基类以及RTTI所带来的开销 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:4:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"技巧 使构造函数和非成员函数具有虚函数的行为 限制类对象的个数 要求或禁止对象分配在堆上 智能(smart)指针 引用计数 代理类 基于多个对象的虚函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:5:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"杂项 在将来时态下开发程序 将非尾端类设计为抽象类 理解如何在同一程序中混合使用C 让自己熟悉C++语言标准 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:6:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 拷贝构造函数 拷贝构造函数的调用时机 1. 当函数的参数为类的对象:以值传递的方式传入函数体 2. 函数的返回值是类的对象:以值传递的方式从函数返回 3. 对象需要通过另外一个对象进行初始化 : 赋值初始化 浅拷贝与深拷贝 1. 默认拷贝构造函数 拷贝赋值函数 copy constructor与copy assignment的区别与联系 拷贝构造函数 拷贝构造函数(复制构造函数)是构造函数的一种，它只有一个参数，参数类型是本类的引用。它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。 复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。 如果类的设计者不写复制构造函数，编译器就会自动生成复制构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。 默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: //构造函数 CExample(int b) { a=b; printf(\"constructor is called\\n\"); } //拷贝构造函数 CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } //析构函数 ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; int main() { CExample A(100); CExample B=A; B.Show(); return 0; } 执行结果： constructor is called copy constructor is called 100 destructor is called destructor is called 拷贝构造函数的调用时机 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:0:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"1. 当函数的参数为类的对象:以值传递的方式传入函数体 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: CExample(int b) { a=b; printf(\"constructor is called\\n\"); } CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; void g_fun(CExample c) { cout\u003c\u003c\"g_func\"\u003c\u003cendl; } int main() { CExample A(100); CExample B=A; B.Show(); g_fun(A); return 0; } 执行结果： constructor is called copy constructor is called 100 copy constructor is called g_func destructor is called destructor is called destructor is called 调用g_fun()时，会产生以下几个重要步骤： A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。 然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A); 等g_fun()执行完后, 析构掉 C 对象。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:1:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"2. 函数的返回值是类的对象:以值传递的方式从函数返回 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: //构造函数 CExample(int b) { a=b; printf(\"constructor is called\\n\"); } //拷贝构造函数 CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } //析构函数 ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; CExample g_fun() { CExample temp(0); return temp; } int main() { CExample example = g_fun(); example.Show(); return 0; } 运行结果： constructor is called copy constructor is called destructor is called copy constructor is called destructor is called 10 destructor is called 当g_Fun()函数执行到return时，会产生以下几个重要步骤： 先会产生一个临时变量，就叫XXXX吧。 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp); 在函数执行到最后先析构temp局部变量。 等g_fun()执行完后再析构掉XXXX对象。 说明，由于g++ 编译是会进行优化，这里需要使用 ： g++ -fno-elide-constructors xx 进行编译 C++返回值为对象时复制构造函数不执行怎么破 命名返回值优化 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:2:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"3. 对象需要通过另外一个对象进行初始化 : 赋值初始化 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。 1 2 3 CExample A(100); CExample B=A; CExample C(A); 注意：赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。 1 2 CExample c1, c2; c1 = c2 ; c1=c2; 这条语句不会引发复制构造函数的调用，因为 c1 早已生成，已经初始化过了。 浅拷贝与深拷贝 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:3:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"1. 默认拷贝构造函数 很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式： 1 2 3 4 5 Rect::Rect(const Rect\u0026 r) { width=r.width; height=r.height; } 当然，以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了。 c++拷贝构造函数详解 C++拷贝构造函数（复制构造函数）详解 拷贝赋值函数 1 A\u0026 operator= (const A\u0026 a); //赋值构造函数 返回值的对象为引用是为了可以连续赋值 赋值函数中可以既可以使用引用也可以使用值传递，不过值传递会多生成一个对象，造成资源的浪费 1.对象以值传递方式从函数返回，且接受返回值的对象已经初始化过 1 2 A c; c = f(); 2.对象直接赋值给另一个对象，且接受值的对象已经初始化过 1 2 3 A a(1); A c; c = a; copy constructor与copy assignment的区别与联系 copy constructor： 从一个已有的对象来构造另一个对象； 包括： 用已有对象来初始化新声明的对象； 将对象按值传递给函数作为参数； 函数按值返回对象。 copy assignment： 将已有的对象赋值个另一个已有的对象； 实例： 1 2 3 4 5 6 7 8 9 10 11 Person A(B); // copy constructor Person C=B; //copy constructor Function1(D); //copy constructor B= Function2(…); //copy constructor Person D; D=B; //copy assignment 注意事项：编译器默认的copy constructor和copy assignment操作，是按照member-wise copy的方式逐个copy每个member，这种浅拷贝操作在有些情况下可能造成资源泄漏/指向重叠。 如果的确需要deep copy，需要自定义相应操作。这时需要清楚哪些地方用了copy constructor，哪些地方用了copy assignment，从而分别自定义copy constructor和copy assignment。一般来说，自定义的copy constructor、destructor和copy assignment操作常常同时出现。 区别与联系： copy constructor不用检测是否是用一个对象来初始化它自己； copy constructor不用对被构造对象做资源清理操作，如delete操作； ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:4:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 最近遇到一个问题，time_t（__int64）类型与float类型直接相加得到的结果是错误的： 1 2 3 time_t curTime = 1563924292; float timeOffset = 3.56951; time_t result = curTime + timeOffset; //结果为1563924352，计算错误 错误原因涉及算术运算中的隐式转换规则，遂查阅资料整理了相关知识。 c++隐式转换分为以下类型： 算数转换：在混合类型的算数表达式中，最宽的数据类型成为目标转换类型。 1 2 3 time_t curTime = 1563924292; float timeOffset = 3.56951; curTime + timeOffset; //time_t(__int64)类型隐式转换为float类型 这就造成一个问题：float 精度最高为7位，运算结果中最后三位已经超出精度范围。所以即使再转换为time_t类型，计算结果后三位也会出问题。解决方法为对float显式转换为int或time_t类型。 1 curTime + (int)timeOffset; 赋值转换：将一种类型赋值给另一种类型，将会转换成被赋值类型。 1 2 float a(5.6); int b = a; //a转换为int类型 函数形参实参不一致转换：传给函数的实参与函数形参类型不一致，将会把实参转换为形参的类型。 1 2 3 double Function(double a); int b(5); double c = Function(b); //此处b转换为double类型计算 函数返回值与返回类型不一致：返回值转换为返回类型。 1 2 3 4 double difference(int ival1, int ival2) { return ival1 - ival2; //返回值转换为double类型 } 构造函数隐式转换 按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象，如下面所示： 1 2 3 4 5 class String { String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } String s1 = “hello”; //OK 隐式转换，等价于String s1 = String（“hello”） 但是有的时候可能会不需要这种隐式转换，如下： 1 2 3 4 5 class String { String ( int n ); //本意是预先分配n个字节给字符串 String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } 下面两种写法比较正常： 1 2 String s2 ( 10 ); //OK 分配10个字节的空字符串 String s3 = String ( 10 ); //OK 分配10个字节的空字符串 下面两种写法就比较疑惑了： 1 2 String s4 = 10; //编译通过，也是分配10个字节的空字符串 String s5 = ‘a’; //编译通过，分配int（‘a’）个字节的空字符串 s4 和s5 分别把一个int型和char型，隐式转换成了分配若干字节的空字符串，容易令人误解。 为了避免这种错误的发生，我们可以声明显示的转换，使用 explicit 关键字： 1 2 3 4 5 class String { explicit String ( int n ); //本意是预先分配n个字节给字符串 String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } 加上 explicit ，就抑制了String ( int n )的隐式转换， 下面两种写法仍然正确： 1 2 String s2 ( 10 ); //OK 分配10个字节的空字符串 String s3 = String ( 10 ); //OK 分配10个字节的空字符串 下面两种写法就不允许了： 1 2 String s4 = 10; //编译不通过，不允许隐式的转换 String s5 = ‘a’; //编译不通过，不允许隐式的转换 因此，某些时候， explicit 可以有效得防止构造函数的隐式转换带来的错误或者误解。 ","date":"2023-01-22","objectID":"/posts/program/cpp/c++%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/:0:0","tags":["cpp"],"title":"c++:隐式转换问题","uri":"/posts/program/cpp/c++%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"},{"categories":["cpp"],"content":"右值引用移动构造完美转发及返回值优化","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++的左值与右值 通用引用和右值引用 右值引用 区分右值引用和左值引用 移动构造函数和移动赋值运算符 移动构造函数 移动构造函数的任务 移动操作和异常安全 移动操作和函数匹配 移动赋值运算符 何时该定义移动构造/赋值 the rule of zero the rule of five std::move 和 std::forward std::move 为什么要使用 std::move？ 使用 std::move 并不代表移动操作一定会发生 std::forward 和完美转发 std::forward 的实现 怎么判断该用 move 还是 forward？ 什么时候用 move 和 forward？ 名字查找和 move、forward 移动和返回值优化 RVO NRVO 移动和 NRVO C++的左值与右值 在 C 语言中，左值和右值即字面意思，左值是表达式左边的值，而右值是表达式右边的值。而 C++ 为了支撑移动语义，对值的类型做了新的划分。 区分左值和右值 C++ 中值有两个独立的属性： 有身份（has identity） 或者说，有地址，有指向它的指针 有身份的值统称为 glvalue （“generalized” lvalue） 可以被移动（can be moved from） 可以移动的值统称为 rvalue glvalue 和 rvalue 就是我们一般说的左值和右值。 根据是否有这两种属性，我们可以对 C++ 中的值做如下划分（i 表示有身份，m 表示可以被移动，大写字母表示没有这种属性，第四种类型 IM 在 C++中没有被使用）： lvalue（ iM ） 有身份，且不能被移动 包括 变量、函数或数据成员的名字 返回左值引用的表达式，比如 ++x、x = 1 字符串字面量，如 \"hello world\" prvalue(“pure” rvalue, Im) 一般译作纯右值 没有身份，可以被移动，也就是所谓的“临时对象” 包括 返回非引用类型的表达式，比如 x++、x + 1 除字符串字面量之外的字面量，比如 42、true 有趣的是 this 指针是 prvalue，你会发现没法对 this 指针求地址 xvalue(an “eXpiring” value, im) 一般译作将亡值 有身份，且可以被移动 包括 右值引用类型的返回值，比如 std::move(x) 虽然说，C++ 对值做了很细粒度的划分，但事实上，大多数时候只需要区分一个值是左值还是右值即可，因此，这里给出一个实践上可以用来区分左右值的法则： 如果你可以对某个表达式取地址，那么它是左值 如果一个表达式的类型是左值引用（ T\u0026 或 const T\u0026 等），那么它是左值 否则，这个表达式是右值 函数的返回值（非引用类型的或右值引用类型的） 通过隐式类型转换创建的值 除字符串以外的字面量（比如 10 和 5.3） 其他的理解如：在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。 一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。 再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。 那么a+5是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。 1 2 3 4 5 6 7 8 9 10 int main(int argc, char *argv[]){ int \u0026\u0026 a = 5; // 正确，5会被直接存放在寄存器中，所以它是右值 int b = 10; int \u0026\u0026 c = b; // 错误，b在内存中有空间，所以是右值；右值不能赋值给左值 int \u0026\u0026 d = b + 5; // 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 int \u0026\u0026 e = a; // 错误，因为a是左值而e必须接收右值。 int \u0026\u0026 e = std::move(a); // 正确，通过std::move可以将一个左值转成右值。e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。 } 通用引用和右值引用 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:0:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"右值引用 伴随着新的右值定义，C++11 也引入了一种新的引用类型——右值引用，比如 int \u0026\u0026，右值引用的特点是它只能绑定到右值上，因此 C++11 中也就有了三种引用类型： 右值引用只能绑定到右值上，比如 int \u0026\u0026 非 const 的左值引用只能绑定到左值上，比如 int \u0026 const 的左值引用可以绑定到左值或右值上，比如 const int \u0026 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:1:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"区分右值引用和左值引用 04区分通用引用和右值引用 Scott Meyers的effective modern c++讲座摘要 条款24：区分通用引用和右值引用 右值引用 一定是 type\u0026\u0026 type\u0026\u0026 不一定是 右值引用（还有可能是通用引用） 1 2 3 4 5 6 7 8 9 10 11 12 13 void f(Widget\u0026\u0026 param); // 右值引用 Widget\u0026\u0026 var1 = Widget(); // 右值引用 auto\u0026\u0026 var2 = var1; // 不是右值引用！！！ decltype(var1) var3 = var1; // 无法编译通过 Widget\u0026\u0026 var4 = var1; // 无法编译通过 template\u003ctypename T\u003e void f(std::vector\u003cT\u003e\u0026\u0026 param); // 右值引用 template\u003ctypename T\u003e void f(T\u0026\u0026 param); // 不是右值引用！！！ 在这里，“type\u0026\u0026“中的”\u0026\u0026“意味着： 右值引用 绑定右值（Binds rvalues only.） 促进移动（Facilitates moves.） 通用引用 右值引用或左值引用（type\u0026\u0026 有可能是 type\u0026 或 type\u0026\u0026 ） 绑定所有值，不管是左值，右值，const, 非const... 即促进拷贝，也促进移动（May facilitate copies, may facilitate moves） 与转发引用（Forwarding Reference）相同 如何区分，简单来说: 如果一个变量或参数的声明类型是T\u0026\u0026，并且需要推导出类型T， 这就是通用引用，否则就是右值引用。 通用引用是需要初始化的，如果是左值，那就是左值引用，如果是右值，那就是右值引用。 移动构造函数和移动赋值运算符 为了支持移动语义，C++11 引用两个新的特殊成员函数，它们是移动构造函数和移动赋值运算符，想要支持移动操作的类必须定义它们。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Widget { private: int i{0}; string s{}; unique_ptr\u003cint\u003e pi{}; public: // Move constructor // 该构造函数的参数是 Widget \u0026\u0026w。\u0026\u0026它表示的是C++中的右值，也就是只有创建Widget对象时传入的是右值才会执行该构造函数。 // 需要注意的是，在移动构造函数操作之后原 Widget 对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了 Widget(Widget \u0026\u0026w) = default; // Move assignment operator Widget \u0026operator=(Widget \u0026\u0026w) = default; }; ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:2:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动构造函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动构造函数的任务 完成资源移动 资源的所有权移交给新创建的对象 确保移动操作完成后，销毁源对象是无害的 不再指向被移动的资源 确保移动操作完成后，源对象依然是有效的 可以赋予它一个新值 对留下的值没有任何要求 也就是说移动操作完成后，可以销毁移后源对象，也可以赋予它一个新值，但不能使用移后源对象的值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动操作和异常安全 移动操作一般不分配新资源，因此不会抛出异常 如果移动操作不抛异常，必须注明 noexcept 如果你的移动操作不注明 noexcept ，标准库就不敢调用你的移动构造函数，这是由于标准库的某些接口会做出异常安全的保障，比如 vector 的 push_back 接口做出的保证为： If an exception is thrown (which can be due to Allocator::allocate() or element copy/move constructor/assignment), this function has no effect (strong exception guarantee). 也就是说有异常抛出时（可能是由于内存分配或元素拷贝/移动），这个调用不产生任何效果。 push_back 可能会导致 vector 扩容，也就是说会申请一块新的内存空间，将现有的元素拷贝/移动到这块新的空间里。 如果我们的移动构造函数会抛异常，假设扩容的过程中，只有部分元素被移动到了新的空间里，这时候有异常抛出，不仅扩容操作没完成，而且原有空间里的部分元素还被已执行的移动操作破坏掉了，不符合 push_back 做出的异常保障。因此，这种情况下，vector 只会使用拷贝操作来完成扩容操作。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动操作和函数匹配 移动右值，拷贝左值 移动构造函数只能用于实参是右值的情况下，其他情况下，都会发生拷贝 但如果没有移动构造函数，则右值也被拷贝 拷贝构造函数的参数是 const 的左值引用，既能接受左值也能接受右值 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:3","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动赋值运算符 定义移动赋值运算符最简单的方法就是定义一个“拷贝并交换”的拷贝赋值运算符（如果你在疑惑该怎样自定义 swap 操作，请看 Effective C++ Item 25）： 1 2 3 4 5 ClassA\u0026 ClassA::operator=(ClassA rhs) { swap(*this, rhs); return *this; } “拷贝并交换”赋值运算符的参数不再是引用，而是传值 rhs 将是右侧运算对象的一个副本； 将 *this 与这个副本交换，也就是将右侧运算对象的值赋给了左侧运算对象； 函数返回时，rhs 被销毁，析构函数销毁 rhs 现在指向的内存，即左侧运算对象原来的内存。 “**拷贝并交换”**的优势是正确处理了自赋值而且是异常安全的。 赋值运算符的异常安全问题主要来自于拷贝时可能申请内存，如果 new 抛异常了，要确保左侧运算对象原本的数据结构还没有被破坏（显然， rhs 做拷贝的时候，左侧运算对象原有数据结构还没有做任何修改）。 如果你定义了移动构造函数，那么这个拷贝赋值运算符同时也是移动赋值运算符： 如果实参是右值，就会用移动构造函数来初始化 rhs； 相反，如果实参是左值，就会用拷贝构造函数来初始化 rhs ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:4:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"何时该定义移动构造/赋值 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"the rule of zero C.20: If you can avoid defining default operations, do 也就是说，如果默认行为够用，就不要再去定义自己的特殊成员函数。 1 2 3 4 5 6 7 8 9 10 struct Named_map { public: // ... no default operations declared ... private: string name; map\u003cint, int\u003e rep; }; Named_map nm; // default construct Named_map nm2 {nm}; // copy construct map 和 string 定义了所有的特殊成员函数，编译器生成的默认实现就已经够用了。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"the rule of five C.21: If you define or =delete any copy, move, or destructor function, define or =delete them all 如果定义拷贝、移动或析构中的任意一个，或将任意一个声明为 =delete 的；那么就需要将它们都定义出来或全部声明为 =delete 的。 实践 the rule of five 时，最简单的判断方法就是看析构函数，如果你析构函数里要做事，不管是释放资源还是关闭数据库连接，那么你就应该把析构函数的这些好兄弟都定义出来。 定义这些特殊成员时，如果你想要默认实现，就将它声明为 =default；如果你想要禁用某个特殊成员，就将它声明为 =delete（这两种情况都被编译器认为是用户定义的）。 the rule of five 背后的逻辑是这些特殊成员函数的语义是息息相关的： 规则 1：如果某个类有自定义拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了 根据函数匹配规则，这种情况下会调用拷贝操作来处理右值 规则 2：如果某个类定义了移动构造函数，没有定义拷贝构造函数，那么后者被编译器定义为删除的（对于赋值运算符也是一样的） 如果定义了这些操作中的某一个，就应该把其他的操作都定义出来，以避免所有（潜在的）可移动的场景都变成昂贵的拷贝（对应规则 1）或者使得类型变成仅能移动的（对应规则 2）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct M2 { // bad: incomplete set of copy/move/destructor operations public: // ... // ... no copy or move operations ... ~M2() { delete[] rep; } private: pair\u003cint, int\u003e* rep; // zero-terminated set of pairs }; void use() { M2 x; M2 y; // ... x = y; // the default assignment // ... } 这段代码没能遵循 the rule of five，造成的后果是 rep 被 double free。 std::move 和 std::forward 虽然这两个函数的名字很有迷惑性，但事实上，从它们所做的事情上来看：move 不移动；forward 不转发，它们只是执行了类型转换操作罢了： std::move 无条件地将实参转换为右值； std::forward 在部分条件下将实参转换为右值 熟悉 C++ 类型转换的朋友应该知道 static_cast 事实上在运行时什么也不做，因此这俩函数也并不会在运行时做什么事情。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::move c++ 之 std::move 原理实现与用法总结 一个简化的 move 实现是这样的： 1 2 3 4 5 template \u003ctypename T\u003e typename remove_reference\u003cT\u003e::type \u0026\u0026move(T \u0026\u0026param) { using ReturnType = typename remove_reference\u003cT\u003e::type \u0026\u0026; return static_cast\u003cReturnType\u003e(param); } T\u0026\u0026 是通用引用，因此这个函数几乎可以接收任何类型的参数。 通过 remove_reference 去掉 T 的引用性质（并不会去掉 cv 限定符），然后给它加上 \u0026\u0026，形成 ReturnType 类型，由于右值引用类型的返回值是右值，因此结果是实参被无条件地转换为右值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"为什么要使用 std::move？ 既然 std::move 只是无条件地做 static_cast，那为什么不直接做类型转换，而要调用 std::move 呢？ std::move 允许我们截断左值，也就是说不再使用该左值，可以自由移动它所拥有的资源；这是非常特殊的类型操作，通过使用 std::move 方便我们确定在哪里对左值做了截断，语义上更加清晰。 C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。 std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。 对指针类型的标准库对象并不需要这么做. ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"使用 std::move 并不代表移动操作一定会发生 可能这个类型根本没有定义移动操作 std::move 并不会去除实参的 const 性质，因此把 const 的对象传给它，得到的返回值类型也是 const 的，对它的操作会变为拷贝操作 因为移动操作往往会修改源对象，所以我们不希望在 const 对象上触发移动操作 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::forward 和完美转发 某些函数需要将其一个或多个实参连同类型不变地转发给其他函数，转发后需要保持被转发实参的所有性质，包括 实参是否是 const 的； 实参是左值还是右值 这种场景我们往往称之为完美转发，C++11 可以通过 std::forward 来实现。 比如工厂函数需要将初始化参数传递给构造函数。一个常见的例子就是 make_unique C++14 才支持，如果我们想自己写一个 make_unique 应该怎么写呢？ 1 2 3 4 template \u003ctypename T, typename... Ts\u003e std::unique_ptr\u003cT\u003e make_unique(Ts \u0026\u0026... params) { return std::unique_ptr\u003cT\u003e(new T(std::forward\u003cTs\u003e(params)...)); } ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:7:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::forward 的实现 1 2 3 4 5 6 7 8 9 template\u003c class T \u003e T\u0026\u0026 forward( typename std::remove_reference\u003cT\u003e::type\u0026 t ) noexcept { return static_cast\u003cT\u0026\u0026\u003e(param); } template\u003c class T \u003e T\u0026\u0026 forward( typename std::remove_reference\u003cT\u003e::type\u0026\u0026 t ) noexcept { return static_cast\u003cT\u0026\u0026\u003e(param); } std::forward 的模板参数是没法推导的，称为无法推导的上下文（nondeduced context）。 理解这个实现的重点在于它的返回值类型是 T\u0026\u0026，我们看一个例子： 1 2 3 4 5 6 7 8 9 void g(int \u0026\u0026i, int\u0026 j); template \u003ctypename F, typename T1, typename T2\u003e void flip3(F f, T1 \u0026\u0026t1, T2 \u0026\u0026t2) { f(std::forward\u003cT2\u003e(t2), std::forward\u003cT1\u003e(t1)); } flip3(g, i, 42); flip3 接受一个可调用对象，以及两个额外实参，将参数逆序传递给可调用对象。 如果实参是 int 变量 i T1 的类型为 int\u0026，std::forward 的返回类型为 int\u0026 \u0026\u0026，根据引用折叠，结果是 int\u0026 t1 的类型为 int\u0026 参数的类型和返回值的类型相同，所以转换不会做任何事 而如果实参是 42 T2 的类型为 int，std::forward 的返回类型是 int \u0026\u0026 t2 的类型为 int \u0026\u0026 从函数返回的右值引用是右值，所以 t2 会被转换为右值 就此，我们也理解了为什么说 forward 是有条件地将实参转换为右值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:7:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"怎么判断该用 move 还是 forward？ 对右值引用 move 右值引用只能绑定到右值上，所以可以无条件地将它转换为右值 对通用引用 forward 通用引用既能绑定到左值上，也能绑定到右值上，在后一种情况下，我们希望能将它转换为右值 在右值引用上调用 std::forward 表现出的行为是正确的，但由于 std::forward 没法自动做类型推导，写出来的代码会比较繁琐；但如果在通用引用上调用 std::move，可能会导致左值被错误地修改，导致异常的行为。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:8:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"什么时候用 move 和 forward？ 你可能需要在函数中多次使用某个右值引用或通用引用，那么只有在最后一次使用它的时候，才可以对它调 std::move 或 std::forward，因为将它转为右值后，它的内容就不能再被使用了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sink(X\u0026\u0026 x); // sink takes ownership of x void user() { X x; // error: cannot bind an lvalue to a rvalue reference sink(x); // OK: sink takes the contents of x, x must now be assumed to be empty sink(std::move(x)); // ... // probably a mistake use(x); } ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:9:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"名字查找和 move、forward std::move 和 std::forward 的形参都是通用引用，它们几乎可以匹配任何类型的参数。 因此如果我们定义了自己的 move 或 forward 函数，如果它接受单一形参，不管类型如何，都将与标准库的版本冲突。 同时，move 和 forward 执行的是非常特殊的类型操作，用户特意去修改函数原有行为的概率非常小，因此最好使用带限定语的版本 std::move 和 std::forward 来明确指出使用标准库的版本。 移动和返回值优化 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:10:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"RVO 如果 return 语句的操作数是 prvalue ，且它和返回值的类型相同。 1 2 3 4 5 T f() { return T(); } f(); // only one call to default constructor of T 此时，编译器可以实施 copy elision（拷贝省略、拷贝消除），将对象直接构造到调用者的栈上去。 return 语句所在的地方，T 的析构函数必须是可访问的且没有被删除，尽管此处并没有 T 对象被析构掉。 C++17 强制编译器做 RVO，RVO 不再是一项可选的编译器优化，而是 C++ 对 prvalue 的新规定，即返回和使用 prvalue 时不再去实体化一个临时对象 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:11:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"NRVO 1 2 3 4 5 6 X bar() { X xx; // process xx ... return xx; } 对于上面的函数 bar，如果直接用参数 __result 代替命名的返回值 xx，即改写为： 1 2 3 4 5 6 7 8 9 10 11 void bar( X \u0026__result ) { // default constructor invocation // Pseudo C++ Code __result.X::X(); // ... process in __result directly return; } 也就是说返回值会被直接构造在调用者的栈上，少了一次拷贝操作，这种优化被称为 Named Return Value Optimization（NRVO）。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:12:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动和 NRVO C++11 开始，NRVO 仍可以发生，但在没有 NRVO 的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。 这一移动行为不需要程序员手工用 std::move 进行干预，使用 std::move 对于移动行为没有帮助，反而会影响返回值优化，因为这种情况下，你返回的并不是局部对象，而是局部对象的引用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:13:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["芯片架构"],"content":"ARMv7-A ARMv8-A  ARMv9-A 架构 介绍","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ARMv7-A 构架 Cortex-A17 Cortex-A15 Cortex-A9 Cortex-A8 Cortex-A7 Cortex-A5 ARMv8-A构架 Cortex-A32 Cortex-A35 Cortex-A53 Cortex-A57 Cortex-A72 Cortex-A73 Cortex-A78 Cortex-A77 Cortex-A76 ARMv9-A 构架 特性 ARM V8 ARM V7 指令集 64位指令集 AArch64， 并且兼容32位指令集 AArch32 32位指令集 A32 和16位指令集 T16 支持地址长度 64位 32位 通用寄存器 31个 x0-x30（64位）或者 w0-w30（32位） 15个, r0-r14 (32位) 异常模式 4层结构 EL0-EL3 2层结构vector table NEON 默认支持 可选支持 LAPE 默认支持 可选支持 Virtualization 默认支持 可选支持 big.LITTLE 支持 支持 TrustZone 默认支持 默认支持 SIMD寄存器 32个 X 128位 32个 X 64位 ARMv7-A 构架 The Armv7-A architecture introduces the concept of architecture profiles, a concept that continues in Armv8-A and Armv9-A. The Armv7-A architecture: Implements a traditional Arm architecture with multiple modes Supports a Virtual Memory System Architecture (VMSA) based on a Memory Management Unit (MMU) Supports the Arm (A32) and Thumb (T32) instruction sets This architecture also supports multiple extensions: Security Extensions Multiprocessing Extensions Large Physical Address Extension Virtualization Extensions Generic Timer Extension Performance Monitors Extension All of these extensions are optional and most of the functionality they provide is included in the Armv8-A architecture. ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:0:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A17 A17仍然基于32位ARMv7-A指令集，初期会采用28nm工艺，后期进化到20nm。本质架构和A12一样都是双宽度、乱序发射，仅仅是改进了外部互联，引入了新的一致性总线AMBA4 ACE，可以更快速地连接内存控制器，从而改善性能和能效。得益于这个新的总线，A17可以支持多核心SoC的完整内存一致性操作，能够参与big.LITTLE双架构混合方案，在特定频率、工艺、内存条件下，A17的性能比A12提升大约40%。在某些特定的环境中，A17的性能已经可以和A15处于一个档次了，但是功耗更低、能效更高。虽然在命名上排在Cortex-A15之上，但其定位中端，而不是高端。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:1:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A15 Cortex-A15最早在2010年发布，基于32位ARMv7-A架构。A15和A9同样具备乱序执行，但是Cortex-A15具备（两倍）的指令发射端口和执行资源，指令解码能力也要高出50%，动态分支预测能力更强（采用了多层级分支表缓存），指令拾取带宽更强（128 bit vs 64 bit），这些都能让A15的流水线执行具备更高的效率。除此以外，A15采用了VFPv4浮点单元设计，能执行FMA指令以及硬件除法指令，相较而言A9的峰值向量浮点性能基本上只有A15的一半。Cortex-A15处理器可以应用在智能手机、平板电脑、移动计算、高端数字家电、服务器和无线基础结构等设备上。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:2:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A9 ARM Cortex-A9采用ARMv7-A架构，目前我们能见到的四核处理器大多都是属于Cortex-A9系列。 Cortex-A9 处理器的设计旨在打造最先进的、高效率的、长度动态可变的、多指令执行超标量体系结构，提供采用乱序猜测方式执行的 8 阶段管道处理器，凭借范围广泛的消费类、网络、企业和移动应用中的前沿产品所需的功能，它可以兼具高性能和高能效。Cortex-A9 微体系结构既可用于可伸缩的多核处理器（Cortex-A9 MPCore多核处理器），也可用于更传统的处理器（Cortex-A9单核处理器）。可伸缩的多核处理器和单核处理器支持 16、32 或 64KB 4 路关联的 L1 高速缓存配置，对于可选的 L2 高速缓存控制器，最多支持 8MB 的 L2 高速缓存配置，它们具有极高的灵活性，均适用于特定应用领域和市场。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:3:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A8 ARM Cortex-A8处理器，基于ARMv7-A架构，是目前使用的单核手机中最为常见的产品。Cortex-A8处理器是首款基于ARMv7体系结构的产品，能够将速度从600MHz提高到1GHz以上。Cortex-A8处理器可以满足需要在300mW以下运行的移动设备的功率优化要求；以及需要2000 Dhrystone MIPS的消费类应用领域的性能优化要求。Cortex-A8 高性能处理器目前已经非常成熟，从手机到上网本、DTV、打印机和汽车信息娱乐，Cortex-A8处理器都提供了可靠的高性能解决方案。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:4:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A7 Cortex-A7采用ARMv7-A架构，它的特点是在保证性能的基础上提供了出色的低功耗表现。Cortex-A7处理器的体系结构和功能集与Cortex-A15 处理器完全相同，不同这处在于，Cortex-A7 处理器的微体系结构侧重于提供最佳能效，因此这两种处理器可在big.LITTLE（大小核大小核心伴侣结构）配置中协同工作，从而提供高性能与超低功耗的终极组合。单个Cortex-A7处理器的能源效率是Cortex-A8处理器的5倍，性能提升50%，而尺寸仅为后者的五分之一。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:5:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A5 Cortex-A5处理器同样基于ARMv7-A架构，它是能效最高、成本最低的处理器，能够向最广泛的设备提供最基础的 Internet 访问。Cortex-A5 处理器在指令以及功能方面与更高性能的 Cortex-A8、Cortex-A9 和 Cortex-A15 处理器完全兼容 - 一直到操作系统级别。Cortex-A5 处理器还保持与经典 ARM 处理器（包括 ARM926EJ-S、ARM1176JZ-S 和 ARM7TDMI?）的向后应用程序兼容性。其定位于从入门级智能手机、低成本手机和智能移动设备以及基础工业设备。 ARMv8-A构架 ARMv8-A是ARM公司的首款支持64位指令集的处理器架构，包括ARM TrustZone技术、NEON、虚拟化和加密技术。 The Armv8-A architecture introduces the ability to use 64-bit and 32-bit Execution states, known as AArch64 and AArch32 respectively. The AArch64 Execution state supports the A64 instruction set. It holds addresses in 64-bit registers and allows instructions in the base instruction set to use 64-bit registers for their processing. The AArch32 Execution state is a 32-bit Execution state that preserves backwards compatibility with the Armv7-A architecture, enhancing that profile so that it can support some features included in the AArch64 state. It supports the T32 and A32 instruction sets. Armv8-A architecture allows different levels of AArch64 and AArch32 support, for example: AArch64 only designs AArch64 designs that also support AArch32 operating systems and virtual machines AArch64 support with AArch32 at (unprivileged) application level only ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:6:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A32 这是ARM 新一代构架中，唯一一个 32 位（ARMv8-A ）架构的处理器，但 A32 就像是 32 位版的 A35，目标很明显，就是在效能比本来就逆天的 A35 的基础上进一步控制功耗。A32 架构主打芯片面积、功耗控制和能耗比，其停留在 32 位（ARMv7-A 指令集），指令预取单元针对效率进行了重新设计，一、二级暂存、浮点和 DSP 操作性能则针对速度进行了改进，并引入了新的电源管理特性。其支持 TrustZone 安全加密、NEON SIMD 指令集、DSP / SIMD 扩展、VFPv4 浮点计算、虚拟硬件等。A32 可以在 32 位下提供和 A35 一样的性能。但更低功耗，让它的效能比（单位电能产出的性能）比 A35 还要高 10%、比 A5 高 30%、比 A7 高 25%。A35 可以透过提升频率达到 A53 80-100% 性能，也就是说，A32 也可以在 32 位下达到同样的性能等级，这时候的芯片面积只有 A53 的 68%，而功耗则只有 A53 的 61%。 在 64 位之下，A35 都有代替 A53 架构的实力，而在 32 位中，A32 就已经是完胜所有人的境界了，而且比起 64 位的 A35 架构，32 位的 A32 更适合用在穿戴设备和物联网产品上。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:7:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A35 Cortex-A35是基于ARMv8-A 64位架构设计的一款低功耗CPU，其目的是为了取代此前32位Cortex-A7和Cortex-A5两颗老核心，采用和A53/A7类似的顺序有限双发射设计，同时融入了A72的一些新特性，并在前端重新设计了指令预取单元，提升了分支预测精度。此外，A35还采用了A53的缓存、内存架构，可配置8-64KB一级指令和数据缓存、128KB-1MB二级缓存，加入了NEON/FP单元，改进了存储性能，支持完整流水线的双精度乘法，还为CPU核心、NEON流水线都配备了硬件保留状态(独立电源域)以提升电源管理效率。在同样的工艺、频率下，A35的功耗比A7低大约10%，同时性能提升6-40%。而对比A53，它可以保留80-100%的性能，但是功耗降低32%、面积缩小25%，能效提升25%。A35还可以和A53、A57、A72等大核心搭配，组成big.LITTLE混合架构系统，进一步提升系统能效。其主要定位于低功耗的低端手机、可穿戴、物联网等领域。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:8:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A53 Cortex-A53同样是采取了ARMv8-A架构，能够支持32位的ARMv7代码和64位代码的AArch64执行状态。A53架构特点是功耗降低、能效提高。其目标是28nm HPM制造工艺下、运行SPECint2000测试时，单个核心的功耗不超过0.13W。它提供的性能比Cortex-A7处理器的功率效率更高，并能够作为一个独立的主要的应用处理器，或者搭配Cortex-A57处理器构成big.LITTLE配置。Cortex-A53在相同的频率下，能提供比Cortex-A9更高的效能。其主要面对的是中高端电脑，平板电脑，机顶盒，数字电视等。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:9:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A57 发布时间： ？ A57是arm第一代64位大核,首次采用64位ARMv8-A架构CPU，而且通过Aarch32执行状态，保持与ARMv7架构的完全后向兼容性。除了ARMv8的架构优势之外，Cortex-A57还提高了单个时钟周期性能，比高性能的Cortex-A15 CPU高出了20%至40%。它还改进了二级高速缓存的的设计以及内存系统的其他组件，极大的提高了能效。Cortex-A57将为移动系统提供超高能的性能，而借助big.LITTLE，SoC能以很低的平均功耗做到这一点。其主要面对的是中高端电脑，平板电脑以及服务器产品。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:10:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A72 发布时间： 2015年年初 ARMv8-A构架 采用台积电16nm FinFET制造工艺，Cortex-A72可在芯片上单独实现性能，也可以搭配Cortex-A53处理器与ARMCoreLinkTMCCI高速缓存一致性互连（CacheCoherentInterconnect）构成ARMbig.LITTLETM配置，进一步提升能效。在相同的移动设备电池寿命限制下，Cortex-A72能相较基于Cortex-A15的设备提供3.5倍的性能表现，相比于Cortex-A57也有约1.8倍的性能提升，展现出了优异的整体功耗效率。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:11:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A73 发布时间： 2016 ARMv8-A构架 Cortex-A73都可以提供适应性最强的移动应用生态开发环境。Cortex-A73包括128位 AMBR 4 ACE接口和ARM的big.LITTLE系统一体化接口，采用了目前最先进的10nm技术制造，可以提供比Cortex-A72高出30%的持续处理能力，非常适合移动设备和消费级设备使用。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:12:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A78 发布时间： 2020 适用于5nm工艺，性能提升20%，功耗则降低了50%。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:13:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A77 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:14:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A76 ARMv9-A 构架 The Armv9-A architecture builds on and is backwards compatible with the Armv8-A architecture. The Armv9-A architecture forms the foundation for the Arm Base System Architecture – a specification outlining a standard that ensures hardware and firmware compatibility across a wide range of applications at the system level. The Armv9-A architecture introduces some major new features: SVE2: extending the benefit of scalable vectors to many more use cases Realm Management Extension (RME): extending Confidential Compute on Arm platforms to all developers. Read more about Confidential Compute and Arm architecture security features BRBE: providing profiling information, such as Auto FDO Embedded Trace Extension (ETE) and Trace Buffer Extension (TRBE): enhanced trace capabilities for Armv9 TME: hardware transactional memory support for the Arm architecture 参考： A-Profile Architectures 详解ARM Cortex-A32处理器，打造超高能效嵌入式环境 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:15:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"ARMv8 架构编程探索","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":" 整理自ARMv8 架构编程探索,感谢原作者分享。 ARMv8-A 架构基础 执行状态与异常级别 ARMv8 寄存器组 通用寄存器组 特殊功能寄存器组 NEON 与浮点寄存器 标量寄存器大小 向量寄存器大小 NEON 在 AArch32 运行模式下 ARMv8 指令集 A64 指令集 内存管理单元 基于分页的虚拟内存 虚拟地址的翻译过程 安全与非安全地址 Memory Ordering 内存类型 屏障指令 内存属性 安全系统 TrustZone 硬件架构 利用中断切换安全世界 在安全态和非安全态切换 随着开发工作逐渐迁移到 ARMv8 的 64 位平台，因此有必要尽快熟悉 ARMv8 架构。ARMv8 与先前较为熟悉的 ARMv7 架构有较大变化，其中非常重要的一点是支持了 A64 指令集，大大提升了处理器的性能。从目前的的了解来看，基本上 ARMv8 与上代架构的差别非常大的。除了 A64 指令集之外，还有许多地方都有较大改动，下面列出几个目前比较关注的点： 执行状态与异常级别（异常级别为 EL0 - EL3） ARMv8 寄存器组（和先前完全不同的 64 位寄存器） A64 指令集（新的 64 位指令集） 内存管理（毕竟地址空间变成 64 位了） Memory Ordering 安全系统（例如普通世界和安全世界的切换） 本篇就依据上面的关键点对 ARMv8 架构进行一番探索。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:0:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8-A 架构基础 从上图可以看到，ARMv8 架构兼容了 ARMv7 架构的关键特性，例如支持 A32 和 T32 指令集，单精度浮点操作以及基于单精度浮点的 SIMD 指令。 ARMv7 为什么不支持双精度浮点的 SIMD 指令呢？也许是可用的浮点寄存器不够吧，AArch64 使用了 32*128-bit 的浮点寄存器，比 ARMv7 要多了一倍。 下图展示了后续要使用的 Cortex-A53 与 Cortex-A57 处理器属性： 可用看出，无论是 A53 还是 A57 的性能都远远超过先前的处理器性能，甚至 A57 架构还配备了专用的 GPU。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:1:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"执行状态与异常级别 在 ARMv8 架构中定义了两种执行状态，AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。然而在 ARMv8 AArch32 中保留了 ARMv7 中定义的特权级，而在 AArch64 中，特权级通过异常等级被定义。因此执行在异常等级 ELn 对应于执行在特权等级 PLn。 在 AArch64 中，处理器模式在不同的异常等级间切换，就像指在 ARMv7（AArch32） 中当异常被处理时，处理器切换到相应的异常等级来处理异常。下图展示了两种架构在异常处理时的映射关系： 可以看出先前在 ARMv7 时有各种异常模式，而在 ARMv8 中，这些模式统统都属于 EL1 级别，处理的时候先进入 EL1 的处理函数，然后再通过寄存器信息判断现在发生了哪种异常，然后执行对应的处理函数。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:2:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8 寄存器组 AArch64 执行状态在所有的异常级别下提供了 31 个 64 位通用寄存器，每一个寄存器有 64 位宽，从 X0-X30。 下图展示了 AArch64 的 通用寄存器组与特殊寄存器： ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"通用寄存器组 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"特殊功能寄存器组 可以看出 AArch64 与先前的寄存器组有了非常大的变化，不仅通用寄存器组的宽度和个数变多了，特殊寄存器组也非常不同。特殊寄存器组最大的变化是，先前在 ARMv7 下各种不同模式下的 BANK 寄存器组都没有了，取而代之的是不同级别异常下的 SP 指针、SPSR 以及异常返回寄存器组。 同时为了兼容先前 ARMv7 下 AArch32 执行状态，支持从 AArch64 到 AArch32 寄存器组的映射，如下图所示： PSTATE at AArch32 在 AArch64 中，传统的 CPSR 寄存器被 PSTATE 取代。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"NEON 与浮点寄存器 除了通用寄存器组之外， ARMv8 也提供了 32 个 128 位的浮点寄存器组，V0-V31。这 32 个寄存器用户保存浮点操作数用于标量浮点执行或者标量和向量操作数用于 NEON 操作。 标量寄存器大小 向量寄存器大小 针对不同大小的向量操作： NEON 在 AArch32 运行模式下 在 AArch32 中，小的寄存器被打包成更大的寄存器，例如 D0 和 D1 被组合成 Q1。这就引入了一些复杂的循环依赖关系，会降低编译器向量化循环结构的能力。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8 指令集 ARMv8 架构最大的变化之一就是引入了额外的 64 位指令集，补充了现有的 32 位指令集架构。这一添加提供了访问 64 位宽的整数寄存器和数据操作，以及使用 64 位大小的指针访问内存的能力。新的指令集称为 A64，运行在 AArch64 执行状态。ARMv8 也包括先前的 ARM 指令集，现在叫做 A32 和 T32 指令集，这两种指令集都运行在 AArch32 状态，提供对 ARMv7 的先后兼容。 另外有一点需要注意的是，A64 指令集的操作码的长度仍然是 32 位，而不是 64 位。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:4:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"A64 指令集 A64 的指令助记符与 ARMv7 没有太大变化，只是所操作的寄存器形式不同， AArch64 寄存器有不同的位宽，但是我们并不需要记住不同形式的指令，汇编器会根据我们操作的寄存器名称自动选择合适的编码。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:4:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存管理单元 MMU 的一个重要功能是使得系统可以运行多任务，作为一个独立的程序运行在它的私有虚拟地址空间上。这些独立程序不需要知道系统的物理内存映射，也就是那些实际被硬件使用的地址，也不用关心其他程序正在运行的程序。 有了 MMU ，我们可以使得每个应用程序都使用相同的虚拟地址。也可以使用连续的虚拟地址映射，即使这些物理内存是分离的。当将代码放置在内存中时，虚拟地址是那些被程序员、编译器和链接器使用的地址空间。而物理地址是那些被实际硬件系统使用的地址。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:5:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"基于分页的虚拟内存 在 RT-Smart 操作系统中采用了基于分页机制的内存设计与实现，而页表是分页机制中的关键部分，负责记录虚拟页到物理页的映射关系，操作系统负责对页表进行配置。 在以往较简单的宏内核版本中，我们往往将虚拟地址和物理地址配置成一一映射，也就是说 CPU 尝试访问指定位置的虚拟地址，经过 MMU 翻译，实际上也访问了实际的物理地址。但是这种方式在支持多进程的 RT-Smart 中是不够的，要想支持多进程，就需要让不同进程在访问相同虚拟地址时，实际上访问了不同的物理地址。 在 AArch64 架构下，我们使用多级页表的方式来解决多进程的内存分配问题，常见的设置是虚拟地址低 48 位参与地址翻译，页表级数为 4 级，虚拟页大小为 4 KB。在这种情况下，物理内存被划分为连续的、4 KB 大小的物理页，一个虚拟页可以映射对应一个物理页。正因为页的大小为 4 KB，所以虚拟地址的低 12 位对应于页内偏移量。 虚拟地址的翻译过程 建立页表是内存管理的一个关键过程，后续用一个专题来仔细研究一下 ARMv8 下多级页表的建立过程，下图展示了如何逐级查询页表最终找到一个正常的 64KB 物理页的过程。 每一个二级页表可以与一个或者多个一级页表所关联，我们可以用多个一级页表描述符指向同一个二级表，这也就是说可以让多个虚拟地址指向相同的物理地址。 安全与非安全地址 从理论上来说，安全和非安全的物理地址空间是相互独立且同时存在的。一个系统可以被设计成有两个完全分离的内存系统。然而大部分实际的系统将安全和非安全当做一个访问控制的属性。普通世界只能访问非安全的物理地址空间。安全世界可以访问两种物理地址空间。这些访问权限是被转换表配置控制的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:5:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"Memory Ordering 在操作系统的开发过程中，需要编写一些与硬件交互或者执行在其他核上的代码，或者直接加载或者写入要被执行的指令（例如加载应用程序），或者修改页表，在这些情况下都需要考虑内存访问顺序问题，也可以理解为观察值和实际执行情况的顺序差。 在上述情况下，程序员必须保证编写的代码有着清晰的内存访问顺序，可以通过正确地利用屏障（barriers）来实现这个目标。 在 ARMv8 架构中使用了内存弱序模型。总的来说，这就意味着内存访问的顺序并不用要求与程序的加载（load）和存储（store）操作一致。处理器可以重新调整内存读、写操作。这样做的结果是，使用一些硬件优化方法，例如 cache 和写缓冲区可以优化处理器的性能，这就意味着处理器和外部内存之间的带宽要求可以降低，而且与外部内存访问相关的延时可以被隐藏。 对普通内存的读写可以被硬件重新排序，只受数据依赖和显示的内存屏障指令的影响。在某些情况下需要更强的排序规则。程序员可以通通过描述该内存的转换表项的内存类型属性，向处理器核心提供相关信息。 一些非常高性能的系统支持包括内存读推测、多发指令或者乱序执行以及其他技术，提供了更进一步的可能性使得硬件重新调整内存访问顺序。 多条指令产生 乱序执行 执行预测 预测加载 加载和存储优化 外部内存系统 缓存一致性与多核处理 编译器优化 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存类型 所有的内存区域都被配置成两种类型之一，普通内存和设备内存。第三种内存类型，强序内存，是 ARMv7 架构的一部分。强序内存与设备内存的区别很小，因此在 ARMv8 中被省略了。 除了内存类型，属性还提供了对 cacheability、shareability、access 和执行权限的控制。可共享和可缓存属性仅适用于普通内存。设备区域永远是不能缓存和不能共享的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"屏障指令 ARM 架构在特定点使用屏障指令来强制指定访问顺序和访问完成。在一些其他架构中，也有类似的指令被称为 fence。 ARMv8 架构提供了三种类型的屏障指令： 指令同步屏障（ISB） 数据内存屏障（DMB） 数据同步屏障（DSB） ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存属性 系统的内存内存映射被分为许多区域，每一个区域都需要不同的内存属性，例如对不同优先级、内存类型、缓存策略的读写访问权限。 内存属性还包括 cacheable 和 shareable，关于 shareable 细分下来还有 Non-shareable、Inner shareable、Outer shareable 以及 full system。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"安全系统 一个系统提供一个特定的安全等级，一个受信的系统，是一个用来保护有价值的数据，例如密码和加密秘钥，信用卡数据，避免受到攻击，避免他们被复制、毁坏或者丢失。 在一个开放的系统中很难保证安全，因为在平台上会运行各种各样的软件，也会下载一些恶意的程序，这些程序可能会篡改系统。 ARM 处理器包括特殊的硬件扩展来构建一个受信的系统。软件以及硬件工具可以被分为如下三类： 软件攻击 简单硬件攻击 实验室硬件攻击 Trust Zone 技术就是被设计用于保护软件和简单硬件攻击。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"TrustZone 硬件架构 TrustZone 架构为系统设计者提供一种方法来帮助安全系统，使用 TrustZone 安全扩展和安全外设。ARM 安全模型分为设备硬件和软件资源，他们存在于安全世界为安全子系统，或者普通世界为非安全系统。系统硬件可以保证安全世界的数据都不可以被普通世界访问到。一个安全的设计会将所有敏感的资源放在安全世界。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"利用中断切换安全世界 因为代码会在两个世界中执行，因此需要利用硬件的异常机制，通过 SMC 指令来进行环境切换。下图展示了在非安全世界的上下文切换过程： 下图展示安全世界中的上下文切换过程： ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"在安全态和非安全态切换 使用 ARMv7 安全扩展，monitor 模式被软件使用与在安全和非安全态进行切换。这个模式与其他模式在安全态下有着同等的优先级。 对于 ARMv8 架构，当 EL3 在使用 AArch32 系统时与 ARMv7 完全兼容，安全状态的特权模式运行在 EL3，如下图所示： 下图展示了在 AArch64 架构下使用 EL3 提供安全监视器的情况。在 EL3 态下是不能运行 AArch32 的，按时 EL1 可以用作安全操作系统。当 EL3 在使用 AArch64，EL3 级别被用于执行切换安全态与非安全态的代码，如下图所示： 关于 ARM 的安全状态，后续还是要仔细研究的，因为通过 ATF 将系统从 EL3 切换到 EL1 的非安全状态后，才可以正常的运行 RT-Smart 操作系统，所以对 ATF 的研究是必不可少的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv7-A ARMv8-A  ARMv9-A","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:0:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A characteristics - Cortex-A 特性 所有Cortex-A处理器们都有相同的架构和特性。 使用ARMv7-A架构的Cortex-A处理器支持32bit的ARM指令和寻址，同时也支持16/32混合的Thumb指令。 ARMv8-A架构的Cortex-A处理器支持64bit的寻址和AArch64执行状态，同时也向后兼容AArch32执行状态。 Cortex-A 系列处理器有以下扩展架构 ARM TrustZone®, to provide support for security SIMD and Advanced SIMD (NEON) technologies ARM Floating Point architecture (VFP) big.LITTLE technology Large Physical Address Extension (LPAE) addressing up to 1TB of physical memory on some of the 32-bit ARMv7-A processors. ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:1:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Multicore technology - 多核技术 从单核到4核具有硬件一致性 支持“对称多处理技术”和“非对称多处理技术” 通过Accelerator Coherency Port (ACP)技术，可以让外部无缓存总线主控器达到一致性 通过AMBA® 4 ACE(AMBA Coherency Extension) 和 AMBA 5 CHI(Coherent Hub Interface)，可以保证非同族间的CPU的使用也可以保持一致性。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:2:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Industry standard - 行业标准 Cortex-A 处理器是行业标准，成功归功于ARM的合作伙伴。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:3:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A 的应用 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:4:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["ros"],"content":"树莓派4B安装ROS2","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 使用安装脚本按装ros2 ROS2构建工具colcon 安装colcon工具 构建目录 常用命令 参考 使用安装脚本按装ros2 这里使用鱼香社区提供的一键安装脚本，脚本开源地址如下 ： 1 https://github.com/fishros/install 使用命令安装 1 wget http://fishros.com/install -O fishros \u0026\u0026 . fishros 按照提示按转即可。 ROS2构建工具colcon ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:0:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"安装colcon工具 1 sudo apt install python3-colcon-common-extensions ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:1:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"构建目录 一般情况下在工作空间目录下构建，它会创建与src目录平级的下列目录： build目录：是存储中间文件的目录，会为每个软件包在build目录中创建一个子目录，在该子目录中； install目录：这是每个软件包将被安装的目录，默认情况下，每个软件包都将会被安装到一个单独的子目录中； log目录：该目录包含有关每个colcon调用的各种日志信息； ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:2:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 全部编译 colcon build # packages-select 命令 colcon build --packages-select YOUR_PKG_NAME # 编译指定包，可以多个 # packages-ignore 命令 colcon build --packages-ignore YOUR_PKG_NAME # 忽略指定包，可以多个 # continue-on-error 命令 colcon build --continue-on-error # 在编译出错之后继续编译其他模块 # symlink-install 命令 colcon build --symlink-install # 表示编译时如果 install 中文件已经存在于 src 或者 build 文件夹中，就用超链接指向该文件，避免浪费空间，也可以实现同步更新 # merge-install 命令 colcon build --merge-install # 默认会使用install使用作为所有软件包的安装前缀，而不是 安装库中特定于软件包的子目录； 如果没有这个选项，每个包都会贡献自己的环境路径，导致环境变量特别长；使用此选项，环境变量更短； # parallel-workers 命令 colcon build --parallel-workers NUMBER # 要并行处理的最大作业数， 默认值是逻辑 CPU 内核数 # cmake-args 命令 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release # 表示传入cmake编译选项参数 参考 originbot 鱼香社区 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:3:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"ubuntu 18.04 安装 ROS Melodic","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 ubuntu 18.04 安装ROS 设置安装源 添加秘钥 安装ROS 更新列表 依赖库 安装ROS Melodic 安装特定的ROS程序包 安装核心组件rosdep 配置ROS环境变量 安装rosinstall 学习ROS源码 资料 ros小课堂 ROS机器人操作系统 github ubuntu 18.04 安装ROS ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:0:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"设置安装源 中国科学技术大学的安装源 1 sudo sh -c '. /etc/lsb-release \u0026\u0026 echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main\" \u003e /etc/apt/sources.list.d/ros-latest.list' ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:1:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"添加秘钥 添加秘钥到本地的trusted数据库中并加以验证，方法如下 1 sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 若密钥服务器hkp://ha.pool.sks-keyservers.net:80无法添加成功，则可以尝试hkp://pgp.mit.edu:80或者hkp://keyserver.ubuntu.com:80。 在更新之前，需要安装公钥，否则无法验证签名，这一步也是原书没有的，需要朋友们注意，命令如下： 1 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:2:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装ROS ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"更新列表 1 sudo apt update ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:1","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"依赖库 1 2 sudo apt install libvtk6-jni libvtk6-java libvtk6-dev libvtk6-qt-dev libpcl-dev sudo apt install ros-melodic-pcl-conversions ros-melodic-pcl-ros ros-melodic-perception-pcl ros-melodic-perception ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:2","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装ROS Melodic 1 sudo apt install ros-melodic-desktop-full ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:3","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装特定的ROS程序包 如果希望安装特定的ROS程序包，则可以首先查看当前可用的程序包列表，然后选择自己需要的程序包进行安装，示例代码如下： 1 2 apt-cache search ros-melodic sudo apt install ros-melodic-slam-gmapping ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:4","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装核心组件rosdep rosdep是ROS一些核心组件的运行基础，会在编译ROS源码时检查和安装程序包依赖。安装ROS方法如下： 1 2 3 4 5 sudo rosdep init # fix-permission限制权限为当前用户 sudo rosdep fix-permissions # 可能由于网络原因会失败，多运行几次即可 rosdep update ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:5","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"配置ROS环境变量 默认情况下，ROS_HOME的路径为\"~/.ros\"，该目录保存着日志文件和测试结果文件。另外，第一次启动ROS时，需要进行环境变量配置，命令如下： 1 2 echo \"source /opt/ros/melodic/setup.bash\" \u003e\u003e ~/.bashrc source ~/.bashrc 查看环境变量是否设置正确，命令如下： 1 env | grep ROS 输出： 1 2 3 4 5 6 7 8 ROS_ETC_DIR=/opt/ros/melodic/etc/ros ROS_ROOT=/opt/ros/melodic/share/ros ROS_MASTER_URI=http://localhost:11311 ROS_VERSION=1 ROS_PYTHON_VERSION=2 ROS_PACKAGE_PATH=/opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES= ROS_DISTRO=melodic ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:4:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装rosinstall 为了构建和管理开发者自己的ROS工作空间，还需要安装rosinstall，方法如下 1 sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 学习ROS源码 如果希望基于ROS源代码进行学习，则可以下载完整的ROS源代码，方法如下： 1 2 3 4 sudo apt-get install python-rosdep python-rosinstall-generator python-rosinstall python-wstool build-essential mkdir ~/ros_catkin_ws/ \u0026\u0026 cd ~/ros_catkin_ws/ rosinstall_generator desktop_full --rosdistro melodic --deps --tar \u003e melodic-desktop-full.rosinstall wstool init -j8 src melodic-desktop-full.rosinstall ROS将使用wstool进行版本管理。如果希望在网络发生中断后可以以断点续传的方式继续下载，那么命令如下： 1 wstool update -j 8 -t src ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:5:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["java"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. VSCODE 插件 2. ubuntu20.04安装Java 3. java 编译 4. JNI 4.1. JAVA调用C++ 4.2. 生成 头文件 com_huhu_test_JNIDemo 4.3. 实现 com_huhu_test_JNIDemo 4.4. 编译 com_huhu_test_JNIDemo.cpp 4.5. 编译运行 java 4.6. JNI GetFieldID和GetMethodID 所需签名参数 1. VSCODE 插件 Code Runner Extension Pack for Java Maven for Java Debugger for Java Test Runner for Java Project Manager for Java Language Support for Java(TM) by Red Hat Java Debugger 2. ubuntu20.04安装Java ​ 默认的ubuntu20.04源仓库包含了两个openJDK软件包，Java Runtime Environment(JRE)和Java Development Kit(JDK)。JRE主要包含了Java虚拟机(JVM),类和允许你允许Java程序的二进制包。JDK包含JRE和用于构建Java应用的开发/调试工具和库文件. Java11s java的一个长期支持版本，同时也是Ubuntu20.04的默认Java开发和运行环境。 安装 1 2 3 sudo apt-get update sudo apt-get -y install openjdk-11-jdk java --version 设置Java默认版本 1 2 java --version sudo update-alternatives --config java 已经安装的Java版本都会输出，输入想要设置为默认的序列化，按enter即可 Java_HOME环境变量 1 2 3 4 5 6 7 8 9 10 11 12 13 # 首先查看Java的安装位置 update-alternatives --config java # 打开/etc/environment文件 sudo vim /etc/environment # 将JAVA_HOME指定到OpenJDK11，在文件末尾添加 JAVA_HOME=\"/usr/lib/jvm/java-11-openjdk-amd64\" # 运行下述命令让shell生效 source /etc/environment # 验证JAVA_HOME环境变量 echo $JAVA_HOME vscode Java_HOME环境变量配置 settings.json 1 \"java.jdt.ls.java.home\": \"/usr/lib/jvm/java-11-openjdk-amd64\", 3. java 编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 编译单个文件 javac test.java javac test # package javac -d . *.java java animals/MammalInt javac -d ../ JNIDemo.java Java2Cplusplus.java BaseClass.java javac test.java java -Djava.library.path=./JNIDemo test # JNI javac -h . JNIDemo.java javap -s -p Java2Cplusplus.class # cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_JNIDemo.so com_huhu_test_JNIDemo.cpp 4. JNI ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.1. JAVA调用C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import com.huhu.test.*; /* 文件名 : MammalInt.java */ public class test { public static void main(String[] args) { //加载C文件 System.loadLibrary(\"com_huhu_test_JNIDemo\"); JNIDemo jniDemo = new JNIDemo(); jniDemo.testHello(); int[] data = {1, 2, 3}; float[] f = jniDemo.execute(data, 1, 2, 3); System.out.println(f[0]); System.out.println(f[1]); System.out.println(f[2]); } } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.2. 生成 头文件 com_huhu_test_JNIDemo 1 javac -h . JNIDemo.java JNIDemo.java ： 1 2 3 4 5 6 7 8 package com.huhu.test; public class JNIDemo { //定义一个方法，该方法在C中实现 public native void testHello(); public native float[] execute(int[] data, int width, int height, float ep); } com_huhu_test_JNIDemo.h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* DO NOT EDIT THIS FILE - it is machine generated */ #include \u003cjni.h\u003e /* Header for class com_huhu_test_JNIDemo */ #ifndef _Included_com_huhu_test_JNIDemo #define _Included_com_huhu_test_JNIDemo #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_huhu_test_JNIDemo * Method: testHello * Signature: ()V */ JNIEXPORT void JNICALL Java_com_huhu_test_JNIDemo_testHello (JNIEnv *, jobject); /* * Class: com_huhu_test_JNIDemo * Method: execute * Signature: ([IIIF)[F */ JNIEXPORT jfloatArray JNICALL Java_com_huhu_test_JNIDemo_execute (JNIEnv *, jobject, jintArray, jint, jint, jfloat); #ifdef __cplusplus } #endif #endif ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.3. 实现 com_huhu_test_JNIDemo com_huhu_test_JNIDemo.cpp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libTestJni.so // TestJni.cpp #include \"com_huhu_test_JNIDemo.h\" #include \u003cjni.h\u003e #include \u003ccstdio\u003e #include \u003ciostream\u003e #include \u003cvector\u003e #define JNI_JAVA2C_PATH \"com/huhu/test/Java2Cplusplus\" #define JNI_BASE_CLASS_PATH \"com/huhu/test/BaseClass\" JNIEXPORT void JNICALL Java_com_huhu_test_JNIDemo_testHello(JNIEnv *env, jobject thiz) { std::cout \u003c\u003c \"this is Java_com_huhu_test_JNIDemo_testHello C++ print\" \u003c\u003c std::endl; } JNIEXPORT jfloatArray JNICALL Java_com_huhu_test_JNIDemo_execute(JNIEnv *env, jobject thiz, jintArray data, jint width, jint height, jfloat ep) { std::cout \u003c\u003c \"this is Java_com_huhu_test_JNIDemo_execute C++ print\" \u003c\u003c std::endl; unsigned char *data_src = (unsigned char *)env-\u003eGetIntArrayElements(data, NULL); std::cout \u003c\u003c \"data_src \" \u003c\u003c data_src[0] \u003c\u003c \" \" \u003c\u003c data_src[1] \u003c\u003c \" \" \u003c\u003c data_src[2] \u003c\u003c \" \" \u003c\u003c std::endl; std::cout \u003c\u003c \"width height ep \" \u003c\u003c width \u003c\u003c \" \" \u003c\u003c height \u003c\u003c \" \" \u003c\u003c ep \u003c\u003c \" \" \u003c\u003c std::endl; std::vector\u003cfloat\u003e result{0.1, 0.2, 0.3}; jfloatArray resultArray = env-\u003eNewFloatArray(result.size()); env-\u003eSetFloatArrayRegion(resultArray, 0, result.size(), \u0026result[0]); /* ------------------ */ //步骤1： jclass clazz = env-\u003eFindClass(JNI_JAVA2C_PATH); //步骤2：\u003cinit\u003e是java的构造函数名，这个有点特殊。在我的一篇文章jetpack中的问题中碰见过它。 //构造函数没输入输出参数，所以这里的signature填写为()V jmethodID method_init_id = env-\u003eGetMethodID(clazz, \"\u003cinit\u003e\", \"()V\"); jmethodID method_set_id = env-\u003eGetMethodID(clazz, \"setNum\", \"(I)V\"); jmethodID method_get_id = env-\u003eGetMethodID(clazz, \"getNum\", \"()I\"); jclass base = env-\u003eFindClass(JNI_BASE_CLASS_PATH); jmethodID method_base_init_id = env-\u003eGetMethodID(base, \"\u003cinit\u003e\", \"()V\"); jobject objbase = env-\u003eNewObject(base, method_base_init_id); jmethodID method_get_jobject_id = env-\u003eGetMethodID(clazz, \"getNum\", \"(Lcom/huhu/test/BaseClass;)I\"); //步骤3： //创建了 Java2Cplusplus 对象 jobject obj = env-\u003eNewObject(clazz, method_init_id); //步骤4:调用相应的方法 env-\u003eCallVoidMethod(obj, method_set_id, 21); // set函数没返回值 int year = env-\u003eCallIntMethod(obj, method_get_id); // getYear有返回值 int year2 = env-\u003eCallIntMethod(obj, method_get_jobject_id,objbase); // getYear有返回值 std::cout \u003c\u003c \"year \" \u003c\u003c year \u003c\u003c std::endl; std::cout \u003c\u003c \"year2 \" \u003c\u003c year2 \u003c\u003c std::endl; /* ------------------ */ return resultArray; } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.4. 编译 com_huhu_test_JNIDemo.cpp 1 2 3 4 5 6 g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_JNIDemo.so com_huhu_test_JNIDemo.cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_UfcwStrategy.so com_huhu_test_UfcwStrategy.cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_ufcw_strategy_UfcwStrategy.so com_ufcw_strategy_UfcwStrategy.cpp ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.5. 编译运行 java 1 2 3 4 5 6 7 8 9 javac -d ../ JNIDemo.java Java2Cplusplus.java BaseClass.java cd ../ javac test.java java -Djava.library.path=./JNIDemo test ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.6. JNI GetFieldID和GetMethodID 所需签名参数 调用JNI的GetMethodID函数获取一个jmethodID时，需要传入一个方法名称和方法签名，方法名称就是在Java中定义的方法名，方法签名的格式为：(形参参数类型列表)返回值。 1.基本类型签名 Java Native Signature byte jbyte B char jchar C double jdouble D float jfloat F int jint I short jshort S long jlong J boolean jboolean Z void void V 2.引用数据类型的转换. Java Native Signature 所有对象 jobject L+classname +; Class jclass Ljava/lang/Class; String jstring Ljava/lang/String; Throwable jthrowable Ljava/lang/Throwable; Object[] jobjectArray [L+classname +; byte[] jbyteArray [B char[] jcharArray [C double[] jdoubleArray [D float[] jfloatArray [F int[] jintArray [I short[] jshortArrsy [S long[] jlongArray [J boolean[] jbooleanArray [Z 获取签名方式： 自己拼写 ​ 方法：int (int param); ​ 签名：(I)I 命令行生成 ​ 1、使用javac，生成对应java文件的class文件； ​ 2、使用 javap -s -p 命令获取对应签名信息，如图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Compiled from \"Java2Cplusplus.java\" public class com.huhu.test.Java2Cplusplus { private int num; descriptor: I public com.huhu.test.Java2Cplusplus(); descriptor: ()V public void setNum(int); descriptor: (I)V public int getNum(); descriptor: ()I public int getBaseClassNum(com.huhu.test.BaseClass); descriptor: (Lcom/huhu/test/BaseClass;)I } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 资源管理 状态管理 简介 RAII RAII是C++的发明者Bjarne Stroustrup提出的概念， “Resource Acquisition is Initialization” ： “资源获取即初始化” 。 RAII技术被认为是C++中管理资源的最佳方法，进一步引申，使用RAII技术也可以实现安全、简洁的状态管理，编写出优雅的异常安全的代码。 在构造函数中申请分配资源，在析构函数中释放资源。 C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。 资源管理 内存只是资源的一种，广义的资源管理,比如说文件的打开与关闭、windows中句柄的获取与释放等等。按照常规的RAII技术需要写一堆管理它们的类，有的时候显得比较麻烦。但是如果手动释放，通常还要考虑各种异常处理，比如说： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void function() { FILE *f = fopen(\"test.txt\", 'r'); if (.....) { fclose(f); return; } else if(.....) { fclose(f); return; } fclose(f); ...... } 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define SCOPEGUARD_LINENAME_CAT(name, line) name##line #define SCOPEGUARD_LINENAME(name, line) SCOPEGUARD_LINENAME_CAT(name, line) #define ON_SCOPE_EXIT(callback) ScopeGuard SCOPEGUARD_LINENAME(EXIT, __LINE__)(callback) class ScopeGuard { public: explicit ScopeGuard(std::function\u003cvoid()\u003e f) : handle_exit_scope_(f){}; ~ScopeGuard(){ handle_exit_scope_(); } private: std::function\u003cvoid()\u003e handle_exit_scope_; }; int main() { { A *a = new A(); ON_SCOPE_EXIT([\u0026] {delete a; }); ...... } { std::ofstream f(\"test.txt\"); ON_SCOPE_EXIT([\u0026] {f.close(); }); ...... } system(\"pause\"); return 0; } 状态管理 RAII另一个引申的应用是可以实现安全的状态管理。 一个典型的应用就是在线程同步中，使用std::unique_lock或者std::lock_guard对互斥量std:: mutex进行状态管理。 1 2 3 4 5 6 7 8 std::mutex mutex_; void function() { mutex_.lock(); ...... ...... mutex_.unlock(); } 在互斥量lock和unlock之间的代码很可能会出现异常，或者有return语句，这样的话，互斥量就不会正确的unlock，会导致线程的死锁。所以正确的方式是使用std::unique_lock或者std::lock_guard对互斥量进行状态管理： 1 2 3 4 5 6 7 std::mutex mutex_; void function() { std::lock_guard\u003cstd::mutex\u003e lock(mutex_); ...... ...... } 在创建std::lock_guard对象的时候，会对std::mutex对象进行lock，当std::lock_guard对象在超出作用域时，会自动std::mutex对象进行解锁，这样的话，就不用担心代码异常造成的线程死锁。 ","date":"2023-01-18","objectID":"/posts/program/cpp/c++raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/:0:0","tags":["cpp"],"title":"C++:RAII(资源获取即初始化)","uri":"/posts/program/cpp/c++raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 资源管理 状态管理 RTTI的英文全称是\"Runtime Type Identification\"，中文称为\"运行时类型识别\"，它指的是程序在运行的时候才确定需要用到的对象是什么类型的。用于在运行时（而不是编译时）获取有关对象的信息。 RTTI可以通过特有的方式来告诉调用方其所调用的对象具体信息，一般有如下几种： • typeid操作符 • type_info类 • dynamic_cast操作符 https://mp.weixin.qq.com/s/3BFkwtOf4P11HxieZdn-dw ","date":"2023-01-18","objectID":"/posts/program/cpp/c++rtti%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/:0:0","tags":["cpp"],"title":"C++:RTTI(运行时类型识别)","uri":"/posts/program/cpp/c++rtti%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/"},{"categories":["makefile"],"content":"makefile","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 语法 target : dependencies CC CFLAGS LFLAGS $@ ，$\u003c，$^ patsubst 和 wildcard Static Pattern Rule LIBS = -lm 语法 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:0:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"target : dependencies 1 \u003ctarget\u003e:\u003cdependencies\u003e。即，目标：目标依赖的文件。 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:1:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"CC CFLAGS LFLAGS CC 表示选择的编译器（也可以改成 gcc） CFLAGS 表示编译选项，-c 即 g++ 中的 -c，-Wall 表示显示编译过程中遇到的所有 warning LFLAGS 表示链接选项 $() 将其括起来，表示这是一个变量名 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:2:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"$@ ，$\u003c，$^ target: dependencies 对：all: library.cpp main.cpp $@ 指代 all ，即 target $\u003c 指代 library.cpp， 即第一个 dependency $^ 指代 library.cpp 和 main.cpp，即所有的 dependencies ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:3:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"patsubst 和 wildcard wildcard 用于获取符合特定规则的文件名 1 2 3 4 SOURCE_DIR = . # 如果是当前目录，也可以不指定 SOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) target: @echo $(SOURCE_FILE) 输出的为当前目录下所有的 .cpp 文件： ./function1.cpp ./function2.cpp ./main.cpp patsubst 应该是 pattern substitution 的缩写。用它可以方便地将 .cpp 文件的后缀换成 .o。 $(patsubst 原模式，目标模式，文件列表) 1 2 3 4 5 SOURCES = main.cpp function1.cpp function2.cpp OBJS = $(patsubst %.cpp, %.o, $(SOURCES)) target: @echo $(SOURCES) @echo $(OBJS) 输出结果： 1 2 main.cpp function1.cpp function2.cpp main.o function1.o function2.o ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:4:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"Static Pattern Rule targets: target-pattern: prereq-patterns 其中 targets 不再是一个目标文件了，而是一组目标文件。而 target-pattern 则表示目标文件的特征。例如目标文件都是 .o 结尾的，那么就将其表示为 %.o，prereq-patterns (prerequisites) 表示依赖文件的特征，例如依赖文件都是 .cpp 结尾的，那么就将其表示为 %.cpp。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OBJS = $(patsubst %.cpp, %.o, $(wildcard *.cpp)) CC = g++ CFLAGS = -c -Wall LFLAGS = -Wall all: hello hello: $(OBJS) $(CC) $(LFLAGS) $^ -o $@ $(OBJS):%.o:%.cpp $(CC) $(CFLAGS) $\u003c -o $@ clean: rm -rf *.o hello ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:5:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"LIBS = -lm -lm 表示连街 math 库 1 2 3 4 CC = g++ LIBS = -lm out: fun.cpp $(CC) -o $@ $^ $(LIBS) ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:6:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["正则表达式"],"content":"正则表达式","date":"2023-01-18","objectID":"/posts/program/regex/regex/","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 #说明 #目录 一、正则基础概述 1、什么是正则表达式? 2、基础语法图表 Ⅰ - 基础语法表格 Ⅱ - 常用语法示例图解析 a) 通用正则表达式 b) 手机号正则 c) 日期匹配与分组替换 3、基本匹配 二、元字符 1、元字符列举 2、点运算符 –\u003e . 3、字符集 Ⅰ- 字符集中匹配句号. –\u003e\u003e [.] Ⅱ - 否定字符集 –\u003e\u003e [^] a) 一个特殊的用法 Ⅲ - 重复次数 –\u003e\u003e *、+、? a) * 号 b) +号 c) ? 号 Ⅳ - 量词 –\u003e\u003e {} a) 正常使用示例 b) 省略第二个参数,带逗号 c) 逗号也省略 Ⅴ- 特征标群 –\u003e\u003e (...) Ⅵ - 或运算符 –\u003e\u003e | Ⅶ - 转码特殊字符 –\u003e\u003e \\ Ⅷ - 锚点(边界) –\u003e\u003e ^、$、\\b、\\B a) ^ 号 b) $ 号 c) 单词边界 \\b d) 非单词边界 \\B 三、简写字符集 四、零宽度断言 (前后预查) 1、 正先行断言 –\u003e\u003e ?=... 2、负先行断言 –\u003e\u003e ?!... 3、 正后发断言 –\u003e\u003e ?\u003c= ... 4、负后发断言 –\u003e\u003e ?\u003c!... 五、标志(修饰符) 1、全局搜索 (Global search) –\u003e\u003e \\g 2、忽略大小写 (Case Insensitive) –\u003e\u003e /i 3、 多行注释符 六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching) 1、贪婪匹配 2、 惰性匹配 七、正则常用方法 1、 RegExp对象方法: Ⅰ- exce()方法 a) 概念与介绍 b) 当正则匹配中没有分组时 c ) 当正则匹配中有分组且分组存在名字时 d) 没有匹配到符合正则的字符时 Ⅱ - test()方法 Ⅲ - compile()方法 2、支持正则表达式的String对象的方法: Ⅰ- search()方法 a) 概念与介绍 b) 举个栗子 Ⅱ - replace()方法 a) 概念与介绍 b) 替换第一个 c) 替换全部 Ⅲ - split()方法 a) 概念与介绍 b) 举个栗子 Ⅳ- match()方法 a) 概念与介绍 b) 没有g的正则匹配 c) 有g的正则匹配 d) 没有匹配到子字符串 八、ES系列中正则的拓展 1、概括与总结 2、 RegExp 构造函数 3、字符串的正则方法 4、 u 修饰符 Ⅰ- 点字符 Ⅱ - Unicode 字符表示法 Ⅲ - 量词 Ⅳ - 预定义模式 Ⅴ - i 修饰符 Ⅵ - 转义 Ⅶ- RegExp.prototype.unicode 属性 5、 y 修饰符 Ⅰ - 正常使用举例说明 Ⅱ - 使用lastIndex属性进行说明 Ⅲ - 使用字符串对象的replace方法的举例 Ⅳ - RegExp.prototype.sticky 属性 6、s 修饰符：dotAll 模式 7、 RegExp.prototype.flags 属性 8、 Unicode 属性类 9、 具名组匹配 Ⅰ- 简介 Ⅱ - 解构赋值和替换 Ⅲ - 引用 10、String.prototype.matchAll() 九、常用正则收录 1、正则表达式只保留数字 2、限制不能为空以及中文 3、关于数字常见正则 4、关于特殊符号 #说明 正则可以说是操作 [ 字符串 ] 最强大的工具了,没有之一,特别是在进行爬虫技术或 前端字符串处理时简直必备技能,然鹅正则总是学了忘、忘了学,用时还需要去百度翻资料,也是严重影响了工作效率,所以我也认真查阅许多资料认真学习梳理成此笔记. 在此我会尽量详细地对查阅的资料进行摘录梳理并加入自己理解,相信看完这个笔记后同学们能快速掌握或者定位知识点 查阅的资料或博客:【韩顺平讲Java】Java 正则表达式专题 -正则 正则表达式 元字符 限定符 Pattern Matcher 分组 捕获 反向引用等 ;[comer的60分钟正则从入门到深入]、[Vincent Ko的可能是最好的正则表达式的教程笔记了吧…]、[gitHub的learn-regex]、阮一峰的ES6文档、deerchao的正则表达式30分钟入门教程 、博客园的 只争朝夕，不负韶华的正则常用的六种方法 除此笔记外大家可以看我其他笔记 :全栈笔记、编程_前端开发学习笔记、Vue笔记整合 、React笔记、 ReactHooks笔记 、微信小程序学习笔记、Chrome开发使用及学习笔记 以及许多其他笔记就不一一例举了 #目录 [TOC] 一、正则基础概述 首先给出正则最基础的知识点概述,好让同学们能回想起一些之前学过的知识点,能更好地进行阅读 这里分享一个在线练习正则的网站,同学们可以在这里进行练习 –\u003e [ 在线练习 ] 笔记中例子中如特殊没有指出,则默认使用 /g 标志(修饰符)全局搜索作为示范 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:0:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、什么是正则表达式? 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。通俗的讲就是按照某种规则去匹配符合条件的字符串 一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:1:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、基础语法图表 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ - 基础语法表格 首先先给出最最基础部分的匹配规则,这个是肯定要会的 single char (单字符) quantifiers(数量) position(位置) \\d 匹配数字 * 0个或者更多 ^一行的开头 \\w 匹配word(数字、字母) + 1个或更多，至少1个 $一行的结尾 \\W 匹配非word(数字、字母) ? 0个或1个,一个Optional \\b 单词\"结界\"(word bounds) \\s 匹配white space(包括空格、tab等) {min,max}出现次数在一个范围内 \\S 匹配非white space(包括空格、tab等) {n}匹配出现n次的 . 匹配任何，任何的字符 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 常用语法示例图解析 此处暂时看不懂没关系,后面会进行详细的语法介绍,此处只是让我们对正则表达式更有概念,感觉不好理解可以跳过,学完再回来看 此示例图解析部分主要摘录自 comer的60分钟正则从入门到深入,本人觉得其图画的挺好的,且确实刚开始可以稍微看下正则具体应用,方便后续理解,便摘录下来 a) 通用正则表达式 b) 手机号正则 1 /^1[34578][0-9]{9}$/ c) 日期匹配与分组替换 1 /^\\d{4}[/-]d{1,2}[/-]\\d{1,2}$/ 这个正则比较复杂，画符念咒的地方太多了，一一分析： Start of line 是由^生效的表示以此开头 对应结尾End of line 由$生效表示以此结尾 接着看digit 由 d 生效表示数字 3times 由{4} 生效表示重复4次，开始的时候有疑问，为什么不是 4times 。后来明白作者的用意，正则表达式是一个规则，用这个规则去从字符串开始匹配到结束（注意计算机读字符串可是不会分行的，都是一个串，我们看到的多行，人家会认为是个 t ）这里设计好像小火车的轨道一直开到末尾。digit 传过一次，3times表示再来三次循环，共4次，后面的once同理。 自己被自己啰嗦到了。 接下来，是 one of 在手机正则里面已经出现了。表示什么都行。只要符合这两个都让通过。 好了这个正则解释完了，接下来用它做什么呢？ 我们可以验证日期的合法性 结合URL分组替换所用到的分组特性，我们可以轻松写出日期格式化的方法 改造下这个正则 1 /^(\\d{4})[/-](\\d{1,2})[/-](\\d{1,2})$/ 轻松的可以拿到 group#1 #2 #3 的内容，对应 $1 $2 $3 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、基本匹配 正则表达式其实就是在执行搜索时的格式，它由一些字母(也可以是汉字)和数字组合而成。 例如：一个正则表达式 学习的汪 H，它表示一个规则：由学开始，接着是习,…最后H。它是组个字符与输入的正则表达式作比较,同时大小写敏感 1 2 3 \"学习的汪 H\" =\u003e 努力学习的汪 hongjilin //无符合匹配字符串 努力学习的汪 Hongjilin //其中的 [ 学习的汪 H ] 高亮 结果示例: 这里分享一个在线练习正则的网站,同学们可以在这里进行练习 –\u003e [ 在线练习 ] 二、元字符 正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:3:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、元字符列举 以下是一些元字符的列举： 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配\u003e=0个重复的在*号之前的字符。 + 匹配\u003e=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n \u003c= num \u003c= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配. $ 从末端开始匹配. ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:4:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、点运算符 –\u003e . .是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式 [...o ] 匹配3个(几个点就几位)任意字符后面跟着是 [ o ] 的字符串。 1 2 3 '...o' =\u003e //此处给出三个点 就是前三位为任意 努力学习的汪 hongjilin //其中的 [ 汪 ho ] 高亮 努力学习的汪 Hongjilin //其中的 [ 汪 Ho ] 高亮 这时,某个认真看笔记的同学提问: . 用来匹配任意字符 那么字符串中的句号.,我们又怎么匹配呢?别急,带着这个疑问继续往下看,答案就在下方字符集中 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:5:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、字符集 字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式 [ 学习的汪 [Hh] ] 匹配 [ 学习的汪 h ] 和 [ 学习的汪 H ] 。 1 2 3 \"学习的汪 [Hh]\" =\u003e 努力学习的汪 hongjilin //其中的 [ 学习的汪 h ] 高亮 努力学习的汪 Hongjilin //其中的 [ 学习的汪 H ] 高亮 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 字符集中匹配句号. –» [.] 前面我们说过点运算符,那同学们是否会有个疑惑, . 被用来匹配任意字符,那么作为字符串中的句号.,又该用什么匹配呢? 方括号的句号就表示句号。 表达式 lin[.] 匹配 lin.字符串 1 2 3 \"lin[.]\" =\u003e 努力学习的汪 hongjilins 努力学习的汪 Hongjilin. ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 否定字符集 –» [^] 一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式[^地]学习的[^帅] 匹配一个字符串为 [ 学习的 ]的, 同时前面一位字符串不能为地,后面一位字符串不能为帅 1 2 3 4 \"[^地]学习的[^帅]\" =\u003e 努力学习的汪 hongjilins //只有此处高亮 努力学习的帅汪 Hongjilin. 帅气地学习的 a) 一个特殊的用法 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 1 /foo.bar/.test('foo\\nbar') // false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 1 /foo[^]bar/.test('foo\\nbar') // true 当然,这种解决方案毕竟不太符合直觉， ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1 /foo.bar/s.test('foo\\nbar') // true 详见ES系列笔记正则部分 –\u003e ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 重复次数 –» *、+、? 后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。 a) * 号 *号匹配 在*之前的字符出现大于等于0次。 例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 1 2 3 4 \"[a-z]*\" =\u003e Hong ji lin VERY shuai //部分高亮 HONGJILINHAOSHUAI //全部不亮 hongjilinhaoshuai //全部高亮 *号搭配 .号 *字符和.字符搭配可以匹配所有的字符.*。 *和表示匹配空格的符号\\s连起来用，如表达式\\s*学习\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 1 2 3 4 \"\\s*学习\\s*\" =\u003e //0~无限次,所以只要有[ 学习 ]都会被匹配,同时会被匹配的还有其紧靠的无限次的空格 努力 学习的汪 hongjilins //[ 学习 ]前一个空格,后面无空格 努力 学习 的汪hongjilins //[ 学习 ]前后多个空格 努力学习的帅汪 Hongjilin. //[ 学习 ] 前后无空格 b) +号 +号匹配+号之前的字符出现 \u003e=1 次。 例如表达式学习.+汪 匹配以中文(也可以是字母)学习开头以 [汪] 结尾，中间跟着至少一个字符的字符串。 1 2 3 4 5 \"学习.+汪\" =\u003e 努力学习的汪 hongjilins 努力学习的帅汪 Hongjilin. 努力学习 66 汪 Hongjilin. 努力的学习汪 //此行无匹配结果 c) ? 号 在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 学习的[帅]?汪 匹配字符串 学习的汪 和 学习的帅汪。 1 2 3 4 5 \"学习的[帅]?汪\" =\u003e 努力学习的汪 hongjilins 努力学习的帅汪 Hongjilin. 努力的学习汪 //无匹配结果 努力学习的帅气汪 Hongjilin. //无匹配结果 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - 量词 –» {} a) 正常使用示例 在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。 1 2 3 4 5 \"[0-9]{2,3}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 b) 省略第二个参数,带逗号 我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 1 2 3 4 5 \"[0-9]{2,}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 c) 逗号也省略 如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{2} 匹配2位数字 1 2 3 4 5 \"[0-9]{2}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅴ- 特征标群 –» (...) 特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。 我们还可以在 () 中用或字符 | 表示或。例如，(学习|打工)的汪 匹配 学习的汪 或 打工的汪 . 1 2 3 4 5 \"(学习|打工)的汪 (hong){2}\" =\u003e 努力学习的汪 hongjilins 努力学习打工的汪 hongjilins 努力打工的汪 honghongjilins 努力学习打工的汪 honghongjilins ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:5","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅵ - 或运算符 –» | 或运算符就表示或，用作判断条件。 举个栗子: (学习|打工)的(汪|打工人) 进行匹配 1 2 3 4 \"(学习|打工)的(汪|打工人)\" =\u003e 努力打工的汪 hongjilins 努力学习的打工人 honghongjilins 努力学习打工的打工人汪 hongjilins ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:6","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅶ - 转码特殊字符 –» \\ 反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. 1 2 3 4 \"(学习|打工)的汪\\.? hong\\??\" =\u003e 努力打工的汪. hong 努力学习的汪? hong 努力学习的汪 hong? ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:7","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅷ - 锚点(边界) –» ^、$、\\b、\\B 在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 通常也会搭配标志(修饰符)相关知识点使用 由于还未说到标志相关知识,此处例子仍使用 [ /g ]全局搜索,如果对此有疑惑的可以留着疑问看下方的 五、标志 a) ^ 号 ^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(学习|打工)的汪 进行匹配 1 2 3 4 5 6 \"^(学习|打工)的汪\" =\u003e //注意:下列字符串要分四次匹配,因为即使换行了,后三行字符串本质上都不在字符串开头 //或者标志换成 /m 而不是 /g 因为此处还未说到标志,所以默认大家使用/g全局搜索 学习的汪 hong 打工的汪 hong 努力打工的汪 hong 努力学习的汪 b) $ 号 同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，学习的(汪|打工人)$ 匹配以 [ 汪 ] 或者 [ 打工人 ] 结尾的字符串。 1 2 3 4 5 6 \"学习的(汪|打工人)$\" =\u003e //注意:下列字符串要分四次匹配,因为即使换行了,前三行字符串本质上都不在字符串结尾 //或者标志换成 /m 而不是 /g 因为此处还未说到标志,所以默认大家使用/g全局搜索 努力学习的汪 努力学习的打工人 努力学习的打工人 hongjilins 努力学习的汪_ //此处 _ 模拟表示空格 c) 单词边界 \\b \\b : 单词边界:指[a-zA-z0-9]之外的字符,举个栗子:\\bis\\b 1 2 3 4 5 '\\bis\\b'=\u003e My name is hongjilin my name@is@hong jilin myname学is习hongjilin mynameishongjilin //只有此处不被匹配 d) 非单词边界 \\B 1 2 3 4 5 '\\Bis\\B'=\u003e My name is hongjilin my name@is@hong jilin myname学is习hongjilin mynameishongjilin //只有此处被匹配,与单词边界切好相反 三、简写字符集 这些简写字符集,简洁明了且非常常用,但是也因为这样当初没有仔细去记,用时还得查阅资料十分不便,建议背下来 正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 四、零宽度断言 (前后预查) 先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。 例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?\u003c=\\$)[0-9\\.]*。 这个表达式匹配 $ 开头，后面可以跟着单个字符:[0~9]、[.]、[?],这些字符可以出现大于等于 0 次。 1 2 3 \"(?\u003c=\\$)[0-9\\.\\?]*\" =\u003e $0.,1,2,3,$4,5,6,$?7,8,$..9.9? //0. //4 //?7 //..9.9? 零宽度断言如下： 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?\u003c= 正后发断言-存在 ?\u003c! 负后发断言-排除 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:8","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、 正先行断言 –» ?=... ?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式(即不会返回先行断言匹配部分的内容)。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。 例如，表达式 学习的汪(?=\\shong) 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了正先行断言 (?=\\shong) ，即 [ 学习的汪 ]后面紧跟着 [ (空格)hong ]。 1 2 3 4 \"学习的汪(?=\\shong)\" =\u003e //此处断言中的可以再加如`+` 、`*` ......,此处举其中一个栗子说明 努力学习的汪 hong //只有此处被匹配到 返回: [学习的汪] --\u003e断言中的匹配项作为约束不会返回 努力学习的汪 帅 努力学习的汪hong //此处后面没有空格 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:7:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、负先行断言 –» ?!... 负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 学习的汪(?!\\s+hong) 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了负先行断言 (?!\\shong) ,即 [ 学习的汪 ]后面不跟着 [ (空格)hong ]。 1 2 3 4 \"学习的汪(?!\\s+hong)\" =\u003e 努力学习的汪 hong //只有此处不被匹配到 努力学习的汪 帅 努力学习的汪hong ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:8:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、 正后发断言 –» ?\u003c= ... 正后发断言 记作(?\u003c=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?\u003c=[学习|打工])的(汪|打工人) 匹配 [汪] 和 [打工人] ，且需要其前方跟着 [学习] 或 [打工] 。 1 2 3 4 \"(?\u003c=[学习|打工])的(汪|打工人)\" =\u003e 努力学习的汪 努力打工的打工人 努力学习汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:9:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、负后发断言 –» ?\u003c!... 负后发断言 记作 (?\u003c!...) 用于筛选所有匹配结果，筛选条件为 其前 不 跟随着断言中定义的格式。 例如，表达式 (?\u003c![学习|打工])的(汪|打工人) 匹配 [汪] 和 [打工人] ，且需要其前方 不 跟着 [学习] 或 [打工] 。 1 2 3 4 \"/(?\u003c![学习|打工])的(汪|打工人)/g\" =\u003e 努力学习的汪 努力打工的打工人 努力学习汪 五、标志(修饰符) 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。 标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:10:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、全局搜索 (Global search) –» \\g 修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /学习的汪/g 表示搜索 任意字符（除了换行）+ 学习的汪，并返回全部结果。 1 2 3 4 \"/学习的汪/g\" =\u003e 努力学习的汪 努力学习的汪 非常努力学习的汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:11:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、忽略大小写 (Case Insensitive) –» /i 修饰语 i 用于忽略大小写。 例如，表达式 /Hong/gi 表示在全局搜索 Hong，在后面的 i 将其条件修改为忽略大小写，则变成搜索 [hong(忽略大小写)]，g 表示全局搜索。 1 2 3 4 5 \"/Hong/gi\" =\u003e //默认情况下是大小写敏感的,但此处这样标志后,就成为忽略大小写 hongjilin Hongjilin HONGJILIN hOngjilin ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:12:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、 多行注释符 多行修饰符 m 常用于执行一个多行匹配。 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。 例如，表达式 /学习的(汪|打工人)$/gm 表示 [学习的] 后面跟着 [汪] 或 [打工人] ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。–\u003e此处举出上方锚点的例子 1 2 3 4 5 \"/学习的(汪|打工人)$/gm\" =\u003e //在之前说到 锚点 时提到,如果是 /g 只能一行一行匹配,而如果换成这个就可以直接匹配 努力学习的汪 努力学习的打工人 努力学习的打工人 hongjilins 努力学习的汪_ //此处 _ 模拟表示空格 六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching) ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:13:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、贪婪匹配 正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。 1 2 \"/(.*汪)/\" =\u003e 努力学习的汪 非常认真读书的汪 的汪 的汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:14:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、 惰性匹配 我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 1 2 \"/(.*?汪)/\" =\u003e 努力学习的汪 非常认真读书的汪 的汪 的汪 七、正则常用方法 正则中常用方法主要分为两类，一类是：RegExp对象方法；一类是：支持正则表达式的String对象的方法。 此处主要列举常用的 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:15:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、 RegExp对象方法: RegExp对象方法:exce()、test() 、compile() ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- exce()方法 a) 概念与介绍 exec() 方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值构成的数组 ， 该数组还有继承的属性： index：表示第一个匹配的字符在原字符串中的位置， input:表示原字符串， groups：表示当初中命名的分组时匹配到的分组对象； exec()方法没有匹配到数据时返回 null。 b) 当正则匹配中没有分组时 1 2 3 4 const str=\"努力666 123 学习! 456 的打工人! qrw\"; const patt=/\\d+/; const result=patt.exec(str); console.log(result) c ) 当正则匹配中有分组且分组存在名字时 1 2 3 4 const str=\"努力666 123 学习! 456 的打工人! qrw\"; const patt=/(?\u003c努力\u003e\\d)+/; const result=patt.exec(str); console.log(result) d) 没有匹配到符合正则的字符时 1 2 3 4 const str=\"努力学习的汪\"; const patt=/\\d+/; const result=patt.exec(str); console.log(result) //返回 null ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - test()方法 介绍：方法用于检测一个字符串是否匹配某个模式；如果字符串中有匹配的值返回 true ，否则返回 false。 1 2 3 4 5 6 7 8 9 const str=\"努力学习的汪\"; //查找\"学习\" const reg1=/学习/g; const result1=reg1.test(str); console.log(result1); //true //查找 \"打工\" const reg2=/打工/g; const result2=reg2.test(str); console.log(result2); //false ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - compile()方法 该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 1 2 3 4 5 6 const reg=/[abc]/gi; console.log(reg.test('a'));//true reg=/[cde]/gi; console.log(reg.test('a')); //false reg.compile(reg); console.log(reg.test('a')); //false 被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、支持正则表达式的String对象的方法: 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 [ String.prototype.match ] 调用 RegExp.prototype[Symbol.match] [ String.prototype.replace ] 调用 RegExp.prototype[Symbol.replace] [ String.prototype.search ] 调用 RegExp.prototype[Symbol.search] [ String.prototype.split ] 调用 RegExp.prototype[Symbol.split] ES系列更多笔记可以点此跳转 –» ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- search()方法 a) 概念与介绍 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 如果找到任何匹配的子串，则返回 该子串在原字符串中的第一次出现的位置。　如果没有找到任何匹配的子串，则返回 -1。 b) 举个栗子 1 2 3 4 5 6 7 8 const str1 = '努力学习 123 的汪 456'; const reg1 = /\\d+/; console.log(str1.search(reg1));//5 console.log(str1.search(\"的汪\"));//9 const str2 = 'hello world'; const reg2 = /\\d+/; console.log(str2.search(reg2));//-1 console.log(str2.search(\"打工人\"));//-1 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - replace()方法 a) 概念与介绍 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。原字符串不变，创建一个新的字符串 创建一个新的字符串，原字符串不变 b) 替换第一个 1 2 3 4 const str=\"努力学习的汪! 努力学习的汪!! 努力学习的汪!!!\"; const n=str.replace('学习',\"打工\"); console.log(str) //原字符串不变 console.log(n) //新字符串 c) 替换全部 1 2 3 4 5 6 const str=\"努力学习的汪! 努力学习的汪!! 努力学习的汪!!!\"; const n=str.replace(/学习/g,\"打工\"); //替换全部 const a=str.replace(/学习/,\"打工\"); //仍是替换单行 console.log(str) //原字符串不变 console.log(a) //仍是替换单行 console.log(n) //新字符串 全部替换 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - split()方法 a) 概念与介绍 用于把一个字符串按符合匹配条件的方式分割成一个字符串数组。不改变原字符串 b) 举个栗子 1 2 3 4 5 6 7 8 9 const str=\"How 1are 2you 3? 4I'm 5fine! 6thanks\"; const a=str.split(\" \"); const b=str.split(\" \",2); const c=str.split(/\\d/); const d=str.split(/\\d/,3); console.log(a); // [\"How\", \"1are\", \"2you\", \"3?\", \"4I'm\", \"5fine!\", \"6thanks\"] console.log(b); // [\"How\", \"1are\"] console.log(c); // [\"How \", \"are \", \"you \", \"? \", \"I'm \", \"fine! \", \"thanks\"] console.log(d); // [\"How \", \"are \", \"you \"] ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ- match()方法 a) 概念与介绍 概念: match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配 注意点: match() 方法将检索字符串 String，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。 如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配，与exce的完全一致 如果 regexp 有标志 g，它将找到全部符合正则子字符串，并返回一个数组。 如果没有找到任何匹配的文本，无论有没有g，match() 将返回 null b) 没有g的正则匹配 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/\\d+/; const result=str.match(reg); console.log(result) //没有 全局搜索 的时候返回与 exce() 完全一致 c) 有g的正则匹配 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/\\d+/g; const result=str.match(reg); console.log(result) //返回数组 d) 没有匹配到子字符串 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/打工/g; const result=str.match(reg); console.log(result) //匹配不到返回null 八、ES系列中正则的拓展 更多ES系列知识点笔记 –\u003e ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、概括与总结 变更RegExp构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符) 正则方法调用变更：字符串对象的match()、replace()、search()、split()内部调用转为调用RegExp实例对应的RegExp.prototype[Symbol.方法] u修饰符：Unicode模式修饰符，正确处理大于 [ \\uFFFF ] 的 [ Unicode字符 ] 点字符(.) Unicode表示法 量词 预定义模式 i修饰符 转义 y修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似) unicode：是否设置u修饰符 sticky：是否设置y修饰符 flags：返回正则表达式的修饰符 重点难点 y修饰符隐含头部匹配标志^ 单单一个y修饰符对match()只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:18:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、 RegExp 构造函数 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag 标志）。 1 2 3 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 1 2 3 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 1 2 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 1 2 new RegExp(/abc/ig, 'i').flags // \"i\" 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:19:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、字符串的正则方法 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 [ String.prototype.match ] 调用 RegExp.prototype[Symbol.match] [ String.prototype.replace ] 调用 RegExp.prototype[Symbol.replace] [ String.prototype.search ] 调用 RegExp.prototype[Symbol.search] [ String.prototype.split ] 调用 RegExp.prototype[Symbol.split] ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:20:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、 u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 1 2 /^\\uD83D/u.test('\\uD83D\\uDC2A') // false /^\\uD83D/.test('\\uD83D\\uDC2A') // true 上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为: ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1 2 3 var s = '𠮷'; /^.$/.test(s) // false /^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - Unicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 1 2 3 /\\u{61}/.test('a') // false /\\u{61}/u.test('a') // true /\\u{20BB7}/u.test('𠮷') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1 2 3 4 /a{2}/.test('aa') // true /a{2}/u.test('aa') // true /𠮷{2}/.test('𠮷𠮷') // false /𠮷{2}/u.test('𠮷𠮷') // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - 预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 1 2 /^\\S$/.test('𠮷') // false /^\\S$/u.test('𠮷') // true 上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 1 2 3 4 5 6 7 function codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0; } var s = '𠮷𠮷'; s.length // 4 codePointLength(s) // 2 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅴ - i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 1 2 /[a-z]/i.test('\\u212A') // false /[a-z]/iu.test('\\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:5","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅵ - 转义 没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\\,）无效，而在u模式会报错。 1 2 /\\,/ // /\\,/ /\\,/u // 报错 上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:6","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅶ- RegExp.prototype.unicode 属性 正则实例对象新增unicode属性，表示是否设置了u修饰符。 1 2 3 4 5 const r1 = /hello/; const r2 = /hello/u; r1.unicode // false r2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:7","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"5、 y 修饰符 提前剧透，y修饰符号相当于 /g隐含了头部匹配的标志^。带着这个思维就相对容易理解下方的粘连一次 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ - 正常使用举例说明 除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。实际上相当于默认加了一个^ y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 1 2 3 4 5 6 7 8 9 var s = 'aaa_aa_a'; var r1 = /a+/g; var r2 = /a+/y; r1.exec(s) // [\"aaa\"] --\u003e此时剩余字符串[_aa_a] r2.exec(s) // [\"aaa\"] --\u003e此时剩余字符串[_aa_a] r1.exec(s) // [\"aa\"] r2.exec(s) // null --\u003ey必须从第一个位置开始匹配,实际上相当于默认加了一个`^`,所以匹配不到 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 1 2 3 4 5 var s = 'aaa_aa_a'; var r = /a+_/y; r.exec(s) // [\"aaa_\"] r.exec(s) // [\"aa_\"] 上面代码每次匹配，都是从剩余字符串的头部开始。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 使用lastIndex属性进行说明 使用lastIndex属性，可以更好地说明y修饰符。 1 2 3 4 5 6 7 8 9 10 11 const REGEX = /a/g; // 指定从2号位置（y）开始匹配 REGEX.lastIndex = 2; // 匹配成功 const match = REGEX.exec('xaya'); // 在3号位置匹配成功 match.index // 3 // 下一次匹配从4号位开始 REGEX.lastIndex // 4 // 4号位开始匹配失败 REGEX.exec('xaya') // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 1 2 3 4 5 6 7 8 9 10 11 const REGEX = /a/y; // 指定从2号位置开始匹配 REGEX.lastIndex = 2; // 不是粘连，匹配失败 REGEX.exec('xaya') // null // 指定从3号位置开始匹配 REGEX.lastIndex = 3; // 3号位置是粘连，匹配成功 const match = REGEX.exec('xaya'); match.index // 3 REGEX.lastIndex // 4 实际上，y修饰符号隐含了头部匹配的标志^。 1 /b/y.exec('aba')// null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 使用字符串对象的replace方法的举例 下面是字符串对象的replace方法的例子。 1 2 const REGEX = /a/gy; 'aaxa'.replace(REGEX, '-') // '--xa' 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 1 2 'a1a2a3'.match(/a\\d/y) // [\"a1\"] 'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y; const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g; tokenize(TOKEN_Y, '3 + 4') // [ '3', '+', '4' ] tokenize(TOKEN_G, '3 + 4') // [ '3', '+', '4' ] function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result; } 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1 2 3 4 tokenize(TOKEN_Y, '3x + 4') // [ '3' ] tokenize(TOKEN_G, '3x + 4') // [ '3', '+', '4' ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - RegExp.prototype.sticky 属性 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 1 2 var r = /hello\\d/y; r.sticky // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"6、s 修饰符：dotAll 模式 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 1 /foo.bar/.test('foo\\nbar') // false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 1 /foo[^]bar/.test('foo\\nbar') // true 这种解决方案毕竟不太符合直觉， ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1 /foo.bar/s.test('foo\\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1 2 3 4 5 6 const re = /foo.bar/s; // 另一种写法 // const re = new RegExp('foo.bar', 's'); re.test('foo\\nbar') // true re.dotAll // true re.flags // 's' /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:23:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"7、 RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 1 2 3 4 5 6 7 8 9 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/ig.flags // 'gi' ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:24:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"8、 Unicode 属性类 ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 1 2 const regexGreekSymbol = /\\p{Script=Greek}/u; regexGreekSymbol.test('π') // true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 1 \\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名，或者只写属性值。 1 2 \\p{UnicodePropertyName} \\p{UnicodePropertyValue} \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。 由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 1 2 const regex = /^\\p{Decimal_Number}+$/u; regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \\p{Number}甚至能匹配罗马数字。 1 2 3 4 5 // 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test('²³¹¼½¾') // true regex.test('㉛㉜㉝') // true regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true 下面是其他一些例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 匹配所有空格 \\p{White_Space} // 匹配各种文字的所有字母，等同于 Unicode 版的 \\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配 Emoji /\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:25:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"9、 具名组匹配 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 简介 正则表达式使用圆括号进行组匹配。 1 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 1 2 3 4 5 6 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 1 2 3 4 5 6 const RE_DATE = /(?\u003cyear\u003e\\d{4})-(?\u003cmonth\u003e\\d{2})-(?\u003cday\u003e\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加 [ “问号 + 尖括号 + 组名” ] （?\u003cyear\u003e），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 1 2 3 4 5 const RE_OPT_A = /^(?\u003cas\u003ea+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 解构赋值和替换 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 1 2 3 let {groups: {one, two}} = /^(?\u003cone\u003e.*):(?\u003ctwo\u003e.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$\u003c组名\u003e引用具名组。 1 2 3 4 let re = /(?\u003cyear\u003e\\d{4})-(?\u003cmonth\u003e\\d{2})-(?\u003cday\u003e\\d{2})/u; '2015-01-02'.replace(re, '$\u003cday\u003e/$\u003cmonth\u003e/$\u003cyear\u003e') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 1 2 3 4 5 6 7 8 9 10 11 12 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) =\u003e { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k\u003c组名\u003e的写法。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\k\u003cword\u003e$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\k\u003cword\u003e!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"10、String.prototype.matchAll() 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var regex = /t(e)(st(\\d?))/g; var string = 'test1test2test3'; var matches = []; var match; while (match = regex.exec(string)) { matches.push(match); } matches // [ // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"], // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"], // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] // ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1 2 3 4 5 6 7 8 9 const string = 'test1test2test3'; const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 1 2 3 4 5 // 转为数组的方法一 [...string.matchAll(regex)] // 转为数组的方法二 Array.from(string.matchAll(regex)) 九、常用正则收录 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:27:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、正则表达式只保留数字 正则代码 1 2 str=str.replaceAll(\"[^0-9]\", \"\");//此表达式匹配错误 str=str.replace(/\\D/g,''); //正确 调用代码示例 1 2 3 4 5 onChange={(e)=\u003e store.changeSearchParamsValue('storeId')(e.target.value.replace(/\\D/g,''))} @action changeSearchNumberParamsValue = (type) =\u003e (value) =\u003e { //this.searchParams[type] = value.replace(/\\D/g,''); 外面限制好后传入 this.searchParams[type] = value; }; 实现效果 输入非数字内容则无法键入(替换为空) ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:28:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、限制不能为空以及中文 1 str=str.replace(/\\s/g, '').replace(/[\\u4E00-\\u9FA5]|[\\uFE30-\\uFFA0]/gi, ''); ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:29:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、关于数字常见正则 数字:\\d 位数限制:{m,n} 数字范围:[n-m], 出现次数: * + 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:30:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、关于特殊符号 匹配带小括号的字符串: const reg = new RegExp([(]${变量}[)], 'g') –\u003e这个变量是可以随着改变的 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:31:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["读书笔记"],"content":"读书笔记：能力陷阱","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 打破你的认知：先⾏动，后思考 1.1. 改变思想从⾏动开始 1.2. 如何成为⼀名⾼效的领导者 1.3. “由外⽽内”原则 1.4. 转变过程中的迷失 1.5. 为什么“由外⽽内”地改变很重要 1.6. “三步⾛”助你实现领导者转变 1.7. 重新定义你的⼯作 1.8. 扩建⼈际关系⽹络 1.9. 试着朝更多不同的⽅向发展⾃⼰ 1.10. 过程和结果，哪个重要 2. 重新定义你的⼯作 1. 打破你的认知：先⾏动，后思考 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:0:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.1. 改变思想从⾏动开始 管理专家理查德·帕斯卡尔（Richard Pascale）所说：“成年⼈更倾向于先做⽽后产⽣新的想法，⽽不是先想再以⼀种新的⽅式去做。” 我们要先学会像领导者⼀样做事。⼀项关于“成年⼈学习⽅式”的研究发现，⼀般情况下的习顺序是“先思考后⾏动”；但是在⼀个⼈的改变过程中，学习顺序其实是相反的，例如，如果我们想要成为⼀名优秀的领导者，就要学会“先⾏动后思考”。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:1:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.2. 如何成为⼀名⾼效的领导者 我发现⼀个⼈之所以能成为领导者，是因为他所做的事是⼀名真正的领导者会做的事。 如果我们像⼀个领导者⼀样做事：如不断提出新观点，在专业领域之外做出贡献，或是集合⼈⼒物⼒做成⼀件很有价值的事，等等。⾝边的其他⼈也就会觉得我们越来越像⼀个真正的领导者。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:2:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.3. “由外⽽内”原则 新的经历不仅会改变你的想法——你认为什么是重要的，什么是值得去做的，还会改变你未来的样⼦。它们可以帮助你从⼀些新的成就⾥获得⾃信，使你放弃过去的⽬标，还可以改变你过去所习惯的做事⽅法。这不仅是因为过去的⽅法不再适⽤于当前的情况，还因为你有了新的⽬标，有更有意义、更有价值的事情需要去做。 与⾃省相⽐，由外⽽内地改变更能帮助你重塑形象，告诉你你能做什么。成为⼀名优秀的领导者并⾮是你发展道路上的起点，⽽是你⾃我⾝份认知的结果。 与⼤众普遍认为的观点相反，⾃省⼤多时候只会让我们停留在过去，蒙蔽我们的双眼，使我们⽆法发现我们的领导潜能，还会让我们毫⽆准备地去⾯对周围环境的根本转变。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:3:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.4. 转变过程中的迷失 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:4:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.5. 为什么“由外⽽内”地改变很重要 ⼯作上发⽣变动通常就意味着是时候该调整或重塑你的领导者形象了。与过去相⽐，现在重要的转变不仅仅是⼀个头衔或是⼀件晚礼服的改变，⽽ 是⼀些或微妙或明显的变化。这些变化会让别⼈对你产⽣⼀些新的期望（尽管有时候不是很明显），他们会期望你做出⼀些不⼀样的事，或是期望你改变⼀下做事风格。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:5:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.6. “三步⾛”助你实现领导者转变 ⼀是思考你所做⼯作的类型； ⼆是转换新⾓⾊或参与新活动能让你接触到不同的⼈，这些⼈有着与你不⼀样的世界观； 三是重新审视⾃⼰。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:6:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.7. 重新定义你的⼯作 想要成为⼀个领导者，⾸先要学会把时间投资在有意义的事情上。 在如今这个⾼速发展的商业世界⾥，价值的创造更多地来源于合作，这就意味着我们需要打破⾃给⾃⾜的企业界限。 在职业⽣涯的早期，我们被限制在⾃⼰的专业领域范围之内。当我们开始向⼀个领导者转变时，通常也都只是在我们的职能范围或专业领域之内，尤其是在我们擅长的领域内。⼀旦我们想要扮演⼀个更⾼等级的领导者⾓⾊，情况就会发⽣根本上的改变。 正如⼼理学家所说，我们应该做的事与我们实际做的事常常是两件完全不⼀样的事。从认真做事得到满意的回报转变为给别⼈提供策略指导并不是⼀件容易的事，这需要我们学会与组织外部的⼈进⾏合作。 要想成为⼀名优秀的领导者，就要先改变你的⽇常⼯作范围，从各种技术操作需求转变为提出更多的策略性指导。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:7:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.8. 扩建⼈际关系⽹络 如果遇到要做⾃⼰专业领域范围之外的事，或是需要他们提出⼀些能适应全局的策略，很多管理者都没有办法完成好这些任务，因为这不仅仅需要很强的分析能⼒，还需要⼴泛的⼈际关系⽹络基础。 与其他职能或其他公司的管理者（在我们领导范围之外的⼈）建⽴起直接或间接联系，对于弄清我们的策略是否能适应全局、如何推销⾃⼰的观点、弄清相关⾏业发展⽅向以及与其他⼈竞争资源这些⽅⾯来说都是⾮常重要的。 在我们刚接触⼀件新的任务时，我们需要有经验的⼈的建议和指导以及周围其他⼈的反馈来帮助我们成长和进步。在最开始的时候，我们的努⼒需要得到别⼈的肯定，还需要前⼈的⿎励和指导，并亲⾃给我们进⾏⽰范。当我们不确定前进的⽅向时，其他⼈所提供的建议也能为我们指明道路。 因此，想要成为⼀名优秀的领导者，你不仅仅需要学会去参与新活动或改变想法，还需要学会⽤⼀种新的⽅法去学习，即学会更多地⾃我引导，或是向同级的⼈学习，又或是在公司外部学习。 简⽽⾔之，你需要积极地去建⽴⼀个新的⼈际关系⽹络，并且你能从中学到很多，⾄少可以与上级建⽴更为密切的关系。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:8:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.9. 试着朝更多不同的⽅向发展⾃⼰ 没有⼈想要在转变的道路上迷失，然⽽要想像领导者⼀样思考的唯⼀办法就是要像领导者⼀样做事，即使最开始的时候你可能会觉得这并不是真正的你。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:9:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.10. 过程和结果，哪个重要 成为⼀名优秀的领导者不是⼀个项⽬或⼀个结果，⽽是⼀个过程。⾸先你需要了解这个过程，然后才能为之努⼒⽽后获得成功。 “当外在改变的速度超过内在改变速度之时，终点就在眼前。” 2. 重新定义你的⼯作","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:10:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["tools"],"content":"配置定时任务","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":" crontab crontab定时任务语法 设置定时任务 cron 服务查看 expect 安装 expect 自动代码拉提交脚本 crontab cron是一个Linux定时执行工具，可以在无需人工干预的情况下运行作业。在Ubuntu中，cron是被默认安装并启动的。 ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:0:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"crontab定时任务语法 1 minute hour day month week user command #顺序：分 时 日 月 周 用户 命令 minute： 表示分钟，可以是从 0 到 59 之间的任何整数。 hour：表示小时，可以是从 0 到 23 之间的任何整数。 day：表示日期，可以是从 1 到 31 之间的任何整数。 month：表示月份，可以是从 1 到 12 之间的任何整数。 week：表示星期几，可以是从 0 到 7 之间的任何整数，这里的 0 或 7 代表星期日。 user：linux的用户身份，例如root，或者其他用户 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 特殊字符 星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，如*/10，如果用在 minute 字段，表示每十分钟执行一次。 ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:1:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"设置定时任务 编辑ect下crontab文件就行了，这个文件里存放的就是cron要执行的命令，以及定时执行的时间 1 sudo vim /etc/crontab 修改文件： 定时每凌晨，自动执行保存在/root目录下hello.sh脚本 1 00 00 * * * root /root/hello.sh 使用 1 2 3 00 01 * * * root /home/zyh/data/blogs/deploy.sh 00 03 * * * root /home/zyh/data/blogs/deploy.sh 00 05 * * * root /home/zyh/data/blogs/deploy.sh ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:2:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"cron 服务查看 1 2 3 4 5 service cron start # 启动服务 service cron stop # 关闭服务 service cron restart # 重启服务 service cron reload # 重新载入配置 service cron status # 查看crond状态 expect expect 就是完成一些需要与用户交互的任务，例如 telnet、ftp、ssh 远程登录机器的时候，这些命令会要求用户输入用户名、密码等相关信息，而这些，是无法通过 shell 脚本来完成的。这是因为这些命令是从控制终端而不是标准输入上读取的，所以无法事先将信息重定向到标准输入从而实现自动化运行。而 expect 就是用来解决这类问题的，举个expect 进行 ssh 登录的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/expect -f set ipaddr \"localhost\" set passwd \"iforgot\" spawn ssh root@$ipaddr expect { \"yes/no\" { send \"yes\\r\"; exp_continue} \"password:\" { send \"$passwd\\r\" } } expect \"]# \" send \"touch a.txt\\r\" send \"exit\\r\" expect eof exit expect 脚本里有这么几个关键动作： spawn ：启动需要执行的命令； expect ：解析命令输出，并根据下面的匹配语句进入子控制块； send ：向命令发送信息，这些信息相当于是命令从控制终端读取的； interact ：继续命令与控制终端的交互，此时用户可以正常向命令输入信息（本例未展示）。 …… ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:3:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"安装 expect 1 2 3 4 # 安装 sudo apt-get install tcl tk expect # 查看版本 expect -v ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:4:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"自动代码拉提交脚本 timeout 1 2 set timeout -1 # 没有timeout set timeout XX # 设定具体的timeout时间（秒） 自动拉取重试 1 2 3 4 5 6 7 8 #! /usr/bin/expect -f set timeout 30 for {set i 0} {$i\u003c=10} {incr i} { puts \"start pulling git $i\" spawn git pull #expect \"Already up-to-date.\" { puts \"pulling ok\"; exit } expect \"已经是最新的。\" { puts \"pulling ok\"; exit } } 自动提交重试 1 2 3 4 5 6 7 #! /usr/bin/expect -f set timeout 30 for {set i 0} {$i\u003c=10} {incr i} { puts \"start pushing git $i\" spawn git push expect \"Everything up-to-date\" { puts \"pushing ok\"; exit } } 完整脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #!/bin/sh PATH=/bin:/usr/bin:/snap/bin export PATH # If a command fails then the deploy stops set -e cd /home/zyh/data/blogs echo \"LOG DATE:\" $(date +\"%Y-%m-%d %H:%M:%S\") DATE=`date '+%Y%m%d-%H%M%S'` echo $DATE LogNameDATE=`date '+%Y'` LogFile='./log/log'$LogNameDATE'.log' echo \" \" \u003e\u003e $LogFile echo \"———————————————–\" \u003e\u003e $LogFile echo \"BACKUP DATE:\" $(date +\"%Y-%m-%d %H:%M:%S\") \u003e\u003e $LogFile printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" printf \"\\n\\n\" printf \"\\033[0;32mPull note files ...\\033[0m\\n\" expect pull.exp printf \"\\n\\n\" printf \"\\033[0;32mHugo build ...\\033[0m\\n\" # clean Public folder # cd public # rm -r * # cd ../ # Build the project. echo $(hugo -t LoveIt) \u003e\u003e $LogFile # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\n\\n\" printf \"\\033[0;32mpush public ...\\033[0m\\n\" # Go To Public folder cd public # Add changes to git. if [ -n \"$(git status -s)\" ];then git add ./ # Commit changes. msg=\"update $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" cd ../ expect push_main.exp else cd ../ fi echo \"———————————————–\" \u003e\u003e $LogFile printf \"\\n\\n\" printf \"\\033[0;32mPush ...\\033[0m\\n\" # Add changes to git. if [ -n \"$(git status -s)\" ];then git add ./ # Commit changes. msg=\"update $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. expect push_master.exp fi printf \"\\n\\n\" printf \"\\033[0;32mDone\\033[0m\\n\" ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:5:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/","tags":["opencv"],"title":"opencv DNN 模块","uri":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/"},{"categories":["开源软件"],"content":"DNN模块介绍 OpenCV的DNN模块是在OpenCV3.3合并到OpenCV release中的，它最早是在扩展模块中的，它可以导入caffe、tensorflow、pytorch等深度学习框架训练生成的模型文件，从而正向传递实现预测功能。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/:0:0","tags":["opencv"],"title":"opencv DNN 模块","uri":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":" Mat 成员变量 Mat 通道理解 通道 图像类型的转换与显示 通道的合成与分解 创建一个Mat Scalar cv::Mat::ones cv::Mat::zeros cv::Mat::eye Mat类中数据部分组成 参考 Mat The class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms may be better stored in a SparseMat ). 上面的一段话引用自官方的文档，Mat类用于表示一个多维的单通道或者多通道的稠密数组。能够用来保存实数或复数的向量、矩阵，灰度或彩色图像，立体元素，点云，张量以及直方图（高维的直方图使用SparseMat保存比较好）。简而言之，Mat就是用来保存多维的矩阵的。 成员变量 data: uchar型的指针。Mat类分为了两个部分:矩阵头和指向矩阵数据部分的指针，data就是指向矩阵数据的指针。 dims: 矩阵的维度，例如5*6矩阵是二维矩阵，则dims=2，三维矩阵dims=3. rows: 矩阵的行数 cols: 矩阵的列数 size: 矩阵的大小，size(cols,rows),如果矩阵的维数大于2，则是size(-1,-1) channels: 矩阵元素拥有的通道数，例如常见的彩色图像，每一个像素由BGR三部分组成，则channels = 3。 type: 表示了矩阵中元素的类型以及矩阵的通道个数，它是一系列的预定义的常量，其命名规则为CV_(位数）+（数据类型）+（通道数）。这里U（unsigned integer）表示的是无符号整数，S（signed integer）是有符号整数，F（float）是浮点数。 例如：CV_16UC2，表示的是元素类型是一个16位的无符号整数，通道为2. C1，C2，C3，C4则表示通道是1,2,3,4。type一般是在创建Mat对象时设定，如果要取得Mat的元素类型，则无需使用type，使用下面的depth depth :矩阵中元素的一个通道的数据类型，这个值和type是相关的。 例如 type为 CV_16SC2，一个2通道的16位的有符号整数。那么，depth则是CV_16S。depth也是一系列的预定义值，将type的预定义值去掉通道信息就是depth值:CV_8U CV_8S CV_16U CV_16S CV_32S CV_32F CV_64F elemSize :矩阵一个元素占用的字节数，例如：type是CV_16SC3，那么elemSize = 3 * 16 / 8 = 6 bytes elemSize1:矩阵元素一个通道占用的字节数，例如：type是CV_16CS3，那么elemSize1 = 16 / 8 = 2 bytes = elemSize / channels Mat 通道理解 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:0:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"通道 一个图像的通道数是N，就表明每个像素点处有N个数，一个a×b的N通道图像，其图像矩阵实际上是b行N×a列的数字矩阵。 OpenCV中图像的通道可以是1、2、3和4。其中常见的是1通道和3通道，2通道和4通道不常见。 1通道的是灰度图。 3通道的是彩色图像，比如RGB图像。 4通道的图像是RGBA，是RGB加上一个A通道，也叫alpha通道，表示透明度。PNG图像是一种典型的4通道图像。alpha通道可以赋值0到1，或者0到255，表示透明到不透明。 2通道的图像是RGB555和RGB565。2通道图在程序处理中会用到，如傅里叶变换，可能会用到，一个通道为实数，一个通道为虚数，主要是编程方便。RGB555是16位的，2个字节，5+6+5，第一字节的前5位是R，后三位+第二字节是G，第二字节后5位是B，可见对原图像进行压缩了。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:1:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"图像类型的转换与显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Mat image=imread(\"../images/RGB.jpg\"); Mat imageGRAY,imageRGBA,imageRGB555; cvtColor(image,imageGRAY,CV_RGB2GRAY); //RGB转GRAY cvtColor(image,imageRGBA,CV_RGB2BGRA); //RGB转RGBA cvtColor(image,imageRGB555,CV_RGB2BGR555); //RGB转RGB555 //来看看通道数 int n = image.channels(); //n=3 int nGRAY = imageGRAY.channels(); //nGRAY = 1 int nRGBA = imageRGBA.channels(); //nRGBA = 4 int nRGB555 = imageRGB555.channels(); //nRGB555 = 2 cout \u003c\u003c \"n: \" \u003c\u003c n \u003c\u003c \" nGRAY: \" \u003c\u003c nGRAY \u003c\u003c \" nRGBA: \" \u003c\u003c nRGBA \u003c\u003c \" nRGB555: \" \u003c\u003c nRGB555 \u003c\u003c endl; //显示GRAY、RGB和RGBA图像 imshow(\"image\",image); imshow(\"imageGRAY\",imageGRAY); imshow(\"imageRGBA\",imageRGBA); //imshow(\"imageRGB555\",imageRGB555); //无法显示 RGB转GRAY是根据一个心理学公式来的：Gray = R0.299 + G0.587 + B*0.114 RGB转GRBA，默认A通道的数值是255，也就是不透明的。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:2:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"通道的合成与分解 分解 1 2 C++: void split(const Mat\u0026 mtx, Mat* mv) C++: void split(const Mat\u0026 mtx, vector\u003cMat\u003e\u0026 mv) 参数：mtx 输入矩阵 mv 输出矩阵或矩阵数组 src 输入矩阵 dst0、dst1、dst2、dst3 最多4个单通道的输出矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void Mat_split(void) { Mat rgb(3, 4, CV_8UC3, Scalar(1, 2, 3, 4)); //这里 由于类型是 CV_8UC3 Scalar 第四个值没有用 vector\u003cMat\u003e channels; split(rgb, channels); Mat R = channels.at(0); //从vector中读数据用vector::at() Mat G = channels.at(1); Mat B = channels.at(2); cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c rgb \u003c\u003c endl; cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"G=\" \u003c\u003c endl \u003c\u003c G \u003c\u003c endl; cout \u003c\u003c \"B=\" \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 RGB= [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] R= [ 1, 1, 1, 1; 1, 1, 1, 1; 1, 1, 1, 1] G= [ 2, 2, 2, 2; 2, 2, 2, 2; 2, 2, 2, 2] B= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] 合成 1 2 C++: void merge(const Mat* mv, size_t count, OutputArray dst) C++: void merge(const vector\u003cMat\u003e\u0026 mv, OutputArray dst) 参数：mv 输入矩阵 count 当mv是C形式的array时，count表示输入矩阵个数 dst 输出矩阵 src0、src1、src2、src3 最多4个单通道的输入矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Mat_merge(void) { Mat R(3, 4, CV_8UC1, Scalar(3)); Mat G(3, 4, CV_8UC1, Scalar(2)); Mat B(3, 4, CV_8UC1, Scalar(1)); Mat RGB(3, 4, CV_8UC3); vector\u003cMat\u003e src; src.push_back(R); //往vector里存数据要用vector::push_back() src.push_back(G); src.push_back(B); merge(src, RGB); cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"G=\" \u003c\u003c endl \u003c\u003c G \u003c\u003c endl; cout \u003c\u003c \"B=\" \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c RGB \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 R= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] G= [ 2, 2, 2, 2; 2, 2, 2, 2; 2, 2, 2, 2] B= [ 1, 1, 1, 1; 1, 1, 1, 1; 1, 1, 1, 1] RGB= [ 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1; 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1; 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1] split( )和merge( )都是mixChannels( )的特例 1 2 C++: void mixChannels(const Mat* src, int nsrc, Mat* dst, int ndst, const int* fromTo, size_t npairs) C++: void mixChannels(const vector\u003cMat\u003e\u0026 src, vector\u003cMat\u003e\u0026 dst, const int* fromTo, int npairs) 参数：src 输入的矩阵，可以是一个矩阵也可以是多个矩阵构成的vector nsrc 输入矩阵的个数 dst 输出矩阵，可以是一个矩阵也可以是多个矩阵构成的vector ndst 输出矩阵的个数 fromTo src到dst通道对应数组 npairs fromTo中有几组对应关系 mixChannels( )本质是改变了几个通道的顺序，输入一共有几个通道，输出肯定也有几个通道，所以定义fromTo时，要知道有多少个通道，而且通道的编号一定是0,1,2，… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void Mat_mixchannels(void) { Mat RGB(3, 4, CV_8UC3, Scalar(1, 2, 3, 4)); Mat A(3, 4, CV_8UC1, Scalar(6)); cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c RGB \u003c\u003c endl; cout \u003c\u003c \"A=\" \u003c\u003c endl \u003c\u003c A \u003c\u003c endl; //RGB+A合成为RGBA cout \u003c\u003c \"RGB+A合成为RGBA\" \u003c\u003c endl; Mat RGBA(3, 4, CV_8UC4); Mat in[] = {RGB, A}; int fromTo1[] = {0, 0, 1, 1, 2, 2, 3, 3}; mixChannels(in, 2, \u0026RGBA, 1, fromTo1, 4); cout \u003c\u003c \"RGBA=\" \u003c\u003c endl \u003c\u003c RGBA \u003c\u003c endl; //RGB分解为R+GB cout \u003c\u003c \"RGB分解为R+GB\" \u003c\u003c endl; Mat R(3, 4, CV_8UC1); Mat GB(3, 4, CV_8UC2); Mat out[] = {R, GB}; int fromTo2[] = {0, 2, 1, 1, 2, 0}; mixChannels(\u0026RGB, 1, out, 2, fromTo2, 3); cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"GB=\" \u003c\u003c endl \u003c\u003c GB \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 RGB= [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] A= [ 6, 6, 6, 6; 6, 6, 6, 6; 6, 6, 6, 6] RGB+A合成为RGBA RGBA= [ 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6; 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6; 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6] RGB分解为R+GB R= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] GB= [ 2, 1, 2, 1, 2, 1, 2, 1; 2, 1, 2, 1, 2, 1, 2, 1; 2, 1, 2, 1, 2, 1, 2, 1] 创建一个Mat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Mat_demo() { cv::Mat M(2, 2, CV_8UC3, Scalar(0, 0, 255)); cout \u003c\u003c M \u003c\u003c endl; cv::Mat Z = cv::Mat::zeros(3, 3, CV_64F); cout \u003c\u003c Z \u003c\u003c endl; cv::Mat F = cv::Mat::ones(2, 2, CV_64F); cout \u003c\u003c F \u003c\u003c endl; cv::Mat M0(1,2,CV_8UC3); cout \u003c\u003c M0 \u003c\u003c endl; float K[3][3] = {1, 0, 1, 0, 1, 1, 0, 0, 1}; cv::Mat M1 = cv::Mat(3,3,CV_32FC1,K); cout \u003c\u003c M1 \u003c\u003c end","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:3:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"Scalar Scalar是一个由长度为4的数组作为元素构成的结构体，Scalar最多可以存储四个值，没有提供的值默认是0。 1 2 3 4 typedef struct Scalar { double val[4]; }Scalar; 1 2 3 4 5 6 7 8 9 // 创建一个2通道，且每个通道的值都为（1,3），深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC2, Scalar(1, 3)); /* [1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3] */ 1 2 3 4 5 6 7 8 9 // 创建一个3通道，且每个通道的值都为（1,2,3），深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC3, Scalar(1, 2, 3)); /* [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] */ 1 2 3 4 5 6 7 8 9 // 创建一个4通道，且每个通道的值都为（1,2,3,0）(默认为0)，深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC4, Scalar(1, 2, 3)); /* [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0] */ 1 2 3 4 5 6 7 8 9 10 11 12 Mat blue_m(256, 256, CV_8UC3, Scalar(255, 0, 0)); //cout\u003c\u003cblue_m\u003c\u003cendl; Mat green_m(256, 256, CV_8UC3, Scalar(0, 255, 0)); //cout\u003c\u003cgreen_m\u003c\u003cendl; Mat red_m(256, 256, CV_8UC3, Scalar(0, 0, 255)); //cout\u003c\u003cred_m\u003c\u003cendl; Mat previewImg(256, 256, CV_8UC3); //CV_EXPORTS void hconcat(InputArray src1, InputArray src2, OutputArray dst); hconcat(blue_m, green_m, previewImg); hconcat(previewImg, red_m, previewImg); imshow(\"previewImg\", previewImg); waitKey(0); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:4:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::ones 1 Mat m = Mat::ones(2, 2, CV_8UC3); 相当于：Mat m = Mat(2, 2, CV_8UC3, 1); // OpenCV replaces 1 with Scalar(1,0,0)相当于每个像素的第一个通道为1，其余两个通道为0； 1 2 3 4 5 6 7 cv::Mat F = cv::Mat::ones(3, 3, CV_64F); cout \u003c\u003c F \u003c\u003c endl; /* [1, 1, 1; 1, 1, 1; 1, 1, 1] */ ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:5:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::zeros Mat m = Mat::zeros(2, 2, CV_8UC3); //相当于创建一张黑色的图，每个像素的每个通道都为0,Scalar(0,0,0)； 1 2 3 4 5 6 7 cv::Mat Z = cv::Mat::zeros(3, 3, CV_64F); cout \u003c\u003c Z \u003c\u003c endl; /* [0, 0, 0; 0, 0, 0; 0, 0, 0] */ ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:6:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::eye 1 2 3 4 5 6 7 cv::Mat Y = cv::Mat::eye(3, 3, CV_64F); cout \u003c\u003c Y \u003c\u003c endl; /* [1, 0, 0; 0, 1, 0; 0, 0, 1] */ Mat类中数据部分组成 矩阵头：包括矩阵尺寸、存储方法、存储地址等。 指针：该指针指向存储所有像素值的矩阵。 因为图片的数据量比较大，所以OpenCV中的Mat定义都是只申请了矩阵头和指针，尽量避免对指针指向的内容进行拷贝操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void Mat_demo1() { Mat A, C; // Identify header only cout \u003c\u003c \"sizeof(A): \" \u003c\u003c sizeof(A) \u003c\u003c \"; sizeof(C): \" \u003c\u003c sizeof(C) \u003c\u003c endl; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; A = Mat::ones(Size(3, 3), CV_8UC1); C = A; cout \u003c\u003c \"sizeof(A): \" \u003c\u003c sizeof(A) \u003c\u003c \"; sizeof(C): \" \u003c\u003c sizeof(C) \u003c\u003c endl; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; Mat B(A); cout \u003c\u003c \"B:\\n\" \u003c\u003c B \u003c\u003c endl; B.at\u003cuchar\u003e(1, 1) = 255; cout \u003c\u003c \"C:\\n\" \u003c\u003c C \u003c\u003c endl; Mat D = A.clone(); cout \u003c\u003c \"D:\\n\" \u003c\u003c D \u003c\u003c endl; D.at\u003cuchar\u003e(0, 0) = 123; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; cout \u003c\u003c \"D:\\n\" \u003c\u003c D \u003c\u003c endl; Mat E; A.copyTo(E); cout \u003c\u003c \"E:\\n\" \u003c\u003c E \u003c\u003c endl; E.at\u003cuchar\u003e(2, 2) = 100; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; cout \u003c\u003c \"E:\\n\" \u003c\u003c E \u003c\u003c endl; } Mat类型的变量定义以及赋值分为： 公用一个数据块 1 2 = 构造函数 不公用一个数据块 1 2 clone copyto 参考 OpenCV CV_RGB2GRAY与CV_BGR2GRAY的区别 学习OpenCV2——Mat之通道的理解 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:7:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 convertTo / cvtColor convertTo cvtColor setTo 直方图均衡化 均值滤波blur 边缘检测Sobel 笛卡尔坐标转极坐标cartToPolar OpenCV中的阈值(threshold)函数 资料 gitbook learn opencv OpenCV:知乎 convertTo / cvtColor 不是所有格式的Mat型数据都能被使用保存为图片，目前OpenCV主要只支持单通道和3通道的图像，并且此时要求其深度为8bit和16bit无符号(即CV_16U)，所以其他一些数据类型是不支持的，比如说float型等。 如果Mat类型数据的深度和通道数不满足上面的要求，则需要使用convertTo()函数和cvtColor()函数来进行转换。 convertTo()函数负责转换数据类型不同的Mat，即可以将类似float型的Mat转换到imwrite()函数能够接受的类型。 cvtColor()函数是负责转换不同通道的Mat，因为该函数的第4个参数就可以设置目的Mat数据的通道数（只是我们一般没有用到它，一般情况下这个函数是用来进行色彩空间转换的）。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"convertTo 图像的对比度和亮度的调整 : dst = alpha * src + beta （alpha控制对比度，beta控制亮度） 1 2 3 4 5 6 7 8 9 //! converts matrix to another datatype with optional scalng. See cvConvertScale. void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const; cv::Mat samples; cv::Mat tdata; samples.convertTo(tdata, CV_32FC1); convertTo(depth_vis, CV_8UC1, 1.0 / 255, 0); 缩放并转换到另外一种数据类型： dst：目的矩阵 type：需要的输出矩阵类型，或者更明确的，是输出矩阵的深度，如果是负值（常用-1）则输出矩阵和输入矩阵类型相同 scale和shift：缩放参数，也可以写为alpha和beta 这个命令也等价于下面的转换公式： m(x,y) = saturate_cast(α(*this)(x,y)+β) 如果scale=1，shift=0，则不进行比例缩放。 如果输入数组与输出数组的类型相同，则函数可以被用于缩放和平移矩阵或图像； ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"cvtColor 1 2 3 4 5 6 7 8 9 10 11 12 cv.cvtColor(src, code[, dst[, dstCn]] void cv::cvtColor ( InputArray src, OutputArray dst, int code, int dstCn = 0 ) //RGB图，转换成灰度图 cv.cvtColor(img, cv.COLOR_BGR2GRAY) //灰度图，转换成RGB图 cv::cvtColor(depth_vis, frame-\u003evis_data, CV_GRAY2BGR); cvtColor RGB转成其他格式时，需要注意RGB图像的三个通道的顺序，是RGB还是BGR.大部分情况下opencv为RGB,但实际上是BGR,这一点需要注意。 需要注意各个值的范围： CV_8U图像 其通道值范围为0到255 CV_16U时其值通道值范围为0到65535 CV_32F时，其通道值范围为0到1 在线性转换时，其范围没有较大关系，但是如果是非线性转换，RGB图像需要做正确的归一化，以扩展到响应的范围。例如TGB-\u003eLUV转换，如果32位的浮点图像之间是由8位的图像转换而来，那么将0到255的范围转换成0,1，那么转换之前首先需要需要所需其图像。 1 2 img *= 1./255; cvtColor(img, img, COLOR_BGR2Luv); setTo 1 2 3 4 5 6 7 /** @brief Sets all or some of the array elements to the specified value. This is an advanced variant of the Mat::operator=(const Scalar\u0026 s) operator. @param value Assigned scalar converted to the actual array type. @param mask Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels */ Mat\u0026 setTo(InputArray value, InputArray mask=noArray()); 说明： 1、功能：把矩阵mask中元素不为0的点全部变为value值； 2、当默认不添加mask的时候，表明mask是一个与原图尺寸大小一致的且元素值全为非0的矩阵，因此不加mask的时候，会将原矩阵的像素值全部赋值为value； 1 2 3 4 Mat src(3, 3, CV_8UC1); Mat mask(3, 3, CV_8UC1, Scalar(0)); src.setTo(100, mask); cout \u003c\u003c src \u003c\u003c endl; [ 0, 0, 0; 0, 0, 0; 0, 0, 0] 1 2 3 4 Mat src(3, 3, CV_8UC1); Mat mask(3, 3, CV_8UC1, Scalar(5)); src.setTo(100, mask); cout \u003c\u003c src \u003c\u003c endl; [100, 100, 100; 100, 100, 100; 100, 100, 100] 直方图均衡化 均值滤波blur 均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点，去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。 opencv提供了blur函数实现均值滤波操作，其原型如下： 1 void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT ) 参数解释： . InputArray src: 输入图像，可以是Mat类型，图像深度是CV_8U、CV_16U、CV_16S、CV_32F以及CV_64F其中的某一个。 . OutputArray dst: 输出图像，深度和类型与输入图像一致 . Size ksize: 滤波模板kernel的尺寸，一般使用Size(w, h)来指定，如Size(3,3) . Point anchor=Point(-1, -1): 字面意思是锚点，也就是处理的像素位于kernel的什么位置，默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改 . int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT 边缘检测Sobel 检测边缘:以灰度图像为例，它的理论基础是这样的:如果出现一个边缘，那么图像的灰度就会有一定的变化。为了方便假设由黑渐变为白代表一个边界，那么对其灰度分析，在边缘的灰度函数就是一个一次函数y=kx，对其求一阶导数就是其斜率k，就是说边缘的一阶导数是一个常数，而由于非边缘的一阶导数为零，这样通过求一阶导数就能初步判断图像的边缘了。通常是X方向和Y方向的导数，也就是梯度。计算机就是通过这种方式来获得图像的边缘。 1 void cvSobel( const CvArr* src, CvArr* dst, int xorder, int yorder, intaperture_size=3 ); src：输入图像； dst：输出图像； xorder：x方向上的差分阶数； yorder：y方向上的差分阶数； aperture_size扩展Sobel核的大小（既窗口阶数），必须是1（注意这是一个3×1或1×3向量而不是一个方阵）,3, 5 或7。 笛卡尔坐标转极坐标cartToPolar 直角坐标系转为极坐标系。 1 2 3 4 5 6 7 void cv::cartToPolar( cv::InputArray x, cv::InputArray y, cv::OutputArray magnitude, cv::OutputArray angle, bool angleInDegrees = false ); OpenCV中的阈值(threshold)函数 OpenCV中提供了阈值化函数threshold，该函数原型如下： 1 2 3 4 5 double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type); 参数说明： src ： 表示输入图像 dst : 表示输出图像（尺寸和类型和输入图像一样） thresh : 表示阈值 maxval : 表示预设最大值 type : 表示阈值化处理的类型设置（type类型有一下几种） THRESH_BINARY表示大于thresh的取maxval,否则取0; THRESH_BINARY_INV表示大于thresh的取0,否则取maxvalue; THRESH_TRUNC表示大于thresh取threshold,否则不改变灰度值; THRESH_TOZERO表示大于thresh的不改变灰度值,否则取0; THRESH_TOZERO_INV表示大于thresh取0,窦泽不改变灰度值; THRESH_OTSU表示使用otsu自动计算阈值; THRESH_TRIANGLE表示使用Triangle自动计算阈值; 基本的阈值操作 OpenCV基础——threshold函数的使用 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","tags":["opencv"],"title":"opencv 常用操作","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["开源软件"],"content":"unsigned char* 转换为 Mat类型 1 cv::Mat mmat = cv::Mat(stFrameInfo.nHeight, stFrameInfo.nWidth, CV_8UC1, stImageInfo.pBufAddr, 0); BYTE* 转换为 Mat类型 1 2 3 cv::Mat sMat = Mat(sFrameHead.iHeight, sFrameHead.iWidth, CV_8UC1);; int nLen = sMat.rows * sMat.cols * sMat.channels(); memcpy(sMat.data, m_pFrameBuffer, nLen); Mat转unsigned char* 1 unsigned char pdata= srcMat.data; // Mat =\u003e unsigned char box 渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void BoxVisualization(cv::Mat frame, int tl_x, int tl_y, int br_x, int br_y, int label, float score) { // 渲染box int fontface = cv::FONT_HERSHEY_SIMPLEX; int thickness = 1; float fontScale = 0.5; int baseline = 0; cv::Scalar color(140, 199, 0); cv::Rect box((int)tl_x, (int)tl_y, (int)(br_x - tl_x), (int)(br_y - tl_y)); cv::rectangle(frame, box, color, 2, 8, 0); cv::String label_str = cv::format(\"l %d, s: %.2f\", label, score); cv::Size fontSize = cv::getTextSize(label_str, fontface, fontScale, thickness, \u0026baseline); cv::rectangle(frame, cv::Size(box.tl().x, box.tl().y - fontSize.height - baseline), cv::Size(box.tl().x + fontSize.width, box.tl().y), cv::Scalar(34, 43, 59), -1, 8); cv::putText(frame, label_str, cv::Point(box.tl().x, box.tl().y - baseline), fontface, fontScale, cv::Scalar(255, 0, 255), thickness, 8); } 画圆 1 2 3 4 5 6 7 void Visualization(cv::Mat frame, int tl_x, int tl_y, int br_x, int br_y) { // 渲染box cv::Point circle_point((br_x + tl_x) / 2, (br_y + tl_y) / 2); int len = std::min((br_y - tl_y) / 2, (br_x - tl_x) / 2); cv::circle(frame, circle_point, len, cv::Scalar(255, 0, 0), 4); } 常用颜色定义 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:0:0","tags":["opencv"],"title":"opencv 常用操作","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 常用到的算子 1. cv::abs() 2. cv::add() 3. cv::addWeighted() 4. cv::bitwise_and() 5. cv::bitwise_not() 6. cv::bitwise_or() 7. cv::bitwise_xor() 8. cv::calcCovarMatrix() 9. cv::cartToPolar() 10. cv::checkRange() 11. cv::compare() 12. cv::completeSymm() 13. cv::convertScaleAbs() 14. cv::countNonZero() 15. cv::cvarrToMat() 16. cv::dct() 17. cv::dft() 18. cv::cvtColor() 19. cv::determinant() 20. cv::divide() 21. cv::eigen() 22. cv::exp() 23. cv::flip() 24. cv::gemm() 25. cv::idct() 26. cv::idft() 27. cv::inRange() 28. cv::invert() 29. cv::log() 30. cv::magnitude() 31. cv::Mahalanobis() 32. cv::max() 33. cv::min() 34. cv::mean() 35. cv::meanStdDev() 36. cv::merge() 37. cv::split() 38. cv::minMaxIdx() 39. cv::minMaxLoc() 40. cv::mixChannels() 41. cv::multiply() 42. cv::mulTransposed() 43. cv::norm() 44. cv::normalize() 45. cv::perspectiveTransform() 46. cv::phase() 47. cv::polarToCart() 48. cv::pow() 49. cv::randu() 50. cv::randn() 51. cv::repeat() 52. cv::scaleAdd() 53. cv::setIdentity() 54. cv::solve() 55. cv::solveCubic() 56. cv::solvePoly() 57. cv::sort() 58. cv::sortIdx() 59. cv::sqrt() 60 cv::subtract() 61. cv::sum() 62. cv::trace() 63. cv::transform() 64. cv::transpose() 常用到的算子 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:0:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"1. cv::abs() 计算矩阵的绝对值 1 2 cv::MatExpr cv::abs( cv::InputArray src ); cv::MatExpr cv::abs( const cv::MatExpr\u0026 src ); // Matrix expression ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:1:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"2. cv::add() 计算矩阵src1和src2的加和，并把结果存放在dst中。 1 2 3 4 5 6 7 void cv::add( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:2:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"3. cv::addWeighted() 该函数和上一个add()函数比较类似，是根据下面公式将结果写入dst中。可用于图像混合。 1 2 3 4 5 6 7 8 9 void cv::addWeighted( cv::InputArray src1, // First input array double alpha, // Weight for first input array cv::InputArray src2, // Second input array double beta, // Weight for second input array double gamma, // Offset added to weighted sum cv::OutputArray dst, // Result array int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:3:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"4. cv::bitwise_and() 逐元素按位与操作。 1 2 3 4 5 6 void cv::bitwise_and( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:4:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"5. cv::bitwise_not() 逐元素按位取反操作。 1 2 3 4 5 void cv::bitwise_not( cv::InputArray src, // Input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:5:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"6. cv::bitwise_or() 逐元素按位取或操作。 1 2 3 4 5 6 void cv::bitwise_or( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:6:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"7. cv::bitwise_xor() 逐元素按位异或操作。 1 2 3 4 5 6 void cv::bitwise_xor( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:7:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"8. cv::calcCovarMatrix() 给定一些向量，假设向量表示的点是近似的高斯分布，，那么该函数将计算这些点的均值和协方差矩阵。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::calcCovarMatrix( const cv::Mat* samples, // C-array of n-by-1 or 1-by-n matrices int nsamples, // num matrices pointed to by 'samples' cv::Mat\u0026 covar, // ref to return array for covariance cv::Mat\u0026 mean, // ref to return array for mean int flags, // special variations, see Table bellow. int ctype = cv::F64 // output matrix type for covar ); void cv::calcCovarMatrix( cv::InputArray samples, // n-by-m matrix, but see 'flags' below cv::Mat\u0026 covar, // ref to return array for covariance cv::Mat\u0026 mean, // ref to return array for mean int flags, // special variations. int ctype = cv::F64 // output matrix type for covar ); 该函数有两种调用方式，如上codes。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:8:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"9. cv::cartToPolar() 直角坐标系转为极坐标系。 1 2 3 4 5 6 7 void cv::cartToPolar( cv::InputArray x, cv::InputArray y, cv::OutputArray magnitude, cv::OutputArray angle, bool angleInDegrees = false ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:9:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"10. cv::checkRange() 检查src中每个元素是否在给定的范围之内。范围有minVal和maxVal设置。除非将quiet设置为true，否则抛出异常。如果都在范围内，则返回true，否则将返回false，并将第一个异常值的位置存放在pos中。 1 2 3 4 5 6 7 bool cv::checkRange( cv::InputArray src, bool quiet = true, cv::Point* pos = 0, // if non-Null, location of first outlier double minVal = -DBL_MAX, // Lower check bound (inclusive) double maxVal = DBL_MAX // Upper check bound (exclusive) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:10:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"11. cv::compare() 逐元素比较src1和src2，并将比较结果放在dst中,匹配标记为255，否则设置为0。 1 2 3 4 5 6 bool cv::compare( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array int cmpop // Comparison operator. ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:11:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"12. cv::completeSymm() 将矩阵mtx通过复制使其对称，默认情况下将上三角的所有元素都被复制到下三角对应转置的位置上，对角元素不变。如果lowerToUpper = true，那么则将下三角复制到上三角位置。 1 2 3 4 bool cv::completeSymm( cv::InputArray mtx, bool lowerToUpper = false ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:12:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"13. cv::convertScaleAbs() 该函数按照如下公式进行转换原图像。实现对原图像像素值的缩放和平移。 1 2 3 4 5 6 void cv::convertScaleAbs( cv::InputArray src, // Input array cv::OutputArray dst, // Result array double alpha = 1.0, // Multiplicative scale factor double beta = 0.0 // Additive offset factor ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:13:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"14. cv::countNonZero() 返回矩阵mtx中非零元素的个数。 1 2 3 int cv::countNonZero( // Return number of nonzero elements in mtx cv::InputArray mtx, // Input array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:14:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"15. cv::cvarrToMat() 将旧版本的图像格式转为Mat类图像。 1 2 3 4 5 6 cv::Mat cv::cvarrToMat( const CvArr* src, // Input array: CvMat, IplImage, or CvMatND bool copyData = false, // if false just make new header, else copy data bool allowND = true, // if true and possible, convert CvMatND to Mat int coiMode = 0 // if 0: error if COI set, if 1: ignore COI ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:15:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"16. cv::dct() 根据flags执行离散余弦变换或者离散余弦逆变换。 1 2 3 4 5 void cv::dct( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags, // for inverse transform or row-by-row ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:16:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"17. cv::dft() 实现离散傅里叶变换及其逆变换。 1 2 3 4 5 6 void cv::dft( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags = 0, // for inverse transform or row-by-row int nonzeroRows = 0 // only this many entries are nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:17:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"18. cv::cvtColor() 保留相同数据类型的同时将图像从一个颜色空间转换到另一个颜色空间。 1 2 3 4 5 6 void cv::cvtColor( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int code, // color mapping code, see Table 5-4. int dstCn = 0 // channels in output (0='automatic') ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:18:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"19. cv::determinant() 计算一个方阵的行列式。 1 2 3 double cv::determinant( cv::InputArray mat ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:19:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"20. cv::divide() 将src1或scale中的元素除以src2中相应的元素，然后将结果放在dst中。 1 2 3 4 5 6 7 8 9 10 11 12 13 void cv::divide( cv::InputArray src1, // First input array (numerators) cv::InputArray src2, // Second input array (denominators) cv::OutputArray dst, // Results array (scale*src1/src2) double scale = 1.0, // Multiplicative scale factor int dtype = -1 // dst data type, -1 to get from src2 ); void cv::divide( double scale, // Numerator for all divisions cv::InputArray src2, // Input array (denominators) cv::OutputArray dst, // Results array (scale/src2) int dtype = -1 // dst data type, -1 to get from src2 ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:20:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"21. cv::eigen() 计算矩阵的特征向量和特征值。 1 2 3 4 5 6 7 8 9 10 11 12 13 bool cv::eigen( cv::InputArray src, cv::OutputArray eigenvalues, int lowindex = -1, int highindex = -1 ); bool cv::eigen( cv::InputArray src, cv::OutputArray eigenvalues, cv::OutputArray eigenvectors, int lowindex = -1, int highindex = -1 ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:21:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"22. cv::exp() 计算src中所有元素的指数，并将结果存放在dst中。 1 2 3 4 void cv::exp( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:22:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"23. cv::flip() 绕x轴或者y轴旋转。 1 2 3 4 5 void cv::flip( cv::InputArray src, // Input array cv::OutputArray dst, // Result array, size and type of 'src' int flipCode = 0 // \u003e0: y-flip, 0: x-flip, \u003c0: both ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:23:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"24. cv::gemm() 广义矩阵乘法（GEMM）。 1 2 3 4 5 6 7 8 9 void cv::gemm( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array double alpha, // Weight for 'src1' * 'src2' product cv::InputArray src3, // Third (offset) input array double beta, // Weight for 'src3' array cv::OutputArray dst, // Results array int flags = 0 // Use to transpose source arrays ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:24:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"25. cv::idct() 离散余弦逆变换，相当于调用带参数的dct()。 1 2 3 4 5 void cv::idct( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags, // for row-by-row ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:25:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"26. cv::idft() 离散傅里叶逆变换，相当于调用带参数的dft()。 1 2 3 4 5 6 void cv::idft( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags = 0, // for row-by-row, etc. int nonzeroRows = 0 // only this many entries are nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:26:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"27. cv::inRange() 判断src中的元素是否在upperb和lowerb之间，满足置为255，否则0。 1 2 3 4 5 6 void cv::inRange( cv::InputArray src, // Input array cv::InputArray upperb, // Array of upper bounds (inclusive) cv::InputArray lowerb, // Array of lower bounds (inclusive) cv::OutputArray dst // Result array, cv::U8C1 type ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:27:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"28. cv::invert() 求矩阵的逆。 1 2 3 4 5 double cv::invert( // Return 0 if 'src' is singular cv::InputArray src, // Input Array, m-by-n cv::OutputArray dst // Result array, n-by-m int method = cv::DECOMP_LU // Method for (pseudo) inverse ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:28:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"29. cv::log() 求原图像的自然对数。 1 2 3 4 void cv::log( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:29:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"30. cv::magnitude() 计算直角坐标系转换成极坐标系的幅值。 1 2 3 4 5 void cv::magnitude( cv::InputArray x, cv::InputArray y, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:30:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"31. cv::Mahalanobis() 计算两个向量的马氏距离。 1 2 3 4 5 cv::Size cv::mahalanobis( cv::InputArray vec1, cv::InputArray vec2, cv::OutputArray icovar ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:31:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"32. cv::max() 计算矩阵src1和src2中每个对应的像素对的最大值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cv::MatExpr cv::max( const cv::Mat\u0026 src1, // First input array (first position) const cv::Mat\u0026 src2 // Second input array ); MatExpr cv::max( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array (first position) double value // Scalar in second position ); MatExpr cv::max( // A matrix expression, not a matrix double value, // Scalar in first position const cv::Mat\u0026 src1 // Input array (second position) ); void cv::max( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst // Result array ); void cv::max( const Mat\u0026 src1, // First input array const Mat\u0026 src2, // Second input array Mat\u0026 dst // Result array ); void cv::max( const Mat\u0026 src1, // Input array double value, // Scalar input Mat\u0026 dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:32:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"33. cv::min() 计算矩阵src1和src2中每个对应的像素对的最小值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cv::MatExpr cv::min( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array const cv::Mat\u0026 src2 // Second input array ); MatExpr cv::min( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array (first position) double value // Scalar in second position ); MatExpr cv::min( // A matrix expression, not a matrix double value, // Scalar in first position const cv::Mat\u0026 src1 // Input array (second position) ); void cv::min( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst // Result array ); void cv::min( const Mat\u0026 src1, // First input array const Mat\u0026 src2, // Second input array Mat\u0026 dst // Result array ); void cv::min( const Mat\u0026 src1, // Input array double value, // Scalar input Mat\u0026 dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:33:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"34. cv::mean() 计算src矩阵的均值。 1 2 3 4 cv::Scalar cv::mean( cv::InputArray src, cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:34:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"35. cv::meanStdDev() 计算矩阵的均值和标准差。 1 2 3 4 5 6 void cv::meanStdDev( cv::InputArray src, cv::OutputArray mean, cv::OutputArray stddev, cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:35:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"36. cv::merge() 将多个二维矩阵合并成一个多维矩阵。 1 2 3 4 5 6 7 8 9 void cv::merge( const cv::Mat* mv, // C-style array of arrays size_t count, // Number of arrays pointed to by 'mv' cv::OutputArray dst // Contains all channels in 'mv' ); void merge( const vector\u003ccv::Mat\u003e\u0026 mv, // STL-style array of arrays cv::OutputArray dst // Contains all channels in 'mv' ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:36:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"37. cv::split() 将多通道矩阵拆分成多个单通道矩阵。 1 2 3 4 5 6 7 8 void cv::split( const cv::Mat\u0026 mtx, cv::Mat* mv ); void cv::split( const cv::Mat\u0026 mtx, vector\u003cMat\u003e\u0026 mv // STL-style vector of n 1-channel cv::Mat's ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:37:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"38. cv::minMaxIdx() 计算单通道矩阵的最大最小值，并返回其位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::minMaxIdx( cv::InputArray src, // Input array, single channel only double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) int* minIdx, // loc of min goes here (if not NULL) int* maxIdx, // loc of max goes here (if not NULL) cv::InputArray mask = cv::noArray() // search only nonzero values ); void cv::minMaxIdx( const cv::SparseMat\u0026 src, // Input sparse array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) int* minIdx, // C-style array, indices of min locs int* maxIdx, // C-style array, indices of max locs ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:38:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"39. cv::minMaxLoc() 计算矩阵的最大最小值，并返回其位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::minMaxLoc( cv::InputArray src, // Input array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) cv::Point* minLoc, // loc of min goes here (if not NULL) cv::Point* maxLoc, // loc of max goes here (if not NULL) cv::InputArray mask = cv::noArray() // search only nonzero values ); void cv::minMaxLoc( const cv::SparseMat\u0026 src, // Input sparse array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) cv::Point* minLoc, // C-style array, indices of min locs cv::Point* maxLoc, // C-style array, indices of max locs ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:39:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"40. cv::mixChannels() 对于输入图像的通道按照给定的顺序重新组合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void cv::mixChannels( const cv::Mat* srcv, // C-style array of matrices int nsrc, // Number of elements in 'srcv' cv::Mat* dstv, // C-style array of target matrices int ndst, // Number of elements in 'dstv' const int* fromTo, // C-style array of pairs, ...from,to... size_t n_pairs // Number of pairs in 'fromTo' ); void cv::mixChannels( const vector\u003ccv::Mat\u003e\u0026 srcv, // STL-style vector of matrices vector\u003ccv::Mat\u003e\u0026 dstv, // STL-style vector of target matrices const int* fromTo, // C-style array of pairs, ...from,to... size_t n_pairs // Number of pairs in 'fromTo' ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:40:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"41. cv::multiply() 矩阵对应元素相乘。 1 2 3 4 5 6 7 void cv::multiply( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array double scale = 1.0, // overall scale factor int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:41:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"42. cv::mulTransposed() 矩阵和其转置的乘积。 1 2 3 4 5 6 7 8 void cv::mulTransposed( cv::InputArray src1, // Input matrix cv::OutputArray dst, // Result array bool aTa, // If true, transpose then multiply cv::InputArray delta = cv::noArray(), // subtract from 'src1' before multiply double scale = 1.0, // overall scale factor int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:42:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"43. cv::norm() 计算一个矩阵的范数，或者如果提供两个矩阵，该函数也可以计算两个矩阵间的各种距离范数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 double cv::norm( // Return norm in double precision cv::InputArray src1, // Input matrix int normType = cv::NORM_L2, // Type of norm to compute cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); double cv::norm( // Return computed norm of difference cv::InputArray src1, // Input matrix cv::InputArray src2, // Second input matrix int normType = cv::NORM_L2, // Type of norm to compute cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); double cv::norm( const cv::SparseMat\u0026 src, // Input sparse matrix int normType = cv::NORM_L2, // Type of norm to compute ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:43:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"44. cv::normalize() 将原图像映射到一个特定范围内并放到dst中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::normalize( cv::InputArray src1, // Input matrix cv::OutputArray dst, // Result matrix double alpha = 1, // first parameter (see Table 5-8) double beta = 0, // second parameter (see Table 5-8) int normType = cv::NORM_L2, // Type of norm to compute int dtype = -1 // Output type for result array cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); void cv::normalize( const cv::SparseMat\u0026 src, // Input sparse matrix cv::SparseMat\u0026 dst, // Result sparse matrix double alpha = 1, // first parameter (see Table 5-8) int normType = cv::NORM_L2, // Type of norm to compute ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:44:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"45. cv::perspectiveTransform() 执行一系列点的平面投影变换。 1 2 3 4 5 void cv::perspectiveTransform( cv::InputArray src, // Input array, 2 or 3 channels cv::OutputArray dst, // Result array, size, type, as src1 cv::InputArray mtx // 3-by-3 or 4-by-4 transoform matrix ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:45:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"46. cv::phase() 对二维矢量场计算笛卡尔-极坐标转换的方位角（角度）部分。 1 2 3 4 5 6 void cv::phase( cv::InputArray x, // Input array of x-components cv::InputArray y, // Input array of y-components cv::OutputArray dst, // Output array of angles (radians) bool angleInDegrees = false // degrees (if true), radians (if false) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:46:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"47. cv::polarToCart() 从向量场的极坐标中计算笛卡尔坐标(x,y)。 1 2 3 4 5 6 7 void cv::polarToCart( cv::InputArray magnitude, // Input array of magnitudes cv::InputArray angle, // Input array of angles cv::OutputArray x, // Output array of x-components cv::OutputArray y, // Output array of y-components bool angleInDegrees = false // degrees (if true) radians (if false) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:47:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"48. cv::pow() 对矩阵逐元素取p次幂。 1 2 3 4 5 void cv::pow( cv::InputArray src, // Input array double p, // power for exponentiation cv::OutputArray dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:48:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"49. cv::randu() 返回适当类型的随机值。 1 2 3 4 5 6 template\u003ctypename _Tp\u003e _Tp randu(); // Return random number of specific type void cv::randu( cv::InputOutArray mtx, // All values will be randomized cv::InputArray low, // minimum, 1-by-1 (Nc=1,4), or 1-by-4 (Nc=1) cv::InputArray high // maximum, 1-by-1 (Nc=1,4), or 1-by-4 (Nc=1) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:49:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"50. cv::randn() 使用正态分布的值填充矩阵mtx。 1 2 3 4 5 void cv::randn( cv::InputOutArray mtx, // All values will be randomized cv::InputArray mean, // mean values, array is in channel space cv::InputArray stddev // standard deviations, channel space ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:50:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"51. cv::repeat() 将src的内容复制到dst中。 1 2 3 4 5 6 7 8 9 10 11 void cv::repeat( cv::InputArray src, // Input 2-dimensional array int nx, // Copies in x-direction int ny, // Copies in y-direction cv::OutputArray dst // Result array ); cv::Mat cv::repeat( // Return result array cv::InputArray src, // Input 2-dimensional array int nx, // Copies in x-direction int ny // Copies in y-direction ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:51:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"52. cv::scaleAdd() 1 2 3 4 5 6 void cv::scaleAdd( cv::InputArray src1, // First input array double scale, // Scale factor applied to first array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:52:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"53. cv::setIdentity() 除了将行数和列数相等的元素设置为1（或者给定数值）外，其他所有矩阵元素设置为0。 1 2 3 4 void cv::setIdentity( cv::InputOutputArray dst, // Array to reset values const cv::Scalar\u0026 value = cv::Scalar(1.0) // Apply to diagonal elements ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:53:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"54. cv::solve() 基于invert()的函数，solve()为求解线性系统提供一条捷径，具体公式如下： 1 2 3 4 5 6 int cv::solve( cv::InputArray lhs, // Lefthand side of system, n-by-n cv::InputArray rhs, // Righthand side of system, n-by-1 cv::OutputArray dst, // Results array, will be n-by-1 int method = cv::DECOMP_LU // Method for solver ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:54:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"55. cv::solveCubic() 计算三次多项式的实根。 1 2 3 4 int cv::solveCubic( cv::InputArray coeffs, cv::OutputArray roots ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:55:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"56. cv::solvePoly() 计算任意阶数多项式的根。 1 2 3 4 5 int cv::solvePoly ( cv::InputArray coeffs, cv::OutputArray roots // n complex roots (2-channels) int maxIters = 300 // maximum iterations for solver ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:56:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"57. cv::sort() opencv的排序函数，分别对每行或列进行排序。 1 2 3 4 5 void cv::sort( cv::InputArray src, cv::OutputArray dst, int flags ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:57:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"58. cv::sortIdx() opencv的排序函数，分别对每行或列进行排序，将排序索引结果存在dst中。 1 2 3 4 5 void cv::sortIdx( cv::InputArray src, cv::OutputArray dst, int flags ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:58:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"59. cv::sqrt() 计算逐元素的平方根。 1 2 3 4 void cv::sqrt( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:59:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"60 cv::subtract() 从src1中减去src2的相应元素。 1 2 3 4 5 6 7 void cv::subtract( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:60:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"61. cv::sum() 计算矩阵各个通道的所有像素的总和。 1 2 3 cv::Scalar cv::sum( cv::InputArray arr ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:61:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"62. cv::trace() 计算矩阵的迹。 1 2 3 cv::Scalar cv::trace( cv::InputArray mat ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:62:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"63. cv::transform() 计算任意线性图像变换。 1 2 3 4 5 void cv::transform( cv::InputArray src, cv::OutputArray dst, cv::InputArray mtx ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:63:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"64. cv::transpose() 将src中每一个元素复制到dst中行号与列数相调换的位置上。 1 2 3 4 void cv::transpose( cv::InputArray src, // Input array, 2-dimensional, n-by-m cv::OutputArray dst, // Result array, 2-dimensional, m-by-n ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:64:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:0","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"1.HighGUI模块做为高层GUI图形用户界面模块，包含媒体的输入输出、视频捕捉、图像和视频的编码解码、图像交互界面的接口等内容。 imread：用于读取文件中的图片到opencv中 imshow : 在指定的窗口中显示一幅图像 namedWindow：用于创建一个窗口 imwrite：输出图像到文件 createTrackbar：用于创建一个可以调整数值的轨迹条 getTrackbarPos：用于获取轨迹条的当前位置 SetMouseCallback：为指定的窗口设置鼠标回调函数 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:1","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"2.opencv中的core组件是核心功能模块主要包含以下的内容：数据基本结构、动态数据结构、绘图函数、数组操作相关函数、辅助功能和系统函数和宏、与OpenGL的互操作。 Mat::Mat() : Mat类的构造函数 Mat::Create() : Mat类的成员函数，可用于Mat类的初始化操作 Point : 用于表示点的数据结构 Scalar : 用于表示颜色的数据结构 Size : 用于表示尺寸的数据结构 Rect : 用于表示矩阵的数据结构 CvtColor() : 用于颜色的空间转换 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:2","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"3.操作图像中的像素、设置感兴趣区域（ROI）、进行图像混合、分离颜色通道、进行多通道图像混合、调整图像的对比对和亮度值、对图像进行离散傅里叶变换、输入输出XML 和YAML文件 addWeighted : 计算两个数组（图像阵列）的加权和 split : 将一个多通道数组分离成单个通道数组 merge : 将多个数组组合合并成一个多通道的数组 dft : 对一维或者二维浮点数数组进行正向或反向离散傅里叶变换 getOptimalDFTSize : 返回给定向尺寸的傅里叶最优化尺寸大小 copyMakeBorder : 扩充图像边界 magnitude : 计算二维矢量的幅值 log：计算每个数组元素绝对值的自然对数 normalize：进行矩阵归一化 FileStorage类：进行文件操作的类 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:3","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"4.imgproc组件是Image和Process这两个单词的缩写，即图像处理模块，这个模块有线性和非线性的图像滤波、图像的几何变换、其他（Miscellaneous）图像转换、直方图相关、结构分析和形状描述、运动分析和对象追踪、特征检测、目标检测等内容。 boxFilter : 使用方框滤波来模糊一张图片 blur : 对输入的图像进行均值滤波操作 GaussianBlur : 用高斯滤波器来模糊一张图片 medianBlur : 使用中值滤波器来模糊一张图片 bilateralFilter : 使用双边滤波器来模糊处理一张图片 dilate : 使用像素领域内的局部极大运算符来膨胀一张图片 erode : 使用像素领域内的局部极小运算符来腐蚀一张图片 morphologyEx : 利用基本的膨胀和腐蚀技术，来执行更加高级形态学变换，如开闭运算、形态学梯度、顶帽、黑帽等，也可以实现最基本的图像膨胀和腐蚀 floodFill : 用指定的颜色从种子点开始填充一个连接域，实现漫水填充算法 pyrUp : 向上采样并模糊一张图片，说白了就是放大一张图片 pyrDown : 向下采样并模糊一张图片，说白了就是缩小一张图片 Threshold : 对单通道数组应用固定阈值操作 adaptiveThreshold : 对矩阵采用自适应阈值操作 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:4","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"5.图像变换（image transfrom）即将一幅图像转变成图像数据的另一种表现形式。变换最常见的例子就是傅里叶变换（Fourier transfrom），即将图像转换成源图像数据的另一种表示形式。这类操作的结果仍然保存为OpenCV图像结构的形式，但是新图像的每个单独像素表示原始输出图像的频谱分量，而不是通常所考虑的空间分量。基于OpenCV的边缘检测、霍夫变换、重映射、仿射变换、直方图均衡化。 Canny : 利用canny算子来进行图像的边缘检测 Sobel : 使用拓展的Sobel算子，来计算一阶、二阶、三阶或混合图像差分 Laplacian : 计算出图像经过拉普拉斯变换后的结果 Scharr : 使用Scharr滤波器运算符计算X或Y方向的图像差分 HoughLinesP : 找出采用标准霍夫变换的二值图像线条 HoughCireles : 采用累计概率霍夫变换（PPHT）来找出二值图像中的直线 remap : 根据指定的映射形式，将源图像进行重映射几何变换 warpAffine : 依据公式对图像做仿射变换 getRotationMatrix2D : 计算二维旋转变换矩阵 equalizeHist : 实现图像的直方图均衡化 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:5","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"6.图像轮廓与图像分割修复，虽然Canny之类的边缘检测算法可以根据像素之间的差异，检测出轮廓边界的像素，但是并没有将轮廓作为一个整体。所以下一步便是把这些边缘像素组装成轮廓。查找并绘制轮廓、寻找物体的凸包、使用多边形逼近物体、认识图像的矩、利用OpenCV进行图像修补。 findContours : 在二值图像中寻找轮廓 drawContours : 在图像中绘制外部或内部轮廓 convexHull : 寻找图像点集中的凸包 BoundingRect : 计算并返回指定点集最外面（up -right）的矩形边界 minAreaRect : 寻找可旋转的最小面积的包围矩形 minEnclosingCircle : 利用一种迭代算法，对给定的2D点集，寻找面积最小的可包围他们的圆形 fitEllipse : 用椭圆拟合二维点集合 approxPolyDP：用指定精度逼近多边形曲线 moments : 计算多边形和光栅形状的最高达三阶的所有矩 contourArea : 计算整个轮廓或部分轮廓的面积 arcLength : 计算封闭轮廓的周长或曲线的长度 watershed : 实现分水岭算法 inpaint : 进行图像修补，从扫描的照片中清除灰尘和划痕，或者从静态图像或视频中去除不需要的物体。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:6","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"7.直方图和匹配，在进行物体图像和视频信息分析的过程中，我们常常会习惯于将眼中看到的物体用直方图（histogram）表示出来，得到比较直观的数据官感展示。直方图可以用来描述各种不同的参数和事物，如物体的彩色分布、物体边缘梯度模板、以及表示目标位置的当前假设的概率分布。 calcHist : 计算一个或多个阵列的直方图 minMaxLoc : 在数组中找到全局最小值和最大值 compareHist : 对两幅直方图进行比较 calcBackProject : 计算直方图反向投影 mixChannels : 由输入参数复制某通道到输出参数特定的通道中 matchTemplate : 匹配出和模板重叠的图像区域 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:7","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"8.feature2d组件，也就是Features 2D，是OpenCV的2D功能框架。自OpenCV以来的众多著名的特征检测算子（如SIFT、SURF、ORB算子等）所依赖的稳定版的特征检测与匹配相关的核心源代码已经从OpenCV3中移除了，转移到xfeature2d的第三方库当中了。特征检测器（Feature Detectors）通用接口、描述符提取器（Descriptor Extractors）通用接口、描述符匹配器（Descriptor Matchers）匹配器通用接口、关键点绘制函数和匹配功能绘制函数。 cornerHarris : 运行Harris角点检测算子来进行角点检测 goodFeaturesToTrack : 结合Shi-Tomasi 算子确定图像的强角点 cornerSubPix: 寻找亚像素角点位置 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:8","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"9.特征点的检测和匹配是计算机视觉中非常重要的技术之一。在物体检测、视觉跟踪、三维重构等领域都有很广泛的应用。 SURF类 、SurfFeatureDetector类 、SurfDescriptorExtractor类 ： 三者等价，同用与在OpenCV中进行SURF特征检测 drawKeypoints函数 ：绘制关键点 drawMatches函数 ：绘制出相匹配的两个图像的关键点 KeyPoint类：用于表示特征点的信息 BruteForceMatcher类：进行暴力匹配相关的操作 FlannBasedMatcher类：实现FLANN特征匹配 DescriptorMatcher::match函数：从每个描述符查询集中找到最佳匹配 findHomography函数：找到并返回源图像和目标图像之间的透视变换H perspectiveTransfrom函数：进行向量透视矩阵变换 ORB类、OrbFeatureDetector类、OrbDescriptorExtractor类：三者等价，同用于在OpenCV中进行ORB特征检测 参考： opencv核心函数名单 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:9","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++ 语法分析 template typename std::bind std::is_same\u003cR, void\u003e::value std::enable_if std::decay std::reverse和std::reverse_copy 可变参数模板消除冗余代码 C++ 语法分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:0:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"template 1 2 3 template\u003ctypename T\u003e struct type_xx{ typedef T type; }; 将T 类型置换为 type 使用：typename type_xx::type ，实际为类型R ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:1:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"typename “typename\"是一个C++程序设计语言中的关键字。当用于泛型编程时是另一术语\"class\"的同义词。这个关键字用于指出模板声明（或定义）中的非独立名称（dependent names）是类型名，而非变量名。 我们经常会这么用 typename，这是一项C++编程语言的泛型编程（或曰“模板编程”）的功能，typename关键字用于引入一个模板参数。 1 2 3 4 5 6 7 8 template \u003ctypename T\u003e const T\u0026 max(const T\u0026 x, const T\u0026 y) { if (y \u003c x) { return x; } return y; } 在模板定义语法中关键字 class 与 typename 的作用完全一样 1 2 3 4 5 6 7 8 template\u003cclass T\u003e const T\u0026 max(const T\u0026 x, const T\u0026 y) { if (y \u003c x) { return x; } return y; } 这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型。 那class使用就够了，为什么又引入了新的关键词 typename ，关于这个问题，Stan Lippman 曾在其博客中表示，最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。 而使用 typename 的作用就是告诉 cpp 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。 解决的问题 1 2 3 4 template\u003ctypename T\u003e void fun(const T\u0026 proto){ T::const_iterator it(proto.begin()); } 发生编译错误是因为编译器不知道T::const_iterator是个类型。万一它是个变量呢？ T::const_iterator的解析有着逻辑上的矛盾： 直到确定了T是什么东西，编译器才会知道T::const_iterator是不是一个类型； 然而当模板被解析时，T还是不确定的。这时我们声明它为一个类型才能通过编译： 而且在模板实例化之前，完全没有办法来区分它们，这绝对是滋生各种bug的温床。这时C++标准委员会再也忍不住了，与其到实例化时才能知道到底选择哪种方式来解释以上代码，委员会决定引入一个新的关键字，这就是typename。 C++标准 对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了 typename 关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。 因此，如果你想直接告诉编译器 T::const_iterator 是类型而不是变量，只需用 typename修饰： 1 typename T::const_iterator it(proto.begin()); 这样编译器就可以确定T::const_iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。 嵌套从属类型 事实上类型T::const_iterator依赖于模板参数T， 模板中依赖于模板参数的名称称为从属名称（dependent name）， 当一个从属名称嵌套在一个类里面时，称为嵌套从属名称（nested dependent name）。 其实T::const_iterator还是一个嵌套从属类型名称（nested dependent type name）。 嵌套从属名称是需要用typename声明的，其他的名称是不可以用typename声明的。比如下面是一个合法的声明： 1 2 template\u003ctypename T\u003e void fun(const T\u0026 proto ,typename T::const_iterator it); ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:2:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::bind 参考: 当 std::bind 遇上 this bind本身是一种延迟计算的思想，它本身可以绑定普通函数、全局函数、静态函数、类静态函数甚至是类成员函数. bind能够在绑定时候就同时绑定一部分参数，未提供的参数则使用占位符表示，然后在运行时传入实际的参数值。PS：绑定的参数将会以值传递的方式传递给具体函数，占位符将会以引用传递。众所周知，静态成员函数其实可以看做是全局函数，而非静态成员函数则需要传递this指针作为第一个参数，所以std::bind能很容易地绑定成员函数。 std::bind 遇上 this : 非静态成员函数则需要传递this指针作为第一个参数. ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:3:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::is_same\u003cR, void\u003e::value 头文件 ： #include \u003ctype_traits\u003e 如果两个一样的类型会返回true ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:4:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::enable_if td::enable_if 顾名思义，满足条件时类型有效。作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）中。它的定义也异常的简单： 1 2 3 4 5 6 7 template \u003cbool, typename T=void\u003e struct enable_if { }; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; 由上可知，只有当第一个模板参数为 true 时，type 才有定义，否则使用 type 会产生编译错误，并且默认模板参数可以让你不必指定类型。 1 2 3 4 5 6 7 8 9 10 11 12 // help call return value type is void function template\u003ctypename R, typename F\u003e typename std::enable_if\u003cstd::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type call_helper(F f) { f(); return 0; } // 这里的意思是 如果 template\u003ctypename R, typename F\u003e typename std::enable_if\u003c!std::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type call_helper(F f) { return f(); } 1 2 3 4 std::enable_if\u003c std::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type 1 2 3 4 5 6 7 8 9 template\u003ctypename R\u003e void buttonrpc::callproxy_(std::function\u003cR()\u003e func, Serializer* pr, const char* data, int len) { typename type_xx\u003cR\u003e::type r = call_helper\u003cR\u003e(std::bind(func)); value_t\u003cR\u003e val; val.set_code(RPC_ERR_SUCCESS); val.set_val(r); (*pr) \u003c\u003c val; } 1 2 3 4 5 template\u003ctypename F\u003e void buttonrpc::callproxy( F fun, Serializer* pr, const char* data, int len ) { callproxy_(fun, pr, data, len); } 1 2 3 4 5 template\u003ctypename F\u003e void buttonrpc::bind( std::string name, F func ) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF\u003e, this, func, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:5:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::decay 头文件 ： #include \u003ctype_traits\u003e 对一个类型进行退化处理，如 ： cosnt int\u0026退化为int ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:6:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::reverse和std::reverse_copy std::reverse：反转排序容器内指定范围中的元素。std::reverse_copy与std::reverse唯一的区别是：reverse_copy会将结果拷贝到另外一个容器中，而不影响原容器的内容。 std::reverse: defined in header , reverses the order of the elements in the range [first, last). std::reverse_copy: defined in header , copies the elements in the range[first,last) to the range beginning at result, but in reverse order. 可变参数模板消除冗余代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // client template\u003ctypename R\u003e value_t\u003cR\u003e call(std::string name); template\u003ctypename R, typename P1\u003e value_t\u003cR\u003e call(std::string name, P1); template\u003ctypename R, typename P1, typename P2\u003e value_t\u003cR\u003e call(std::string name, P1, P2); template\u003ctypename R, typename P1, typename P2, typename P3\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3); template\u003ctypename R, typename P1, typename P2, typename P3, typename P4\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3, P4); template\u003ctypename R, typename P1, typename P2, typename P3, typename P4, typename P5\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3, P4, P5); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // client template\u003ctypename R, typename... Params\u003e value_t\u003cR\u003e call(std::string name, Params... ps) { using args_type = std::tuple\u003ctypename std::decay\u003cParams\u003e::type...\u003e; args_type args = std::make_tuple(ps...); Serializer ds; ds \u003c\u003c name; package_params(ds, args); return net_call\u003cR\u003e(ds); } template\u003ctypename R\u003e value_t\u003cR\u003e call(std::string name) { Serializer ds; ds \u003c\u003c name; return net_call\u003cR\u003e(ds); } ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:7:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 开源地址 2. 编译运行 2.1. buttonrpc 2.2. buttonrpc_cpp14 3. 原理 3.1. RPC 3.2. buttonrpc 分析 3.2.1. Call ID映射：buttonrpc.hpp 3.2.2. 序列化和反序列化：Serializer.hpp 3.2.3. 网络传输：ZeroMQ 1. 开源地址 buttonrpc buttonrpc_cpp14 2. 编译运行 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:0:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"2.1. buttonrpc 依赖安装： 1 sudo apt-get install libzmq3-dev 编译： ubuntu 下修改文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 diff --git a/example/main_client.cpp b/example/main_client.cpp index abdec37..fab93c5 100644 --- a/example/main_client.cpp +++ b/example/main_client.cpp @@ -3,7 +3,11 @@ #include \u003cctime\u003e #include \"buttonrpc.hpp\" +#ifdef _WIN32 #include \u003cWindows.h\u003e // use sleep +#else + #include \u003cunistd.h\u003e +#endif #define buttont_assert(exp) { \\ @@ -64,7 +68,11 @@ int main() buttonrpc::value_t\u003cvoid\u003e xx = client.call\u003cvoid\u003e(\"foo_7\", 666); buttont_assert(!xx.valid()); +#ifdef _WIN32 Sleep(1000); +#else + sleep(1); +#endif } return 0; 创建CMakeLists 并编译 1 2 3 4 5 6 cd buttonrpc touch CMakeLists.txt # 内容见下 mkdir build cd build cmake .. make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 这个是cmake最小版本要求 cmake_minimum_required(VERSION 3.1) # Enable C++11，这一段是源码里的 set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED TRUE) # 填写你的项目名称Project project( RPC ) aux_source_directory(${CMAKE_SOURCE_DIR}/src/ DIR_SRCS) aux_source_directory(${CMAKE_SOURCE_DIR}/example DIR_SRCS) include_directories( ${CMAKE_SOURCE_DIR} ${CMAKE_SOURCE_DIR}/src ) message(\"${CMAKE_CURRENT_SOURCE_DIR}\") # Find all *.cpp files and store in list cpps # GLOB这个参数不支持子目录， 用GLOB_RECURSE可以支持子目录。 file(GLOB cpps RELATIVE \"${CMAKE_CURRENT_SOURCE_DIR}/example\" \"${CMAKE_CURRENT_SOURCE_DIR}/example/*.cpp\") foreach(mainfile IN LISTS cpps) # Get file name without directory get_filename_component(mainname ${mainfile} NAME_WE) add_executable(${mainname} ${CMAKE_CURRENT_SOURCE_DIR}/example/${mainfile}) target_link_libraries(${mainname} zmq) endforeach() 运行demo 1 2 ./main_server ./main_client ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:1:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"2.2. buttonrpc_cpp14 参考 buttonrpc 3. 原理 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:2:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.1. RPC RPC（Remote Procedure Call）远程过程调用。要像调用本地的函数一样去调远程函数。 RPC 是需要有三个主要模块：Call ID映射，序列化和反序列化，网络传输。 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 \u003c–\u003e Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:3:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2. buttonrpc 分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.1. Call ID映射：buttonrpc.hpp server server 中主要完成被调用函数的注册,在收到网络发送的数据进行序列化还原后找到对应的调用函数和参数,执行调用再将结果返回. 1 2 3 4 5 6 // server template\u003ctypename F\u003e void bind(std::string name, F func); template\u003ctypename F, typename S\u003e void bind(std::string name, F func, S* s); bind 函数两种模板的实现是为了兼容多参数函数的设计,其中 name 为函数名,同时也是对应的函数的索引,func 为函数指针,s 为函数参数.bind 的实现如下: 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename F\u003e void buttonrpc::bind( std::string name, F func ) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF\u003e, this, func, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } template\u003ctypename F, typename S\u003e inline void buttonrpc::bind(std::string name, F func, S* s) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF, S\u003e, this, func, s, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } 函数最终被放到m_handlers 中索引,m_handlers的类型如下: 1 std::map\u003cstd::string, std::function\u003cvoid(Serializer*, const char*, int)\u003e\u003e m_handlers; 映射关系为 函数名(string) — 函数指针 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename F\u003e void buttonrpc::callproxy( F fun, Serializer* pr, const char* data, int len ) { callproxy_(fun, pr, data, len); } template\u003ctypename F, typename S\u003e inline void buttonrpc::callproxy(F fun, S * s, Serializer * pr, const char * data, int len) { callproxy_(fun, s, pr, data, len); } callproxy_ 实现如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 template\u003ctypename R\u003e void buttonrpc::callproxy_(std::function\u003cR()\u003e func, Serializer* pr, const char* data, int len) { typename type_xx\u003cR\u003e::type r = call_helper\u003cR\u003e(std::bind(func)); value_t\u003cR\u003e val; val.set_code(RPC_ERR_SUCCESS); val.set_val(r); (*pr) \u003c\u003c val; } /*-------------------------------------------------------------------------------------------*/ template\u003ctypename F\u003e void callproxy(F fun, Serializer* pr, const char* data, int len); template\u003ctypename F, typename S\u003e void callproxy(F fun, S* s, Serializer* pr, const char* data, int len); // PROXY FUNCTION POINT template\u003ctypename R\u003e void callproxy_(R(*func)(), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR()\u003e(func), pr, data, len); } template\u003ctypename R, typename P1\u003e void callproxy_(R(*func)(P1), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2\u003e void callproxy_(R(*func)(P1, P2), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3\u003e void callproxy_(R(*func)(P1, P2, P3), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3, typename P4\u003e void callproxy_(R(*func)(P1, P2, P3, P4), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3, P4)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3, typename P4, typename P5\u003e void callproxy_(R(*func)(P1, P2, P3, P4, P5), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3, P4, P5)\u003e(func), pr, data, len); } // PROXY CLASS MEMBER template\u003ctypename R, typename C, typename S\u003e void callproxy_(R(C::* func)(), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR()\u003e(std::bind(func, s)), pr, data, len); } template\u003ctypename R, typename C, typename S, typename P1\u003e void callproxy_(R(C::* func)(P1), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1)\u003e(std::bind(func, s, std::placeholders::_1)), pr, data, len); } template\u003ctypename R, typename C, typename S, typename P1, typename P2\u003e void callproxy_(R(C::* func)(P1, P2), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::funct","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:1","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.2. 序列化和反序列化：Serializer.hpp 重载 \u003c\u003c \u003e\u003e 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename T\u003e Serializer \u0026operator \u003e\u003e (T\u0026 i){ output_type(i); return *this; } template\u003ctypename T\u003e Serializer \u0026operator \u003c\u003c (T i){ input_type(i); return *this; } 重载 « » 并调用 input_type output_type 将数据转化为数据流(char类型)用于网络传输 output_type \u0026 input_type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template\u003ctypename T\u003e inline void Serializer::output_type(T\u0026 t) { ... } template\u003c\u003e inline void Serializer::output_type(std::string\u0026 in) { ... } template\u003ctypename T\u003e inline void Serializer::input_type(T t) { ... } template\u003c\u003e inline void Serializer::input_type(std::string in) { ... } template\u003c\u003e inline void Serializer::input_type(const char* in) { ... } 这里的 input_type output_type 提供了多种的特化和偏特化的实现同样是为了有多参数函数的序列化的需求. ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:2","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.3. 网络传输：ZeroMQ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // network void buttonrpc::as_client( std::string ip, int port ) { m_role = RPC_CLIENT; m_socket = new zmq::socket_t(m_context, ZMQ_REQ); ostringstream os; os \u003c\u003c \"tcp://\" \u003c\u003c ip \u003c\u003c \":\" \u003c\u003c port; m_socket-\u003econnect (os.str()); } void buttonrpc::as_server( int port ) { m_role = RPC_SERVER; m_socket = new zmq::socket_t(m_context, ZMQ_REP); ostringstream os; os \u003c\u003c \"tcp://*:\" \u003c\u003c port; m_socket-\u003ebind (os.str()); } void buttonrpc::send( zmq::message_t\u0026 data ) { m_socket-\u003esend(data); } void buttonrpc::recv( zmq::message_t\u0026 data ) { m_socket-\u003erecv(\u0026data); } inline void buttonrpc::set_timeout(uint32_t ms) { // only client can set if (m_role == RPC_CLIENT) { m_socket-\u003esetsockopt(ZMQ_RCVTIMEO, ms); } } void buttonrpc::run() { // only server can call if (m_role != RPC_SERVER) { return; } while (1){ zmq::message_t data; recv(data); StreamBuffer iodev((char*)data.data(), data.size()); Serializer ds(iodev); std::string funname; ds \u003e\u003e funname; Serializer* r = call_(funname, ds.current(), ds.size()- funname.size()); zmq::message_t retmsg (r-\u003esize()); memcpy (retmsg.data (), r-\u003edata(), r-\u003esize()); send(retmsg); delete r; } } 网络传输使用的 ZeroMQ . ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:3","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/cpufetch/cpufetch/","tags":["cpufetch"],"title":"开源软件:cpufetch","uri":"/posts/open_source_software/cpufetch/cpufetch/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. CPUFetch 2. 开源地址 3. 编译运行 4. 运行效果 5. bash 启动打印CPU信息 1. CPUFetch CPUFetch是一个简单的命令行工具，与Neofetch有点类似，但是用于在Linux，Windows，macOS和Android中获取CPU体系结构。 该工具会输出制造商徽标（例如Intel，AMD）以及基本的CPU信息，包括： CPU名称。 微架构。 纳米（nm）的半导体技术。 最大频率。 核心和线程数。 高级向量扩展（AVX） 融合乘加（FMA） L1，L2，L3缓存大小。 峰值性能。 2. 开源地址 cpufetch 3. 编译运行 1 2 3 4 git clone https://github.com/Dr-Noob/cpufetch cd cpufetch make ./cpufetch 4. 运行效果 5. bash 启动打印CPU信息 请将可执行文件复制到/usr/local/bin/ 1 sudo mv cpufetch /usr/local/bin/ .修改 .bashrc 1 2 cd ~ vi .bashrc 在.bashrc 最后位置添加 1 2 # start cpufetch cpufetch 重新打开终端 ","date":"2023-01-16","objectID":"/posts/open_source_software/cpufetch/cpufetch/:0:0","tags":["cpufetch"],"title":"开源软件:cpufetch","uri":"/posts/open_source_software/cpufetch/cpufetch/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 编译的原因 2. 环境 3. ffmpeg 3.1. 下载编译 !/bin/bash !/bin/bash download 3.2. cmake支持 !/usr/bin/env python !/usr/bin/env python coding: utf-8 note: the order matters ref: https://blog.csdn.net/zijin0802034/article/details/52779791 setup library names setup library found setup library versions final stuffs summary up and write 4. opencv 4.1. toolchain message(“begin child cmake”) message(“begin child cmake”) set cross-compiled system type, it’s better not use the type which cmake cannot recognized. when gcc-arm-aarch64-none-linux-gnu was installed, toolchain was available as below: set searching rules for cross-compiler other needed options set(GNUEABIHFCFLAGS “-Wall -fPIC -mcpu=cortex-a9 -mfpu=neon-fp16 -mfloat-abi=hard -mthumb-interwork -marm” CACHE INTERNAL docstring) set(GNUEABIHFCFLAGS “-Wall -fPIC -Wl,-rpath-link=/home/zz/soft/ffmpeg/aarch64-none-linux-gnu/lib” CACHE INTERNAL docstring) # for shared libs, rpath required 4.2. 下载编译 !/bin/bash !/bin/bash download 编译 5. References 1. 编译的原因 想在目标平台 gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf 上读取视频，作为算法 SDK 的输入数据；交叉编译了带 videoio 模块的 OpenCV，遇到 VideoCapture 无法读取 .mp4 格式视频的问题。排查后发现： 尽管不指定 FFMPEG，VideoIO 模块也能编译出来，但对应的编解码器 FOURCC 只能编解码 .avi 格式的视频，无法满足实际需求。 videoio 模块可以有不同 backend，在 PC 上先前主要是 Windows 平台，使用了预编译的 ffmpeg dll，没有对编解码 backend 引起重视；而 aarch64-none-linux-gnu 这样的嵌入式平台，没找到现成的 FFMPEG 库（如果有，请留言告知），于是手动编译 FFMPEG，并在 OpenCV 的 cmake 构建中集成。 2. 环境 Host: Ubuntu 18.04 交叉编译工具: rv1126 工具链 gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf cmake 3.20 3. ffmpeg ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:0:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"3.1. 下载编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash OUT_DIR=../out_ffmpeg_rv1126 CROSS_PREFIX=/opt/tools/rk_docs_and_compiler/compiler/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf- FFMPENG_BRANCH=n4.2.2 MAKE_JOBE=40 #download git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg cd ffmpeg git checkout -b ${FFMPENG_BRANCH} ./configure \\ --prefix=${OUT_DIR} \\ --shlibdir=${OUT_DIR}/lib \\ --disable-shared \\ --disable-doc \\ --arch=aarch64 \\ --cross-prefix=${CROSS_PREFIX} \\ --target-os=linux \\ --disable-x86asm \\ --disable-asm \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --enable-avresample make -j${MAKE_JOBE} make install ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:1:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"3.2. cmake支持 ffmpeg 官方不提供 cmake 构建支持，github 上找到的 ffmpeg cmake 写得很长但不起作用；简单起见，用如下 Python 代码生成 ffmpeg-config.cmake（注意库版本为手动硬编码，库的顺序也很重要） gen-ffmpeg-cmake-config.py： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python #coding: utf-8 \"\"\" Generate ffmpeg-config.cmake \"\"\" # note: the order matters # ref: https://blog.csdn.net/zijin0802034/article/details/52779791 ffmpeg_lib_desc = { 'libavformat': '58.71.100', 'libavdevice': '58.12.100', 'libavcodec': '58.129.100', 'libavutil': '56.67.100', 'libswscale': '5.8.100', 'libswresample': '3.8.100', 'libavfilter': '7.109.100', 'libavresample': '4.0.0', } content_lines = [ 'set(ffmpeg_path \"${CMAKE_CURRENT_LIST_DIR}\")', '', 'set(FFMPEG_EXEC_DIR \"${ffmpeg_path}/bin\")', 'set(FFMPEG_LIBDIR \"${ffmpeg_path}/lib\")', 'set(FFMPEG_INCLUDE_DIRS \"${ffmpeg_path}/include\")', '', ] # setup library names content_lines.append('# library names') content_lines.append( 'set(FFMPEG_LIBRARIES', ) for key, value in ffmpeg_lib_desc.items(): lib_name = key lib_version = value content_lines.append( ' ${FFMPEG_LIBDIR}/' + lib_name + '.a' ) content_lines.append(' pthread') content_lines.append(')') content_lines.append('') # setup library found content_lines.append('# found status') for key, value in ffmpeg_lib_desc.items(): lib_name = key content_lines.append( 'set(FFMPEG_{:s}_FOUND TRUE)'.format(lib_name) ) content_lines.append('') # setup library versions content_lines.append('# library versions') for key, value in ffmpeg_lib_desc.items(): lib_name = key lib_version = value content_lines.append( 'set(FFMPEG_{:s}_VERSION {:s})'.format(lib_name, lib_version) ) content_lines.append('') # final stuffs content_lines.append('set(FFMPEG_FOUND TRUE)') content_lines.append('set(FFMPEG_LIBS ${FFMPEG_LIBRARIES})') # summary up and write fout = open('ffmpeg-config.cmake', 'w') for line in content_lines: fout.write(line + '\\n') fout.close() 其中版本号的设定，是为了在 OpenCV 中找到 FFMPEG 后，能通过最低版本检查。 将这个文件，放在 ffmpeg 安装路径的根目录，并运行，得到 ffmpeg-config.cmake，则后续可用 find_package(FFMPEG) 使用； 4. opencv ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:2:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"4.1. toolchain 交叉编译阶段用到的 toolchain 文件里，如果后续用的是 ffmpeg 动态库，则需要在 toolchain 里指定 rpath。本人最终用的静态库，因而未设 rpath。 如下脚本，保存为 build/aarch64-none-linux-gnu.toolchain.cmake 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # message(\"begin child cmake\") # set cross-compiled system type, it's better not use the type which cmake cannot recognized. set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_PROCESSOR ARM) # when gcc-arm-aarch64-none-linux-gnu was installed, toolchain was available as below: set(TOOLCHAIN_DIR \"/opt/tools/rk_docs_and_compiler/compiler/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin\") set(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/arm-linux-gnueabihf-g++) set(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/arm-linux-gnueabihf-gcc) # set searching rules for cross-compiler set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # other needed options #set(GNUEABIHF_C_FLAGS \"-Wall -fPIC -mcpu=cortex-a9 -mfpu=neon-fp16 -mfloat-abi=hard -mthumb-interwork -marm\" CACHE INTERNAL docstring) #set(GNUEABIHF_C_FLAGS \"-Wall -fPIC -Wl,-rpath-link=/home/zz/soft/ffmpeg/aarch64-none-linux-gnu/lib\" CACHE INTERNAL docstring) # for shared libs, rpath required set(GNUEABIHF_C_FLAGS \"-Wall -fPIC\" CACHE INTERNAL docstring) set(GNUEABIHF_CXX_FLAGS \"\") set(CMAKE_C_FLAGS \"-march=armv7-a ${CMAKE_C_FLAGS} ${GNUEABIHF_C_FLAGS}\" CACHE STRING \"C flags\" FORCE) set(CMAKE_CXX_FLAGS \"-march=armv7-a ${CMAKE_CXX_FLAGS} ${GNUEABIHF_C_FLAGS} ${NDK_CXX_FLAGS}\" CACHE STRING \"C++ flags\" FORCE) https://stackoverflow.com/questions/12427928/configure-and-build-opencv-to-custom-ffmpeg-install ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:3:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"4.2. 下载编译 用如下脚本来编译，保存为 build/aarch64-linux-gnu.sh 并执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/bin/bash OUT_DIR=../out_opencv_rv1126 OPENCV_MODULES_DIR=../opencv_contrib/modules/ FFMPEG_DIR=../out_ffmpeg_rv1126 OPENCV_BRANCH=4.5.0 MAKE_JOBE=40 #download git clone --branch ${OPENCV_BRANCH} https://github.com/opencv/opencv.git git clone --branch ${OPENCV_BRANCH} https://github.com/opencv/opencv_contrib.git #编译 mkdir build_opencv cd build_opencv TOOLCHAIN=../cross.cmake cmake -DCMAKE_TOOLCHAIN_FILE=$TOOLCHAIN \\ -D CMAKE_BUILD_TYPE=Release \\ -D CMAKE_INSTALL_PREFIX=${OUT_DIR} \\ -D OPENCV_EXTRA_MODULES_PATH=${OPENCV_MODULES_DIR} \\ -D WITH_FFMPEG=ON \\ -D OPENCV_FFMPEG_USE_FIND_PACKAGE=ON \\ -D OPENCV_FFMPEG_SKIP_BUILD_CHECK=ON \\ -D FFMPEG_DIR=${FFMPEG_DIR} \\ -D BUILD_TESTS=OFF \\ -D BUILD_PERF_TESTS=OFF \\ -D BUILD_opencv_apps=OFF \\ -D WITH_PROTOBUF=OFF \\ -D WITH_QUIRC=OFF \\ -D WITH_1394=OFF \\ -D WITH_CUDA=OFF \\ -D WITH_OPENCL=OFF \\ -D WITH_VTK=OFF \\ -D WITH_MATLAB=OFF \\ -D BUILD_DOCS=OFF \\ -D BUILD_opencv_python3=OFF \\ -D BUILD_opencv_python2=OFF \\ -D WITH_IPP=OFF \\ -D BUILD_ANDROID_PROJECTS=OFF \\ -D BUILD_ANDROID_EXAMPLES=OFF \\ -D BUILD_ANDROID_SERVICE=OFF \\ -D BUILD_SHARED_LIBS=OFF \\ -D OPENCV_FORCE_3RDPARTY_BUILD=ON \\ -D BUILD_JAVA=OFF \\ -D BUILD_FAT_JAVA_LIB=OFF \\ -D OPENCV_GENERATE_PKGCONFIG=ON \\ ../opencv make -j${MAKE_JOBE} make install 5. References OpenCV 交叉编译：基于 FFMPEG 的 VideoIO 模块 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:4:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:0","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"explicit \u0026 implicit C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:1","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"std::streambuf https://blog.csdn.net/man_sion/article/details/78110842 using ContentProvider = std::function\u003cbool(size_t offset, size_t length, DataSink \u0026sink)\u003e; using ContentProviderWithoutLength = std::function\u003cbool(size_t offset, DataSink \u0026sink)\u003e; using ContentProviderResourceReleaser = std::function\u003cvoid(bool success)\u003e; using ContentReceiverWithProgress = std::function\u003cbool(const char *data, size_t data_length, uint64_t offset,uint64_t total_length)\u003e; using ContentReceiver = std::function\u003cbool(const char *data, size_t data_length)\u003e; using MultipartContentHeader = std::function\u003cbool(const MultipartFormData \u0026file)\u003e; class ContentReader { public: using Reader = std::function\u003cbool(ContentReceiver receiver)\u003e; using MultipartReader = std::function\u003cbool(MultipartContentHeader header, ContentReceiver receiver)\u003e; ContentReader(Reader reader, MultipartReader multipart_reader) : reader_(std::move(reader)), multipart_reader_(std::move(multipart_reader)) {} bool operator()(MultipartContentHeader header, ContentReceiver receiver) const { return multipart_reader_(std::move(header), std::move(receiver)); } bool operator()(ContentReceiver receiver) const { return reader_(std::move(receiver)); } Reader reader_; MultipartReader multipart_reader_; }; class Stream { public: virtual ~Stream() = default; virtual bool is_readable() const = 0; virtual bool is_writable() const = 0; virtual ssize_t read(char *ptr, size_t size) = 0; virtual ssize_t write(const char *ptr, size_t size) = 0; virtual void get_remote_ip_and_port(std::string \u0026ip, int \u0026port) const = 0; virtual socket_t socket() const = 0; template \u003ctypename… Args\u003e ssize_t write_format(const char *fmt, const Args \u0026…args); ssize_t write(const char *ptr); ssize_t write(const std::string \u0026s); }; class TaskQueue { public: TaskQueue() = default; virtual ~TaskQueue() = default; virtual void enqueue(std::function\u003cvoid()\u003e fn) = 0; virtual void shutdown() = 0; virtual void on_idle() {} }; class ThreadPool : public TaskQueue { public: explicit ThreadPool(size_t n) : shutdown_(false) { while (n) { threads_.emplace_back(worker(*this)); n–; } } ThreadPool(const ThreadPool \u0026) = delete; ~ThreadPool() override = default; void enqueue(std::function\u003cvoid()\u003e fn) override { std::unique_lockstd::mutex lock(mutex_); jobs_.push_back(std::move(fn)); cond_.notify_one(); } void shutdown() override { // Stop all worker threads… { std::unique_lockstd::mutex lock(mutex_); shutdown_ = true; } cond_.notify_all(); // Join... for (auto \u0026t : threads_) { t.join(); } } private: struct worker { explicit worker(ThreadPool \u0026pool) : pool_(pool) {} void operator()() { for (;;) { std::function\u003cvoid()\u003e fn; { std::unique_lock\u003cstd::mutex\u003e lock(pool_.mutex_); pool_.cond_.wait( lock, [\u0026] { return !pool_.jobs_.empty() || pool_.shutdown_; }); if (pool_.shutdown_ \u0026\u0026 pool_.jobs_.empty()) { break; } fn = pool_.jobs_.front(); pool_.jobs_.pop_front(); } assert(true == static_cast\u003cbool\u003e(fn)); fn(); } } ThreadPool \u0026pool_; }; friend struct worker; std::vectorstd::thread threads_; std::list\u003cstd::function\u003cvoid()» jobs_; bool shutdown_; std::condition_variable cond_; std::mutex mutex_; }; std::vectorstd::thread threads_; ThreadPool \u0026pool_; std::list\u003cstd::function\u003cvoid()» jobs_; using SocketOptions = std::function\u003cvoid(socket_t sock)\u003e; line_reader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 inline bool is_file(const std::string \u0026path) { struct stat st; return stat(path.c_str(), \u0026st) \u003e= 0 \u0026\u0026 S_ISREG(st.st_mode); } inline bool is_dir(const std::string \u0026path) { struct stat st; return stat(path.c_str(), \u0026st) \u003e= 0 \u0026\u0026 S_ISDIR(st.st_mode); } inline bool is_valid_path(const std::string \u0026path) { size_t level = 0; size_t i = 0; // Skip slash while (i \u003c path.size() \u0026\u0026 path[i] == '/') { i++; } while (i \u003c path.size()) { ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:2","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 背景 环境 安装 参考教程 源码及依赖文件下载 问题解决 cmake 问题 编译问题解决 测试 其他 背景 需要用到OpenCV3中使用SIFT和SURF特征提取，需要手动下载opencv和opencv_contrib的源码，然后将两个源码放在一起手动编译安装。 环境 ubuntu18.04 opencv-3.2.0 opencv_contrib-3.2.0 安装 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:0:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"参考教程 在ubuntu18.04中安装opencv_contrib-3.2.0采坑教程 主要参考上面教程，包含依赖库安装，cmake 配置等，下面会补充使用上述教程中优化和解决的部分编译问题。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:1:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"源码及依赖文件下载 这里主要提供了部分源文件的国内的gitee 下载地址和cmake 自动下载的配置文件(有几率下载不成功这里做下备份)。 opencv opencv_contrib opencv3.2_CMake 问题解决 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:2:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"cmake 问题 问题： 1 2 3 4 5 6 7 8 9 10 11 12 CMake Error: The following variables are used in this project, but they are set to NOTFOUND. Please set them or make sure they are set and tested correctly in the CMake files: CUDA_nppi_LIBRARY (ADVANCED) linked by target \"opencv_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev linked by target \"opencv_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev linked by target \"opencv_test_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev/test linked by target \"opencv_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_test_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_perf_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core ... ... 解决： 参考：OpenCV3.3+CUDA9.0+Cmake3.9 环境搭建 已经更换的 FindCUDA.cmake OpenCVDetectCUDA.cmake 文件下载地址： https://gitee.com/fromyuhu/opencv3.2_CMake ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:3:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"编译问题解决 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv/modules/imgcodecs/src/grfmt_exr.hpp:52:10: fatal error: ImfChromaticities.h: 没有那个文件或目录 #include \u003cImfChromaticities.h\u003e 解决： 1 sudo apt-get install libopenexr-dev 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv/modules/videoio/src/cap_gphoto2.cpp:32:10: fatal error: gphoto2/gphoto2.h: 没有那个文件或目录 #include \u003cgphoto2/gphoto2.h\u003e 解决： 1 sudo apt-get install libgphoto2-dev 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv3.2.0-bulid/opencv_lapack.h:2:10: fatal error: LAPACKE_H_PATH-NOTFOUND/lapacke.h: 没有那个文件或目录 #include \"LAPACKE_H_PATH-NOTFOUND/lapacke.h\" 解决： 1 2 3 4 5 sudo apt-get install liblapacke-dev checkinstall 修改出现问题的文件，例如我的文件是 opencv-3.2.0/build/opencv_lapack.h 将第二行中的#include\"LAPACKE_H_PATH-NOTFOUND/lapacke.h\" 修改为#include\"lapacke.h\"即可 问题： 1 Unsupported gpu architecture 'compute_20' 解决： CUDA_GENERATION=Kepler .. 测试 获取文件： https://gitee.com/fromyuhu/COMMON/tree/master/opencv/surf mkdir bulid cd bulid cmake .. make ./demo 能正常提取匹配特征点说明正常。 其他 笔者在安装的时候，有碰到 libgtk2.0-dev 由于依赖库问题无法安装问题，努力了很久也有搞定，这里说下，如果真的有碰到相的依赖库实在无法安装的问题，可以选择重装系统。笔者曾尝试解决部分库安装问题花费了不少时间，最后也没能解决，耽误了不少时间。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:4:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/introduction/introduction/","tags":["opencv"],"title":"开源软件:opencv modules介绍","uri":"/posts/open_source_software/opencv/introduction/introduction/"},{"categories":["开源软件"],"content":" Main modules: core. Core functionality imgproc. Image processing imgcodecs. Image file reading and writing videoio. Video I/O highgui. High-level GUI video. Video Analysis calib3d. Camera Calibration and 3D Reconstruction features2d. 2D Features Framework objdetect. Object Detection dnn. Deep Neural Network module ml. Machine Learning flann. Clustering and Search in Multi-Dimensional Spaces photo. Computational Photography stitching. Images stitching cudaarithm. Operations on Matrices cudabgsegm. Background Segmentation cudacodec. Video Encoding/Decoding cudafeatures2d. Feature Detection and Description cudafilters. Image Filtering cudaimgproc. Image Processing cudalegacy. Legacy support cudaobjdetect. Object Detection cudaoptflow. Optical Flow cudastereo. Stereo Correspondence cudawarping. Image Warping cudev. Device layer shape. Shape Distance and Matching superres. Super Resolution videostab. Video Stabilization viz. 3D Visualizer Extra modules: aruco. ArUco Marker Detection bgsegm. Improved Background-Foreground Segmentation Methods bioinspired. Biologically inspired vision models and derivated tools ccalib. Custom Calibration Pattern for 3D reconstruction cnn_3dobj. 3D object recognition and pose estimation API cvv. GUI for Interactive Visual Debugging of Computer Vision Programs datasets. Framework for working with different datasets dnn_modern. Deep Learning Modern Module dpm. Deformable Part-based Models face. Face Analysis freetype. Drawing UTF-8 strings with freetype/harfbuzz fuzzy. Image processing based on fuzzy mathematics hdf. Hierarchical Data Format I/O routines img_hash. The module brings implementations of different image hashing algorithms. line_descriptor. Binary descriptors for lines extracted from an image matlab. MATLAB Bridge optflow. Optical Flow Algorithms ovis. OGRE 3D Visualiser phase_unwrapping. Phase Unwrapping API plot. Plot function for Mat data reg. Image Registration rgbd. RGB-Depth Processing saliency. Saliency API sfm. Structure From Motion stereo. Stereo Correspondance Algorithms structured_light. Structured Light API surface_matching. Surface Matching text. Scene Text Detection and Recognition tracking. Tracking API xfeatures2d. Extra 2D Features Framework ximgproc. Extended Image Processing xobjdetect. Extended object detection xphoto. Additional photo processing algorithms ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/introduction/introduction/:0:0","tags":["opencv"],"title":"开源软件:opencv modules介绍","uri":"/posts/open_source_software/opencv/introduction/introduction/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 源码及编译使用 源码分析 std::future 源码及编译使用 源码地址：ThreadPool 源码及编译cmake 文件 ： ThreadPool 编译 1 2 3 4 mkdir build cd build cmake .. make 运行： 1 ./example 源码分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/:0:0","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":"std::future future std::future类模板定义头文件,其函数声明如下： 1 2 3 template \u003cclass T\u003e future; template \u003cclass R\u0026\u003e future\u003cR\u0026\u003e; // specialization : T is a reference type (R\u0026) template \u003c\u003e future\u003cvoid\u003e; // specialization : T is void 对于future补充说明如下： std::async 、 std::packaged_task 或 std::promise 能提供一个std::future对象给该异步操作的创建者 异步操作的创建者能用各种方法查询、等待或从 std::future 提取值。若异步操作仍未提供值，则这些方法可能阻塞。 异步操作准备好发送结果给创建者时，它能通过接口（eg,std::promise::set_value std::future） 修改共享状态的值。 std::future使用 下面就用std::future对象来获取异步操作的结果，没有使用到全局变量，逻辑非常清晰，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // future example #include \u003ciostream\u003e // std::cout #include \u003cfuture\u003e // std::async, std::future #include \u003cchrono\u003e // std::chrono::milliseconds // a non-optimized way of checking for prime numbers: bool is_prime (int x) { for (int i=2; i\u003cx; ++i) if (x%i==0) return false; return true; } int main () { // call function asynchronously: std::future\u003cbool\u003e fut = std::async (is_prime,444444443); // do something while waiting for function to set future: std::cout \u003c\u003c \"checking, please wait\"; std::chrono::milliseconds span (100); while (fut.wait_for(span)==std::future_status::timeout) std::cout \u003c\u003c '.' \u003c\u003c std::flush; bool x = fut.get(); // retrieve return value std::cout \u003c\u003c \"\\n444444443 \" \u003c\u003c (x?\"is\":\"is not\") \u003c\u003c \" prime.\\n\"; return 0; } ","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/:1:0","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":" TBB 基础 简介 并行 使用 接口 parallel_for parallel_reduce parallel_while graph 并发容器 concurrent_hash_map concurrent_vector concurrent_queue 锁 Task Scheduler ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:0:0","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"TBB 基础 Intel Threading Building Blocks TBB API ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:0","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"简介 并行 1、指令级的并行；即所谓的微程序、指令流水线等，现在cpu的一级缓存、二级缓存都很大，所以这个cache的效果还是比较好的（基于局部性原理） 2、线程级的并行；即同一个时刻多个函数在运行（现在的cpu好像都是多核的） 3、服务级别的（比如一个游戏服务器中有商店服务、也有战斗服务、聊天服务等 这里的每个服务可能对应多个逻辑线程） 4、节点级别的；即所谓的分布式系统，多个节点互相配合，使整个系统在逻辑上成为一个单一的系统。（google、qq等这些海量访问的服务统统是分布式的）。 一般来说，第一个级别的并行直接做在硬件里面，第二个级别的并行会有一些基础的框架，第三和第四个级别的并行就是应用程序自己的架构的问题了。 这里面实际上有一个争论：是在算法并行化上面花心思去研究还是采用分布式的框架来面对问题规模的增长？实际上2者各有利弊，前者可以充分利用已有硬件，但是对程序员的要求较高，维护开发成本高，风险大；后者容易实现但是浪费硬件，在有些情况下不是所有问题都可以用加个机器的方式可以解决的（比如客户端上的多媒体软件，其计算量极大，总不能要求所有用户都升级吧。） Intel Threading Building Blocks，是为了方便程序员使用多核处理器的C++库，应该是对应上面的线程级的并行。 使用 整个程序逻辑没办法自动并行化，那就针对控制流进行并行化，所以TBB中提供了 parallel_for、parallel_while、 parallel_reduce等；（这些是TBB给C++程序员的比较高层的接口）并行肯定是多线程，这样的话数据竞争问题就比较棘手，所以TBB提供并发容器；如果觉得TBB提供的这些接口还没有办法解决性能问题，那就可以更深入的研究使用mutex、atomic、task等了；可以看出，TBB从几个层次上为程序员提供了支持。 BB提供的接口： 由底层到高层，task_scheduler——–concurrent_container——–parallel_for—pipeline简单说，TBB帮我们调度一个个task（比OS的调度要高效），实现高效的并行算法。 要使用TBB进行并行化，首先程序员要知道哪些是可以并行化；其次，要熟悉TBB并行化的框架（主要是泛型编程）；再次，程序员要大概知道并行算法的执行步骤；最后，利用TBB的组件，实现并行化的算法。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:1","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"接口 parallel_for parallel_for 适用场合：多个数据或请求彼此没有依赖关系，所要进行的操作是一样的（典型SPMD）。 blocked_range 1 2 3 4 5 6 7 // 典型的c++泛型编程 blocked_range 是要处理的多个数据，3个参数依次是开始的指针（迭代器）、结束指针、每个任务分配的数据数 //! Construct range over half-open interval [begin,end), with the given grainsize. blocked_range( Value begin_, Value end_, size_type grainsize_=1 ) : my_end(end_), my_begin(begin_), my_grainsize(grainsize_) { __TBB_ASSERT( my_grainsize\u003e0, \"grainsize must be positive\" ); } 第一个参数表示起始，第二个参数表示结束，它们的类型为const_iterator，表示的区间为[begin，end)这样一个半开区间。第三个参数，grainsize，表示的是一个“合适的大小”块，这个块会在一个循环中进行处理，如果数组比这个grainsize还大，parallel_for会把它分割为独立的block，然后分别进行调度（有可能由多个线程进行处理）。 这样我们知道，grainsize其实决定了TBB什么时候对数据进行划分，如果我们把grainsize指定得太小，那就可能会导致产生过多得block，从而使得不同block间的overhead增加（比如多个线程间切换的代价），有可能会使性能下降。相反，如果grainsize设得太大，以致于这个数组几乎没有被划分，那又会导致不能发挥parallel_for期望达到的并行效果，也没有达到理想得性能。所以我们在决定grainsize时需要小心，最好是能够经过调整测试后得到的值，当然你也可以如本例中一样不指定，让TBB帮你来决定合适的值（一般不是最优的）。一个调整grainsize的经验性步骤： 1）首先把grainsize设得比预想的要大一些，通常设为10000 2）在单处理机机器上运行，得到性能数据 3）把grainsize减半，看性能降低多少，如果降低在5%-10%之间，那这个grainsize就已经是一个不错的设定。 parallel_for 1 2 3 4 5 6 //! Parallel iteration over range with simple partitioner. /** @ingroup algorithms **/ template\u003ctypename Range, typename Body\u003e void parallel_for( const Range\u0026 range, const Body\u0026 body, const simple_partitioner\u0026 partitioner ) { internal::start_for\u003cRange,Body,const simple_partitioner\u003e::run(range,body,partitioner); } 其参数： 1）range：指定划分block的范围。 2）body：指定对block应用的操作，Body可以看成是一个操作子functor，它的operator(…)会以blocked_range为参数进行调用，当然如果我们传过来的是一个函数指针也是可以的，只要它能以blocked_range为参数进行调用。 3）partitioner：指定划分器，可选的两种simple_partitioner和auto_partitioner。 1 parallel_for(0,100,[](int v){cout\u003c\u003cv\u003c\u003cendl;}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // parallel_forFibBody可以简单理解为一个函数对象（c++里是用运算符重载实现的，即（）是通信的接口） parallel_for( blocked_range\u003cint\u003e( 1, my_n, 10 ), parallel_forFibBody(my_stream) ); struct parallel_forFibBody { QueueStream \u0026my_stream; //! fill functor arguments parallel_forFibBody(QueueStream \u0026s) : my_stream(s) { } // 这里是并行的代码 void operator()( const blocked_range\u003cint\u003e \u0026range ) const { int i_end = range.end(); for( int i = range.begin(); i != i_end; ++i ) { my_stream.Queue.push( Matrix1110 ); // push initial matrix } } }; parallel_reduce parallel_reduce 适合于需要汇总的情况，即各个数据的结果需要汇总回来。 1 2 3 4 5 6 7 8 9 10 11 12 /** parallel_reduce overloads that work with anonymous function objects (see also \\ref parallel_reduce_lambda_req \"requirements on parallel_reduce anonymous function objects\"). **/ //! Parallel iteration with reduction and default partitioner. /** @ingroup algorithms **/ template\u003ctypename Range, typename Value, typename RealBody, typename Reduction\u003e Value parallel_reduce( const Range\u0026 range, const Value\u0026 identity, const RealBody\u0026 real_body, const Reduction\u0026 reduction ) { internal::lambda_reduce_body\u003cRange,Value,RealBody,Reduction\u003e body(identity, real_body, reduction); internal::start_reduce\u003cRange,internal::lambda_reduce_body\u003cRange,Value,RealBody,Reduction\u003e,const __TBB_DEFAULT_PARTITIONER\u003e ::run(range, body, __TBB_DEFAULT_PARTITIONER() ); return body.result(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 float ParallelSumFoo(float a[], size_t n) { return parallel_reduce(tbb::blocked_range\u003csize_t\u003e(0, n), float(0.f), [a](const tbb::blocked_range\u003csize_t\u003e\u0026 r, const float\u0026 x) -\u003e float { float sum = x; for (size_t i = r.begin(); i != r.end(); ++i) { sum += foo(a[i]); } return sum; }, [](const float\u0026 x, const float\u0026 y) -\u003e float{ return x + y; }); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //注意分发下去和汇总回来的方法 float ParallelSumFoo( const float a[], size_t n ) { SumFoo sf(a); parallel_reduce(blocked_range\u003csize_t\u003e(0,n,IdealGrainSize), sf ); return sf.sum; } class SumFoo { float* my_a; public: float sum; void operator()( const blocked_range\u003csize_t\u003e\u0026 r ) { float *a = my_a; for( size_t i=r.begin(); i!=r.end(); ++i ) sum += Foo(a[i]); } SumFoo( SumFoo\u0026 x, split ) : my_a(x.my_a), sum(0) {} // 分发任务，注意这个构造器要求是线程安全的 void join( const SumFoo\u0026 y ) {sum+=y.sum;} // 收集汇总结果 SumFoo(float a[] ) : my_a(a), sum(0) {} }","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:2","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"graph 1 2 3 4 5 //! Makes an edge between a single predecessor and a single successor template\u003c typename T \u003e inline void make_edge( sender\u003cT\u003e \u0026p, receiver\u003cT\u003e \u0026s ) { internal_make_edge( p, s ); } ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:3","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"并发容器 大部分程序都有容器类，在多线程环境下就有数据污染的问题，为了使并发的线程串行化，一般是使用加锁的办法，如果这个容器由程序员自己来实现，难度还是比较大的，这样就需要有线程安全的容器类。 concurrent_hash_map hash接口与stl类似 concurrent_vector grow_by(n) 插入n个item（动态增长） grow_to_at_least（）设定容器的大小 size() 包括正在并发增长的部分 因为有可能会同时取，所以程序员需要自己维护自己的class的线程安全性 clear() 不是线程安全的 concurrent_queue pop_if_present(item) 非阻塞， pop（） 阻塞， concurrent_queue::size() 负数时表示有多少个消费者在等待 set_capacity（）指定队列大小，会使push操作被阻塞 在并行时，paralell_while pipeline 的效率要高于concurrent_queue ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:4","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"锁 如果觉得TBB的加锁效率不高，可以自己控制锁，最常用的是spin lock。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:5","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"Task Scheduler 整个TBB引擎的核心是 Task Scheduler（基于任务图来实现），提高效率的核心是threading stealing，保证cpu的效率。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:6","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["java"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Android NDK JNI之C\u0026C++调用Java NDK-动态和静态库 1. 静态库 1.1. 静态库编译流程 1.2. 静态库使用 2. 动态库 2.1. 动态库编译流程 2.2. 动态库使用 2.3. readelf工具 3. 总结 Android NDK Android NDK JNI之C\u0026C++调用Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 //使用jni调用java的代码, 必须了解java的反射机制; //在jni中反射调用java代码的话, 一定要写异常处理 // jni中异常处理: if (pEnv-\u003eExceptionCheck()) //这里异常判断一定要写 { pEnv-\u003eExceptionDescribe(); pEnv-\u003eExceptionClear();//如果出现异常,不清除,返回也会崩溃; } //这里就直接贴jni代码了, 详细在注释里说明; //异常处理 #define isException() if (pEnv-\u003eExceptionCheck())\\ {pEnv-\u003eExceptionDescribe();pEnv-\u003eExceptionClear();} JNIEXPORT jint JNICALL Java_org_bing_testjni_MainActivity_Add (JNIEnv *env, jobject obj, jint a, jint b) { //通过包名或的类的类型 //如果是静态函数, 那么第二个参数就是jclass jclass clsMainActivity = pEnv-\u003eFindClass(\"cr25/myjni/MainActivity\"); isException();//异常处理 //获取构造 //参数1: 类的类型jclass //参数2: 构造函数名称, java中所有类的构造函数名都是”\u003cinit\u003e” //参数3: 记录了参数个数, 类型, 返回值类型, 下面会详细说 jmethodID methodConstruct = pEnv-\u003eGetMethodID(clsMainActivity, \"\u003cinit\u003e\", \"()V\"); isException(); //创建类对象 jobject objMain = pEnv-\u003eNewObject(clsMainActivity, methodConstruct); isException(); //获取javaAdd方法地址 jmethodID JavaAdd= pEnv-\u003eGetMethodID(clsMainActivity,\"JavaAdd\", \"(II)I\"); isException(); //执行函数, 注意这个CallXXXMethod, XXX是要根据返回值类型来确定 //如: CallByteMethod, CallStringMethod, CallFloatMethod //因为在JAVA反射中可以用Object统一返回值, C++没法来统一返回值 int resutl = pEnv-\u003eCallIntMethod(objMain , JavaAdd, a, b); //到这里就调用完了函数, 还说一下字段获取与修改 //获取字段 //参数1: jclass //参数2: 字段名 //参数3: 字段类型记录 jfieldID mData = pEnv-\u003eGetFieldID(clsMainActivity, \"mData\", \"I\"); //设置字段的值 pEnv-\u003eSetIntField(objMainActivity, mData, 2); return resutl ; } Daalvik字节码类型描述符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 单独说一下GetMethodID与GetFieldID第三个参数意义, 其实这些字符串就是代表了参数与返回值类型的的简写; 括号内的代表参数, 括号外代表返回值 如: (II)V I是代表int , V是代表viod, 表示有两个int的参数, 返回值是void类型 如: (Ljava/lang/String;ILjava/lang/String;)J Ljava/lang/String;代表是类的类型, 格式为L[包名]; 注意是”;”结束 J是代表Long 表示有三个参数, String, int, String, 返回值为Long V void 只能用于返回值类型 Z boolean 变量值只能是 真(true) 或 假(false) B byte 字节型 S short 短整型 C char 字符型 I int 整数型 J long（64位） 长整型 F float 浮点型 D double(64位) 双精度浮点型 L java类类型 package.name.ObjectName Lpackage/name/ObjectName; [ 数组类型 [I表示一个整型一维数组，等于java中的int[]。注意多位数数组的维数最大为255个。 [[I=int[][] [[[I=int[][][] NDK-动态和静态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:0:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1. 静态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1.1. 静态库编译流程 gcc——\u003e obj 文件—-\u003e多个obj使用ar—–\u003e静态库文件 需要用到的核心命令: 1 2 3 4 gcc –g –c mod1.c mod2.c mod3.c 编译obj (debug版) AR r libdemo.a mod1.o mod2.o mod3.o 将3个obj 添加到libdemo.a中 AR tv libdemo.a 查看libdemo.a中的obj文件 AR d libdemo.a mod3.o 将mod3.o从libdemo.a中删除 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:1","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1.2. 静态库使用 代码中包含头文件, 在链接的时候使用libdemo.a链接即可; ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:2","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2. 动态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.1. 动态库编译流程 gcc——\u003e obj 文件—-\u003e多个obj使用gcc的 -shared—–\u003eso文件 需要用到的核心命令: 1 2 3 4 5 6 7 8 gcc -g -c -fpic -Wall mod1.c mod2.c mod3.c gcc -g -shared mod1.o mod2.o mod3.o -o libfoo.so gcc -g -fpic -Wall -shared mod1.o mod2.o mod3.o -o libfoo.so -fpic 表示代码中地址全部使用相对地址, 不使用绝对地址,解决重定位 -c 只编译不链接 -Wall 显示所有警告 -g 生成Debug版 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:1","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.2. 动态库使用 静态使用 直接把So文件当作obj一起链接到文件, 文件中会存so信息, 在使用时会在目录中搜索so linux动态库搜索顺序: system -\u003e lib -\u003e 环境变量 增加新环境变量, 用于系统搜索到我们的so, 这个环境变量是一次性的 adb shell export LD_LIBRARY_PATH += /data/local/tmp 动态使用 使用api加载指定目录的so, 再使用; dlopen打开一个so文件 dlsym根据函数名拿到函数指针 一个工程代码如果同时有静态和动态编译, 那么就只编译动态库; ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:2","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.3. readelf工具 使用readelf工具可以查看elf文件的符号表 命令: 平台-readelf - s elf文件 ,当value值为0表示为导入函数 1 __attribute__() //关键字可以指定函数属性 如: 1 2 __attribute__(visibility(\"hidden\")) // 隐藏函数 __attribute__(visibility(\"defult\")) // 导出函数 以下在so的装载和卸载的时候被调用(老版本, 已经被淘汰, 但是可以用); 1 2 void _init() // 初始化函数 void _fini() // 反初始化函数 在新版本的初始化与反初始化机制中, 可以设置多个函数, 名字可以自定义; 1 2 3 4 void __attribute__((constructor)) OnLoad() // 初始化函数 void __attribute__((destructor)) UnLoad() // 反初始化 void __attribute__((constructor)) OnLoad1() // 初始化函数1 void __attribute__((destructor)) UnLoad1() // 反初始化1 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:3","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"3. 总结 1.相关函数 1 2 3 4 dlopen()函数打开一个共享库 dlsym()函数在库中搜 dlclose() 函数光比之前dlopen打开的库 dlerror() 函数返回一个错误消息的字符串 2.隐藏函数 1 void __attribute__ ((visibility(\"hidden\"))) fun() {} so构造析构(会在so加载和卸载的时候调用) 1 2 void __attribute__ ((constructor)) Load() void __attribute__ ((destructor)) UnLoad() _init()和_fini()函数 会在so加载和卸载时调用 _init函数比构造函数来的早 hidden后在用dlsym函数无法找到 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:3:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 第一部分 bash简介 第二部分 bash示例和书写流程 第三部分 bash基础语法 1. 条件判断 1.1 test判断语句 1.2 []条件判断 1.3 测试逻辑表达式 2. if then else语句 3. case语句 4. for循环 5. until循环 6. while循环 7. 使用break和continue控制循环 第四部分 bash数组 1. 数组定义 2. 数组操作 第五部分 函数 1. 函数定义 2. 函数调用和传参 3. 函数返回值 4. 应用实例 第六部分 数值运算 应用实例一：分别用上面四种方式实现\"3*(5+2)\"。 应用实例二：分别勇上面四种方式实现“数值+1”。 应用实例三：计算1/3,保留3位小数。 第七部分 字符运算 1. 字符串定义 2. 字符串操作 2.1 string操作公式表 2.2 应用实例 第八部分 bash自带参数 第九部分 bash调试 1. bash命令调试 2. echo调试 3. printf 第十部分 bash注释 1. 单行注释 2. 多行注释 第十一部分 bash内建指令 1. 内建命令查看方法 2. 常用内建命令说明 第一部分 bash简介 在介绍bash之前，需要先了解它的起源——shell。 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。 UNIX系统上有很多种Shell。首个shell，即Bourne Shell，于1978年在V7(AT\u0026T的第7版)UNIX上推出。后来，又演变出C shell、bash等不同版本的shell。 bash，全称为Bourne-Again Shell。它是一个为GNU项目编写的Unix shell。bash脚本功能非常强大，尤其是在处理自动循环或大的任务方面可节省大量的时间。bash是许多Linux平台的内定Shell，这也是我们介绍它主要的原因。 第二部分 bash示例和书写流程 1 新建文件test.sh $ touch test.sh 2 添加可执行权限 $ chmod +x test.sh 3 编辑test.sh，test.sh内容如下： #!/bin/bash echo \"hello bash\" exit 0 说明： (01) #!/bin/bash : 它是bash文件声明语句，表示是以/bin/bash程序执行该文件。它必须写在文件的第一行！ (02) echo “hello bash” : 表示在终端输出“hello bash” (03) exit 0 : 表示返回0。在bash中，0表示执行成功，其他表示失败。 4 执行bash脚本 $ ./test.sh 在终端输出“bash hello” 第三部分 bash基础语法 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:0:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 条件判断 条件判断有2中格式，分别是“test EXPRESSION”和“[ EXPRESSION ]”。 “test”判断语句，在实际中应用的比较少；相反的，“[]”判断语句应用很广。下面分别对它们进行介绍 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.1 test判断语句 基本格式 test EXPRESSION 格式说明 test是关键字，表示判断； EXPRESSION是被判断的语句。 应用实例 表达式 说明 test -d File 判断File是不是\"目录\" test -f File 判断File是不是\"普通文件\" test -L File 判断File是不是\"符号链接\" test -r File 判断File是不是\"可读\" test -s File 判断File是不是\"文件长度大于0、非空\" test -w File 判断File是不是\"可写\" test -u File 判断File是不是\"有suid位设置\" test -x File 判断File是不是\"可执行\" ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:1","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.2 []条件判断 基本格式 [ EXPRESSION ] 格式说明 中括号的左右扩弧和EXPRESSION之间都必须有空格！ 应用实例 表达式 说明 [ (expr) ] expr为真 [ !expr ] expr为假 [ expr1 -a expr2 ] expr1和expr2同时为真 [ expr1 -o expr2 ] expr1或expr2为真 [ -n string ] string的长度不为0 [ -z string ] string的长度为0 [ string1 = string2 ] 两个字符串string1和string2相等 [ string1 != string2 ] 两个字符串string1和string2不等 [ integer1 -eq integer2 ] 两个integer1和integer2整数相等 [ integer1 -ne integer2 ] integer1不等于integer2 [ integer1 -ge integer2 ] integer1大于或等于integer2 [ integer1 -gt integer2 ] integer1大于integer2 [ integer1 -le integer2 ] integer1小于或等于integer2 [ integer1 -lt integer2 ] integer1小于integer2 [ file1 -ef file2 ] 文件file1和file2有相同的device和inode数目 [ file1 -nt file2 ] file1的修改事件早于file2 [ file1 -ot file2 ] file1的修改事件晚于file2 [ -b file ] file是块设备 [ -c file ] file是字符设备 [ -d file ] file是文件夹 [ -e file ] file是存在 [ -f file ] file是普通文件 [ -g file ] file存在，且有group-ID [ -G file ] file存在，且group-ID是有效的 [ -h file ] file存在，且是一个硬链接 [ -L file ] file存在，且是一个软链接 [ -r file ] file存在，且可读 [ -w file ] file存在，且可写 [ -x file ] file存在，且可执行 例如， 一、判断文件/home/skywang/123.txt是否存在 $ [ -f /home/skywang/123.txt ] 二、判断变量val是否等于字符串“skywang” $ [ \"$val\" = \"skywang\" ] 三，判断变量num是否等于数字100 $ [ \"$num\" -eq \"100\" ] ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:2","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.3 测试逻辑表达式 基本格式 符号 说明 -a 逻辑与,操作符两边均为真,结果为真,否则为假。 -o 逻辑或,操作符两边一边为真,结果为真,否则为假。 ! 逻辑否,条件为假,结果为真。 应用实例 一、判断文件123.txt是不是可读写 $ [ -r 123.txt -a -w 123.txt ] 等价于 $ [ -r 123.txt ] \u0026\u0026 [ -w 123.txt ] 二、判断变量num是不是等于数字101或102 $ [ \"$num\" -eq \"101\" -o \"$num\" -eq \"102\" ] 等价于 $ [ -r 123.txt ] || [ -w 123.txt ] 三、判断文件123.txt是不是不可读 $ [ ! -r 123.txt ] ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:3","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. if then else语句 基本格式 if 条件1 then 命令1 elif 条件2 then 命令2 else 命令3 if 格式说明 if 语句必须以单词 fi 终止。 elif 和 else 为可选项,如果语句中没有否则部分,那么就不需要 elif 和 else 部分。 if 语句可以有许多 elif 部分。最常用的 if 语句是 if then fi 结构。 应用实例 一、判断文件文件123.txt是否存在，存在则输出“file exist”；没有则输出“file not exist”。bash文件内容如下： #!/bin/bash if [ -f 123.txt ];then echo \"file exist\" else echo \"file not exist\" fi exit 0 二、提示用户输入值。若输入的值小于0，则输出“negtive number”；若等于0,则输出“number zero”，否则，输出“positive number”。bash文件内容如下： #!/bin/bash # 提示用户输入一个值 echo -n \"please input a number:\" # 保存用户输入的值到num中 read num if [ \"$num\" -lt \"0\" ];then # 小于0,则输出“negtive number” echo \"negtive number\" elif [ \"$num\" -gt \"0\" ];then # 大于0,则输出“positive number” echo \"positive number\" else # 大于0,则输出\"number zero\" echo \"number zero\" fi exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:2:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. case语句 case语句为多选择语句。可以用case语句匹配一个值与一个模式,如果匹配成功,执行相匹配的命令。 基本格式 case 值 in 模式1} 命令1 ... ;; 模式2) 命令2 ... ;; esac 格式说明 “模式”部分可能包括元字符，即: 符号 说明 * 任意字符。 ? 任意单字符。 [..] 类或范围中任意字符 应用实例 一、提示用户输入Y/y或N/n。若输入Y/y，则输出“yes”；若输入N/n,则输出“no”；否则，“incorrect input”。bash文件内容如下： #!/bin/bash # 提示用户输入一个值 echo -n \"are you femail(Y/N):\" # 保存用户输入的值到val中 read val case $val in Y|y) # 用户输入Y或y echo \"yes\" ;; N|n) # 用户输入N或n \"no\" ;; *) # 其它输入 echo \"incorrect input\" ;; esac exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:3:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"4. for循环 基本格式 for 变量名in列表 do 命令1 命令2... done 格式说明 当变量值在列表里, for循环即执行一次所有命令,使用变量名访问列表中取值。 命令可为任何有效的 shell命令和语句。变量名为任何单词。 in列表用法是可选的,如果不用它, for循环使用命令行的位置参数。 应用实例 一、输入当前文件夹的一级子目录中文件名字。bash脚本内容如下： #!/bin/bash # 将ls的结果保存到变量CUR_DIR中 CUR_DIR=`ls` # 显示ls的结果 echo $CUR_DIR for val in $CUR_DIR do # 若val是文件，则输出该文件名 if [ -f $val ];then echo \"FILE: $val\" fi done exit 0 二、输出1-10之间数字的总和。bash脚本内容如下： #!/bin/bash sum=0 for ((i=1;i\u003c10;i++)) do ((sum=$sum+$i)) done echo \"sum=$sum\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:4:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"5. until循环 until循环执行一系列命令直至条件为真时停止。 until循环与 while循环在处理方式上刚好相反。一般 while循环优于until循环,但在某些时候 — 也只是极少数情况下, until循环更加有用。 基本格式 until 条件 命令1 ... done 格式说明 条件可为任意测试条件,测试发生在循环末尾,因此循环至少执行一次 — 请注意这一点。 应用实例 一、从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 until [ \"$val\" -eq \"5\" ] do # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) done exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:5:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"6. while循环 基本格式 while 命令 do 命令1 命令2 ... done 应用实例 一、从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while [ \"$val\" -lt \"5\" ] do # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) done exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:6:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"7. 使用break和continue控制循环 基本格式 break命令允许跳出循环。 continue命令类似于 break命令,只有一点重要差别,它不会跳出循环,只是跳过这个循环步。 应用实例 一、[break应用]从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while true do if [ \"$val\" -eq \"5\" ];then # 如果val=5，则跳出循环 break; else # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) fi done exit 0 二、[continue应用]从0开始逐步递增到10：当数值为5时，将数值递增2；否则，输出数值。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while [ \"$val\" -le \"10\" ] do if [ \"$val\" -eq \"5\" ];then # 如果val=5，则将数值加2 ((val=$val+2)) continue; else # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) fi done exit 0 第四部分 bash数组 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:7:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 数组定义 方法一 array=(10 20 30 40 50) 一对括号表示是数组，数组元素用“空格”符号分割开。引用数组时从序号0开始。 方法二 array[0]=10 array[1]=20 array[2]=30 array[3]=40 array[4]=50 方法三 var=\"10 20 30 40 50\"; array=($var) ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:8:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 数组操作 (01) 显示数组中第2项 $ echo ${array[i]} 说明：数组是从序号0开始计算(即第1项为array[0])。 (02) 显示数组中的所有元素 $ echo ${array[@]} 或者 $ echo ${array[*]} (03) 显示数组长度 $ echo ${#array[@]} 或者 $ echo ${#array[*]} (04) 删除数组第2项元素 $ unset array[1] 说明：unset仅仅只清除array[1]的值，并没有将array[1]删除掉 (05) 删除整个数组 $ unset array (06) 输出数组的第1-3项 $ echo ${array[@]:0:3} 说明：参考“${数组名[@或*]:起始位置:长度}” (07) 将数组中的0替换成1 $ echo ${a[@]/0/1} 说明：${数组名[@或*]/查找字符/替换字符 第五部分 函数 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:9:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 函数定义 基本格式 function 函数名() { ... } 格式说明 function可有可无。但建议保留，因为保留的话看起来更加直观。 应用实例 function foo() { # 定义局部变量i local i=0 # 定义局部变量total=传入foo的参数总数 local total=$# # 输出参数总数 echo \"total param =$total\" # 输出传入foo的每一个参数 for val in $@ do ((i++)) echo \"$i -- val=$val\" done # 返回参数总数 return $total } ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:10:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 函数调用和传参 调用方法 直接通过函数名去调用。 应用实例 foo param1 param2 param3 说明：调用函数foo，并传入param1 param2 param3三个参数 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:11:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. 函数返回值 使用方法 return 返回值 方法说明 例如，foo param1 param2 param3之后，再调用$?就是上次调用的返回值 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:12:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"4. 应用实例 编辑一个函数foo：打印foo的输入参数的总数，并输入每个参数和参数对应的序号。 #!/bin/bash function foo() { # 定义局部变量i local i=0 # 定义局部变量total=传入foo的参数总数 local total=$# # 输出参数总数 echo \"total param =$total\" # 输出传入foo的每一个参数 for val in $@ do ((i++)) echo \"$i -- val=$val\" done # 返回参数总数 return $total } foo foo param1 param2 param3 # 输出foo param1 param2 param3的返回值 echo \"return value=$?\" exit 0 输出结果: total param =0 total param =3 1 -- val=param1 2 -- val=param2 3 -- val=param3 return value=3 第六部分 数值运算 数值比较请参考\"第三部分\"的1.2节，本部分只介绍数值运算。 常用的4种数值运算说明 数值元算主要有4种实现方式：(())、let、expr、bc。 工作效率：(()) == let \u003e expr \u003e bc (01), (())和let是bash内建命令，执行效率高；而expr和bc是系统命令，会消耗内存，执行效率低。 (02), (())、let和expr只支持整数运算，不支持浮点运算；而bc支持浮点运算。 下面分别介绍这4种实现方式的使用方法。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:13:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例一：分别用上面四种方式实现\"3*(5+2)\"。 #!/bin/bash # 数值i=3*(5+2) (方法一:$(())实现) val=$((3*(5+2))) echo \"val=$val\" # 数值i=3*(5+2) (方法二:let实现) let \"val=3*(5+2)\" echo \"val=$val\" # 数值i=3*(5+2) (方法三:expr实现) val=`expr 3 \\* \\( 5 + 2 \\)` echo \"val=$val\" # 数值i=3*(5+2) (方法四:bc实现) val=`echo \"3*(5+2)\"|bc` echo \"val=$val\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:14:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例二：分别勇上面四种方式实现“数值+1”。 #!/bin/bash val=0 # 数值加1 (方法一) ((val++)) echo \"val=$val\" val=0 # 数值加1 (方法二) let val++ echo \"val=$val\" val=0 # 数值加1 (方法三) val=`expr $val + 1` echo \"val=$val\" val=0 # 数值加1(方法四) val=`echo \"$val+1\"|bc` echo \"val=$val\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:15:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例三：计算1/3,保留3位小数。 #!/bin/bash # 数值i=3*(5+2) (方法四:bc实现) val=`echo \"scale=3; 1/3\"|bc` echo \"val=$val\" exit 0 第七部分 字符运算 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:16:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 字符串定义 表达式 说明 ${var} 变量var的值, 与$var相同 ${var-DEFAULT} 如果var没有被声明, 那么就以$DEFAULT作为其值 ${var:-DEFAULT} 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 ${var=DEFAULT} 如果var没有被声明, 那么就以$DEFAULT作为其值 ${var:=DEFAULT} 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 ${var+OTHER} 如果var声明了, 那么其值就是$OTHER, 否则就为null字符串 ${var:+OTHER} 如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串 ${var?ERR_MSG} 如果var没被声明, 那么就打印$ERR_MSG ${var:?ERR_MSG} 如果var没被设置, 那么就打印$ERR_MSG ${!varprefix*} 匹配之前所有以varprefix开头进行声明的变量 ${!varprefix@} 匹配之前所有以varprefix开头进行声明的变量 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:17:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 字符串操作 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2.1 string操作公式表 表达式 说明 ${#string} $string的长度 ${string:position} 在$string中, 从位置$position开始提取子串 ${string:position:length} 在$string中, 从位置$position开始提取长度为$length的子串 ${string#substring} 从变量$string的开头, 删除最短匹配$substring的子串 ${string##substring} 从变量$string的开头, 删除最长匹配$substring的子串 ${string%substring} 从变量$string的结尾, 删除最短匹配$substring的子串 ${string%%substring} 从变量$string的结尾, 删除最长匹配$substring的子串 ${string/substring/replacement} 使用$replacement, 来代替第一个匹配的$substring ${string//substring/replacement} 使用$replacement, 代替所有匹配的$substring ${string/#substring/replacement} 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring ${string/%substring/replacement} 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:1","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2.2 应用实例 首先，我们定义个str字符串变量，然后再对此变量进行字符串操作。 $ str=\"hello world\" (01) 显示字符串长度 $ echo ${#str} (02) 提取world $ echo ${str:6} (03) 提取or $ echo ${str:7:2} (04) 删除hello $ echo ${str#hello} 或 $ echo ${str#*lo} (05) 删除world $ echo ${str%world} 或 $ echo ${str%wo*} (06) 将所有的字符“l”替换为“m” $ echo ${str//l/m} 第八部分 bash自带参数 表达式 说明 $? 上次指令或程序的执行结果。如果执行成功则为0，否则为非0 $# 参数个数 $@ 代表全部变量，例如，\"$1\" “$2” “$3” “$4”，每个变量是独立的，且用双引号括起来 $* 代表全部变量，例如，$1 $2 $3 $4 $- 在shell启动或使用set命令时提供选项 $$ 当前shell的进程号 $0 当前shell进程名 $n n表示数字。例如，$1表示第1个参数，$2表示第2个参数 第九部分 bash调试 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:2","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. bash命令调试 bash [-nvx] scripts.sh 选项与参数: -n :不要执行 script,仅查询语法的问题; -v :再执行 sccript 前,先将 scripts 的内容输出到屏幕上; -x :将使用到的 script 内容显示到屏幕上,这是很有用的参数! 例如，想要执行bash脚本，并查看bash的调用流程，可以通过以下命令： $ bash -x test.sh ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:19:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. echo调试 echo [OPTION] STRING 说明： -n : 输出内容之后，不换行。默认是输入内容之后，换行。 -e : 开启反斜线“\\”转义功能 -E : 开启反斜线“\\”转义功能（默认）。 例如，输出“please input a number:”之后不换行。 $ echo -n \"please input a number:\" ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:20:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. printf 和echo一样，printf也能用于输出。语法格式和C语言中printf一样。 例如，输出“hello printf”之后换行。 $ printf \"hello printf\\n\" 第十部分 bash注释 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:21:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 单行注释 # echo \"single line\" 说明：#放在文件开头，表示注释掉本行。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:22:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 多行注释 可以通过以下两种方法实现多行注释： :||{ ....被注释的多行内容 } 或者 if false ; then ....被注释的多行内容 fi 第十一部分 bash内建指令 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:23:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 内建命令查看方法 基本格式 type cmd 格式说明 type是命令关键字，cmd表示查看的命令；若输出builtin，则该命令是bash的内建命令。 例如: $ type echo 除此之外，用户也可以通过man bash或者man builtins查看bash的全部内置命令. ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:24:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 常用内建命令说明 指令 使用示例 说明 echo echo arg 在屏幕上显示出由arg指定的字串 read read变量名表 从标准输入设备读入一行，分解成若干字，赋值给bash程序内部定义的变量 shift shift [N] (N为大于0的整数；当N省略时，等价与于“shift 1”) 所有的参数依次向左移动N个位置，并使用$#减少N，直到$#=0为止。 alias alias name=‘value’ 别名。用name替换value，value要用单引号括住。 export export变量名[=变量值] export可以把bash的变量向下带入子bash(即子bash中可以使用父bash的变量)，从而让子进程继承父进程中的环境变量。但子bash不能用export把它的变量向上带入父bash。 readonly readonly 变量名 定义只读变量。不带任何参数的readonly命令将显示出所有只读变量。 exec exec 命令参数 当bash执行到exec语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时，该进程（也就是最初的bash）就终止了，所以bash程序中exec后面的语句将不再被执行。 “.\"(点) bash程序文件名 使bash读入指定的bash程序文件并依次执行文件中的所有语句。 exit exit N 退出Shell程序。在exit之后可有选择地指定一个数位作为返回状态。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:25:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_03/","tags":["bash"],"title":"bash 编程笔记 (三)","uri":"/posts/program/bash/bash_note_03/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 实例一：备份/更新文件的脚本 实例一：备份/更新文件的脚本 编写一个脚本文件backup.sh，备份android、kernel或uboot中的文件，备份的时候要保留文件在备份文件夹(即保留文件的相对路径)。 (01) 新建list_file.txt，并在list_file.txt中记录要备份的文件的路径。 (02) 当执行“./backup.sh bb”命令时：backup.sh会新建bb目录，然后读取list_file.txt中记录的文件路径，并将记录的文件路径对应的文件备份到bb目录下。 (03) 当执行“./backup.sh tt”命令时，backup.sh会判断是否存在tt目录，若存在tt目录的话，则tt中的文件更新到list_file.txt所记录的文件路径；否则的话，不更新文件。 脚本内容如下： #!/bin/bash ##############################NOTE############################ # # AUTHOR : skyWang # DATE : 2012-07-16 # DESCRIPTION : 用于备份文件 or 更新文件 # # 1. 备份文件 # (1) 备份命令 : ./run.sh bb # (2) 备份文件所在目录: bb # 这个是在步骤(1)之后，在当前目录下自动建立bb目录 # # 2. 更新文件 # (1) 更新命令 : ./run.sh tt # (2) 更新文件所在目录: tt # 这个是必须在步骤(1)之前已经存在的目录。因为，就是为了用tt目录中的文件去替换到目标文件。 # # OTHER : 1. list_file.txt 文件说明(即，list_file.txt中的文件必须满足一下条件）： # “变量COMMPATH_PATH的值”和“list_file.txt中的每一行内容”组合起来得到的完整路径所对应的文件，必须存在！ # # 例如： COMMON_PATH=/root/ # list_file.txt中有以下1行内容： # android/build/core/Makefile # 这样，“变量COMMPATH_PATH的值”和“list_file.txt中的行”组合起来得到的完整路径就是： # /root/android/build/core/Makefile # # “/root/android/build/core/Makefile”这个文件必须存在于电脑中。 # # （1）若list_file.txt满足以上条件，运行“./run.sh bb”就可以备份“/root/android/build/core/Makefile”。 # 备份时，会自动(在当前目录下)建立目录“bb”，并将文件备份到“bb”目录下 # （2）若将bb目录重命名成tt，运行“./run.sh tt”就可以将“tt”中的文件更新到“/root/android/build/core/Makefile”。 # # ##############################NOTE############################ #########TODO...START######### # 假设android、kernel、uboot在同一级目录； # 则，COMMON_PATH是它们所在目录的路径。 COMMON_PATH=/home/skywang/a8/gingerbread/code/ #########TODO...END########### #########CONSTANT...START######### LIST_FILE=\"list_file.txt\" B_FOLDER=\"bb/\" T_FOLDER=\"tt/\" # android工程的文件夹名字 ANDROID_FOLDER=\"android\" # kernel工程的文件夹名字 KERNEL_FOLDER=\"kernel\" # uboot工程的文件夹名字 UBOOT_FOLDER=\"uboot\" # android长度 ANDROID_FOLDER_LEN=`expr length \"$ANDROID_FOLDER\"` # kernel长度 KERNEL_FOLDER_LEN=`expr length \"$KERNEL_FOLDER\"` # uboot长度 UBOOT_FOLDER_LEN=`expr length \"$UBOOT_FOLDER\"` #########CONSTANT...END########### # 功能说明：根据源文件和目标文件所在完整路径，将源文件更新到目标文件 # 更新成功的话，输出更新的起止路径；否则，打印错误信息 # 输入参数：src_full_path —— 源文件所在完整路径。 # dst_full_path —— 目标文件所在完整路径。 # 例如：src_full_path=\"tt/android/hardware/libsensor/sensors.cpp\" # dst_full_path=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/code/android/hardware/libsensor/sensors.cpp\" function func_update_file_by_path() { local src_full_path=$1 local dst_full_path=$2 local dst_full_dir=`dirname $dst_full_path` if [ -f \"$src_full_path\" ];then if [ -e \"$dst_full_path\" ] || [ -d \"$dst_full_dir\" ];then cp -v $src_full_path $dst_full_path else mkdir -p $dst_full_dir cp -v $src_full_path $dst_full_path fi else echo copy file ERROR: echo file $src_full_path not existes!!! fi } # 功能说明：将“输入文件”中全部文件全部更新到代码中 # 更新成功的话，输出更新的起止路径；否则，打印错误信息 # 输入参数：input_file —— “输入文件”所在的完整路径 # 例如：input_file=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/backup/exmaple/list_file.txt\" function func_push_files() { local input_file=$1 local full_path local backup_path local count=0 while read -r line do let count=`expr $count + 1` if [ `expr match $line $ANDROID_FOLDER` == \"$ANDROID_FOLDER_LEN\" ] || [ `expr match $line $KERNEL_FOLDER` == \"$KERNEL_FOLDER_LEN\" ] || [ `expr match $line $UBOOT_FOLDER` == \"$UBOOT_FOLDER_LEN\" ];then echo \"$count : right push path\" src_path=${T_FOLDER}${line} dst_path=${COMMON_PATH}${line} func_update_file_by_path $src_path $dst_path else echo \"$count : push file $line is invalidate!\" fi done \u003c $input_file } # 功能说明：根据源文件所在完整路径，将源文件拷贝到另一个目录下 # 备份成功的话，输出备份的起止路径；否则，打印错误信息 # 输入参数：src_full_path —— 源文件所在完整路径。 # dst_full_dir —— 目标路径 # 例如：src_full_path=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/code/android/hardware/libsensor/sensors.cpp\" # dst_full_dir=\"bb/android/hardware/libsensor/\" function func_backup_file_by_path() { local src_full_path=$1 local dst_full_dir=$2\"/\" if [ -f \"$src_full_path\" ];then if [ -d \"$dst_full_dir\" ];then cp -v $src_full_path $dst_full_dir else mkdir -p $dst_full_dir cp -v $src_full_path $dst_full_dir fi else echo back","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_03/:0:0","tags":["bash"],"title":"bash 编程笔记 (三)","uri":"/posts/program/bash/bash_note_03/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 第一部分 awk工具 1. awk介绍 第二部分 sed工具 1. sed介绍 第三部分 正则表达式和grep 1. 正则表达式 2. 正则表达式特殊符号 3. grep表达式 4. 应用实例 5. egrep 5.1. egrep说明 5.2. egrep应用实例 本文主要通过实例对bash中需要用到的一些高级工具(如awk、sed、…)进行说明。 学习的时候，请以“应用实例”为中心，以其它内容为参考进行学习。如果遇到文章中未讲解的内容，可以通过man去查阅用法。 第一部分 awk工具 本章主要通过awk的一些应用实例，来说明awk的相关语法。这样，更利于我们进行理解；所以，阅读本章时，请以“应用实例”为中心进行阅读，其它部分是参考内容。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:0:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. awk介绍 awk是一种用于处理文本的编程语言工具。awk本身就是linux下的一个工具，既可以单独使用，也可以嵌入到bash中。 awk语言的最基本功能是在文件或字符串中基于指定规则浏览和抽取信息。 awk抽取信息后,才能进行其他文本操作。完整的 awk脚本通常用来格式化文本文件中的信息。 ## 2. awk环境变量 变量 说明 $n 当前记录的第n个字段，字段由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认是%.6g) ENVIRON 环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 同NR，当FNR是相对于当前文件而言 FS 字段分隔符(默认是任意的空格符) IGNORECASE 若为真，则匹配时忽略大小写 NF 当前记录中的字段数 NR 已读的记录数 OFMT 数字的输出格式(默认是%.6g) OFS 输出域分隔符(默认是一个空格) ORS 输出记录分隔符(默认是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 控制记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数字下标分隔符(默认值是\\034) ## 3. awk条件操作符 符号 描述 \u003c 小于 \u003c= 小于或等于 == 等于 != 不等于 \u003e= 大于或等于 \u003e 大于 ! 匹配正则表达式 !~ 不匹配正则表达式 ## 4. awk字符串操作 表达式 说明 gsub(r,s) 在整个$0中用s替换r gsub(r,s,t) 在整个t中用s替换r index(s,t) 返回s中字符串t的第一个位置 length(s) 返回s的长度 match(s,r) 测试s是否包含匹配r的字符串 split(s,a,fs) 在fs上将s分成序列a sprint(fmt,exp) 返回经fmt格式化后的exp sub(r,s) 用$0中最左边最长的子串代替s substr(s,p) 返回字符串s中从p开始的后缀部分 substr(s,p,n) 返回字符串s中从p开始的长度为n后缀部分 ## 5. 正则表达式中常用类 表达式 说明 [[:upper:]] [A-Z] [[:lower:]] [a-z] [[:alpha:]] [a-zA-Z] [[:digit:]] [0-9] [[:alnum:]] [0-9a-zA-Z] [[:space:]] 空格或tab键 ## 6 awk应用实例 首先建立一个123.txt，添加任意文本，然后进行以下练习。 (01), 输出文件全部文本 $ awk '{print $0}' 123.txt 说明: {}：表示一段awk命令。 print：输出指令。 $0：当前行的全部文本。 awk工具操作文件时，是以行为单位，逐步对每行进行操作。拿本例来说{print $0}，意味着“对每一行都执行print $0操作，即输出每一行的全部文本”。 $N：当N\u003e1时，$N表示当前行的第N段；每一行中以FS(默认值是空格)来分段。 (02), 输出\"ls -l\"中每行的field1、field9 $ ls -l | awk '{printf(\"%s %s\\n\", $1, $9)}' 说明: |：管道符号。表示将“前面指令的输出”作为“后面指令的输入”，即将“ls -l”的输出作为“awk”的输入。 printf：输出指令。它的使用方法和C语言中printf的使用方法一样。 $1：该行的第1段。 $9：该行的第9端。 (03), 在上一题的基础上添加功能：第一，输出每一行的行号和该行所包括的域的总数。第二，第1行和最后一行输出提示语 $ ls -l | awk 'BEGIN{printf(\"----begin----\\n\")} {printf(\"Line-%3d Field-%d : %s %s\\n\", NR, NF, $1, $9)} END{printf(\"----end----\\n\")}' 说明： BEGIN：表示在文本进行操作之前进行的工作。 END：表示在对文本的所有行都处理完毕之后前进行的工作。 在awk中，请尽量使用{}来进行区分指令段，{}可以嵌套使用！这样做的好处写出的脚本不容易出错，而且可读性更强！ (04), 输出\"ls -l\"中文件(夹)名字包括数字的完整信息 $ ls -l | awk '{if($9 ~ /[[:digit:]]/) {print $0}}' 说明： $9 ~ /[[:digit:]]/ ： 表示能够匹配数字的“第一行的第9段”。 (05), 输出\"ls -l\"中非文件夹的完整信息 $ ls -l | awk '{if($1 !~ /^d/) {print $0}}' 说明： ^d ： 以d开头的。^表示起始位。此外，$表示结束位。如d$，表示以d结尾的。 (06), 找到\"ls -l\"中文件(夹)名字的长度大于10的行，然后输出其完整信息。 $ ls -l | awk '{if(length($9) \u003e 10) {print $0}}' (07), 如何给文本的每一行添加行号？ $ awk '{printf(\"%03d %s\\n\",NR, $0)}' ori.txt \u003e dst.txt (08), 打印字段数大于3的行的总数 $ awk 'BEGIN{COUNT=0}; {if(NF\u003e3) COUNT++}; END{printf(\"COUNT=%d\\n\", COUNT)}' ori.txt (09), 将文本中的各行合并一行，中间用“|”分割 $ awk 'BEGIN{ORS=\"|\"}{print $0 }END{print \"\\n\"}' ori.txt \u003e dst.txt 说明： ORS：表示记录分割符，每条记录表示每行。ORS默认值为换行符。 (10), 将文本中空格换成换行符 $ awk 'BEGIN{FS=\" \";OFS=\"\\n\"}{print $1 }END{print \"\\n\"}' ori.txt \u003e dst.txt (11), 将3行合并成一行，并输入行号 $ awk 'BEGIN{ORS=\"\";i=0}{ j=1; while(j\u003c=NF){ if(i%3==0){printf(\"%02d \",i/3+1)}; printf(\"%s \",$j); i++; j++; if(i%3==0){print \"\\n\"} }} END{print \"\\n\"}' ori.txt \u003e dst.txt 第二部分 sed工具 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:1:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. sed介绍 sed是一个非交互性文本流编辑器。和awk一样，它是个独立的工具，当然也可以和bash联合使用。 它可以随意编辑文件或标准输入,对它们进行编辑、删除。它能一次性处理所有改变,对用户来讲,十分高效。sed编辑文件或标准输入时，编辑的是它们的拷贝；也就是说，不会改变原始的文件。若需要保存修改，可以通过重定向操作符»、»\u003e,或者在利用sed的写入参数。 ## 2. 基本格式 sed [选项] 输入文件 -n 不打印;sed不写编辑行到标准输出,缺省为打印所有行(编辑和未编辑)。 -p 命令可以用来打印编辑行。 -c 下一命令是编辑命令。使用多项编辑时加入此选项。如果只用到一条 sed命令,此选项无用,但指定它也没有关系。 -e 追加执行脚本 -f 如果正在调用 sed脚本文件,使用此选项。 ## 3. 使用sed在文件中定位文本的方式 方式 说明 x x为行号。例如，1 x,y 表示行号范围从x到y。例如，2,5表示从第2行到第5行 x,y! 查询不包含指定行(x到y) /pattern/ 查询包含pattern模式的行。例如, /disk/或/[a-z]/ pattern/,x 在给定行号上查询包含pattern模式的行。例如， /ribbon/,3 x,/pattern/ 通过行号和模式查询匹配行。 例如， 3,/vdu/ ## 4. sed编辑命令 方式 说明 p 打印匹配行 = 显示文件行号 a\\ 在定位行后附加文本信息 i\\ 在定位行前附加文本信息 d 删除定位行 c\\ 用新文本替换定位文本 s 使用替换模式 r 从另一个文件中读文本 w 写文本到一个文件 q 第一个模式匹配完成后退出 {} 在定位行指定的命令组 n 从另一个文件中读取，并追加在下一行 ## 5. 应用实例 首先建立一个123.txt，添加任意文本，然后进行以下练习。 (01), 输出文件第5行 $ sed -n '5p' 123.txt 说明：-n表示默认不输出任何内容。5p表示输出第5行：5表示第5行，p表示输出。 (02), 输出文件除1-3行之外的行 $ sed -n '1,3!p' 123.txt 说明： “1,3\"表示输出范围是第1-3行; “1,3!“表示输出范围是除第1-3行之外。 ‘1,$p’表示输出全部行，因为$表示最后一行。 (03), 输出\"ls -l\"结果中的第1-3行 $ ls -l |sed -n '1,3p' 说明：|是管道符号，表示将ls -l的输出作为sed的输入。 (04), 输出匹配“the”的行 $ sed -n '/the/p' 123.txt 说明：/the/表示匹配the的行 (05), 输出匹配“the”的行，并且输出每行行号 $ sed -n -e '/the/p' -e '/the/=' 123.txt 说明：-e表示对每行进行多重编辑，多重编辑的每一个命令前都需要添加-e。 本例中，-e ‘/the/p’打印匹配the的行；-e ‘/the/=‘表示输出匹配the的行的行号。 (06), 删除匹配“the”的行 $ sed '/the/d' 123.txt 说明：d表示删除。 (07), 删除匹配“the”的行；然后输出删除操作之后的所有行，并输出每行行号 $ sed '/the/d' 123.txt | sed -n -e '1,$p' -e '1,$=' 说明： sed ‘/the/d’ 123.txt ：得到了删除“the”之后的行 | ：管道符号。意味着前面的输出作为后面的输入 sed -n -e ‘1,$p’ -e ‘1,$=’ ：表示输出全部行之后，在输出每行行号 (08), 在每一行前面插入2行文本，第一行是line1,第2行是line2 $ sed '1,$iline1\\nline2' 123.txt 说明： 1,$i表示第一行到最后一行的每一行都执行插入操作。 line1\\nline2表示插入的文本，其中\\n转义之后表示“换行”符号。 (09), 在最后一行后面插入1行文本，内容是end $ sed '$aend' 123.txt 说明：$表示最后一行，a表示在文本后插入，end是插入的内容 (10), 将“this”全部替换成“that” $ sed 's/this/that/g' 123.txt 说明： [ address[,address ] ] s / pattern-to-find / replacement-pattern/[gpwn] s 表示替换操作。查询pattern-to-find,成功后用replacement-pattern替换它。 替换选项如下: g 缺省情况下只替换每行的第一次匹配，g表示替换每行的所有匹配。 p 缺省sed将所有被替换行写入标准输出，加p选项将使-n选项无效。-n选项不打印输出结果。 w 后接“文件名”，表示将输出定向到一个文件。 (11), 将“this”全部替换成“this boy” $ sed 's/this/this boy/g' 123.txt 或 $ sed 's/this/boy \u0026/g' 123.txt 说明： sed ’s/this/boy \u0026/pg’ 123.txt中\u0026表示附加修改(即在原始内容的基础上添加内容)。 \u0026表示匹配的内容。即，boy \u0026等价于boy this (12), 去掉空白行后另存文件 $ sed '/^$/d' 123.txt \u003e 456.txt 或 $ sed '/^$/c\\' 123.txt \u003e 456.txt 说明： /^$/表示空白行：^表示开启，$表示结尾，开始和结尾之间没有任何内容，即是空白行。 c\\表示修改。 (13), 去掉文件扩展名 $ echo \"hello.txt\"| sed 's/.txt//g' (14), 添加文件扩展名 $ echo \"hello\"| sed 's/$/.txt/g' (15), 删除文本中每一行的第2个字符 $ sed 's/.//2' ori.txt \u003e dst.txt (16), 删除文本中每一行的倒数第2个字符 $ sed 's/\\(.\\)\\(.\\)$/\\2/' ori.txt \u003e dst.txt 说明：考察了sed中”( )“的含义和用法 (17), 删除每一行的第2个单词 $ sed 's/\\([[:alpha:]]\\+\\)\\(\\ \\)\\([[:alpha:]]\\+\\)*/\\1/' ori.txt \u003e dst.txt (18), 隔行删除 $ sed '0~2 d' ori.txt \u003e dst.txt 第三部分 正则表达式和grep ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:2:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. 正则表达式 正则表达式就是字符串的表达式。它能通过具有意义的特殊符号表示一列或多列字符串。 grep是linux系统下常用的正则表达式工具，可以使用grep来检索文本等输入流的字符串。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:3:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"2. 正则表达式特殊符号 表达式 说明 ^ 匹配行首 $ 匹配行尾 . 任意字符 * 匹配0～N个某字符或某表达式。例如， [a-z]*表示匹配0到多个小写字母 [] 匹配中括号类的字符。中括号内可以用-表示范围，例如，[1-5]等价于[12345] \\ 屏蔽具有字符的特殊含义 \u003c 匹配以某内容为开始的项。例如， \u003cst表示匹配以st开始的项 \u003e 匹配以某内容为结束的项。例如， nd\u003e表示匹配以end结尾的项 string{m,n} 连续m到n个string string{m} 出现m次string string{m} 至少出现m次string [[:upper:]] A-Z的任意大写字母 [[:lower:]] a-z的任意小写字母 [[:alpha:]] 任意字母 [[:digit:]] 0-9的任意数字 [[:xdigit:]] 十六禁止的数字类型，包括：0-9，A-F，a-f [[:alnum:]] 任意字母或数字 [[:blank:]] 空格或tab键 [[:space:]] 任何会产生空白的字母，包括空格、TAB、CR等 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:4:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"3. grep表达式 基本格式 grep [OPTIONS] PATTERN [FILE...] 格式说明 PATTERN : 匹配模式。可以是字符串，也可以是正则表达式。 [FILE…] : 是grep搜索的文件(集) [OPTIONS] : 是grep的选项。常用的选项有以下选项。 -c : 只输出匹配行的计数。 -I : 不区分大 小写(只适用于单字符)。 -h : 查询多文件时不显示文件名。 -l : 查询多文件时只输出包含匹配字符的文件名。 -n : 显示匹配行及 行号。 -s : 不显示不存在或无匹配文本的错误信息。 -v : 显示不包含匹配文本的所有行。 -r : 当FILE中包含文件夹名时，遍历该文件夹的所有子目录；默认情况下，不会遍历子目录。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:5:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"4. 应用实例 下面以input.txt为例，对grep进行说明。input.txt的文本内容如下： \"Open Source\" is a good mechanism to develop programs. apple is my favorite food. Football game is not use feet only. this dress doesn't fit me. However, this dress is about $ 3183 dollars.^M GNU is free air not free beer.^M Her hair is very beauty.^M I can't finish the test.^M Oh! The soup taste good.^M motorcycle is cheap than car. This window is clear. the symbol '*' is represented as start. Oh! My god! The gd software is a library for drafting programs.^M You are the best is mean you are the no. 1. The world \u003cHappy\u003e is the same with \"glad\". I like dog. google is the best tools for search keyword. goooooogle yes! go! go! Let's go (01), 查找包含“the”的行，并显示行号。 $ grep -n \"the\" input.txt 说明：-n表示显示“行号” (02), 不区分大小写，查找包括“the”的行，并显示行号。 $ grep -in \"the\" input.txt 说明：-n表示显示“行号”；-i表示不区分大小写，即ignore大小写。 (03), 查找不包括“the”的行，统计行数。 $ grep -cv \"the\" input.txt 说明：-c表示统计(count)；-v表示不匹配的项。 (04), 查找“当前目录”及其“所有子目录”中包含“the”的文件，并显示“the”在其中的行号。 $ grep -rn \"the\" . 说明：-r表示递归查找；-n表示显示行号。 (05), 查找匹配“t?st”的项，其中?为任意字符。 $ grep -n \"t.st\" input.txt 说明：.表示匹配任意字符 (06), 查找包含数字的行 $ grep -n \"[0-9]\" input.txt 或 $ grep -n \"[[:digit:]]\" input.txt 说明：[0-9]表示0-9之间的一个数字；[[:digit:]]也表示0-9之间的一个数字 (07), 查找以the开头的行 $ grep -n \"^the\" input.txt 说明：\"^the\"表示以the开头 (08), 查找以小写字母结尾的行。 $ grep -n \"[a-z]$\" input.txt 说明：[a-z]表示一个小写字母，$表示结束符；[a-z]$表示以小写字母结束的项。 (09), 查找空白行。 $ grep -n \"^$\" input.txt 说明：^表示开头，如^t表示以字母t开头；$表示结尾，如e$表示以e结尾。^$表示空白行。 (10), 查找以字母g开头的单词 $ grep -n \"\\\u003cg\" input.txt 说明：\u003c表示单词的开始，\u003cg表示以g开始的单词。 (11), 查找字符串为go的单词。注意：不能包括goo,good等字符串 $ grep -n \"\\\u003cgo\\\u003e\" input.txt 说明：\u003c表示单词的开始，\u003e表示单词结尾。\u003cgo\u003e表示以字母g开头，以字母o结尾。 (12), 查找包括2-5个字母o的行。 $ grep -n \"o\\{2,5\\}\" input.txt 说明：pattern{n,m}表示n到m个pattern。o{2,5}表示2-5个字母o。 (13), 查找包括2个以上字母o(包括2个)的行。 $ grep -n \"ooo*\" input.txt 或 $ grep -n \"oo\\+\" input.txt 或 $ grep -n \"o\\{2,\\}\" input.txt 说明： ooo*: 前面两个oo表示匹配2个字母o，后面的o*表示匹配0到多个字母o。 oo+: 第一个字母o表示匹配单个字母o；最后的“o+”一起发挥作用，其中，+是转义后的+，表示1到多个；而o+表示1到多个字母o。 pattern{n,}表示多于n个pattern。o{2,}表示多于2个字母o。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:6:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5. egrep ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5.1 egrep说明 egrep是扩展的grep，即它的功能比grep更多一些。“egrep\"等价于\"grep -e”。 egrep相比与grep，支持括号“()”以及操作符“|”(表示或)。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:1","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5.2 egrep应用实例 仍然以上面的input.txt为输入文本进行说明 (01), 查找包含the或者this的行 $ egrep -n \"the|this\" input.txt 说明：-n表示输出匹配项的行号，“the|this\"表示包括the或者包括this的项。 (02), 查找包含the或者this的行 $ egrep -vn \"(the|this)\" input.txt 说明：-n表示输出匹配项的行号，“the|this\"表示包括the或者包括this的项；-v表示匹配的对立面。即 -v “the|this\"表示既不包括the又不包括this的项。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:2","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["cpp"],"content":"整理部分现代C++作用在函数后的关键字","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++函数后面加const关键字 C++函数后面加throw关键字 C++11引入的关键字=default、=delete、override、final 1. =default 2. =delete 3. override C++函数后面加const关键字 非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）,表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用） 唯一的例外是对于mutable修饰的成员。 加了const的成员函数可以被非const对象和const对象调用,但不加const的成员函数只能被非const对象调用 1 2 3 4 char getData() const { return this-\u003eletter; } C++函数后面加throw关键字 void fun() throw() 表示fun不允许抛出任何异常，即fun是异常安全的。 void fun() throw(…) 表示fun可以抛出任何形式的异常。 void fun() throw(exceptionType) 表示fun只能抛出exceptionType类型的异常。 void GetTag() throw(int); 表示只抛出int类型异常 void GetTag() throw(int，char); 表示抛出in，char类型异常 void GetTag() throw(); 表示不会抛出任何类型异常 void GetTag() throw(…); 表示抛出任何类型异常 那么，void GetTag() throw(int); 表示只抛出int类型异常 这句解释怎么理解呢？ 并不表示一定会抛出异常，但是一旦抛出异常只会抛出int类型。 如果抛出非int类型异常，调用unexsetpion()函数，退出程序。 C++11引入的关键字=default、=delete、override、final ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"1. =default 在C++11中，如果需要使用默认的构造、析构函数，需要在参数列表后面加上=default关键字，与之对应，如果你不想使用默认的构造、析构函数，就在参数列表后面加上=delete，这样编译器就会删除对应的默认构造、析构函数。 1 2 3 4 5 6 7 8 9 //demo.h #pragma once class CobjectA { public: CobjectA(int i); CobjectA() = default; }; 再次编译输出： 1 Test Con ! 这样可以看出，当我们需要使用编译器默认生成的构造函数，只需要在头文件声明的时候，在参数列表后加上关键字=default，不需要在对应的cpp文件中进行定义。 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"2. =delete 为了不让一个类被拷贝，可以将其拷贝构造函数声明为private属性，但是有了delete关键字后，可以直接在拷贝构造函数的参数列表后面加上=delete，对于一些不需要构造、析构函数的类，可以在其默认的构造、析构函数参数列表后加上=delete，减少生成可执行文件的体积。 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:2:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"3. override 在继承机制中会用到override关键字，使用该关键字可以避免一些低级错误的出现。例如，定义类A与类B，并让B继承A。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func1() override { std::cout \u003c\u003c \"class B func1\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func1(); return 0; } A中有虚函数func1，在B中继承后重新实现了一下，输出结果： 1 2 class A func1 class B func1 在B中改写func1，其后增加了override关键字，如果存在这样一种情况，本想改写从A中继承来的func1，由于疏忽，修改了函数的签名： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func2() override //将func1写成了func2 { std::cout \u003c\u003c \"class B func2\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func2(); return 0; } 结果编译出错： 1 2 3 test2.cpp:15:18: error: ‘virtual void B::func2()’ marked ‘override’, but does not override 15 | virtual void func2() override //将func1写成了func2 | 提示没有重写基类的方法，所以，有了override关键字，一定要重写基类的方法，这里的func2相当于是在类B中重新定义的一个函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func2() //这里去掉override关键字，相当于自己定义了一个func2函数 { std::cout \u003c\u003c \"class B func2\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func2(); return 0; } 输出结果： 1 2 class A func1 class B func2 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:3:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/note/","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"[TOC] CMake -D 定义 -DCMAKE_INSTALL_PREFIX= 指定安装路径，相当于 –prefix= -DCMAKE_C_COMPILER= 指定 C 编译器，相当于 CC= -DCMAKE_CXX_COMPILER=指定 CXX 编译器，相当于 CXX= CMake中条件判断语句 1 2 3 4 5 if(\u003cconstant\u003e) ... else() ... endif() \u003cconstant\u003e表示一个常量，其取值与对应逻辑值如下（不区分大小写）： 逻辑值 常量值 true 1、ON、YES、TRUE、Y、非0数字 false 0、OFF、NO、FALSE、N、IGNORE、NOTFOUNT、空字符串、-NOTFOUND结尾字符串 变量 1 if(\u003cvariable\u003e) \u003cvariable\u003e表示一个变量，变量取值不是上述定义的false常量时其逻辑值为true，否则逻辑值为false。 注： 宏参数不是变量，环境变量不可作为条件。 使用变量时，不要用${}表示变量，直接使用变量名即可。 字符串 1 if(\u003cstring\u003e) \u003cstring\u003e表示带引号的字符串。以下情况其逻辑值为true: 字符串内容为上述定义的true常量 策略 CMP0054 未设置为 NEW，并且字符串的值恰好是受 CMP0054 行为影响的变量名称。 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:0:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"逻辑运算 1 2 3 4 if(NOT \u003ccondition\u003e) # 非运算 if(\u003ccond1\u003e AND \u003ccond2\u003e) # 与运算 if(\u003ccond1\u003e OR \u003ccond2\u003e) #或运算 if((condition) AND (condition OR (condition))) # 有括号时，先计算括号的逻辑值 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:1:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"存在性判断 1 2 3 4 5 6 if(COMMAND command-name) # true 给定参数是可调用的命令、宏、函数时 if(POLICY policy-id) # true 给定的策略存在时 if(TARGET target-name) # true 给定的目标参数是通过add_executable()、add_library() 或 add_custom_target() 命令创建并存在的 if(TEST test-name) # true 给定参数是通过add_test()创建并存在的 if(DEFINED \u003cname\u003e|CACHE{\u003cname\u003e}|ENV{\u003cname\u003e}) # true 如果变量、缓存、环境变量存在（其取值无关） if(\u003cvariable|string\u003e IN_LIST \u003cvariable\u003e) # true 如果\u003cvariable|string\u003e存在于列表变量\u003cvariable\u003e中 1 2 3 4 5 6 # 以下路径参数可以为相对路径或绝对路径，相对是指相对于当前执行cmake的路径。 if(EXISTS path-to-file-or-directory) # true 如果文件/目录存在，当参数是连接时表示连接指向的实体存在。 if(file1 IS_NEWER_THAN file2) # true file1比file2新 if(IS_DIRECTORY path-to-directory) # true 如果参数是目录 if(IS_SYMLINK file-name)# true 如果参数是一个链接 if(IS_ABSOLUTE path) # true 如果参数是绝对路径 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:2:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"正则匹配 如果\u003cvariable|string\u003e匹配了正则表达式regex，则为true \u003cvariable|string\u003e可以是字符串，或者内容为字符串的变量。 1 if(\u003cvariable|string\u003e MATCHES regex) ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:3:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"数字比较 \u003cvariable|string\u003e表示存储数字的变量，或合法的数字字符串（如 “512”） 1 2 3 4 5 if(\u003cvariable|string\u003e LESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e GREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e EQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e LESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e GREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:4:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"字符串比较 \u003cvariable|string\u003e可以是字符串，或者内容为字符串的变量。 1 2 3 4 5 if(\u003cvariable|string\u003e STRLESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e STRGREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e STREQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e STRLESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e STRGREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:5:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"版本号比较 \u003cvariable|string\u003e表示存储版本号的变量，或合法的版本号字符串（如 “3.1.4”） 1 2 3 4 5 if(\u003cvariable|string\u003e VERSION_LESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e VERSION_GREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e VERSION_EQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e VERSION_LESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e VERSION_GREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:6:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 CMake CMake中常用预定义变量 CMake的预定义变量 系统信息预定义变量 开关选项 常用语法 CMAKE_MINIMUM_REQUIRED PROJECT 外部构建与内部构建 SET ADD_SUBDIRECTORY INCLUDE_DIRECTORIES ADD_EXECUTABLE ADD_LIBRARY 变量EXECUTABLE_OUTPUT_PATH, LIBRARY_OUTPUT_PATH LINK_DIRECTORIES TARGET_LINK_LIBRARIES MESSAGE SET_TARGET_PROPERTIES AUX_SOURCE_DIRECTORY 基本控制语法 实战 单个源文件 多个源文件 同一目录，多个源文件 多个目录，多个源文件 自定义编译选项 安装和测试 定制安装规则 为工程添加测试 参考资料 CMake CMakeLists.txt cmake PATH ccmake PATH ccmake 和 cmake 的区别在于前者提供了一个交互式的界面 PATH 是 CMakeLists.txt 所在的目录 使用 make 命令进行编译。 CMake中常用预定义变量 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:0:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"CMake的预定义变量 PROJECT_SOURCE_DIR：工程根目录； PROJECT_BINARY_DIR：运行cmake命令的目录。笔者建议定义为${PROJECT_SOURCE_DIR}/ build下。具体原因见后文外部编译部分； CMAKE_INCLUDE_PATH：环境变量，非cmake变量； CMAKE_LIBRARY_PATH：环境变量； CMAKE_CURRENT_SOURCE_DIR：当前处理的CMakeLists.txt文件所在路径； CMAKE_CURRENT_BINARY_DIR：target编译目录； 使用ADD_SURDIRECTORY指令可以更改该变量的值； SET(EXECUTABLE_OUTPUT_PATH \u003c dir \u003e) 指令不会对该变量有影响，但改变了最终目标文件的存储路径； CMAKE_CURRENT_LIST_FILE：输出调用该变量的CMakeLists.txt的完整路径； CMAKE_CURRENT_LIST_LINE：输出该变量所在的行； CMAKE_MODULE_PATH：定义自己的cmake模块所在路径； EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置； LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置； PROJECT_NAME：返回由PROJECT指令定义的项目名称； CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS：用来控制IF…ELSE…语句的书写方式； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"系统信息预定义变量 CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2 CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8 CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6 CMAKE_SYSTEM 系统名称,例如Linux-2.6.22 CMAKE_SYSTEM_NAME 不包含版本的系统名,如Linux CMAKE_SYSTEM_VERSION 系统版本,如2.6.22 CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686 UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin WIN32 在所有的win32平台为TRUE,包括cygwin ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"开关选项 BUILD_SHARED_LIBS 控制默认的库编译方式。 注：如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库。 CMAKE_C_FLAGS 设置C编译选项 CMAKE_CXX_FLAGS 设置C++编译选项 常用语法 CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 每一个需要进行cmake操作的目录下面，都必须存在文件CMakeLists.txt 。 cmake指令不区分大小写。 cmake内置变量是区分大小写的，或者干脆就说，cmake的所有变量都是区分大小写的。 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名； 指令(参数 1 参数 2…)，参数使用括弧括起，参数之间使用空格或分号分开； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"CMAKE_MINIMUM_REQUIRED 该语句一般都可以放置在CMakeLists.txt的开头，用于说明CMake最低版本要求。 这行命令是可选的，我们可以不写这句话，但在有些情况下，如果CMakeLists.txt文件中使用了一些高版本cmake特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行cmake。 1 cmake_minimum_required (VERSION 2.6) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"PROJECT 1 PROJECT(name) name：工程名称 该指令一般置于CMakeLists.txt的开头，定义了工程的名称。但项目最终编译生成的可执行文件并不一定是这个项目名称。 执行了该条指令之后，将会自动创建两个变量： 1 2 \u003c projectname \u003e_BINARY_DIR：二进制文件保存路径； \u003c projectname \u003e_SOURCE_DIR：源代码路径； 1 project(CRNode) 执行了上一条指令，即定义了一个项目名称CRNode，相应的会生成两个变量：CRNode_BINARY_DIR, CRNode_SOURCE_DIR。 cmake中预定义了两个变量：PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR。 在这个例子中： 1 2 PROJECT_BINARY_DIR = CRNode_BINARY_DIR PROJECT_SOURCE_DIR = CRNode_SOURCE_DIR 推荐直接使用PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR，这样及时项目名称发生了变化，也不会影响CMakeLists.txt文件。 关于上面两个变量是否相同的问题，涉及到编译方法是内部编译还是外部编译。如果是内部编译，则上面两个变量相同；如果是外部编译，则两个变量不同。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"外部构建与内部构建 假设此时已经完成了CMakeLists.txt的编写，在CMakeLists.txt所在目录下，有两种执行cmake的方法： 1 2 cmake ./ make 以及： 1 2 3 4 mkdir build cd ./build cmake ../ make 第一种方法是内部构建，第二种方法是外部构建。上述两种方法中，最大不同在于cmake与make的工作路径不同。 内部构建方法中，cmake生成的中间文件和可执行文件都会存放在项目目录中；外部构建方法中，中间文件与可执行文件都存放在build目录中。 建议使用外部构建方法。优点显而易见：最大限度的保持了代码目录的整洁，生成、编译与安装是不同于项目目录的其他目录中，在外部构建方法下，PROJECT_SOURCE_DIR指向目录与内部构建相同，为CMakeLists.txt所在根目录；而PROJECT_BINARY_DIR不同，它指向CMakeLists.txt所在根目录下的build目录。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"SET 1 SET(VAR [VALUE] [CACHE TYPEDOCSTRING [FORCE]]) eg: 1 SET(CMAKE_INSTALL_PREFIX /usr/local) 我们显式的将CMAKE_INSTALL_PREFIX的值定义为/usr/local，如此在外部构建情况下执行make install命令时，make会将生成的可执行文件拷贝到/usr/local/bin目录下。 当然，可执行文件的安装路径CMAKE_INSTALL_PREFIX也可以在执行cmake命令的时候指定，cmake参数如下： 1 cmake -DCMAKE_INSTALL_PREFIX=/usr .. 如果cmake参数和CMakeLists.txt文件中都不指定该值的话，则该值为默认的/usr/local。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_SUBDIRECTORY 1 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) source_dir：源文件路径； [binary_dir]：中间二进制与目标二进制存放路径； [EXECLUDE_FROM_ALL]：将这个目录从编译过程中排除； 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。 EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如，工程有时候存在example，可能就需要工程构建完成后，再进入example目录单独进行构建。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:7:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"INCLUDE_DIRECTORIES 1 INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) [AFTER|BEFORE]：追加标志，指定控制追加或置前； [SYSTEM]：（笔者也不知道干嘛用的） dir1, …, dir n：添加的一系列头文件搜索路径； 向工程添加多个特定的头文件搜索路径，路径之间用空格分隔。类似于gcc中的编译参数-l，即指定编译过程中编译器搜索头文件的路径。当项目需要的头文件不在系统默认的搜索路径时，则指定该路径。 AFTER/BEFORE参数，控制追加或置前。默认情况下，追加当前头文件搜索路径的后面。 注：如果路径包含空格，可以使用双引号将它括起来。 eg： 1 INCLUDE_DIRECTORIES(/usr/include/thrift) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_EXECUTABLE 1 ADD_EXECUTABLE(exename srcname) exename：可执行文件名 srcname：生成该可执行文件的源文件 该命令给出源文件名称，并指出需要编译出的可执行文件名。 eg： 1 ADD_EXECUTABLE(hello ${SRC_LIST}) 上述例程说明SRC_LIST变量中的源文件，需要编译出名为hello的可执行文件。 eg: 1 2 3 4 5 6 7 8 9 10 SET(SRC_LIST main.cc rpc/CRNode.cpp rpc/Schd_types.cpp task/TaskExecutor.cpp task/TaskMoniter.cpp util/Const.cpp util/Globals.cc ) ADD_EXECUTABLE(CRNode ${SRC_LIST}) 该例程中，定义了该工程会生成一个名为CRNode的可执行文件，所依赖的源文件是变量SRC_LIST定义的源文件列表。 注：如果前文PROJECT()指令中定义的项目名称也定义为CRNode，也没有什么问题，两者之间没有任何关系。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_LIBRARY 1 ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) libname：库文件名称； [SHARED|STATIC|MODULE]：生成库文件类型（共享库/静态库） [EXCLUDE_FROM_ALL]：表示该库不会被默认构建 source1, …, sourceN：生成库所依赖的源文件 eg： 1 ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:10:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"变量EXECUTABLE_OUTPUT_PATH, LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH为生成可执行文件路径，LIBRARY_OUTPUT_PATH为生成库文件路径。 我们可以通过SET指令对其进行设置最终的目标二进制的位置，即最终生成的工程可执行文件与最终的共享库，而不包含编译生成的中间文件。 1 2 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 注：指令ADD_EXECUTABLE, ADD_LIBRARY出现的位置，如果需要改变目标存放路径，就在该处添加上述定义。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"LINK_DIRECTORIES 1 LINK_DIRECTORIES(directory1 directory2 ...) 该指令用于添加外部库的搜索路径。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"TARGET_LINK_LIBRARIES 1 TARGET_LINK_LIBRARIES(target library1 \u003cdebug | optimized\u003e library2 ..) target：目标文件； library1, …, libraryN：链接外部库文件； 指定链接目标文件时需要链接的外部库，效果类似于gcc编译参数-L，解决外部库依赖的问题。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"MESSAGE 1 MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …) 向终端输出用户定义的信息或变量值 SEND_ERROR：产生错误，生成过程被跳过； STATUS：输出前缀为 – 的信息； FATAL_ERROR：立即终止所有cmake过程； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"SET_TARGET_PROPERTIES 1 2 SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ...) 设置目标的某些属性，改变它们构建的方式。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:15:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"AUX_SOURCE_DIRECTORY 基本控制语法 实战 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:16:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"单个源文件 1 2 3 4 5 6 7 8 9 10 11 # CMake 最低版本号要求 # cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本 cmake_minimum_required (VERSION 2.8) # 项目信息 # project：参数值是 Demo1，该命令表示项目的名称是 Demo1 project (Demo1) # 指定生成目标 # add_executable： 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件 add_executable(Demo main.cc) cmake . ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:17:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"多个源文件 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"同一目录，多个源文件 1 2 3 4 5 6 7 8 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo2) # 指定生成目标 add_executable(Demo main.cc MathFunctions.cc) aux_source_directory: 查找指定目录下的所有源文件，然后将结果存进指定变量名。 1 aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) 1 2 3 4 5 6 7 8 9 10 11 12 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo2) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(Demo ${DIR_SRCS}) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"多个目录，多个源文件 add_subdirectory : 项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理。 target_link_libraries：指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo3) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 添加 math 子目录 add_subdirectory(math) # 指定生成目标 add_executable(Demo main.cc) # 添加链接库 target_link_libraries(Demo MathFunctions) 子目录中的 CMakeLists.txt： 1 2 3 4 5 6 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:2","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"自定义编译选项 CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo4) # 加入一个配置头文件，用于处理 CMake 对源码的设置 configure_file ( \"${PROJECT_SOURCE_DIR}/config.h.in\" \"${PROJECT_BINARY_DIR}/config.h\" ) # 是否使用自己的 MathFunctions 库 option (USE_MYMATH \"Use provided math implementation\" ON) # 是否加入 MathFunctions 库 if (USE_MYMATH) include_directories (\"${PROJECT_SOURCE_DIR}/math\") add_subdirectory (math) set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) endif (USE_MYMATH) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(Demo ${DIR_SRCS}) target_link_libraries (Demo ${EXTRA_LIBS}) 其中： 第7行的 configure_file 命令用于加入一个配置头文件 config.h ，这个文件由CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 第13行的 option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。 第17行根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。 config.h.in 1 #cmakedefine USE_MYMATH CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。 从中可以找到刚刚定义的 USE_MYMATH 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 enter 键可以修改该选项。修改完成后可以按下 c 选项完成配置，之后再按 g 键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:19:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"安装和测试 CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 make install 和 make test 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 install 和 test 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"定制安装规则 math/CMakeLists.txt 指明 MathFunctions 库的安装路径 1 2 3 # 指定 MathFunctions 库的安装路径 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) 改根目录的 CMakeLists 文件 1 2 3 4 # 指定安装路径 install (TARGETS Demo DESTINATION bin) install (FILES \"${PROJECT_BINARY_DIR}/config.h\" DESTINATION include) 通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 /usr/local/bin 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 /usr/local/include 中。（这里的 /usr/local/ 是默认安装到的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录）。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"为工程添加测试 添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 add_test 命令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 启用测试 enable_testing() # 测试程序是否成功运行 add_test (test_run Demo 5 2) # 测试帮助信息是否可以正常提示 add_test (test_usage Demo) set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage: .* base exponent\") # 测试 5 的平方 add_test (test_5_2 Demo 5 2) set_tests_properties (test_5_2 PROPERTIES PASS_REGULAR_EXPRESSION \"is 25\") # 测试 10 的 5 次方 add_test (test_10_5 Demo 10 5) set_tests_properties (test_10_5 PROPERTIES PASS_REGULAR_EXPRESSION \"is 100000\") # 测试 2 的 10 次方 add_test (test_2_10 Demo 2 10) set_tests_properties (test_2_10 PROPERTIES PASS_REGULAR_EXPRESSION \"is 1024\") 上面的代码包含了四个测试。第一个测试 test_run 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 PASS_REGULAR_EXPRESSION 用来测试输出是否包含后面跟着的字符串。 可以通过编写宏来实现 1 2 3 4 5 6 7 8 9 10 11 # 定义一个宏，用来简化测试工作 macro (do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2}) set_tests_properties (test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro (do_test) # 使用该宏进行一系列的数据测试 do_test (5 2 \"is 25\") do_test (10 5 \"is 100000\") do_test (2 10 \"is 1024\") 参考资料 CMake 入门实战 CMake 入门实战源码 CMake语法 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:2","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/","tags":["cmake"],"title":"CMake交叉编译配置","uri":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 几个重要的变量 使用变量来控制编译步骤 demo CMake给交叉编译预留了一个很好的变量即CMAKE_TOOLCHAIN_FILE,它定义了一个文件的路径，这个文件即toolChain,里面set了一系列你需要改变的变量和属性，包括C_COMPILER,CXX_COMPILER,如果用Qt的话需要更改QT_QMAKE_EXECUTABLE以及如果用BOOST的话需要更改的BOOST_ROOT(具体查看相关Findxxx.cmake里面指定的路径)。CMake为了不让用户每次交叉编译都要重新输入这些命令，因此它带来toolChain机制，简而言之就是一个cmake脚本，内嵌了你需要改变以及需要set的所有交叉环境的设置。 几个重要的变量 CMAKE_SYSTEM_NAME: 即你目标机target所在的操作系统名称，比如ARM或者Linux你就需要写\"Linux\",如果Windows平台你就写\"Windows\",如果你的嵌入式平台没有相关OS你即需要写成\"Generic\",只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译，它会额外设置一个变量CMAKE_CROSSCOMPILING为TRUE. CMAKE_C_COMPILER: 顾名思义，即C语言编译器，这里可以将变量设置成完整路径或者文件名，设置成完整路径有一个好处就是CMake会去这个路径下去寻找编译相关的其他工具比如linker,binutils等，如果你写的文件名带有arm-elf等等前缀，CMake会识别到并且去寻找相关的交叉编译器。 CMAKE_CXX_COMPILER: 同上，此时代表的是C++编译器。 CMAKE_FIND_ROOT_PATH: 代表了一系列的相关文件夹路径的根路径的变更，比如你设置了/opt/arm/,所有的Find_xxx.cmake都会优先根据这个路径下的/usr/lib,/lib等进行查找，然后才会去你自己的/usr/lib和/lib进行查找，如果你有一些库是不被包含在/opt/arm里面的，你也可以显示指定多个值给CMAKE_FIND_ROOT_PATH,比如 1 set(CMAKE_FIND_ROOT_PATH /opt/arm /opt/inst) CMAKE_FIND_ROOT_PATH_MODE_PROGRAM: 对FIND_PROGRAM()起作用，有三种取值，NEVER,ONLY,BOTH,第一个表示不在你CMAKE_FIND_ROOT_PATH下进行查找，第二个表示只在这个路径下查找，第三个表示先查找这个路径，再查找全局路径，对于这个变量来说，一般都是调用宿主机的程序，所以一般都设置成NEVER CMAKE_FIND_ROOT_PATH_MODE_LIBRARY: 对FIND_LIBRARY()起作用，表示在链接的时候的库的相关选项，因此这里需要设置成ONLY来保证我们的库是在交叉环境中找的. CMAKE_FIND_ROOT_PATH_MODE_INCLUDE: 对FIND_PATH()和FIND_FILE()起作用，一般来说也是ONLY,如果你想改变，一般也是在相关的FIND命令中增加option来改变局部设置，有NO_CMAKE_FIND_ROOT_PATH,ONLY_CMAKE_FIND_ROOT_PATH,BOTH_CMAKE_FIND_ROOT_PATH BOOST_ROOT： 对于需要boost库的用户来说，相关的boost库路径配置也需要设置，因此这里的路径即ARM下的boost路径，里面有include和lib。 QT_QMAKE_EXECUTABLE: 对于Qt用户来说，需要更改相关的qmake命令切换成嵌入式版本，因此这里需要指定成相应的qmake路径（指定到qmake本身） 使用变量来控制编译步骤 CMAKE_CROSSCOMPILING：是否处于交叉编译环境 ANDROID：安卓的编译环境 APPLE：是否是苹果系列的编译环境 IOS：是否是苹果手机环境 UNIX：是否是 UNIX 或者 UNIX-like 的环境 WIN32、MSVC：是否是 Windows demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # this is required SET(CMAKE_SYSTEM_NAME Linux) # where is the target environment SET(TOOLCHAIN_DIR \"/usr/local/aarch64-himix100-linux-toolchain-libra-v3\") SET(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN_DIR}) # search for programs in the build host directories (not necessary) SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # for libraries and headers in the target directories SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # specify the cross compiler SET(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-gcc) SET(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-gcc) SET(STRIP ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-strip) # configure Boost and Qt SET(QT_QMAKE_EXECUTABLE /opt/qt-embedded/qmake) SET(BOOST_ROOT /opt/boost_arm) 指定编译工具链 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_TOOLCHAIN_FILE=xxx/toochain.cmake make ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/:0:0","tags":["cmake"],"title":"CMake交叉编译配置","uri":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 类的成员 1. 类的属性 1.1. 静态属性的创建方式 1.2. 实例属性 2. 类的方法 类成员的修饰符 类的特殊成员 类的专有方法： 继承 1. 单继承 2. 多继承 3. 方法重写 运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Document(): def __init__(self, title, author, context): print('init function called') self.title = title self.author = author self.__context = context # __ 开头的属性是私有属性 def get_context_length(self): return len(self.__context) def intercept_context(self, length): self.__context = self.__context[:length] harry_potter_book = Document('Harry Potter', 'J. K. Rowling', '... Forever Do not believe any thing is capable of thinking independently ...') print(harry_potter_book.title) print(harry_potter_book.author) print(harry_potter_book.get_context_length()) harry_potter_book.intercept_context(10) print(harry_potter_book.get_context_length()) print(harry_potter_book.__context) 类：一群有着相似性的事物的集合，这里对应 Python 的 class。 对象：集合中的一个事物，这里对应由 class 生成的某一个 object，比如代码中的 harry_potter_book。 属性：对象的某个静态特征，比如上述代码中的 title、author 和 __context。 函数：对象的某个动态能力，比如上述代码中的 intercept_context () 函数。 1. 类的成员 类的成员包括：属性和方法。 属性可以分为：静态属性和实例属性 方法可以分为：普通方法、类方法和静态方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/python3 class MyClass: \"\"\"一个简单的类实例\"\"\" i = 12345 def f(self): return 'hello world' # 实例化类 x = MyClass() # 访问类的属性和方法 print(\"MyClass 类的属性 i 为：\", x.i) print(\"MyClass 类的方法 f 输出为：\", x.f()) ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:0:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1. 类的属性 属性可以分为：静态属性和实例属性。 实例属性属于对象，而静态属性属于类。 通过类创建对象时，如果每个对象都具有相同的属性，那么就使用静态属性。 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1.1. 静态属性的创建方式 静态属性是属于类的，所以不用创建对象访问。 1 2 3 4 5 6 7 8 9 10 #!/usr/bin/python3 class Province: # 静态字段 country ＝ '中国' # 直接访问静态字段 Province.country ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:1","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1.2. 实例属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 lass Goods: def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price 实例属性可以在构造方法中进行初始化。@property装饰器可以把一个实例方法变成其同名属性，以支持.号访问。我们可以根据属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除。 扩展： 对于静态属性还可以使用property函数的形式定义一个属性。与@property实现原理类似。 property(fget=None, fset=None, fdel=None, doc=None) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Foo: def get_bar(self): return 'get_bar' # *必须两个参数 def set_bar(self, value): return 'set value' + value def del_bar(self): return 'del_bar' age = property(fget=get_bar,fset=set_bar,fdel=del_bar,doc='description...') ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:2","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.2. 类的方法 方法包括：普通方法、类方法和静态方法。 普通方法：由对象调用；至少一个self参数；执行普通方法时，自动将调用该方法的对象赋值给self； 类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类复制给cls； 静态方法：由类调用；无默认参数； 如果Python中没有属性，方法完全可以代替其功能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Foo: def __init__(self, name): self.name = name def ord_func(self): \"\"\" 定义普通方法，至少有一个self参数 \"\"\" # print self.name print('普通方法') @classmethod def class_func(cls): \"\"\" 定义类方法，至少有一个cls参数 \"\"\" print('类方法') @staticmethod def static_func(): \"\"\" 定义静态方法 ，无默认参数\"\"\" print('静态方法') 2. 类成员的修饰符 对于每一个类的成员而言都有两种形式： 公有成员，在任何地方都能访问。 私有成员，只有在类的内部才能方法。 私有成员和公有成员的定义不同：私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：init、call、__dict__等） ps：如果想要强制访问私有字段，可以通过 【对象._类名__私有字段明 】访问（如：obj._C__foo），不建议强制访问私有成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C: name = '公有静态字段' __sname ='私有静态字段' def pub_func(self): print(C.name) def pra_func(self): print(C._sname) class D(C): def pub_show(self): print(C.name) def pra_show(self): print(C._sname) 注：不建议强制访问私有成员。 3. 类的特殊成员 __doc__ : 表示类的描述信息。 __module__ : 表示当前操作的对象在哪个模块 __class__ : 表示当前操作的对象的类是什么 __init__ : 构造方法，通过类创建对象时，自动触发执行。 1 2 3 4 5 6 7 8 #!/usr/bin/python3 class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) print(x.r, x.i) # 输出结果：3.0 -4.5 __del__ : 当对象在内存中被释放时，自动触发执行。 __call__ : 对象后面加括号，触发执行。 __dict__ : 类或对象中的所有成员。 __str__ : 如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。有点像java中的toString方法。 __getitem__、__setitem__、__delitem__ : 用于索引操作，如字典。以上分别表示获取、设置、删除数据。 __getslice__、__setslice__、__delslice__ : 三个方法用于分片操作。 __iter__ : 用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 __iter__。 4. 类的专有方法： __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 5. 继承 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:2:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.1. 单继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 1 2 3 4 5 6 class DerivedClassName(BaseClassName): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1 class DerivedClassName(modname.BaseClassName): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) s = student('ken',10,60,3) s.speak() ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:3:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.2. 多继承 1 2 3 4 5 6 class DerivedClassName(Base1, Base2, Base3): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备 class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic)) #多重继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\"Tim\",25,80,4,\"Python\") test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:4:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.3. 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数是用于调用父类(超类)的一个方法。 执行以上程序输出结果为： 6. 运算符重载 Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/usr/bin/python3 class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2) ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:5:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. python 中的类 2. 类 class 中为啥用使用 self 3. 在Python中类的定义 4. def __init__self 方法 5. 为啥要使用 self 6. self 到底是什么 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:0:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.1. python 中的类 在Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。 class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。一个类（class）应该包含数据和操作数据的方法，通俗来讲就是属性和函数（即调用方法）。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:1:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.2. 类 class 中为啥用使用 self 在类的代码（函数）中，需要访问当前的实例中的变量和函数，即访问Instance中的： 对应的变量（property)：Instance.ProperyNam，去读取之前的值和写入新的值。 调用对应函数（function）：Instance.function()，即执行对应的动作。 需要访问实例的变量和调用实例的函数，当然需要对应的实例Instance对象本身。 Python中就规定好了，函数的第一个参数，就必须是实例对象本身，并且建议，约定俗成，把其名字写为self。 所以，我们需要self（需要用到self）。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:2:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.3. 在Python中类的定义 在python中，类是通过关键字 class 定义的： class 后面紧跟类名，即 Person，类名通常大写字母开头，紧接着是(object),表示该类是从哪个类继承下来的，通常，如果没有合适的 继承类，就使用 object 类，这是所有类最终都会继承的类。 1 2 class Person（object）: pass 将 Person类实例化，创建实例化是通过 类名+() 实现的。 1 2 3 4 5 6 7 8 9 10 11 class Person(object): pass student = Person() # 创建类的实例化 print(student) print(Person) --------------------------------- 输出： \u003c__main__.Person object at 0x7f8a4bb14e20\u003e \u003cclass '__main__.Person'\u003e 可以看到，变量 student 指向的就是一个 Person的 object，后面的 0x7f8a4bb14e20 是内存地址，每个 object 的地址都不一样，而 Person 本身则是一个类。 也可以给实例变量绑定属性，比如：为 student 绑定 name 和 score 属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person(object): pass student = Person() # print(student) # print(Person) student.name = \"Gavin\" # 为实例变量 # student 绑定 name 属性 类似于 赋值 操作 student.score = 100 # 为 其绑定 # score 属性 print(student.name) print(student.score) --------------------------------- 输出： Gavin 100 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:3:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.4. def init(self) 方法 上述的方法虽然可以为类的实例变量绑定属性，但是不够方便和elegant , 由于类 可以起到模板的作用，故在创建实例的时候，可以将我们认为必须绑定 属性 强制填写进去，在python中，是通过 类中通常都会使用的一个方法，即def init(self) 方法，在创建实例变量的时候，就把 name 和 score 等属性绑上去。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Person(object): def __init__(self,name,score): self.name = name self.score = score student = Person('Gavin',100) # 传入 __init__ 方法中需要的参数 print(student.name) print(student.score) --------------------------------- 输出： Gavin 100 传入空参数的情况，会报错： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person(object): def __init__(self,name,score): self.name = name self.score = score student = Person() print(student.name) print(student.score) --------------------------------- 输出： File \"/mnt/DATA/code/COMMON/Program/python/self/self2.py\", line 6, in \u003cmodule\u003e student = Person() TypeError: __init__() missing 2 required positional arguments: 'name' and 'score' 注意： 1、init 方法的第一个参数永远是 self ，表示创建的实例本身，因此，在 init 方法的内部，就可以把各种属性绑定到 self，因为 self 就指向创建的实例本身。 2、使用了 init 方法，在创建实例的时候就不能传入 空的参数了，必须传入与 init 方法匹配的参数，但是 self 不需要传，python解释器会自己把实例变量传进去。 在类中定义多个函数相互调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self): sum = self.x + self.y return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self): c = self.add() + self.square() return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square()) --------------------------------- 输出： 7 25 --------- 我是可爱的分割线----------- 32 通过上述的例子可以看出，与普通的函数相比，在类中定义的函数只有两点不同： 1、第一个参数永远是 self ，并且调用时不用传递该参数 2、在类中函数相互调用要加 self ，如上例中： c = self.add()+self.square(), 不加 self ，会报错： 函数未定义。 除此之外，类的方法和普通函数没甚区别，当然也可以使用 默认参数、可变参数和关键字参数，例子如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self, z=16): # 设置 默认变量 z =16,这只是个普通的局部变量，非实例变量，实例变量需要 self.z = z,这样定义 sum = self.x + self.y + z return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self, z): # 调用时传入变量，这也是个普通的局部变量，非实例变量 c = self.add() + self.square() + z return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square(16)) --------------------------------- 输出： 23 25 --------- 我是可爱的分割线----------- 64 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:4:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.5. 为啥要使用 self 看了上述的例子可能还是不明白 self 到底是个什么鬼，为啥要使用 self 这鬼东西？没关系，往下看： 其实 self 这家伙简单的说就是把 class 中 定义的 变量和函数 变成 实例变量和实例函数，作为类 class 的成员，使得成员间能互相调用，而不需要从外部调用 数据（变量）和 方法（函数），以实现数据的封装，以上面的 Person 类为例： 创建实例的时候需要给出实例变量 x,y, 调用函数时给出 z ，调用很容易，却不知道内部实现的细节。 总之，类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都相互独立、互不影响；方法是与实例绑定的函数，和普通的函数不同，方法可以直接访问实例的数据。 其实 self 中存储的是实例变量和实例函数的属性，可以理解为一个字典（ dict ），如：{'name':'zhang','age':'18'}就是这些。 注意只有数据属性，并没有创建新的类的方法。 类—–\u003e通过实例化生成—-对象—-\u003e（对象只是一串类似于字典的数据，没有把类的里的方法复制给你，python没有new这个方法！） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self, z=16): # 设置 z 为实例变量，即 self.z = z, z # 是 class 的一个成员了，而非普通局部变量 self.z = z sum = self.x + self.y + z # z虽然已被实例化，但是依然可以当作 普通变量来用 r return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self): c = self.add() + self.square() + self.z # 调用实例变量 z return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square()) print(student.z) # 函数add 中的 z 被实例化以后，就可以利用实例化的方法访问它 --------------------------------- 输出： 23 25 --------- 我是可爱的分割线----------- 64 16 通过这个例子可以看出， z 本来是 add() 函数的默认形参，通过将其实例化，就可以在其他函数体内调用实例变量z 被实例化以后，就可以利用实例化的方法访问它。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:5:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.6. self 到底是什么 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Box(object): def __init__(self, boxname, size, color): self.boxname = boxname self.size = size self.color = color # self就是用于存储对象属性的集合，就算没有属性self也是必备的 def open(self, myself): print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (self.color, self.size, self.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) b = Box(\"魔盒\", \"14m\", \"红色\") b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'size': '14m', 'color': '红色'} self代表类的实例，而非类；self 就是 对象/实例 属性集合 Box 是个类—–》self 实例化——》 b对象/ 实例 class 抽象体——》实例化——》对象/实例，含有属性：{‘boxname’:‘魔盒’, ‘size’：‘14m’, ‘color’:‘red’}，即 self self 看似是整个对象，实际上清楚地描述了类就是产生对象的过程，描述了 self 就是得到了 对象，所以 self 内的键值可以直接使用 正如自然界中一个有效的对象，必须包括： 描述对象的属性； 对象的方法 所以 self是必须的，也是对象中重要的特性。 看下面的代码，感觉就更神奇了： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Box(object): def myInit(mySelf, boxname, size, color): print(mySelf.__dict__) # 显示为{}空字典 mySelf.boxname = boxname mySelf.__dict__[\"aa\"] = \"w\" # 甚至可以像字典一样操作 mySelf.size = size mySelf.color = color # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self return mySelf # 返回给实例化过程一个对象！神奇！并且含有对象属性/字典 # def __init__(self, boxname, size, color): # self.boxname = boxname # self.size = size # self.color = color #注释掉原来标准的初始化 def open(self, myself): print(self) print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) # 经过改造，运行结果和标准初始化没区别 b = Box().myInit(\"魔盒\", \"14m\", \"红色\") # b = Box('魔盒', '14m', '红色')#注释掉原来标准的初始化方法 b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 \u003c__main__.Box object at 0x7f0c536c3e20\u003e --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'aa': 'w', 'size': '14m', 'color': '红色'} 换个角度来讲，对类的操作有： 定义属性 ； 调用方法 对类的反馈有： 得到属性 ； 执行方法 在 class 类的函数中，为什么 self是必要的，因为 self 是对象的载体，可以理解成一个字典，看下面代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Box(object): def myInit(mySelf, boxname, size, color): print(mySelf.__dict__) # 显示为{}空字典 mySelf.boxname = boxname mySelf.__dict__[\"aa\"] = \"w\" # 甚至可以像字典一样操作 mySelf.size = size mySelf.color = color # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self return mySelf # 返回给实例化过程一个对象！神奇！并且含有对象属性/字典 # def __init__(self, boxname, size, color): # self.boxname = boxname # self.size = size # self.color = color #注释掉原来标准的初始化 def open(self, myself): print(self) print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) # 经过改造，运行结果和标准初始化没区别 b = Box().myInit(\"魔盒\", \"14m\", \"红色\") # b = Box('魔盒', '14m', '红色')#注释掉原来标准的初始化方法 b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 \u003c__main__.Box object at 0x7fe655060e20\u003e --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'aa': 'w', 'size': '14m', 'color': '红色'} 注意此处的： mySelf.dict[‘aa’] = ‘w’ #甚至可以像字典一样操作； 在 b.dict 的结果中显示为：‘aa’:‘w’ 故可以把 self 理解成存储 实例化对象属性的字典(dict), self 存储属性，而没有动作执行。 self总是指调用时的类的实例。 python 中一些特殊的实例变量： 私有变量(private),只有内部可以访问，外部不能访问，私有变量是在名称前以两个下划线开头，如：__name，其实私有变量也不是完全不能被外部访问，不能直接访问是因为python解释器对外把 __name 变量改成了 _类名__name,所仍然可以通过 _类名__name 来访问 __name。 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 以一个下","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:6:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 列表和元组 2. Python 中的列表和元组都支持负数索引 3. 列表和元组都支持切片操作 4. 列表和元组都可以随意嵌套 5. 两者也可以通过 list 和 tuple 函数相互转换 6. 列表和元组常用的内置函数 7. 列表和元组存储方式的差异 8. 列表和元组的性能 9. 列表和元组的使用场景 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:0:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"1. 列表和元组 相同点： 列表和元组，都是一个可以放置任意数据类型的有序集合。 不同点： 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 1 2 3 4 5 6 7 8 9 10 l = [1, 2, 3, 4] l[3] = 40 # 和很多语言类似，python 中索引同样从 0 开始，l[3] 表示访问列表的第四个元素 l [1, 2, 3, 40] tup = (1, 2, 3, 4) tup[3] = 40 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: 'tuple' object does not support item assignment 想对已有的元组做任何\"改变“ 只能创建新的元组，对于列表来说，由于其是动态的，我们只需简单地在列表末尾，加入对应元素就可以了。 1 2 3 4 5 6 7 8 9 tup = (1, 2, 3, 4) new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值 new _tup (1, 2, 3, 4, 5) l = [1, 2, 3, 4] l.append(5) # 添加元素 5 到原列表的末尾 l [1, 2, 3, 4, 5] ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:1:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"2. Python 中的列表和元组都支持负数索引 Python 中的列表和元组都支持负数索引，-1 表示最后一个元素，-2 表示倒数第二个元素。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:2:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"3. 列表和元组都支持切片操作 1 2 3 4 5 6 7 l = [1, 2, 3, 4] l[1:3] # 返回列表中索引从 1 到 2 的子列表 [2, 3] tup = (1, 2, 3, 4) tup[1:3] # 返回元组中索引从 1 到 2 的子元组 (2, 3) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:3:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"4. 列表和元组都可以随意嵌套 1 2 3 l = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列表 tup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一元组 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:4:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"5. 两者也可以通过 list() 和 tuple() 函数相互转换 1 2 3 4 5 list((1, 2, 3)) [1, 2, 3] tuple([1, 2, 3]) (1, 2, 3) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:5:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"6. 列表和元组常用的内置函数 count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 l = [3, 2, 3, 7, 8, 1] l.count(3) 2 l.index(7) 3 l.reverse() l [1, 8, 7, 3, 2, 3] l.sort() l [1, 2, 3, 3, 7, 8] tup = (3, 2, 3, 7, 8, 1) tup.count(3) 2 tup.index(7) 3 list(reversed(tup)) [1, 8, 7, 3, 2, 3] sorted(tup) [1, 2, 3, 3, 7, 8] ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:6:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"7. 列表和元组存储方式的差异 列表的存储空间略大于元组。 列表是动态的、可变的，它需要存储指针，来指向对应的元素，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。。元组长度大小固定，元素不可变，所以存储空间固定。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:7:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"8. 列表和元组的性能 列表的性能略逊于元组。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:8:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"9. 列表和元组的使用场景 1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。 1 2 3 def get_location(): ..... return (longitude, latitude) 2. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。 1 2 3 4 viewer_owner_id_list = [] # 里面的每个元素记录了这个 viewer 一周内看过的所有 owner 的 id records = queryDB(viewer_id) # 索引数据库，拿到某个 viewer 一周内的日志 for record in records: viewer_owner_id_list.append(record.id) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:9:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 字典排序 1. 字典排序 2. 字典列表排序 计算字典值之和 移除字典点键值 合并字典 使用字典格式化字符串 1. 简介 字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key=\u003evalue 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示： 1 d = {key1 : value1, key2 : value2, key3 : value3 } 键必须是唯一的，但值则不必。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字。 1.1. 字典排序 ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:0:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"1.2. 字典排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # coding:utf-8 from random import randint def key_sort(dict): print(\"按键(key)排序:\") # sorted(key_value) 返回重新排序的列表 # 字典按键排序 for i in sorted(dict): print((i, dict[i]), end=\" \") print(\"\\r\") def value_sort(dict): print(\"按键(value)排序:\") # sorted(key_value) 返回重新排序的列表 # 字典按键排序 for i in sorted(dict.items(), key=lambda kv: (kv[1])): print(i) print(\"\\r\") def main(): d = {x: randint(60, 100) for x in \"xyzabc\"} key_sort(d) value_sort(d) # 主函数 if __name__ == \"__main__\": main() ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:1:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"1.3. 字典列表排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # coding:utf-8 def main(): lis = [ {\"name\": \"Taobao\", \"age\": 100}, {\"name\": \"Runoob\", \"age\": 7}, {\"name\": \"Google\", \"age\": 100}, {\"name\": \"Wiki\", \"age\": 200}, ] print(\"\\r\") # 通过 age 升序排序 print(\"列表通过 age 升序排序: \") print(sorted(lis, key=lambda i: i[\"age\"])) print(\"\\r\") # 先按 age 排序，再按 name 排序 print(\"列表通过 age 和 name 排序: \") print(sorted(lis, key=lambda i: (i[\"age\"], i[\"name\"]))) print(\"\\r\") # 按 age 降序排序 print(\"列表通过 age 降序排序: \") print(sorted(lis, key=lambda i: i[\"age\"], reverse=True)) # 主函数 if __name__ == \"__main__\": main() 2. 计算字典值之和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # coding:utf-8 from random import randint def returnSum(Dict): sum = 0 for i in Dict: sum = sum + Dict[i] return sum def main(): d = {x: randint(60, 100) for x in \"xyzabc\"} print(returnSum(d)) # 主函数 if __name__ == \"__main__\": main() 3. 移除字典点键值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # coding:utf-8 from random import randint def main(): test_dict = {x: randint(0, 50) for x in \"abcdefg\"} # 输出原始的字典 print (\"字典移除前 : \" + str(test_dict)) # 使用 del 移除 Zhihu del test_dict['a'] # 使用 pop 移除 Zhihu removed_value = test_dict.pop('b') print(\"removed_value : \" + str(removed_value)) # 使用 pop 移除 Zhihu new_dict = {key:val for key, val in test_dict.items() if key != 'c'} # 输出移除后的字典 print (\"字典移除后 : \" + str(test_dict)) print (\"字典移除后 : \" + str(new_dict)) # 主函数 if __name__ == \"__main__\": main() 4. 合并字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # coding:utf-8 from random import randint def Merge1(dict1, dict2): return(dict2.update(dict1)) def Merge2(dict1, dict2): res = {**dict1, **dict2} return res def main(): d1 = {x: randint(0, 50) for x in \"abc\"} d2 = {x: randint(50, 100) for x in \"xyz\"} Merge1(d1, d2) print(d2) dict2 = Merge2(d1, d2) print(dict2) # 主函数 if __name__ == \"__main__\": main() 5. 使用字典格式化字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # coding:utf-8 from random import randint def main(): # 字符串模板中使用key temp = '教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s' book = {'name':'Python基础教程', 'price': 99, 'publish': 'C语言中文网'} # 使用字典为字符串模板中的key传入值 print(temp % book) book = {'name':'C语言小白变怪兽', 'price':159, 'publish': 'C语言中文网'} # 使用字典为字符串模板中的key传入值 print(temp % book) # 主函数 if __name__ == \"__main__\": main() ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:2:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 字典和集合基础 字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。 相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。 而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。 Python 中字典和集合，无论是键还是值，都可以是混合类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 d1 = {'name': 'jason', 'age': 20, 'gender': 'male'} d2 = dict({'name': 'jason', 'age': 20, 'gender': 'male'}) d3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')]) d4 = dict(name='jason', age=20, gender='male') d1 == d2 == d3 ==d4 True s = {1, 'hello', 5.0} s1 = {1, 2, 3} s2 = set([1, 2, 3]) s1 == s2 True ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:0:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"元素访问 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"字典 字典访问可以直接索引键，如果不存在，就会抛出异常 1 2 3 4 5 6 7 d = {'name': 'jason', 'age': 20} d['name'] 'jason' d['location'] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e KeyError: 'location' 也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值。比如下面这个示例，返回了'null'。 1 2 3 4 5 d = {'name': 'jason', 'age': 20} d.get('name') 'jason' d.get('location', 'null') 'null' ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:1","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"集合 集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:2","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"增加、删除、更新等操作 字典和集合也同样支持增加、删除、更新等操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 d = {'name': 'jason', 'age': 20} d['gender'] = 'male' # 增加元素对'gender': 'male' d['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01' d {'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'} d['dob'] = '1998-01-01' # 更新键'dob'对应的值 d.pop('dob') # 删除键为'dob'的元素对 '1998-01-01' d {'name': 'jason', 'age': 20, 'gender': 'male'} s = {1, 2, 3} s.add(4) # 增加元素 4 到集合 s {1, 2, 3, 4} s.remove(4) # 从集合中删除元素 4 s {1, 2, 3} 集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:2:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"排序 1 2 3 4 5 6 7 d = {'b': 1, 'a': 2, 'c': 10} d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序 d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序 d_sorted_by_key [('a', 2), ('b', 1), ('c', 10)] d_sorted_by_value [('b', 1), ('a', 2), ('c', 10)] 返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。 对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。 1 2 3 s = {3, 4, 2, 1} sorted(s) # 对集合的元素进行升序排序 [1, 2, 3, 4] ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:3:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"性能 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:4:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:0:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串基础 Python 中单引号、双引号和三引号的字符串是一模一样的，没有区别。 1 2 3 4 5 s1 = 'hello' s2 = \"hello\" s3 = \"\"\"hello\"\"\" s1 == s2 == s3 True Python 的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:1:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"转义字符 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:1:1","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串的常用操作 Python 的字符串同样支持索引，切片和遍历等等操作。 1 2 3 4 5 name = 'jason' name[0] 'j' name[1:3] 'as' Python 的字符串是不可变的（immutable）,Python 中字符串的改变，通常只能通过创建新的字符串来完成。 1 2 3 4 5 # 是直接用大写的'H'，通过加号'+'操作符，与原字符串切片操作的子字符串拼接而成新的字符串。 s = 'H' + s[1:] # 是直接扫描原字符串，把小写的'h'替换成大写的'H'，得到新的字符串。 s = s.replace('h', 'H') 使用加法操作符'+='的字符串拼接方法。 1 2 3 s = '' for n in range(0, 100000): s += str(n) 对于字符串拼接问题，除了使用加法操作符，我们还可以使用字符串内置的 join 函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来。 1 2 3 4 l = [] for n in range(0, 100000): l.append(str(n)) l = ' '.join(l) 由于列表的 append 操作是 O(1) 复杂度，字符串同理。因此，这个含有 for 循环例子的时间复杂度为 n*O(1)=O(n)。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:2:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"split() string.split(separator)，表示把字符串按照 separator 分割成子字符串，并返回一个分割后子字符串组合的列表 string.strip(str)，表示去掉首尾的 str 字符串 string.lstrip(str)，表示只去掉开头的 str 字符串 string.rstrip(str)，表示只去掉尾部的 str 字符串 1 2 3 s = ' my name is jason ' s.strip() 'my name is jason' ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:3:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串的格式化 1 2 3 4 5 6 print('no data available for person with id: {}, name: {}'.format(id, name)) 'no data available for person with id: 123, name: jason' # 在 Python 之前版本中，字符串格式化通常用 % 来表示 print('no data available for person with id: %s, name: %s' % (id, name)) ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:4:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/","tags":["python"],"title":"Python中的装饰器","uri":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 装饰器(Decorators) 装饰器(Decorators) 装饰器（Decorator）是Python中一个重要部分，它本质上是一个函数，不同于普通函数，装饰器的返回值是一个函数对象。通过利用装饰器，我们可以让其他函数在不做任何代码改动的情况下增加额外的功能，同时也能够让代码更加简洁。 1 2 3 4 5 6 def decorator(func): return func @decorator def some_func(): pass 等同于 1 2 3 4 5 6 7 def decorator(func): return func def some_func(): pass some_func = decorator(some_func) 举例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Pizza(object): def __init__(self): # __init__ : 构造方法，通过类创建对象时，自动触发执行。 self.toppings = [] def __call__(self, topping): # __call__ : 对象后面加括号，触发执行。 # When using '@instance_of_pizza' before a function definition # the function gets passed onto 'topping'. self.toppings.append(topping()) def __repr__(self): # __repr__ : 打印，转换 return str(self.toppings) + \" \" + str(1) def __str__(self): # __str__ : 如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。有点像java中的toString方法。 return str(self.toppings)+ \" \" + str(2) pizza = Pizza() @pizza def cheese(): return 'cheese' @pizza def sauce(): return 'sauce' print (pizza) # ['cheese', 'sauce'] 2 ","date":"2023-01-15","objectID":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","tags":["python"],"title":"Python中的装饰器","uri":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["rust"],"content":"rust 编程笔记","date":"2023-01-15","objectID":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["rust"],"title":"rust环境搭建","uri":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["rust"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Rust 程序设计语言 中文版 安装 rust Getting started 1 2 3 4 5 6 7 8 9 10 11 # 安装 curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh # 升级 rustup update # 卸载 rustup self uninstall # 查看版本 rustc --version vscode 插件：rust-analyzer ： Rust 语言服务器 (RLS) 已被弃用，取而代之的是 rust-analyzer。RLS 用户应该改用 rust-analyzer。 （2022-07-02） 编译运行 rustc rustc 只适合简单的程序。 1 rustc main.rs cargo Cargo 是 Rust 的构建系统和包管理器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 查看版本 cargo --version # 构建项目 cargo new hello_cargo cd hello_cargo # 构建了项目，并使用 ./target/debug/hello_cargo 运行了程序 cargo build # cargo run 在一个命令中同时编译代码并运行生成的可执行文件 cargo run # 快速检查代码确保其可以编译，但并不产生可执行文件 cargo check # 优化编译项目 cargo build --release cargo build --debug 使用 Cargo 当作习惯 1 2 3 git clone example.org/someproject cd someproject cargo build ","date":"2023-01-15","objectID":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["rust"],"title":"rust环境搭建","uri":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["rust"],"content":"rust 编程笔记","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Rust 程序设计语言 中文版 关键字 as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名 async - 返回一个 Future 而不是阻塞当前线程 await - 暂停执行，直到 Future 的结果准备好 break - 立刻退出循环 const - 定义常量或不变裸指针（constant raw pointer） continue - 继续进入下一次循环迭代 crate - 链接（link）一个外部 crate 或一个代表宏定义的 crate 的宏变量 dyn - 动态分发 trait 对象 else - 作为 if 和 if let 控制流结构的 fallback enum - 定义一个枚举 extern - 链接一个外部 crate 、函数或变量 false - 布尔字面量 false fn - 定义一个函数或 函数指针类型 (function pointer type) for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期 if - 基于条件表达式的结果分支 impl - 实现自有或 trait 功能 in - for 循环语法的一部分 let - 绑定一个变量 loop - 无条件循环 match - 模式匹配 mod - 定义一个模块 move - 使闭包获取其所捕获项的所有权 mut - 表示引用、裸指针或模式绑定的可变性 pub - 表示结构体字段、impl 块或模块的公有可见性 ref - 通过引用绑定 return - 从函数中返回 Self - 实现 trait 的类型的类型别名 self - 表示方法本身或当前模块 static - 表示全局变量或在整个程序执行期间保持其生命周期 struct - 定义一个结构体 super - 表示当前模块的父模块 trait - 定义一个 trait true - 布尔字面量 true type - 定义一个类型别名或关联类型 unsafe - 表示不安全的代码、函数、trait 或实现 use - 引入外部空间的符号 where - 表示一个约束类型的从句 while - 基于一个表达式的结果判断是否进行循环 变量和可变性 ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:0:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"immutable \u0026 immutable 不可变的（immutable），可变的（immutable）。 1 2 3 4 5 6 fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); x = 6; println!(\"The value of x is: {}\", x); } ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:1:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"常量 常量（constant）是绑定到一个常量名且不允许更改的值。 1 const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:2:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"遮蔽 遮蔽（shadow）：以声明和前面变量具有相同名称的新变量，这意味着当我们使用变量时我们看到的会是第二个变量的值。 1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\"The value of x in the inner scope is: {}\", x); } println!(\"The value of x is: {}\", x); } mut 和遮蔽之间的另一个区别是，因为我们在再次使用 let 关键字时有效地创建了一个新的变量，所以我们可以改变值的类型，但重复使用相同的名称。 1 2 let spaces = \" \"; let spaces = spaces.len(); 数据类型 Rust 是一种静态类型（statically typed）的语言，这意味着它必须在编译期知道所有变量的类型。 1 let guess: u32 = \"42\".parse().expect(\"Not a number!\"); ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:3:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"标量类型 标量（scalar）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。 整型 长度 有符号类型 无符号类型 8 位 i8 u8 16 位 i16 u16 32 位 i32 u32 64 位 i64 u64 128 位 i128 u128 arch isize usize 整型字面量 数字字面量 示例 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 (仅限于 u8) b'A' 浮点型 Rust 的浮点型是 f32 和 f64，它们的大小分别为 32 位和 64 位。默认浮点类型是 f64，因为在现代的 CPU 中它的速度与 f32 的几乎相同，但精度更高。所有浮点型都是有符号的。 数字运算 Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; let floored = 2 / 3; // Results in 0 // remainder let remainder = 43 % 5; } bool 1 let f: bool = false; char 1 let c = 'z'; ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:4:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"复合类型 Rust 有两种基本的复合类型：元组（tuple）和数组（array）。 1 2 3 4 5 6 7 let tup: (i32, f64, u8) = (500, 6.4, 1); let a = [1, 2, 3, 4, 5]; let months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]; let a: [i32; 5] = [1, 2, 3, 4, 5]; // i32 是每个元素的类型。分号之后，数字 5 表明该数组包含 5 个元素。 let a = [3; 5]; // 变量名为 a 的数组将包含 5 个元素，这些元素的值初始化为 3。 函数 Rust 中的函数定义以 fn 开始，后跟着函数名和一对圆括号。大括号告诉编译器函数体在哪里开始和结束。 参数 1 2 3 4 5 6 7 fn main() { another_function(5); } fn another_function(x: i32) { println!(\"The value of x is: {}\", x); } 语句和表达式 语句（statement）是执行一些操作但不返回值的指令。表达式（expression）计算并产生一个值 1 2 3 4 5 6 7 8 fn main() { let y = { let x = 3; x + 1 // 注意，x + 1 行的末尾没有分号，这与你目前见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。 }; println!(\"The value of y is: {}\", y); } 带有返回值的函数 1 2 3 4 5 6 7 8 9 fn five() -\u003e i32 { 5 } fn main() { let x = five(); println!(\"The value of x is: {}\", x); } 控制流 ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:5:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn main() { let number = 6; if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); } let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {}\", number); } 循环 Rust 有三种循环：loop、while 和 for。 loop loop 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { let mut count = 0; 'counting_up: loop { println!(\"count = {}\", count); let mut remaining = 10; loop { println!(\"remaining = {}\", remaining); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(\"End count = {}\", count); } 从循环返回 1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\"The result is {}\", result); } while 在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 break 停止循环。这个循环类型可以通过组合 loop、if、else 和 break 来实现. for 1 2 3 4 5 6 7 fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {}\", element); } } ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:6:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/shell/","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 note：关键字 1. $#,$@,$0,$1,$2 2. while循环和遍历参数 3. i 4. 通配符wildcard 5. 元字符（特殊字符 Meta） 6. shell转义符 7. 管道和重定向 note:代码段 1. 判断文件夹或文件是否存在 资料 ABS_GUIDE Linux Shell 通配符、元字符、转义符使用实例介绍 note：关键字 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:0:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"$#,$@,$0,$1,$2 $$ Shell本身的PID（ProcessID） $! Shell最后运行的后台Process的PID $? 最后运行的命令的结束代码（返回值） $- 使用Set命令设定的Flag一览 $* 所有参数列表。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $@ 所有参数列表。如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $# 添加到Shell的参数个数 $0 Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 1 2 3 4 5 6 7 8 9 10 #!/bin/bash printf \"The complete list is %s\\n\" \"$$\" printf \"The complete list is %s\\n\" \"$!\" printf \"The complete list is %s\\n\" \"$?\" printf \"The complete list is %s\\n\" \"$*\" printf \"The complete list is %s\\n\" \"$@\" printf \"The complete list is %s\\n\" \"$#\" printf \"The complete list is %s\\n\" \"$0\" printf \"The complete list is %s\\n\" \"$1\" printf \"The complete list is %s\\n\" \"$2 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:1:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"while循环和遍历参数 1 2 3 4 5 while [ $# -gt 0 ] ; do echo $1 #左移一个参数，这样可以使用$1遍历所有参数 shift done ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:2:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"i 1 2 3 4 5 !! 重复前一个命令 !字符 重复前一个以此字符开头的命令 !num 重复历史记录里序号为num的命令 !?abc 重复执行之前命令中包含abc的命令 !-n 重复之前第n个命令 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:3:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"通配符(wildcard) ​ 通配符是由shell处理的（不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍）, 它只会出现在 命令的“参数”里（它不用在 命令名称里， 也不用在 操作符上）。当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符 实际上就是一种shell实现的路径扩展功能。在 通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。 1 2 3 4 5 6 * 匹配一个或多个 M* 以M 开头的字符串 ？匹配任意一个字符 M？ 以M开头的两个字符 [0-9]匹配0-9中的一个数字 [abc]匹配abc中的一个字符 [^abc]匹配abc以外的一个字符 ls Do[ab]ument 报错，匹配不到 ls Document 字符 含义 实例 * 匹配 0 或多个字符 a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。 ? 匹配任意一个字符 a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。 [list] 匹配 list 中的任意单一字符 a[xyz]b a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。 [!list] 匹配 除list 中的任意单一字符 a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b… a9b。 {string1,string2,…} 匹配 sring1 或 string2 (或更多)其一字符串 a{abc,xyz,123}b a与b之间只能是abc或xyz或123这三个字符串之一。 需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，*,? [] ,{} 这几种。 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:4:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"元字符（特殊字符 Meta） shell 除了有通配符之外，由shell 负责预先先解析后，将处理结果传给命令行之外，shell还有一系列自己的其他特殊字符。 字符 说明 IFS 由 或 或 三者之一组成(我们常用 space )。 CR 由 产生。 = 设定变量。 $ 作变量或运算替换(请不要与 shell prompt 搞混了)。 \u003e 重导向 stdout。 * \u003c 重导向 stdin。 * | 命令管线。 * \u0026 重导向 file descriptor ，或将命令置于背境执行。 * ( ) 将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 * { } 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。 ; 在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 * \u0026\u0026 在前一个命令结束时，若返回值为 true，继续执行下一个命令。 * || 在前一个命令结束时，若返回值为 false，继续执行下一个命令。 * ! 执行 history 列表中的命令。* 加入”*” 都是作用在命令名直接。可以看到shell 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。 以下是man bash 得到的英文解析： metacharacter A character that, when unquoted, separates words. One of the following: | \u0026 ; ( ) \u003c \u003e space tab control operator A token that performs a control function. It is one of the following symbols: || \u0026 \u0026\u0026 ; ;; ( ) | ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:5:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"shell转义符 有时候，我们想让 通配符，或者元字符 变成普通字符，不需要使用它。那么这里我们就需要用到转义符了。 shell提供转义符有三种。 字符 说明 ‘’(单引号) 又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。 “”(双引号) 又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替 (反斜杠) 又叫转义，去除其后紧跟的元字符或通配符的特殊意义。 man bash 英文解释如下： There are three quoting mechanisms: the escape character, single quotes, and double quotes. ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:6:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"管道和重定向 多命令协作:通过管道和重定向完成.(将多个命令结合在一起),几乎所有命令的输入和返回输出是纯文本. example : cat 输入 文件路径 返回 文件文本内容 命令行shell的数据流定义: 名称 说明 编号 默认 STDIN 标准输入 0 键盘 STDOUT 标准输出 1 终端 STDERR 标准错误 2 终端 命令通过STDIN接收参数或数据，通过STDOUT输出结果或通过STDERR输出错误. 分类 关键字 定义 例子 重定向 \u003e 将STDOUT重定向到文件(覆盖) echo “baidu” \u003e outfile / ls \u003e outfile » 将STDOUT重定向到文件(追加) echo “baidu” » outfile/ date »outfile 2\u003e 将STDERROR重定向到文件(覆盖) ls nothere 2\u003e errorout 2\u003e\u00261 将STDERROR与STDOUT结合 ls nothere 2\u003e\u00261 alloutput \u003c 重定向STDIN grep linuxcast \u003c /etc/passwd 管道 | 将一个命令的STDOUT ls -l | grep linuxcast 作为另一个命令的STDIN find / -user linuxcast | grep video 2\u003e /dev/null 重定向给null,丢弃 note:代码段 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:7:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"判断文件夹或文件是否存在 文件夹不存在则创建 1 2 3 4 5 if [ ! -d \"/data/\" ];then mkdir /data else echo \"文件夹已经存在\" fi 文件存在则删除 1 2 3 4 5 if [ ! -f \"/data/filename\" ];then echo \"文件不存在\" else rm -f /data/filename fi 判断文件夹是否存在 1 2 3 4 5 if [ -d \"/data/\" ];then echo \"文件夹存在\" else echo \"文件夹不存在\" fi 判断文件是否存在 1 2 3 4 5 if [ -f \"/data/filename\" ];then echo \"文件存在\" else echo \"文件不存在\" fi 文件比较符 1 2 3 4 5 6 7 8 9 10 11 12 13 -e 判断对象是否存在 -d 判断对象是否存在，并且为目录 -f 判断对象是否存在，并且为常规文件 -L 判断对象是否存在，并且为符号链接 -h 判断对象是否存在，并且为软链接 -s 判断对象是否存在，并且长度不为0 -r 判断对象是否存在，并且可读 -w 判断对象是否存在，并且可写 -x 判断对象是否存在，并且可执行 -O 判断对象是否存在，并且属于当前用户 -G 判断对象是否存在，并且属于当前用户组 -nt 判断file1是否比file2新 [ \"/data/file1\" -nt \"/data/file2\" ] -ot 判断file1是否比file2旧 [ \"/data/file1\" -ot \"/data/file2\" ] ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:8:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 # 井号 (comments) ~ 帐户的 home 目录 ; 分号 (Command separator) ;; 连续分号 (Terminator) 逗号 (dot,就是“点”) ‘string’ 单引号 (single quote) “string” 双引号 (double quote) command 倒引号 (backticks) , 逗点 (comma，标点中的逗号) / 斜线 (forward slash) \\ 倒斜线 | 管道 (pipeline) ! 惊叹号(negate or reverse) : 冒号 ? 问号 (wild card) * 星号 (wild card) ** 次方运算 $ 钱号(dollar sign) 1. 变量替换(Variable Substitution)的代表符号。 2. ${} 变量的正规表达式 3. $* 4. $@ 5. $# 6. $? 状态值 (status variable) 7. $$ () 指令群组 (command group) 1. (())) {} 大括号 (Block of code) 1. 常规用法 1.1. 大括号拓展 1.2. 代码块 2. 几种特殊的替换结构 3. 四种模式匹配替换结构 4. 字符串提取和替换 [] 中括号 [[]] || \u0026\u0026 \u0026 1. ||或逻辑符号 2. \u0026\u0026 逻辑符号 3. \u0026后台工作 / 单字边界 + 加号 (plus) - 减号 (dash) % 除法 (Modulo) = 等号 (Equals) == 等号 (Equals) != 不等于 ^ 参考： 在shell中常用的特殊符号罗列如下： 1 2 3 4 5 # ; ;; . , / \\\\ 'string'| ! $ ${} $? $$ $* \\\"string\\\"* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || \u0026\u0026 {xx,yy,zz,...}~ ~+ ~- \u0026 \\\\\u003c...\\\\\u003e + - %= == != # 井号 (comments) 这几乎是个满场都有的符号，除了先前已经提过的\"第一行\" #!/bin/bash 井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。 1 2 # This line is comments. echo \\\"a = $a\\\" # a = 0 由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。 1 echo \\\"a = $a\\\" # a = 0 如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。 ~ 帐户的 home 目录 算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份： 1 ~/bin ~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。 1 2 # echo ~+/ var/log ~- 上次的工作目录，这个符号代表上次的工作目录。 1 2 # echo ~- /etc/httpd/logs ; 分号 (Command separator) 在 shell 中，担任\"连续指令\"功能的符号就是\"分号\"。譬如以下的例子： 1 cd ~/backup ; mkdir startup ;cp ~/.* startup/. ;; 连续分号 (Terminator) 专用在 case 的选项，担任 Terminator 的角色。 1 2 3 4 5 6 7 8 case \\\"$fop\\\" inhelp) echo \\\"Usage: Command -help -version filename\\\" ;; version) echo \\\"version 0.1\\\" ;; esac 逗号 (dot,就是“点”) 在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。 1 CDPATH=.:~:/home:/home/web:/var:/usr/local 在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。 如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。 除此之外，在 regular expression 中，一个 dot 代表匹配一个字元。 ‘string’ 单引号 (single quote) 被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。 1 2 heyyou=home echo '$heyyou' # We get $heyyou \"string\" 双引号 (double quote) 被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。 通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。 当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“*Not?pad”可以对应Notepad\\MyNotepad【*可以代表任何字符串；?仅代表单个字符串，但此单字必须存在】;Notep[ao]d可以对应Notepad\\Notepod【ao代表a与o里二选一】，其余以此类推。 1 2 heyyou=home echo \"$heyyou\" # We get home command 倒引号 (backticks) 在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。 1 2 fdv=`date +%F` echo \"Today $fdv\" 在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。 , 逗点 (comma，标点中的逗号) 这个符号常运用在运算当中当做\"区隔\"用途。如下例 1 2 let \"t1= ((a = 5 + 3, b = 7 - 1, c = 15 / 5),(a + b + c))\" echo \"t1= $t1, a = $a, b = $b\" let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 如果表达式中包含了空格或其他特殊字符，则必须引起来。 / 斜线 (forward slash) 在路径表示时，代表目录。 1 2 3 cd /etc/rc.d cd ../.. cd / 通常单一的 / 代表 root 根目录的意思； 在四则运算中，代表除法的符号。 let \"num1 = ((a = 10 / 2, b = 25 / 5))\" \\ 倒斜线 在交互模式下的escape 字元，有几个作用: 放在指令前，有取消 aliases的作用； 放在特殊符号前，则该特殊符号的作用消失； 放在指令的最末端，表示指令连接下一行。 1 2 # type rmrm is aliased to `rm -i' # \\\\rm ./*.log 上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。 1 # bkdir=/home# echo \\\"Backup dir, \\\\$bkdir = $bkdir\\\"Backup dir,$bkdir = /home 上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。 | 管道 (pipeline) pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。 1 2 3 4 5 who | wc -l # wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。 # - c 统计字节数。 # - l 统计行数。 # - w 统计字数。 善用这个观念，对精简 script 有相当的帮助。 ! 惊叹号(negate or reverse) 通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于” 1 2 3 4 if [ \"$?\" != 0 ]then echo \"Executes error\" exit 1 fi 在规则表达式中她担任 “反逻辑” 的角色 1 ls a[!0-9] 上例，代表显示除了a0, a1 …. a9 这几个文件的其他文件。 : 冒号 在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0。 1 2 3 : echo $? # 回应为 0 : \u003e f.$$ 上面这一行，相当于 cat /dev/null \u003e f.$$。不仅写法简短了，而且执行效率也好上许多。 有时，也会出现以下这类的用法 1 : ${HOSTNAME?} ${USER?} ${MAIL?} 这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if 这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:0:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. 变量替换(Variable Substitution)的代表符号。 1 2 vrs=123 echo \"vrs = $vrs\" # vrs = 123 另外，在 Regular Expressions 里被定义为 “行” 的最末端 (end-of-line)。这个常用在 grep、sed、awk 以及 vim(vi) 当中。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:1:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. ${} 变量的正规表达式 bash 对 ${} 定义了不少用法。以下是取自线上说明的表列 1 2 3 4 5 ${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length} ${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/string} ${parameter//pattern/string} ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:2:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. $* $* 引用script 的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下： 1 $0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}….. 个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。 $* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。 1 echo “$*” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:3:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"4. $@ $@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。 符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:4:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"5. $# 这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。 1 echo “$#” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:5:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"6. $? 状态值 (status variable) 一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。 一般指令程序倘若执行成功，其回传值为 0；失败为 1。 1 tar cvfz dfbackup.tar.gz /home/user \u003e /dev/nullecho “$?” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:6:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"7. $$ 由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script 会需要产生临时文件，用来存放必要的资料。 而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。 符号$$或许可以符合这种需求。它代表当前shell 的 PID。 1 echo “$HOSTNAME, $USER, $MAIL” \u003e ftmp.$$ 使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。 ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果 script 执行完毕后仍不加以清除，会产生其他问题。 () 指令群组 (command group) 用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子： 1 (cd ~ ; vcgh=`pwd` ; echo $vcgh) 指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子 1 # cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e “/n $a /n”)echo $a# ./ftmp-01incgfsh 除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape 字元才能使用的场合，如运算式。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:7:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. (())) 这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let 指令要好许多。 1 2 3 4 5 #!/bin/bash (( a = 10 )) echo -e \"inital value, a = $a/n\" (( a++ )) echo \"after a++, a = $a\" {} 大括号 (Block of code) ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:8:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. 常规用法 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1.1. 大括号拓展 (通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt 1 2 3 4 5 6 # ls {ex1,ex2}.sh ex1.sh ex2.sh # ls {ex{1..3},ex4}.sh ex1.sh ex2.sh ex3.sh ex4.sh # ls {ex[1-3],ex4}.sh ex1.sh ex2.sh ex3.sh ex4.sh ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:1","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1.2. 代码块 又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。 大括号也被运用在 “函数” 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script 也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:2","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. 几种特殊的替换结构 1 2 3 4 ${var:-string} ${var:+string} ${var:=string} ${var:?string} 1、${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。 2、${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 3、{var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。 补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。 此外，大括号还有另一种用法，如下 1 {xx,yy,zz,…} 这种大括号的组合，常用在字串的组合上，来看个例子 1 mkdir {userA,userB,userC}-{home,bin,data} 我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子 1 chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}} 如果不是因为这种用法，我们得写几行重复几次呀！ ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:10:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. 四种模式匹配替换结构 模式匹配记忆方法： 1 2 # 是去掉左边(在键盘上#在$之左边) % 是去掉右边(在键盘上%在$之右边) #和%中的单一符号是最小匹配，两个相同符号是最大匹配。 1 2 3 4 ${var%pattern} ${var%%pattern ${var#pattern} ${var##pattern} 第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式 第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式 第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # var=testcase # echo $var testcase # echo ${var%s*e} testca # echo $var testcase # echo ${var%%s*e} te # echo ${var#?e} stcase # echo ${var##?e} stcase # echo ${var##*e} # echo ${var##*s} e # echo ${var##test} case ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:11:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"4. 字符串提取和替换 1 2 3 4 ${var:num} ${var:num1:num2} ${var/pattern/pattern} ${var//pattern/pattern} 第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。 第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。 第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。 第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [root@centos ~]# var=/home/centos [root@centos ~]# echo $var /home/centos [root@centos ~]# echo ${var:5} /centos [root@centos ~]# echo ${var: -6} centos [root@centos ~]# echo ${var:(-6)} centos [root@centos ~]# echo ${var:1:4} home [root@centos ~]# echo ${var/o/h} /hhme/centos [root@centos ~]# echo ${var//o/h} /hhme/cenths [] 中括号 常出现在流程控制中，扮演括住判断式的作用。 1 2 3 4 if [ \"$?\" != 0 ]then echo \"Executes error\" exit 1 fi 这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色 1 rm -r 200[1234] 上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。 [[]] 这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与 \u0026\u0026 逻辑等符号。 1 2 3 4 5 #!/bin/bash read ak if [[ $ak \u003e 5 || $ak \u003c 9 ]]then echo $ak fi || \u0026\u0026 \u0026 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:12:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. ||或逻辑符号 这个会时常看到，代表 or 逻辑的符号。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:13:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. \u0026\u0026 逻辑符号 这个也会常看到，代表 and 逻辑的符号。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:14:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. \u0026后台工作 单一个\u0026 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 1 tar cvfz data.tar.gz data \u003e /dev/null \u0026 / 单字边界 这组符号在规则表达式中，被定义为”边界”的意思。譬如，当我们想找寻 the 这个单字时，如果我们用 1 grep the FileA 你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there 的一部份。如果我们要必免这种情况，就得加上 “边界” 的符号 1 grep ‘/' FileA + 加号 (plus) 在运算式中，她用来表示 “加法”。 1 expr 1 + 2 + 3 此外在规则表达式中，用来表示”很多个”的前面字元的意思。 1 # grep '10/+9′ fileB109100910000910000931010009#这个符号在使用时，前面必须加上 escape 字元。 - 减号 (dash) 在运算式中，她用来表示 “减法”。 1 expr 10 – 2 此外也是系统指令的选项符号。 1 ls -expr 10 – 2 在 GNU 指令中，如果单独使用 – 符号，不加任何该加的文件名称时，代表”标准输入”的意思。这是 GNU 指令的共通选项。譬如下例 1 tar xpvf - 这里的 – 符号，既代表从标准输入读取资料。 不过，在 cd 指令中则比较特别 1 cd - 这代表变更工作目录到”上一次”工作目录。 % 除法 (Modulo) 在运算式中，用来表示 “除法”。 1 expr 10 % 2 此外，也被运用在关于变量的规则表达式当中的下列 1 ${parameter%word}${parameter%%word} 一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。 = 等号 (Equals) 常在设定变数时看到的符号。 1 2 vara=123 echo \"vara = $vara\" 或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。 == 等号 (Equals) 常在条件判断式中看到，代表 “等于” 的意思。 1 2 if [ $vara == $varb ] …下略 != 不等于 常在条件判断式中看到，代表 “不等于” 的意思。 1 2 if [ $vara != $varb ] …下略 ^ 这个符号在规则表达式中，代表行的 “开头” 位置 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:15:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["tools"],"content":"repo","date":"2023-01-15","objectID":"/posts/tools/git/repo/","tags":["repo"],"title":"tool: repo 代码库管理工具","uri":"/posts/tools/git/repo/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-15","objectID":"/posts/tools/git/repo/:0:0","tags":["repo"],"title":"tool: repo 代码库管理工具","uri":"/posts/tools/git/repo/"},{"categories":["tools"],"content":"android studio 安装使用","date":"2023-01-15","objectID":"/posts/tools/android/android_studio/","tags":["android studio"],"title":"tool:android studio 安装使用","uri":"/posts/tools/android/android_studio/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 下载 安装 配置 插件 快捷键设置 1. 下载 studio 2. 安装 1 2 3 mv android-studio-2021.2.1.15-linux.tar.gz /opt/ cd /opt sudo tar -zxvf android-studio-2021.2.1.15-linux.tar.gz 更改 /opt/android-studio/bin/idea.porperties： 1 sudo gedit /opt/android-studio/bin/idea.properties 文末添加 1 disable.android.first.run=true 此操作防止第一次打开Android Studio时卡在”Fetching Android SDK component information” 。 更改/opt/android-studio/bin目录权限： 1 sudo chmod 777 /opt/android-studio/bin 配置 插件 Rainbow Brackets 快捷键设置 参考: 【Android – 开发工具】Android Studio 设置快捷键 File → Settings → keymap 代码返回快捷键 ： Ctrl + Alt + left/right ","date":"2023-01-15","objectID":"/posts/tools/android/android_studio/:0:0","tags":["android studio"],"title":"tool:android studio 安装使用","uri":"/posts/tools/android/android_studio/"},{"categories":["tools"],"content":"下载工具","date":"2023-01-15","objectID":"/posts/tools/aria2c/aria2c/","tags":["aria2c"],"title":"tool:aria2c下载工具","uri":"/posts/tools/aria2c/aria2c/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 安装 配置 服务模式开机启动 简介 Aria2 是一个多平台轻量级，支持 HTTP、FTP、BitTorrent 等多协议、多来源的命令行下载工具。Aria2 可以从多个来源、多个协议下载资源，最大的程度上利用了你的带宽。Aria2 有着非常小的资源占用，在关闭磁盘缓存的情况下，物理内存占用通常为 4M（正常 HTTP/FTP 下载的情况下），BitTorrent 下载每秒2.8M/S的情况下，CPU 占有率约为 6%。Aria2 支持 JSON-RPC 和 XML-RPC 接口远程调用。 安装 1 sudo apt-get install aria2 配置 创建配置文件 : 1 2 3 4 sudo mkdir /etc/aria2 #新建文件夹 sudo touch /etc/aria2/aria2.session #新建session文件 sudo chmod 777 /etc/aria2/aria2.session #设置aria2.session可写 sudo vi /etc/aria2/aria2.conf #创建配置文件 配置文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 ## 全局设置 ## ============================================================ # 日志 #log-level=warn #log=/PATH/.aria2/aria2.log # 后台运行 #daemon=true # 下载位置, 默认: 当前启动位置(***) dir=/home/***/Downloads # 从会话文件中读取下载任务(***) input-file=/usr/customer/aria2/aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件(***) save-session=/usr/customer/aria2/aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=30 # 断点续传 continue=true # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u003c falloc ? trunc \u003c prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=none https://www.jianshu.com/p/6adf79d29add # 客户端伪装 user-agent=netdisk;5.2.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia referer=http://pan.baidu.com/disk/home # 禁用IPv6, 默认:false disable-ipv6=true # 其他 always-resume=true check-integrity=true ## 下载位置 ## ============================================================ # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=10 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=10 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 ## RPC设置 ## ============================================================ # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=\u003cTOKEN\u003e # 是否启用 RPC 服务的 SSL/TLS 加密, # 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接 #rpc-secure=true # 在 RPC 服务中启用 SSL/TLS 加密时的证书文件, # 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件 #rpc-private-key=/path/to/certificate.key ## BT/PT下载相关 ## ============================================================ # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 dht-file-path=/opt/var/aria2/dht.dat dht-file-path6=/opt/var/aria2/dht6.dat # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 设置 peer id 前缀 peer-id-prefix=-TR2770- # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverif","date":"2023-01-15","objectID":"/posts/tools/aria2c/aria2c/:0:0","tags":["aria2c"],"title":"tool:aria2c下载工具","uri":"/posts/tools/aria2c/aria2c/"},{"categories":["tools"],"content":"gdb","date":"2023-01-15","objectID":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/","tags":["gdb"],"title":"tool:gdb 常用调试方法记录","uri":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 gdb 启动程序带运行参数 指定断点位置 gdb 启动程序带运行参数 1 2 3 set args --gtest_filter=TestAdasPipe.AssetsData r --gtest_filter=TestAdasPipe.AssetsData 指定断点位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 断点管理 https://blog.csdn.net/wohu1104/article/details/125052150 # 查看断点 info b i b # 启用断点并命中N次 enable count 数量 断点编号 # 忽略断点前N次命中 ignore 断点编号 次数 # 删除所有断点 delete # 删除指定断点 delete 断点编号 # 删除指定范围的断点 delete 范围 delete 5-7 delete 5-7 10-12 # 删除指定函数的断点 clear 函数名 # 删除指定行号的断点 clear demo.cpp:10 执行到下一个断点 c ","date":"2023-01-15","objectID":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/:0:0","tags":["gdb"],"title":"tool:gdb 常用调试方法记录","uri":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"categories":["tools"],"content":"git tag","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git tag ","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/:0:0","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":"git tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git tag # 列出已有的标签 git tag -l \"v0.1\" # 过滤列出已有的标签 git tag -a v1.4 -m \"my version 1.4\" # 创建标签 git show v1.4 # 查看标签信息和与之对应的提交信息 git tag -d v1.4 # 删除标签 git push origin :refs/tags/v1.4 # 删除远程标签 git push origin --delete v1.4 # 删除远程标签 git checkout v1.4 # 切换到 v1.4 tag git checkout -b version_v1.4 v1.4 # 切换到 v1.4 tag version_v1.4 git push origin v1.4 # 传送标签到远程仓库服务器 git push origin --tags # 把所有不在远程仓库服务器上的标签全部传送到远程仓库服务器 后期打标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git log --pretty=oneline dd1db2ddf7ab23a57b0197abe80167ba4847f185 (HEAD -\u003e master, tag: v0.0.2, origin/master, origin/HEAD) Merge branch 'release-0.0.2' 1967f19f3d2f7b13d18f80dada14da1b8385ecc3 (release-0.0.2) version update :v0.0.2 28b3ff52ea28221314264482d6db6fb7349cf2f8 (develop) Merge branch 'release-0.0.1' into develop e2d4b5d8eb8407d7141c9846c4459cd1733922fb (release-0.0.1) version update :v0.0.1 2c6ffbce9ffd31e4cee8ca5013924324b49ec898 add bump-version.sh 9c29190a5388ae74f6c983468c8637de40653816 (origin/develop) Merge remote-tracking branch 'origin/hotfix' into develop 5a0a3d928c59a35e3421d2dc029b0487e24a2772 add HotFix/01.fix 78881870f888c519f21025d22869eb5d38b75030 Merge remote-tracking branch 'origin/myfeature_02' into develop 1c9e156e9b54c6714a6f6e8075b8f6cf316ca7c5 Merge remote-tracking branch 'origin/myfeature_01' into develop b2dc34bc80ce6c9a77a9c399abc7633d09bf9359 Merge branch 'myfeature' into develop 696a92f6e0f77700c1aef37a57abcbc5d69a6673 add TestFile/4.text 5f57182ab7113fdadfa855e4c78237e1a29292b8 Merge branch 'myfeature' into develop 18dd8ba9bb27dc1ff1e414c8538转载说明beb9e904c9032 TestFile/3.test 2124458eef016c34a4d0a0af68dc93166e93ba84 TestFile/2.test 754b56d1c44e49923d679c41839e84e0dfb650d6 add TestFile/1.test 3a8af3c6e7d2852d24b6de6711530cc0ddcc8760 Merge branch 'myfeature' into develop 963672575df191249da5c7f1aaef56afa9cccf2e (origin/feature, feature) add new file 395f4fbd335500cf7c5b51735a27231bea028cd8 (origin/release) Initial commit git tag -a v0.0.1 5a0a3d928c59a35e3421d2dc029b0487e24a2772 git tag -a v0.0.0 -m \"version 0.0.0\" 395f4fbd335500cf7c5b51735a27231bea028cd8 ","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/:1:0","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. Git提交代码的流程 2. git commit –amend 3. git 查看 4. git 修改某次提交 5. 修改提交时间 6. commit 撤回及修改 重写历史 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:0:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"Git提交代码的流程 提交流程 1 2 3 4 git pull --rebase git add . git commit -m\"\" git push origin xxx 1 2 3 git push origin --delete xx # 删除远程分支 git push origin xxx --force # 强制推送到远程分支 git push origin dev-zyh # 推送到指定分支 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:1:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git commit –amend 1 2 3 git commit --amend # 会通过 core.editor 指定的编辑器进行编辑 git commit --amend --no-edit # 不会进入编辑器，直接进行提交 git commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\" ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:2:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git 查看 1 2 3 4 5 6 7 8 9 git log -1 --stat git show 548c72f42f51c22dbf2fdf133426e094c59789e4 --stat git show //最新的commit git show commitId //指定commit git show commitId fileName //指定commit的某个文件 # 查看指定commit id对应修改文件列表 git show --raw git show --raw commit_id ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:3:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git 修改某次提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 commit f2711319a72fa9d3a5486c397c7a10511b970036 (HEAD -\u003e master) Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Mon Aug 24 13:08:12 2020 +0800 update shll sys folder commit 1caaf17d90a3288aff8897fca08e33c81a6b9703 Author: yuhuzhang \u003cyuhuzhang@deepglint.com\u003e Date: Mon Aug 24 12:56:55 2020 +0800 add RunPowerOn.sh commit 8ac823f3e93e82638db5b076952bdcfa12e93cfb Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Fri Aug 21 19:44:06 2020 +0800 add go test file 1 2 3 4 5 6 7 8 git rebase -i 8ac823f3e93e82638db5b076952bdcfa12e93cfb edit b8901f3 add RunPowerOn.sh pick 5593c97 update shll sys folder git cazyh git rebase --continue 1 2 3 4 1.git rebase -i 分支~移动数字 2. 选择对应操作 3.git commit --amend 4.git rebase continue ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:4:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"修改提交时间 1 git commit --amend --date=\"2020-11-28T09:51:07\" --no-edit ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:5:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"commit 撤回及修改 1 2 3 git reset --soft :取消commit git reset --mixed :取消commit ，取消add git reset --hard :取消commit ，取消add，取消源文件修改 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:6:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git 缓存清理（解决ignore不生效问题） .git 文件夹过大 出现原因 删除历史操作 脚本操作 git 缓存清理（解决ignore不生效问题） 明明.ignore文件中标明了忽略，提交时还是有这些文件？ .ignore文件可以按照其注明的规则让git忽略文件，但是有时候，有部分我们不想让git管理的文件已经被git管理了，我们再在.ingore中添加规则，是不能生效的，这时我们清理下git缓存就好 删除git 缓存 1 2 3 git rm -r --cached . git add . git commit -m 'update .gitignore' 下次提交我们就不会看到.ignore中的文件了 .git 文件夹过大 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"出现原因 .git文件主要用来记录每次提交的变动，当我们的项目越来越大的时候， .git文件越来越大。 很大的可能是因为提交了大文件，如果你提交了大文件 A，那么即使你在之后的版本中将其删除，但实际上，记录中的大文件仍然存在。 原因在于虽然你在后面的版本中删除了大文件A，但是Git是有版本倒退功能，那么如果大文件A不记录下来，git拿什么来回退呢？ git给出了解决方案，使用git branch-filter来遍历git history tree, 可以永久删除history中的大文件，达到让.git文件瘦身的目的。 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"删除历史操作 首先找出git中前N大的文件 1 git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}' | sed ':a;N;$!ba;s/\\n/|/g'` 删除文件 遍历所有提交： commit多了会比较慢 1 git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch \u003cfile\u003e' --tag-name-filter cat -- --all 回收内存 1 2 3 4 5 6 7 8 9 10 11 rm -Rf .git/refs/original rm -Rf .git/logs/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now 提交到远程仓库 1 git push --force [remote] master 上述操作最重要的两条命令是 git filter-branch 和 gc, filter-branch 真正在清理，但是只运行它也是没用的，需要再删除备份的文件，重新打包之类的，最后的gc命令，用来收集产生的垃圾，最终清除大文件。 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"脚本操作 编辑脚本文件： git_clean.sh 脚本文件下载：git_clean.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}' | sed ':a;N;$!ba;s/\\n/|/g'` \u003e1.txt for value in `cat 1.txt |awk '{print $2}'` do # echo ${value} git log --pretty=oneline --branches -- ${value} git filter-branch --index-filter \"git rm --cached --ignore-unmatch ${value}\" -- --all rm -Rf .git/refs/original rm -Rf .git/logs/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now done 将脚本文件放置到仓库根目录（与.git 同级） 执行 1 ./git_clean.sh 更新远程仓库 1 git push --force [remote] master ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git/","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git 部分概念 四个工作区域 工作流程 文件的四种状态 git 常用命令 git 安装配置 git 乱码 Git提交代码的流程 git commit –amend git 查看 git diff git diff meld git rm git reset git config git stash git alias git log git fetch / merge /pull git tag git 常用操作 git 修改某次提交 修改提交时间 添加子项目/库 移动代码到另一个仓库保留提交点 全局修改邮箱地址 拉取远程分支强制覆盖本地 常见概念 Pull Request branch 开发/发布/缺陷分离模型 (支持 master/develop/feature/release/hotfix 类型分支) 参考资料 git 部分概念 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:0:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"四个工作区域 Git本地有四个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)、git仓库(Remote Directory)。 Workspace： 工作区，就是你平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:1:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) ","date":"2023-01-15","objectID":"/posts/tools/git/git/:2:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"文件的四种状态 GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用 SHA-1算法计算文件的校验和。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存,文件状态为Modified 新建文件—\u003eUntracked 使用add命令将新建的文件加入到暂存区—\u003eStaged 使用commit命令将暂存区的文件提交到本地仓库—\u003eUnmodified 如果对Unmodified状态的文件进行修改—\u003e modified 如果对Unmodified状态的文件进行remove操作—\u003eUntracked git 常用命令 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:3:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 安装配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 sudo apt-get install git git config --global user.name \"yuhuzhang\" git config --global user.email \"yuhuzhang@deepglint.com\" git config --global user.name \"zhangyuhu\" git config --global user.email \"zhangyuhu@didiglobal.com\" ssh-keygen -C 'yuhuzhang@deepglint.com' -t rsa cat ~/.ssh/id_rsa.pub ssh-keygen -C 'zhangyuhu@didiglobal.com' -t rsa cat ~/.ssh/id_rsa.pub sudo apt install gitk sudo apt-get install git-gui gitk git config --global core.editor vim git config --add core.filemode false # 忽略filemode发生改变 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:4:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 乱码 编辑 .gitconfig 1 2 [gui] encoding = utf-8 1 2 3 git config --global gui.encoding utf-8 图形界面编码 git config --global i18n.commit.encoding utf-8 提交信息编码 git config --global i18n.logoutputencoding utf-8 输出 log 编码 1 2 3 4 5 # \"linux\\347\\263\\273\\347\\273\\237\\347\\256\\241\\347\\220\\206.md\" git config --global core.quotepath false # core.quotepath的作用是控制路径是否编码显示的选项。当路径中的字符大于0x80的时候，如果设置为true，转义显示；设置为false，不转义。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:5:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"Git提交代码的流程 提交流程 1 2 3 4 git pull --rebase git add . git commit -m\"\" git push origin xxx 1 2 3 git push origin --delete xx # 删除远程分支 git push origin xxx --force # 强制推送到远程分支 git push origin dev-zyh # 推送到指定分支 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:6:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git commit –amend 1 2 3 git commit --amend # 会通过 core.editor 指定的编辑器进行编辑 git commit --amend --no-edit # 不会进入编辑器，直接进行提交 git commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:7:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 查看 1 2 3 4 5 git log -1 --stat git show 548c72f42f51c22dbf2fdf133426e094c59789e4 --stat git show //最新的commit git show commitId //指定commit git show commitId fileName //指定commit的某个文件 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:8:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git diff git-diff 1 2 3 4 5 6 7 8 9 10 11 git diff [\u003coptions\u003e] [--] [\u003cpath\u003e…​] —— 工作区与暂存区比较 git diff [\u003coptions\u003e] \u003ccommit\u003e [--] [\u003cpath\u003e…​] —— 工作区与提交比较 git diff [\u003coptions\u003e] --cached [\u003ccommit\u003e] [--][\u003cpath\u003e…​] —— 暂存区与提交比较 git diff [\u003coptions\u003e] \u003ccommit\u003e \u003ccommit\u003e [--] [\u003cpath\u003e…​] —— 提交与提交比较 -U\u003cn\u003e 选项——显示 n 行上下文 --output=\u003cfile\u003e 选项——输出差异文件 --shortstat 选项——仅显示修改文件的总数 --name-only 选项——仅显示已更改文件的名称 --name-status 选项——仅显示已更改文件的名称和状态 -W 选项——显示完整的函数作为上下文 -- \u003cpath\u003e —— 限定比较文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #比较工作空间中的文件和暂存区文件的差异 git diff [files] #比较暂存区的文件与之前已经提交过的文件差异 git diff --cached [files] #比较repo与工作空间中的文件差异 git diff HEAD [files] #查看本地分支和远程差异 git diff origin/master git diff origin/HEAD # git diff [--options] \u003cNew_commit\u003e \u003cOld_commit\u003e # 查看两次提交间文件的变化 # numstat表示以表格的形式展示改动文件，并且文件路径是完整路径 # numstat后面接的是需要对比的两次提交记录的id，前后顺序没有关系 # 第一个\u003ccommit\u003e对应于基本提交, # 第二个\u003ccommit\u003e对应于与基本提交进行比较的提交. # New_commit 相对 Old_commit 变动 git diff --numstat \u003cOld_commit\u003e \u003cNew_commit\u003e # 统计两个版本之间的改动文件 git diff --shortstat \u003cOld_commit\u003e \u003cNew_commit\u003e # 会展示改动文件的路径并统计改动文件个数，但是路径太长时会省略一部分路径 git diff --stat \u003cOld_commit\u003e \u003cNew_commit\u003e # 查看指定文件两次提交之间的变动 git diff \u003cOld_commit\u003e \u003cNew_commit\u003e \u003cFile_path\u003e ","date":"2023-01-15","objectID":"/posts/tools/git/git/:9:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git diff meld 1 2 3 4 5 sudo apt-get install meld git config --global diff.tool meld git difftool master..devel git difftool dev-adas-730 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:10:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git rm 1 2 3 4 5 #当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用（⚠️） git rm file_path #当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 这个时候直接push那边这个文件就没有，如果push之前重新add那么还是会有。 git rm --cached file_path ","date":"2023-01-15","objectID":"/posts/tools/git/git/:11:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git reset 1 2 3 4 5 6 7 #如果出现:将不必要的文件commit 或者 上次提交觉得是错的 或者 不想改变暂存区内容，只是想调整提交的信息 #移除不必要的添加到暂存区的文件 git reset HEAD 文件名 #去掉上一次的提交（会直接变成add之前状态） git reset HEAD^ #去掉上一次的提交（变成add之后，commit之前状态） git reset --soft HEAD^ ","date":"2023-01-15","objectID":"/posts/tools/git/git/:12:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git config git config config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 查看系统config git config --system --list # 查看当前用户（global）配置 git config --global --list # 查看当前仓库配置信息 git config -- local --list # 显示当前的Git配置 git config --list # 编辑Git配置文件 git config -e [--global] ","date":"2023-01-15","objectID":"/posts/tools/git/git/:13:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git stash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 git stash git stash save 'message...'可以添加一些注释 git stash list git stash pop [–index] [stash_id] git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。 git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区） git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 通过git stash pop命令恢复进度后，会删除当前进度。 git stash apply [–index] [stash_id] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。 git stash clear 删除所有存储的进度。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:14:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git alias 配置别名 1 2 3 4 5 locate .gitconfig cd xx cat .gitconfig git config --global alias.cazyh 'commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\"' ","date":"2023-01-15","objectID":"/posts/tools/git/git/:15:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git log 1 2 3 git log --graph git config --global alias.lg \"log --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit --date=relative\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:16:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git fetch / merge /pull git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。 1 2 3 4 5 6 # 从远程的origin仓库的master主分支更新最新的版本到origin/master分支上 git fetch origin master # 比较本地的master分支和origin/master分支的差别 git log -p master..origin/master # 合并内容到本地master分支 git merge origin/master 尽量少用git pull，多用git fetch和merge ","date":"2023-01-15","objectID":"/posts/tools/git/git/:17:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git tag # 列出已有的标签 git tag -l \"v0.1\" # 过滤列出已有的标签 git tag -a v1.4 -m \"my version 1.4\" # 创建标签 git show v1.4 # 查看标签信息和与之对应的提交信息 git tag -d v1.4 # 删除标签 git push origin :refs/tags/v1.4 # 删除远程标签 git push origin --delete v1.4 # 删除远程标签 git checkout v1.4 # 切换到 v1.4 tag git checkout -b version_v1.4 v1.4 # 切换到 v1.4 tag version_v1.4 git push origin v1.4 # 传送标签到远程仓库服务器 git push origin --tags # 把所有不在远程仓库服务器上的标签全部传送到远程仓库服务器 后期打标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git log --pretty=oneline dd1db2ddf7ab23a57b0197abe80167ba4847f185 (HEAD -\u003e master, tag: v0.0.2, origin/master, origin/HEAD) Merge branch 'release-0.0.2' 1967f19f3d2f7b13d18f80dada14da1b8385ecc3 (release-0.0.2) version update :v0.0.2 28b3ff52ea28221314264482d6db6fb7349cf2f8 (develop) Merge branch 'release-0.0.1' into develop e2d4b5d8eb8407d7141c9846c4459cd1733922fb (release-0.0.1) version update :v0.0.1 2c6ffbce9ffd31e4cee8ca5013924324b49ec898 add bump-version.sh 9c29190a5388ae74f6c983468c8637de40653816 (origin/develop) Merge remote-tracking branch 'origin/hotfix' into develop 5a0a3d928c59a35e3421d2dc029b0487e24a2772 add HotFix/01.fix 78881870f888c519f21025d22869eb5d38b75030 Merge remote-tracking branch 'origin/myfeature_02' into develop 1c9e156e9b54c6714a6f6e8075b8f6cf316ca7c5 Merge remote-tracking branch 'origin/myfeature_01' into develop b2dc34bc80ce6c9a77a9c399abc7633d09bf9359 Merge branch 'myfeature' into develop 696a92f6e0f77700c1aef37a57abcbc5d69a6673 add TestFile/4.text 5f57182ab7113fdadfa855e4c78237e1a29292b8 Merge branch 'myfeature' into develop 18dd8ba9bb27dc1ff1e414c8538转载说明beb9e904c9032 TestFile/3.test 2124458eef016c34a4d0a0af68dc93166e93ba84 TestFile/2.test 754b56d1c44e49923d679c41839e84e0dfb650d6 add TestFile/1.test 3a8af3c6e7d2852d24b6de6711530cc0ddcc8760 Merge branch 'myfeature' into develop 963672575df191249da5c7f1aaef56afa9cccf2e (origin/feature, feature) add new file 395f4fbd335500cf7c5b51735a27231bea028cd8 (origin/release) Initial commit git tag -a v0.0.1 5a0a3d928c59a35e3421d2dc029b0487e24a2772 git tag -a v0.0.0 -m \"version 0.0.0\" 395f4fbd335500cf7c5b51735a27231bea028cd8 git 常用操作 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:18:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git clone 指定端口 在使用 git clone 命令时，默认情况下它使用的是 Git 协议（也称为 SSH）或 HTTP/HTTPS 协议的默认端口（22 或 443）。如果需要通过其他端口进行克隆，请按照下面的步骤进行操作。 使用 SSH 协议和指定的端口进行克隆： 1 shellCopy Code$ git clone ssh://\u003cusername\u003e@\u003chostname\u003e:\u003cport\u003e/\u003crepository_path\u003e 将 \u003cusername\u003e 替换为你的用户名，\u003chostname\u003e 替换为主机名或 IP 地址，\u003cport\u003e 替换为指定的端口号，\u003crepository_path\u003e 替换为要克隆的仓库路径。 使用 HTTPS 协议和指定的端口进行克隆： 1 shellCopy Code$ git clone https://\u003cusername\u003e@\u003chostname\u003e:\u003cport\u003e/\u003crepository_path\u003e 将 \u003cusername\u003e 替换为你的用户名，\u003chostname\u003e 替换为主机名或 IP 地址，\u003cport\u003e 替换为指定的端口号，\u003crepository_path\u003e 替换为要克隆的仓库路径。 请确保有适当的访问权限，并替换命令中的占位符以符合你的实际情况。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:19:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 修改某次提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 commit f2711319a72fa9d3a5486c397c7a10511b970036 (HEAD -\u003e master) Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Mon Aug 24 13:08:12 2020 +0800 update shll sys folder commit 1caaf17d90a3288aff8897fca08e33c81a6b9703 Author: yuhuzhang \u003cyuhuzhang@deepglint.com\u003e Date: Mon Aug 24 12:56:55 2020 +0800 add RunPowerOn.sh commit 8ac823f3e93e82638db5b076952bdcfa12e93cfb Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Fri Aug 21 19:44:06 2020 +0800 add go test file 1 2 3 4 5 6 7 8 git rebase -i 8ac823f3e93e82638db5b076952bdcfa12e93cfb edit b8901f3 add RunPowerOn.sh pick 5593c97 update shll sys folder git cazyh git rebase --continue 1 2 3 4 1.git rebase -i 分支~移动数字 2. 选择对应操作 3.git commit --amend 4.git rebase continue ","date":"2023-01-15","objectID":"/posts/tools/git/git/:20:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"修改提交时间 1 git commit --amend --date=\"2020-11-28T09:51:07\" --no-edit ","date":"2023-01-15","objectID":"/posts/tools/git/git/:21:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"添加子项目/库 git submodule add 仓库地址 路径 仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 1 git submodule add -f https://gitee.com/fromyuhu/helloword ","date":"2023-01-15","objectID":"/posts/tools/git/git/:22:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"移动代码到另一个仓库保留提交点 查看当前分支远程状态 1 2 3 git remote # 列出已经存在的远程分支 git remote -v # 列出已经存在的远程分支 在每一个名字后面列出其远程url git remote show origin # 查看远程仓库，以及与本地仓库的关系 添加远程仓库 1 2 git remote add \u003cshortname\u003e \u003curl\u003e #添加一个新的远程 Git 仓库，同时指定一个方便使用的简写 git remote add origin_repo_b git@server_ip:/path/repo_b.git 推送代码到指定远程 1 2 3 git push origin_repo_b branch_a # origin_repo_b:远程 仓库repo_b的名字 # branch_a: 仓库repo_a的branch_a分支 克隆仓库repo_b，或者使用页面，检查是否push成功 1 git clone git@server_ip:/path/repo_b.git 远程仓库的重命名与移除 1 2 3 git remote rename origin_repo_b zyh_origin # 修改一个远程仓库的简写名 git remote remove origin_repo_b # 移除一个远程仓库 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:23:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"全局修改邮箱地址 另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 –commit-filter： 1 2 3 4 5 6 7 8 9 $ git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"yuhuzhang@deepglint.com\" ]; then GIT_AUTHOR_NAME=\"zhangyuhu\"; GIT_AUTHOR_EMAIL=\"zhangyuhude@163.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_NAME\" = \"yuhuzhang\" ]; then GIT_AUTHOR_NAME=\"zhangyuhu\"; GIT_AUTHOR_EMAIL=\"zhangyuhude@163.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"zhangyuhude@163.com\" ]; then GIT_AUTHOR_NAME=\"yuhuzhang\"; GIT_AUTHOR_EMAIL=\"yuhuzhang@deepglint.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:24:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"拉取远程分支强制覆盖本地 1 2 3 git fetch --all git reset --hard master git pull #可省略 1 git fetch --all \u0026\u0026 git reset --hard master \u0026\u0026 git pull 常见概念 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:25:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"Pull Request 有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了。 当你想更正别人仓库里的bug 或者增加 feature 时，要走一个流程： 先 fork 别人的仓库，相当于拷贝一份，不会有人直接让你改修原仓库的 clone 到本地分支，做一些 bug fix 或者 feature 开发 发起 pull request 给原仓库，让他看到你修改的 bug 原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中 至此，整个 pull request 的过程就结束了。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:26:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"branch 分支（branches）是用来标记特定的代码提交，每一个分支通过SHA1sum值来标识，所以对分支进行的操作是轻量级的——你改变的仅仅是SHA1sum值。所以为什么git提倡大家多使用分支，因为它即轻量级又灵活。 本地分支(local branches) 1 git branch 远程分支(remote branches) 1 git branch -r 分支在本地存储 .git/refs/head/[本地分支] .git/refs/remotes/[正在跟踪的分支] ","date":"2023-01-15","objectID":"/posts/tools/git/git/:27:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"开发/发布/缺陷分离模型 (支持 master/develop/feature/release/hotfix 类型分支) 介绍一个成功的 Git 分支模型(master - hotfix - develop - feature - release) 参考资料 gitbook 1 2 btime = !\"for k in `git branch|perl -pe s/^..//`;do echo `git show --pretty=format:\\\"%Cgreen%ci %Cblue%cr%Creset\\\" $k|head -n 1`\\\\\\t$k;done|sort\" brtime = !\"for k in `git branch -r|perl -pe s/^..//`;do echo `git show --pretty=format:\\\"%Cgreen%ci %Cblue%cr%Creset\\\" $k|head -n 1`\\\\\\t$k;done|sort\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:28:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"mac电脑常用配置","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":" 终端 homebrew git 配置 OS 升级后 id_rsa 不可用（需要输入密码） mac快捷键 通用 Mac系统设置git命令自动补全 mac 使用 zsh ZSH oh-my-zsh zsh-syntax-highlighting 终端 iterm2 homebrew 一、brew 安装脚本 （自动选择软件源） 1 /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" 二、brew 卸载脚本 1 /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)\" 三、常用命令 安装软件：brew install xxx 卸载软件：brew uninstall xxx 搜索软件：brew search xxx 更新软件：brew upgrade xxx 查看列表：brew list 更新brew：brew update 清理所有包的旧版本：brew cleanup 清理指定包的旧版本：brew cleanup $FORMULA 查看可清理的旧版本包，不执行实际操作：brew cleanup -n ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:0:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"brew 替换源 1 /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" git ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:1:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"配置 1 2 3 4 git config --global user.name \"zhangyuhu\" git config --global user.email \"zhangyuhu@didiglobal.com\" ssh-keygen -C 'zhangyuhu@didiglobal.com' -t rsa cat ~/.ssh/id_rsa.pub ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:2:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"OS 升级后 id_rsa 不可用（需要输入密码） 苹果mac升级系统后，默认不支持rsa方式加密git通讯，所以如果要继续使用这个pub文件加密的方式，则要手动添加cofig配置文件来支持，需要在 ~/.ssh/config文件中新增如下内容： 1 2 3 Host * PubkeyAcceptedKeyTypes +ssh-rsa HostKeyAlgorithms +ssh-rsa mac快捷键 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:3:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"通用 Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。 所以以下最基本操作很好理解： Command + Z 撤销 Command + X 剪切 Command + C 拷贝（Copy） Command + V 粘贴 Command + A 全选（All） Command + S 保存（Save) Command + F 查找（Find） Mac系统设置git命令自动补全 brew install bash-completion brew info bash-completion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DIDI-FVFDH0A8P3Y1:bash_completion.d didi$ brew info bash-completion bash-completion: stable 1.3 (bottled) Programmable completion for Bash 3.2 https://salsa.debian.org/debian/bash-completion Conflicts with: bash-completion@2 (because each are different versions of the same formula) /usr/local/Cellar/bash-completion/1.3_3 (189 files, 608.3KB) * Poured from bottle on 2021-09-15 at 00:40:57 From: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git/Formula/bash-completion.rb ==\u003e Caveats Add the following line to your ~/.bash_profile: [[ -r \"/usr/local/etc/profile.d/bash_completion.sh\" ]] \u0026\u0026 . \"/usr/local/etc/profile.d/bash_completion.sh\" Bash completion has been installed to: /usr/local/etc/bash_completion.d ==\u003e Analytics install: 8,329 (30 days), 25,293 (90 days), 111,168 (365 days) install-on-request: 7,394 (30 days), 22,291 (90 days), 98,980 (365 days) build-error: 0 (30 days) git –version 1 git version 2.30.1 (Apple Git-130) 1 curl https://raw.githubusercontent.com/git/git/v2.30.1/contrib/completion/git-completion.bash -o /usr/local/etc/bash_completion.d/git-completion.bash brew unlink bash-completion brew link bash-completion mac 使用 zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:4:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"ZSH 查看安装的 shell 1 2 3 4 5 6 7 8 cat /etc/shells /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 使用 brew 更新 zsh 1 2 3 4 5 6 brew install zsh ==\u003e Downloading https://homebrew.bintray.com/bottles/zsh-5.5.1.high_sierra.bottle.tar.gz ######################################################################## 100.0% ==\u003e Pouring zsh-5.5.1.high_sierra.bottle.tar.gz /usr/local/Cellar/zsh/5.5.1: 1,444 files, 12MB 切换为 zsh 1 chsh -s /bin/zsh 重启终端即可使用 zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:5:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"oh-my-zsh 下载安装脚本 1 sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 配置主题 1 2 ZSH_THEME=\"bira\" source ~/.zshrc 插件 自动补全插件 1 2 3 4 mkdir ~/.oh-my-zsh/custom/plugins/incr cd ~/.oh-my-zsh/custom/plugins/incr wget -O incr.plugin.zsh http://mimosa-pudica.net/src/incr-0.2.zsh # wget -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh http://mimosa-pudica.net/src/incr-0.2.zsh incr 下载后，还需要在 ~/.zshrc 中添加： 1 2 3 4 5 plugins=( zsh-autosuggestions git incr ) 在 ~/.zshrc 文件末尾添加： 1 source ~/.oh-my-zsh/custom/plugins/incr/incr*.zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:6:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"zsh-syntax-highlighting 官网 作用 平常用的ls、cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。 安装 克隆项目 1 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中配置 1 plugins=(其他的插件 zsh-syntax-highlighting) 使配置生效 1 source ~/.zshrc 常用插件： zsh oh-my-zsh 插件推荐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 autoload -Uz vcs_info precmd() { vcs_info } zstyle ':vcs_info:git:*' formats '%b' zstyle ':vcs_info:*' enable git # 定义颜色和样式的转义序列 red_bold=\"\\e[1;31m\" reset=\"\\e[0m\" setopt prompt_subst PROMPT='$(tput setaf 3)%* $(tput sgr0)$(tput setaf 2)%n@%m$(tput sgr0):$(tput bold)$(tput setaf 4)%2~$(tput sgr0)$(if [[ -n \"${vcs_info_msg_0_}\" ]]; then echo \"${red_bold}(${vcs_info_msg_0_})${reset}\"; fi) %# $(tput sgr0)' ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:7:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"Markdown","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 MD 语法示例 代码插入行数 高亮 表格 删除线 图片居中 MD 语法示例 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:0:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"代码插入行数 1 2 //11 //22 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:1:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"高亮 高亮 高亮 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:2:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"表格 项目 价格 Computer $1600 Phone $12 Pipe 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:3:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"删除线 我是删除线 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:4:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"图片居中 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:5:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"minicom","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 Minicoms使用 安装 相关配置 更多 Ctrl+A 自动保存log 退出软件 其他问题 配置串口权限 方式一：使用命令更改 方式二：配置udev规则(推荐) 配置默认文件 使用自动脚本 简介 minicom是一个串口通信工具，就像Windows下的超级终端。可用来与串口设备通信，如调试交换机和Modem等。 Minicoms使用 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:0:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"安装 1 sudo apt-get install minicom ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:1:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"相关配置 使用前需要进行配置，执行 1 sudo minicom -s 可打开minicom并进入配置模式，使用方向键，选择需要配置的项目，如 Serial port setup ，回车进入配置，可以看到多个配置项，此时光标在最下方。 需要修改某个配置，则输入对应的字母，光标即会跳转到对应的项，编辑后，回车确认，光标再次回到最下方。 一般而言，需要修改 1 2 3 A - Serial Device # A配置项，指定USB设备。一般USB转串口会生成设备/dev/ttyUSBx，x是数字序号。 E - Bps/Par/Bits # E配置项，根据实际情况，指定波特率等参数 F - Hardware Flow Control # F配置项，硬件流控，要看你的设备是否有。如果没有，或者你不确定的话，可以先关掉，将默认的Yes切换为No. 修改好之后，回车退到上一个界面，此时记得往下，选择 Save setup as dfl 将刚刚的修改保存为默认配置，避免下次使用还需要再次配置。 最后，选择 Exit 会退出配置界面，并打开minicom软件才会使用上述参数进行初始化。选择 Exit from Minicom 则会直接退出minicom。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:2:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"更多 可以使用 minicom -h 查看，也可在mincon中，按 Ctrl+A 再按 Z 查看。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"Ctrl+A Ctrl+A 是mimicom的特殊功能前缀按键，但还有另一个很实用的作用，就是暂停屏幕输出。在设备开始大量输出log时，基本看不清屏幕内容。此时可以按 Ctrl+A，暂停输出，方便查看所需log。 Ctrl+A 进入特殊功能： 按Z进入设置菜单 按 O键：打开配置选项 按 W键：自动卷屏。当显示的内容超过一行之後，自动将後面的内容换行。这个功能在查看内核的啓动信息时很有用 按 C键：清除屏幕的显示内容 按 B键：浏览minicom的历史显示 按 X键：退出minicom，会提示确认退出 按 N键：可激活时间戳，在每行log前添加当前系统的时间戳 按 S键：可向设备端发送文件 按 R键：可接收文件 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:1","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"自动保存log 让 minicom 自动保存log，可以方便调试。 查看参数，minicom可以使用 -C 参数指定保存log文件。于是完善脚本，自动把log以日期命名，保存到/tmp目录下。tmp目录关机即清空，如果想持久保存log，需要修改到其他目录。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:2","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"退出软件 minicom使用前缀按键 Ctrl-A，即执行特殊操作时，都需要先按 Ctrl+A，再按某个按键使用对应的功能。 Ctrl+A，再按 Z， 可查看帮助，从帮助可以看到，退出时，要先按 Ctrl+A，再按 X 其他问题 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:4:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"配置串口权限 minicom 本身不需要sudo权限，但因为要打开串口设备/dev/xxx ，所以一般会需要使用sudo来启动minicom。 这里我们可以修改下串口设备的权限，这样以后就不用使用sudo了。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"方式一：使用命令更改 简单粗暴地使用chmod命令修改 1 sudo chmod 666 /dev/ttyUSB0 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:1","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"方式二：配置udev规则(推荐) 修改配置文件 1 sudo vim /etc/udev/rules.d/70-ttyusb.rules 增加一行 1 KERNEL==\"ttyUSB[0-9]*\", MODE=\"0666\" 修改后，需要重新插拔设备，以重新生成设备节点。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:2","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"配置默认文件 在/etc/minicom/目录下是minicom的配置文件 增加配置文件如下： 1 sudo vi /etc/minicom/minirc.ttyUSB0 1 2 3 4 5 6 7 8 pr port /dev/ttyUSB0 pu baudrate 115200 pu bits 8 pu parity N pu stopbits 1 pu minit pu mreset pu rtscts No 执行 1 minicom ttyUSB0 加载默认配置文件 使用自动脚本 参考：EasierMinicom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 com() { local ports_USB ports_ACM ports datename dev devs dev_count ports_USB=$(ls /dev/ttyUSB* 2\u003enull | xargs -I {} basename {}) ports_ACM=$(ls /dev/ttyACM* 2\u003enull | xargs -I {} basename {}) ports=\"$ports_USB $ports_ACM\" #check lock devs=\"\" dev_count=0 for dev in ${ports}; do ! ls /run/lock/*\"${dev}\"* \u0026\u003e/dev/null \u0026\u0026 { devs+=\"${dev} \" ((dev_count++)) } done [ -z \"$devs\" ] \u0026\u0026 echo \"No Unlock Devices\" \u0026\u0026 return 0 datename=$(date +%Y%m%d-%H%M%S) if [ $dev_count -eq 1 ]; then dev=$devs else #select dev to open echo \"Please select one device: (Ctrl+C to abort)\" select dev in $devs; do if [ \"$dev\" ]; then echo \"You select the '$dev'\" break else echo \"Invaild selection\" fi done fi out=\"/tmp/$(basename ${dev}).$datename.log\" keep_dir=\"${HOME}/minicom_keep\" minicom $dev -C \"${out}\" \"$@\" [ -f \"${out}\" ] \u0026\u0026 { echo log : \"${out}\" read -p \"Keep it? [y|N]: \" keep [ \"${keep}\" = 'Y' -o \"${keep}\" = 'y' ] \u0026\u0026 { read -p \"Enter file name \u003e \" keep_file_name [ x\"$keep_file_name\" = x\"\" ] \u0026\u0026 keep_file_name=$(basename \"${out}\") mkdir -p \"$keep_dir\" cp \"${out}\" \"${keep_dir}/$keep_file_name\" echo \"saved in $keep_dir/$keep_file_name\" } } read -p \"Vim it? [y|N]: \" edit_vim [ \"${edit_vim}\" = 'Y' -o \"${edit_vim}\" = 'y' ] \u0026\u0026 vim \"${out}\" } 自动检测未锁定的设备，如果有多个则列出给用户选择，如果只有一个则直接使用。 默人加载 /etc/minicom/minirc.${dev} 的配置文件 自动保存log到/tmp目录，退出时，询问是否要保存到另外的目录。 使用 1 2 3 echo \"source $(pwd)/EasierMinicom.sh\" \u003e\u003e ~/.bashrc source ~/.bashrc com ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:6:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"NFS","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 什么是NFS Network File System SUN RPC 基本原理 NFS过程 NFS客户端和NFS服务端通讯过程 NFS服务的优缺点 Ubuntu主机的NFS共享文件夹 nfs server 安装 nfs client 安装 /etc/exports 参数 mount 参数 什么是NFS ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:0:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"Network File System 网络文件系统（英语：Network File System，缩写作 NFS）是一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样，它由Sun微系统（已被甲骨文公司收购）开发，于1984年发布。 它基于开放网络运算远程过程调用（ONC RPC）系统：一个开放、标准的RFC系统，任何人或组织都可以依据标准实现它。 开放网络运算远程过程调用（英语：Open Network Computing Remote Procedure Call，缩写为ONC RPC），一种被广泛应用的远程过程调用（RPC）系统，是一种属于应用层的协议堆栈，底层为TCP/IP协议。开放网络运算（ONC）最早源自于Sun微系统（Sun），是网络文件系统计划的一部分，因此它经常也被称为Sun ONC 或 Sun RPC。现今在多数类UNIX系统上都实现了这套系统，微软公司也以Windows Services for UNIX在他们产品上提供ONC RPC的支持。2009年，Sun微系统以标准三条款的BSD许可证发布这套系统。2010年，收购了Sun微系统的甲骨文公司确认了这套软件BSD许可证的有效性与适用范围。 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:1:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"SUN RPC 基本原理 客户端触发调用远程过程，实际上是选取了对应RPC程序封装的函 数，并将相关参数（包括远程方法名，方法参数等）封装成IP数据包，发送给服务器 服务器进程接收到此数据包后，提取参数，执行相应方法过程 服务器方法过程返回后，将返回结果封装成IP数据包，发送给客户端 客户端进程，收取到数据包后，提取返回结果 RPC程序包提供了数据报文封装和传递，保证异构环境下的可用性，客户端和服务器端应用程序设计时不需要考虑系统差异带来的数据格式，编码解码等问题，提供了很大方便。 客户程序和服务程序更多的职责是在于去定义描述具体远程过程及其触发，并将其注册绑定到RPC程序包中。 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:2:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"NFS过程 NFS客户可以是一个用户进程，对服务器进行显式调用。而服务器也可以是一个用户进程 — 因为两个理由，NFS一般不这样实现。 首先，访问一个NFS文件必须对客户透明。因此，NFS的客户调用是由客户操作系统代表用户进程来完成的。第二，出于效率的考虑， N F S服务器在服务器操作系统中实现。如果NFS服务器是一个用户进程，每个客户请求和服务器应答（包括读和写的数据）将不得不在内核和用户进程之间进行切换，这个代价太大。 一个客户对一个NFS服务器的访问开始于安装协议，返回给客户一个文件句柄。客户接着可以使用那个文件句柄来访问服务器文件系统中的文件。在服务器上，一次检查文件名的一个成员，返回每个成员的一个新的文件句柄。最后的结果就是要引用的文件的一个文件句柄，它可以在随后的读写操作中被使用。 初始时，文件系统协议安装，客户端需知道服务端的文件系统，后续的交互处理都是基于这一文件系统 客户端与服务端之间通过文件句柄来表示所访问文件，客户端每打开一个文件，就会获得服务端的一个文件句柄（可理解成文件描述符ID） 可能触发的远程过程（下面这些并非都会存在）： GETATTR。返回一个文件的属性：文件类型（一般文件，目录等）、访问权限、文件 大小、文件的属主者及上次访问时间等信息。 SETATTR。设置一个文件的属性。只允许设置文件属性的一个子集： 访问权限、文件的属主、组的属主、文件大小、上次访问时间和上次修改时间。 STATFS。返回一个文件系统的状态：可用空间的大小、最佳传送大小等。例如 U n i x的 d f命令使用此过程。 LOOKUP。查找一个文件。每当一个用户进程打开一个 N F S服务器上的一个文件时， N F S客户调用此过程。 READ。从一个文件中读数据。客户说明文件的句柄、读操作的开始位置和读数据的 最大字节数（最多8192个字节）。 WRITE。对一个文件进行写操作。客户说明文件的句柄、开始位置、写数据的字节数 和要写的数据。 CREATE。创建一个文件。 REMOVE。删除一个文件。 RENAME。重命名一个文件。 LINK。为一个文件构造一个硬链接。硬链接是一个 U n i x的概念，指的是磁盘中的一 个文件可以有任意多个目录项（即名字，也叫作硬链接）指向它。 SYMLINK。为一个文件创建一个符号链接。符号链接是一个包含另一个文件名字的 文MKDIR。创建一个目录。 RMDIR。删除一个目录。 READDIR。读一个目录。例如 Un ix的l s命令使用此过程 比如在windows上用记事本打开共享目录下的某一文本文件，会产生的过程有GETATTR来确认访问权限，LOOKUP确认文件存在，READ返回文件内容（当然实际windows上操作时，GETATTR和LOOKUP在打开共享目录的时候已经完成）件。大多数引用符号链接的操作（例如，打开）实际上引用的是符号链接所指的文件。 READLINK。读一个符号链接。即返回符号链接所指的文件的名字。 MKDIR。创建一个目录。 RMDIR。删除一个目录。 READDIR。读一个目录。例如 Un ix的l s命令使用此过程 比如在windows上用记事本打开共享目录下的某一文本文件，会产生的过程有GETATTR来确认访问权限，LOOKUP确认文件存在，READ返回文件内容（当然实际windows上操作时，GETATTR和LOOKUP在打开共享目录的时候已经完成） ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:3:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"NFS客户端和NFS服务端通讯过程 首先服务器端启动RPC服务，并开启111端口 服务器端启动NFS服务，并向RPC注册端口信息 客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口 服务端的RPC(portmap)服务反馈NFS端口信息给客户端 客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输 NFS服务的优缺点 优点 ： 节省本地存储空间，将常用的数据存放在一台服务器可以通过网络访问该数据 简单容易上手 方便部署非常快速，维护十分简单 缺点 ： 局限性容易发生单点故障，服务器机宕机的话所有客户端都不能访问 在高并发情况下下NFS效率/性能有限 客户端没用用户认证机制，且数据是通过明文传送，安全性一般（一般建议在局域网内使用） NFS的数据是明文的，对数据完整性不做验证 多台机器挂载NFS服务器时，连接管理维护麻烦 Ubuntu主机的NFS共享文件夹 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:4:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"nfs server 安装 1 2 3 4 5 6 # 安装server apt-get install nfs-common nfs-kernel-server # 创建配置文件 vi /etc/exports sudo gedit /etc/exports 配置文件内容 1 2 # home /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) 启动nfs server 1 2 3 4 5 # 启动 sudo service nfs-kernel-server restart # 查看共享目录 showmount -e 设置启动 nfs server 别名 1 2 3 alias nfsstart='sudo service nfs-kernel-server restart' vi ~/.bashrc source ~/.bashr ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:5:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"nfs client 安装 安装 1 2 3 4 5 6 7 # nfs client安装 sudo apt-get install nfs-common # 查看nfs server上共享的目录 showmount -e \u003cip address of nfs server\u003e showmount -e 10.42.0.1 创建挂载点 1 2 3 4 5 mkdir /path-to-mount chmod 777 -R /path-to-mount mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount sudo mount -t nfs -o nolock,rw,rsize=32768,wsize=32768 10.42.0.1:/home/didi/work/Dedge /home/zyh/dedge 开机自动挂载： 1 2 3 4 # 将 mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount # 添加到 /etc/rc.local /etc/rc.local ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:6:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"/etc/exports 参数 1 2 3 4 /path-to-share *(rw,sync,no_subtree_check,no_root_squash) # path-to-share是要共享的目录，根据自己情况修改,*表示允许所有的网段访问，也可以使用具体的IP /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) 参数 说明 ro 只读访问 rw 读写访问 sync 所有数据在请求时写入共享 async nfs 在写入数据前可以响应请求 secure nfs 通过 1024 以下的安全 TCP/IP 端口发送 insecure nfs 通过 1024 以上的端口发送 wdelay 如果多个用户要写入 nfs 目录，则归组写入（默认） no_wdelay 如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置 hide 在 nfs 共享目录中不共享其子目录 no_hide 共享 nfs 目录的子目录 subtree_check 如果共享 /usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认） no_subtree_check 不检查父目录权限 all_squash 共享文件的 UID 和 GID 映射匿名用户 anonymous，适合公用目录 no_all_squash 保留共享文件的 UID 和 GID（默认） root_squash root 用户的所有请求映射成如 anonymous 用户一样的权限（默认）客户机用root访问该共享文件夹时，不映射root用户。（root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户） no_root_squash root 用户具有根目录的完全管理访问权限 anonuid=xxx 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 UID anongid=xxx 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 GID ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:7:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"mount 参数 1 Mount -t nfs -o rw,hard,nointr,tcp,noac,vers=3,timeo=600,rsize=32768,wsize=32768 192.168.100.189:/mnt/DG/WORK/2_code/3_T4/aiva /home/firefly/zyh/aiva 指定参数具体含义如下： 参数 说明 rw 以读写方式安装文件系统（也必须要以相同的方式来导出） ro 以只读方式安装文件系统 bg 如果安装失败（服务器没有响应），在后台一直尝试，继续发其它的安装请求 hard 以硬方式安装文件系统(这是默认情况)。如果服务器当机，让试图访问它的操作被阻塞，直到服务器恢复为止 soft 以软方式安装文件系统。如果服务器当机，让试图访问它的操作失败，返回一条出错消息。这项功能对于避免进程“挂”在无关紧要的安装操作上来说非常有用 intr 允许用户中断被阻塞的操作（并且让它们返回一条出错消息） nointr 不允许用户中断 retrans=n 指定在以软方式安装的文件系统上，在返回一条出错消息之前重复发出请求的次数 timeo=n 设置请求的超时时间（以十分之一秒为单位） rsize=n 设置读缓冲的大小为n字节。对TCP和UDP安装都适用，但最优值不一样（32K较好） wsize=n 设置写缓冲的大小为n字节。对TCP和UDP安装都适 nfsvers=n 设置NFS协议的版本 2 或者 3 （在正常情况下是自动的） tcp 选择通过TCP来传输。默认选择UDP fg 和bg正好相反，是默认的参数 mountport 设定mount的端口[@more@] ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:8:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"tmux的使用","date":"2023-01-15","objectID":"/posts/tools/tmux/tmux/","tags":["tmux"],"title":"tool:tmux的使用","uri":"/posts/tools/tmux/tmux/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 tmux 自定义快捷操作 参考 tmux 自定义快捷操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 1 新建会话 alias tnew=\"tmux new -s \" # 2 分离会话(ctrl+b d) alias tdetach=\"tmux detach\" # 3 列出会话(ctrl+b s) alias tlist=\"tmux ls\" # 4 接入会话 alias tattach=\"tmux attach -t \" # 5 杀死指定会话 alias tkill=\"tmux kill-session -t \" # 6 杀死全部会话 alias tkillall=\"tmux kill-server\" # 7 切换会话 alias tswitch=\"tmux switch -t \" # 8 重命名会话(ctrl+b $) alias trename=\"tmux rename-session -t \" # 9 窗口上下划分窗格 alias tsplitud=\"tmux split-window\" # 10 窗口左右划分窗格 alias tsplitlr=\"tmux split-window -h\" # 11 光标到上方窗格 alias tmoveu=\"tmux select-pane -U\" # 12 光标到下方窗格 alias tmoved=\"tmux select-pane -D\" # 13 光标到上方窗格 alias tmovel=\"tmux select-pane -L\" # 14 光标到上方窗格 alias tmover=\"tmux select-pane -R\" # 15 交换窗格位置(当前窗格上移) alias tswapu=\"tmux swap-pane -U\" # 16 交换窗格位置(当前窗格下移) alias tswapd=\"tmux swap-pane -D\" 参考 Tmux 使用教程 ","date":"2023-01-15","objectID":"/posts/tools/tmux/tmux/:0:0","tags":["tmux"],"title":"tool:tmux的使用","uri":"/posts/tools/tmux/tmux/"},{"categories":["tools"],"content":"software install","date":"2023-01-15","objectID":"/posts/tools/sw/install/","tags":["software"],"title":"tool:ubuntu 常用软件安装","uri":"/posts/tools/sw/install/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 cmake 升级 readline GCC 升级及切换 cmake 升级 1 2 3 4 5 6 7 8 9 10 apt remove cmake cd /usr/src wget https://github.com/Kitware/CMake/releases/download/v3.16.0/cmake-3.16.0.tar.gz tar -zxvf cmake-3.16.0.tar.gz cd cmake-3.16.0 apt install libssl-dev build-essential ./bootstrap \u0026\u0026 make \u0026\u0026 sudo make install cmake --version readline 1 2 3 4 5 6 7 8 9 10 11 wget -c ftp://ftp.gnu.org/gnu/readline/readline-6.2.tar.gz tar -zxvf readline-6.2.tar.gz cd readline-6.2 ./configure //这个地方一定要指定路径,要不然要报错(一般在/usr/local下用软件命名,比如 /usr/local/readline下) make \u0026\u0026 make installl ldconfig GCC 升级及切换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 安装 sudo add-apt-repository -y ppa:ubuntu-toolchain-r/test sudo apt install -y gcc-11 sudo apt install -y g++-11 g++-11 -v # 切换 # 10，20这些表示的是优先级，可根据需要选定，优先级高的即为默认的。 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 20 --slave /usr/bin/g++ g++ /usr/bin/g++-9 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 10 --slave /usr/bin/g++ g++ /usr/bin/g++-11 # 然后执行，并且输入数字来选择gcc版本 sudo update-alternatives --config gcc # 查看版本 gcc -v ","date":"2023-01-15","objectID":"/posts/tools/sw/install/:0:0","tags":["software"],"title":"tool:ubuntu 常用软件安装","uri":"/posts/tools/sw/install/"},{"categories":["tools"],"content":"ubuntu(linux)系统常用配置","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":" 1. ununtu 设置 1.1. ubuntu 自动挂载机械硬盘 1.2. ubuntu 开机自启动程序 1.3. Ubuntu主机的NFS共享文件夹 1.4. 软链接 1.4.1. 创建软链接 1.4.2. 删除软链接 1.5. Ubuntu终端显示Git当前所在分支 1.6. SSH 使用别名代替IP地址登录 1.7. ubuntu 显示字体大小设置 1.8. ubuntu 设置wifi 上网，有线连接局域网设备 1.9. 快捷键 1.9.1. 文件管理器 1.10. 任务栏设置 1.11. 修改主机名 2. 常用软件安装 2.1. vim 2.2. 微信 2.3. net-tools 2.4. opencv 2.5. openssl 2.6. cmake 2.7. terminator 2.8. tree 2.9. doublecmd 2.10. gnome-tweaks 2.11. VLC 2.12. Typora 2.13. Samba 2.14. 截图工具 flameshot 2.15. Finalshell 2.16. 搜狗输入法 2.17. ubuntu 删除应用显示图标 2.18. ZSH 和 oh-my-sh 2.19. clash 2.20. jq 工具 2.21. screenkey 2.22. pycharm 2.23. android stduio 内网穿透 cpolar 1. ununtu 设置 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:0:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.1. ubuntu 自动挂载机械硬盘 Ubuntu18.04 自动挂载硬盘 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:1:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.2. ubuntu 开机自启动程序 参考： ubuntu-18.04 设置开机启动脚本 建立rc-local.service文件 1 sudo vi /etc/systemd/system/rc-local.service rc-local.service: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 创建文件rc.local　1 sudo vi /etc/rc.local rc.local : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \"exit 0\" on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. cd /usr/local ./RunPowerOn.sh exit 0 RunPowerOn.sh 给rc.local加上权限/启用服务/启动服务并检查状态 1 2 3 4 sudo chmod +x /etc/rc.local sudo systemctl enable rc-local sudo systemctl start rc-local.service sudo systemctl status rc-local.service 重启并检查日志文件 1 2 ls /mnt/DG/DATA/LOG/sys_start/ cat xxx ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:2:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.3. Ubuntu主机的NFS共享文件夹 ubuntu: 1 2 3 4 apt-get install nfs-common nfs-kernel-server vi /etc/exports sudo gedit /etc/exports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /home/zyh/T3-libra *(rw,sync,no_root_squash,no_subtree_check) /home/zyh/DATA *(rw,sync,no_root_squash,no_subtree_check) /home/zyh/sensor_test *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/RGBD2 *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/RGBD *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/test_roi *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/rknn_demo *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/T3RHeadDetectTest *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/t3r_pressure_test *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/rockchip_mpp *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/mpp *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/libra_v3/release *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/T3R/encoder/image *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/HaomuF *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/9_other/StereoCamera *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/9_other/librealsense *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/ZYH/COMMON/Multimedia/rkmmp *(rw,sync,no_root_squash,no_subtree_check) /home/ubuntu/workspace/yuhuzhang/mpp *(rw,sync,no_root_squash,no_subtree_check) # home /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) mount -t nfs -o nolock 192.168.100.189:/mnt/DATA/CODE/beagle-bone 1 2 3 4 5 sudo service nfs-kernel-server restart alias nfsstart='sudo service nfs-kernel-server restart' vi ~/.bashrc source ~/.bashr T3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 mount -t nfs -o nolock 192.168.101.15:/home/zyh/code /mnt ls /mnt mount -t nfs -o nolock 192.168.101.98:/media/zyh/DG/WORK/2_code/1_T3/libra_v3 /mnt mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /root/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/ubuntu/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/sensor_test /home/sensor_test T4DEMO mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/3_T4/libra_v3/release /home/deepglint/zyh/zyh_libra RK mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo /home/toybrick/Rockchip/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo/rknn_demo /home/toybrick/Rockchip/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/toybrick/Rockchip/zyh/zyh_libra mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/99_TEST/mpp /home/toybrick/Rockchip/zyh/mpp mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/libra_v3/release mount -t nfs -o nolock 192.168.100.189:/mnt/DG/DATA/T3R/encoder/image /home/deepglint/zyh/image mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/99_TEST/t3r_pressure_test /home/toybrick/Rockchip/zyh/t3r_pressure_test mount -t nfs -o nolock 192.168.100.189:/mnt/DG/DATA/T3R/encoder/image /home/toybrick/Rockchip/zyh/image mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/9_other/StereoCamera /home/toybrick/Rockchip/zyh/StereoCamera mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo/rknn_demo /home/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/HaomuF /home/toybrick/Rockchip/zyh/HaomuF mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/BeagleBone /root/BeagleBone 1 2 3 4 5 6 7 8 9 10 11 //////////////////////////////////////////////////////////////////////////////// mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:3:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4. 软链接 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4.1. 创建软链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # rk3399 sudo ln -fs /mnt/DG/DATA/tool_chain/aarch64-buildroot-linux-gnu_rk3399-buildroot /usr/local/aarch64-rk3399-linux-toolchain-libra-v4 # aarch64-himix100 sudo ln -fs /mnt/DG/DATA/tool_chain/aarch64-buildroot-linux-gnu_sdk-buildroot /usr/local/aarch64-himix100-linux-toolchain-libra-v3 # gnueabihf sudo ln -fs /mnt/DG/DATA/tool_chain/arm-buildroot-linux-gnueabihf_sdk-buildroot /usr/local/arm-linux-gnueabihf-toolchain-libra-v3 # BeagleBone sudo ln -fs /mnt/DG/DATA/tool_chain/arm-buildroot-linux-gnueabihf_sdk-buildroot /usr/local/arm-linux-gnueabihf-toolchain # code sudo ln -fs /mnt/DG/WORK/2_code/1_T3/libra_v3 /home/zyh/T3-libra sudo ln -fs /mnt/DG/WORK/2_code/100_ZYH/COMMON/BeagleBone /home/zyh/BeagleBone sudo ln -fs /mnt/DG/WORK/2_code/99_TEST/libra_v3 /home/zyh/sensor_test ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:1","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4.2. 删除软链接 正确的是：rm -rf hb_link 错误的是：rm -rf hb_link/ 这个会把整个目录都删了 备注：想要删除链接文件要用以下命令 rm /home/hb_link 只是少了一个“ / ” 删除的 就是链接文件, 也就是在文件的最后不要加上/ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:2","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.5. Ubuntu终端显示Git当前所在分支 cd ~ vi .bashrc 插入代码 1 2 3 4 5 6 7 8 9 10 11 function git_branch { branch=\"`git branch 2\u003e/dev/null | grep \"^\\*\" | sed -e \"s/^\\*\\ //\"`\" if [ \"${branch}\" != \"\" ];then if [ \"${branch}\" = \"(no branch)\" ];then branch=\"(`git rev-parse --short HEAD`...)\" fi echo \" ($branch)\" fi } export PS1='\\u@\\h \\[\\033[01;36m\\]\\W\\[\\033[01;32m\\]$(git_branch)\\[\\033[00m\\] \\$ ' source ./.bashrc ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:5:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.6. SSH 使用别名代替IP地址登录 如果要想把前面的ssh root@192.168.1.2使用一个好记的别名（比如：test），则可以在~/.ssh/config添加如下的配置： 1 2 3 Host test HostName 192.168.1.2 User root 保存文件后，即可以用下面的方式登录了： 1 $ ssh test 1 2 3 4 5 ssh-copy-id -i ~/.ssh/id_rsa user@ssh.test.com ssh-copy-id -i ~/.ssh/id_rsa luban@10.186.6.134 ssh-copy-id -i ~/.ssh/id_rsa zhangyuhu@172.22.50.250 ssh-copy-id -i ~/.ssh/id_rsa didi@172.24.158.48 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:6:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.7. ubuntu 显示字体大小设置 终端命令： 安装gnome-tweaks桌面配置工具; 1 sudo apt install gnome-tweaks Alt+F2 在运行窗口输入 gnome-tweaks 命令，回车; 打开的优化窗口中，字体一栏，调整缩放比例（如1.5则会放大）。 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:7:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.8. ubuntu 设置wifi 上网，有线连接局域网设备 配置有线网如下 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:8:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.9. 快捷键 设置-\u003e 设备 -\u003e 键盘 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:9:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.9.1. 文件管理器 1 nautilus . ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:9:1","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.10. 任务栏设置 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:10:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.11. 修改主机名 2. 常用软件安装 自动安装 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:11:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.1. vim 1 2 3 4 sudo apt-get install vim # https://github.com/ma6174/vim vim配置文件和插件 wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -xY ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:12:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.2. 微信 1 2 wget -O- https://deepin-wine.i-m.dev/setup.sh | sh sudo apt-get install deepin.com.wechat Ubuntu通过deepin-wine安装wechat和wechat Work ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:13:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.3. net-tools 1 sudo apt install net-tools ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:14:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.4. opencv 1 sudo apt-get install libopencv-dev ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:15:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.5. openssl 1 2 sudo apt-get install openssl sudo apt-get install libssl-dev ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:16:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.6. cmake 1 sudo apt install cmake ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:17:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.7. terminator 1 sudo apt-get install terminator 快捷键： Ctrl-E(注意是大E要按住Shift)可以垂直分割终端 Ctrl-O 可水平分割终端 按住Alt然后按上下左右可以在不同的分割窗中切换 Ctrl-D 可以关闭分割窗 terminator配置文件 ：~/.config/terminator/config 1 2 3 4 5 6 7 8 font = Monaco 10 #设置体字 background_color = \"#204070\" # 背景颜色 foreground_color = \"#F0F0F0\" # 字体颜色 cursor_blink = True # 设置光标 scrollbar_position = disabled # 禁用滚动条 titlebars = no # 禁用标题栏 background_darkness = 0.4 background_type = transparent # 背景类型可以设置为图片 更多配置： 1 man terminator_config ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:18:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.8. tree 1 sudo apt install tree ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:19:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.9. doublecmd 文件管理工具 1 2 3 4 5 sudo add-apt-repository ppa:alexx2000/doublecmd sudo apt-get update sudo apt-get install doublecmd-gtk sudo apt-get remove doublecmd-* ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:20:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.10. gnome-tweaks unutu 桌面配置 1 2 3 4 5 6 # 安装 sudo apt-get gnome-tweaks # 启动 gnome-tweaks ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:21:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.11. VLC ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:22:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.12. Typora Linux安装及美化Typora详细步骤 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:23:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.13. Samba Samba 是种用来让UNIX系列的操作系统与微软Windows操作系统的SMB / CIFS（服务器消息块/通用Internet文件系统）网络协议做链接的自由软件。第三版不仅可访问及分享SMB的文件夹及打印机，本身还可以集成入Windows Server的网域，扮演为网域控制站（域控制器）以及加入Active Directory成员。简而言之，此软件在Windows与UNIX系列操作系统之间搭起一座桥梁，让两者的资源可互通有无。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 安装 sudo apt-get install samba # 查看是否安装成功 samba # samba 配置文件路径 /etc/samba/smb.conf # 修改配置文件 - 文件最后添加 [ZYH-DATA] comment = zyh ubuntu data path = /mnt/DG public = yes browseable = yes public = yes writeable = yes read only = no valid users = zyh create mask = 0777 directory mask = 0777 force user = nobody force group = nogroup available = yes # 添加密码 sudo smbpasswd -a zyh # 重启samba 服务器 sudo service smbd restart # win 访问 \\\\+ ip ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:24:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.14. 截图工具 flameshot 1 2 3 4 5 6 7 8 9 # 安装 sudo apt-get install flameshot # 手动下载 https://github.com/flameshot-org/flameshot/releases # 启动 flameshot gui ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:25:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.15. Finalshell github release 1 2 3 4 rm -f finalshell_install_linux.sh wget www.hostbuf.com/downloads/finalshell_install_linux.sh chmod +x finalshell_install_linux.sh ./finalshell_install_linux.sh 安装路径 1 /usr/lib/FinalShell/ 配置文件路径 1 /home/$USER/.finalshell/ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:26:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.16. 搜狗输入法 https://shurufa.sogou.com/linux/guide ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:27:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.17. ubuntu 删除应用显示图标 删除系统自带的图标 1 sudo nautilus /usr/share/applications 删除wine等软件安装的自定义图标 1 sudo nautilus ~/.local/share/applications ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:28:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.18. ZSH 和 oh-my-sh 1 2 3 4 5 6 7 8 9 10 11 # zsh sudo apt-get install zsh # oh-my-sh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" # 设置默认终端 chsh -s /bin/zsh root # 切换回bash也是相同的方法 chsh -s /bin/bash root ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:29:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.19. clash 参考 ：ubuntu 20.04 配置使用 clash for linux 下载地址 1 2 https://github.com/Dreamacro/clash wget -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.4.1/clash-linux-amd64-v1.4.1.gz 安装 1 2 3 4 5 6 7 8 9 gzip -f clash.gz -d chmod +x clash cp clash /usr/bin vi .bashrc alias clash='sudo ./usr/bin/clash -d ~/.config/clash/' ./clash 配置 拷贝 mac / win 上配置文件到ubuntu 使用 Web 工具管理 clash 地址：http://clash.razord.top/#/proxies 配置 ubunutu 网络代理 打开 设置 -\u003e 网络 -\u003e 网络代理 配置 HTTP 代理和 socket 代理 分别为上面的端口号 其他问题 git clone 报错 ：Failed to receive SOCKS4 connect request ack. 因为 clash 代理的 socket5，github 是 socket4 1 2 3 # 7891 是clash 代理 socket 的端口 git config --global http.proxy 'socks5://127.0.0.1:7891' git config --global https.proxy 'socks5://127.0.0.1:7891' ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:30:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.20. jq 工具 官网 1 2 3 4 sudo apt-get install jq # json 格式化 cat Recfront_20200916_095044_refine.json |jq . \u003edata_2.json ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:31:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.21. screenkey 下载 https://www.thregr.org/~wavexx/software/screenkey/ 安装 1 2 3 4 5 6 tar xvf screenkey-1.5.tar.gz cd screenkey-1.5 sudo ./setup.py install cd data sudo cp ./screenkey.desktop /usr/share/applications/ 使用 1 screenkey 设置 参考 ： https://gitlab.com/screenkey/screenkey#interactive-placement 1 screenkey -p fixed -g 30%x10%+65%-10% ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:32:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.22. pycharm 下载 ： https://www.jetbrains.com/pycharm/download/#section=linux 解压 cp xxx/* /opt/pycharm alias pycharm=‘cd /opt/pycharm/bin \u0026\u0026 ./pycharm.sh \u0026’ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:33:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.23. android stduio 下载 https://developer.android.google.cn/studio 解压 cp xxx/* /opt/android-studio/ alias android=‘cd /opt/android-studio/bin \u0026\u0026 ./studio.sh \u0026’ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:34:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"内网穿透 cpolar cpolar一键安装脚本 1 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 配置cpolar开机自启动 1 2 3 sudo systemctl enable cpolar sudo systemctl start cpolar sudo systemctl status cpolar 获取ssh隧道的公网地址 http://localhost:9200 配置 远程登陆 1 ssh linux用户名@cpolar所生成的公网地址 -p XXXXX（cpolar生成的端口号） ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:35:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"UML","date":"2023-01-15","objectID":"/posts/tools/uml/uml/","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. UML 1.1. UML常用图表 2. 常见类图 2.1. 类（Class) 2.2. 接口（Interface） 2.3. 类图中关系（relation） 2.3.1. 泛化（Generalization） 2.3.2. 实现（Realization） 2.3.3. 关联（Association) 2.3.4. 聚合（Aggregation） 2.3.5. 组合(Composition) 2.3.6. 依赖(Dependency) 2.3.7. 总结 3. 类图的绘制 3.1. 绘制要点 3.2. 类的UML图示 4. 参考 1. UML ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:0:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"1.1. UML常用图表 项目 价格 数量 泛化（继承） B——▷A B 类作为 A 类的子类存在 实现 B——▷A B 类实现 A 接口 依赖 A——\u003eB B 类作为 A 类某个方法的参数，表示A想做某些事情需要依赖 B，不然做不成 关联 A——\u003eB（单向） B 类作为 A 类的属性存在，语义上 A 类和 B 类的地位或水平相等 A \u003c——\u003e B（双向) B 类作为 A 类的属相存在， A 类作为 B 类的属性存在，语义上 A 类和 B 类的地位或水平相等 聚合 A♢——\u003eB B 类作为 A 类的属性存在，语义上 B 类可作为 A 类的一部分，这个关系可有可无，是A has–a B 的关系，如房子（A），桌子（B） 组合 A♦——\u003eB B 类作为 A 类的属性存在，语义上 B 类是 A 类的一部分，这部分必须有，是 A contain–a B 的关系，如（人），大脑（B） 2. 常见类图 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:1:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.1. 类（Class) 在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:2:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.2. 接口（Interface） 接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:3:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3. 类图中关系（relation） 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.1. 泛化（Generalization） 【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。 例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:1","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.2. 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:2","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.3. 关联（Association) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生， 丈夫与妻子关联可以是双向的，也可以是单向的。 双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。 但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联: ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:3","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.4. 聚合（Aggregation） 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。 如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:4","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.5. 组合(Composition) 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。 如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系， 它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:5","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.6. 依赖(Dependency) 【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助， 所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 下面这张UML图，比较形象地展示了各种类图关系： ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:6","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.7. 总结 依赖： 对类 B 进行修改会影响到类 A 。 关联： 对象 A 知道对象 B。 类 A 依赖于类 B。 聚合： 对象 A 知道对象 B 且由 B 构成。 类 A 依赖于类 B。 组合： 对象 A 知道对象 B、 由 B 构成而且管理着 B 的生命周期。 类 A 依赖于类 B。 实现： 类 A 定义的方法由接口 B 声明。 对象 A 可被视为对象 B。 类 A 依赖于类 B。 继承： 类 A 继承类 B 的接口和实现， 但是可以对其进行扩展。 对象 A 可被视为对象 B。 类 A 依赖于类 B。 3. 类图的绘制 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:7","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"3.1. 绘制要点 类的操作是针对类自身的操作，而不是它去操作人家。比如书这个类有上架下架的操作，是书自己被上架下架，不能因为上架下架是管理员的动作而把它放在管理员的操作里。 两个相关联的类，需要在关联的类中加上被关联类的ID，并且箭头指向被关联类。可以理解为数据表中的外键。比如借书和书，借书需要用到书的信息，因此借书类需包含书的ID，箭头指向书。 由于业务复杂性，一个显示中的实体可能会被分为多个类，这是很正常的，类不是越少越好。类的设计取决于怎样让后台程序的操作更加简单。比如单看逻辑，借书类可以不存在，它的信息可以放在书这个类里。然而借还书和书的上架下架完全不是一回事，借书类对借书的操作更加方便，不需要去重复改动书这个类中的内容。此外，如果书和借书是1对多的关系，那就必须分为两个类。 类图中的规范问题，比如不同关系需要不同的箭头，可见性符号等。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:5:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"3.2. 类的UML图示 1 2 3 4 5 6 7 8 9 10 public class Employee { private String name; private int age; private String email; public void modifyInfo() { ...... } } 在UML类图中，类一般由三部分组成： (1) 第一部分是类名：每个类都必须有一个名字，类名是一个字符串。 (2) 第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性 UML规定属性的表示方式为： 可见性 名称:类型 [ = 缺省值 ] 其中： “可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。 “名称”表示属性名，用一个字符串表示。 “类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。 “缺省值”是一个可选项，即属性的初始值。 (3) 第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。 UML规定操作的表示方式为： 可见性 名称(参数列表) [ : 返回类型] 4. 参考 解析UML类图符号意义 深入浅出UML类图 敏捷软件开发：原则、模式与实践——第20章　咖啡的启示 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:6:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"vscode基础配置","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 资料 2. vs code 快捷键 2.1. 将下一个查找匹配项添加到选择 3. VS 插件 3.1. Markdown TOC 3.2. Markdown Preview Enhanced 3.3. Markdown All in One 3.4. GitLens 3.5. Code Spell Checker 3.6. Remote - SSH 3.7. vscode-fileheader 3.8. Rainbow Brackets 3.9. vscode-pdf 3.10. vscode-drawio 3.11. Comment Translate 3.12. shellman 3.13. shell-format 3.14. shellcheck 4. 问题及配置 4.1. ubuntu vscode 字体间隔大 4.2. ubuntu vscode 代码空格小 4.3. 显示空格和tab 4.4. 保存去除行尾字符 4.5. markdown 去除 保存去除行尾字符 4.6. linux下vscode编写cpp占用内存过高问题 4.7. 设置忽略文件 1. 资料 官方文档 第一次使用VS Code时你应该知道的一切配置 2. vs code 快捷键 1 2 3 4 5 6 7 8 9 10 11 12 The cmd key for Windows is ctrl. Shortcuts Functionality cmd-k v or ctrl-k v Open preview to the Side cmd-shift-v or ctrl-shift-v Open preview ctrl-shift-s Sync preview / Sync source shift-enter Run Code Chunk ctrl-shift-enter Run all Code Chunks cmd-= or cmd-shift-= Preview zoom in cmd-- or cmd-shift-_ Preview zoom out cmd-0 Preview reset zoom esc Toggle sidebar TOC ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:0:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"2.1. 将下一个查找匹配项添加到选择 vsCode多选多个元素进行统一修改 1 2 3 4 5 { \"key\": \"ctrl+d\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" } 3. VS 插件 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:1:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.1. Markdown TOC 自动生成目录 VScode markdown md TOC 插件目录生成错误auto 搜索eol 改为’\\n' ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:2:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.2. Markdown Preview Enhanced markdown 预览 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:3:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.3. Markdown All in One ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:4:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.4. GitLens VsCode中好用的git源代码管理插件GitLens ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:5:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.5. Code Spell Checker 代码拼写检查工具 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:6:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.6. Remote - SSH 连接远程主机 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:7:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.7. vscode-fileheader 自动生成文件头 1 /* \\r\\n* @file xxx\\r\\n* @brief xxx\\r\\n* @author ZYH\\r\\n* @version v0.1\\r\\n* @date 2020/07/22\\r\\n* @copyright 2019, Deepglint All rights reserved.\\r\\n*/ ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:8:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.8. Rainbow Brackets 彩虹括号 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:9:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.9. vscode-pdf PDF 查看器 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:10:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.10. vscode-drawio VSCode Drawio ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:11:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.11. Comment Translate VSCode 注释翻译 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:12:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.12. shellman 编辑过程中会有代码提示 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:13:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.13. shell-format 右键 -\u003e 格式化文档（Ctrl + Alt + L） ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:14:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.14. shellcheck 语法错误检查插件 安装shellcheck（shellcheck插件依赖于shellcheck） : sudo apt-get install shellcheck 在编辑过程中，会提示语法错误 4. 问题及配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:15:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.1. ubuntu vscode 字体间隔大 修改：“terminal.integrated.fontFamily”: “monospace”， ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:16:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.2. ubuntu vscode 代码空格小 修改： \" Editor:Font Family\":‘monospace’ ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:17:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.3. 显示空格和tab 修改 ：\" Editor: Render Whitespace “:all ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:18:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.4. 保存去除行尾字符 启用 ：trimTrailingWhitespace ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:19:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.5. markdown 去除 保存去除行尾字符 markdown 文件根目录配置 1 2 3 { \"files.trimTrailingWhitespace\": false } ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:20:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.6. linux下vscode编写cpp占用内存过高问题 intelli Sense Cache Size 默认大小为5G,将其改为2048(2G)或者其他任意，不要太大。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:21:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.7. 设置忽略文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"files.exclude\": { \"*.metadata\": true, \"*.settings\": true, \"**/*.pyc\": true, //隐藏所有pyc文件 \"**/*.meta\": true, //隐藏所有meta文件 \"**/*.prefab\": true, //隐藏所有prefab文件 \"**/*.d.ts\": true, //隐藏所有d.ts文件 \"**/*.fnt\": true, \"**/*.sln\": true, \"**/*.csproj\": true, \"**/.vscode\": true, \"**/*.anim\": true, \"**/*.controller\": true, \"**/Logs\": true, \"**/[Pp]lugins\": true, //使用中括号时表示不区分大小写 \"**/[Mm]aterials\": true, \"**/[Aa]nimation\": true, \"**/[Pp]ackages\": true, \"**/[Tt]extures\": true, \"**/[Ss]cenes\": true, \"**/temp\": true, //隐藏temp文件夹 \"**/library\": true, //隐藏library文件夹 \"**/audio\": true, //隐藏audio文件夹 \"**/video\": true, //隐藏video文件夹 } ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:22:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"vscode配置文件(config.json)设置","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"参考： Using C++ on Linux in VS Code Getting Started with Python in VS Code 【笔记】vscode做C++开发，launch.json、tasks.json、settings.json写法示例 教你如何快速解决需要在每个新项目新建launch.json文件的问题？ Tips and Tricks Ctrl+R : Displays a Quick Pick dropdown with the list from File \u003e Open Recent with recently opened folders and workspaces followed by files. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:0:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Command line 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # open code with current directory code . # open the current directory in the most recently used code window code -r . # create a new window code -n # change the language code --locale=es # open diff editor code --diff \u003cfile1\u003e \u003cfile2\u003e # open file at specific line and column \u003cfile:line[:character]\u003e code --goto package.json:10:5 # see help options code --help # disable all extensions code --disable-extensions . ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:1:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":".vscode folder Workspace specific files are in a .vscode folder at the root. For example, tasks.json for the Task Runner and launch.json for the debugger. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:2:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Ignore files / folders Removes these files / folders from your editor window. 1 2 3 4 \"files.exclude\": { \"somefolder/\": true, \"somefile\": true } Remove these files / folders from search results. 1 2 3 4 \"search.exclude\": { \"someFolder/\": true, \"somefile\": true } launch.json、tasks.json、settings.json settings.json User and Workspace Settings User Settings - Settings that apply globally to any instance of VS Code you open. Workspace Settings - Settings stored inside your workspace and only apply when the workspace is opened. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:3:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"User Settings ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:4:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Settings file locations# Depending on your platform, the user settings file is located here: Windows %APPDATA%\\Code\\User\\settings.json macOS $HOME/Library/Application\\ Support/Code/User/settings.json Linux $HOME/.config/Code/User/settings.json ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:4:1","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Workspace Settings launch.json Configure C/C++ debugging ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:5:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"工具使用","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":" 代码管理工具 代码格式化工具ClangFormat 简介 文档 安装 使用 使用vscode 手动格式化 git 自动格式化提交文件 手动格式化 静态扫描工具 cppcheck 安装 使用 Tscancode 安装 使用 文档自动生成工具 doxygen 安装 常用配置 根据配置生成doxygen文档 vscode 自动生成 Doxygen 注释 下载 配置文件 使用 建议安装的插件及配置 Code Spell Checker 其他配置 保存去除行尾字符 保存文件在文件末尾插入最终行 代码管理工具 为了团队协作方便以及代码代码稳定性建设，团队内可以使用统一的工具进行代码格式化，生成文档等。这里整理下相关工具及导入工程实施的方法。 以下工具基于如Ubuntu 18.04 LTS环境进行验证，但工具到时跨平台，保持配置文件一致，其他平台环境安装需要使用的同学自行解决。 代码格式化工具ClangFormat ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:0:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"简介 ClangFormat 是一个规范代码的工具 ClangFormat 支持的语言有：C/C++/Java/JavaScript/Objective-C/Protobuf/C# ClangFormat 支持的规范有：LLVM，Google，Chromium，Mozilla 和 WebKit ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:1:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"文档 官方文档 其配置文件的官方文档 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:2:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 2 3 4 # 安装 sudo apt install clang-format # 查看版本 clang-format --version ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:3:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用vscode 手动格式化 安装 插件 clang-format 将默认格式化工具设置为 clang-format vscode 设置中 搜索 defaultFormatter ，选择默认配置为 clang-format 。 将配置文件 .clang-format 放到工程根目录，以DVR 工程为例： 使用快捷格式化 ，windows：Shift+Alt+F Mac：Shift+Option+F Ubuntu：Ctrl+Shift+I ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"git 自动格式化提交文件 git pre-commit 在提交代码的时候对变动的文件进行格式化, 将 pre-commit 拷贝到 git/hooks 目录下 1 cp ./pre-commit ../../.git/hooks/ 此后git在提交的时候会进行自动格式化。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"手动格式化 使用 clang-format 命令 ```bash clang-format -style=google -i xxx.cpp 指定格式化方式 clang-format -style=file .clang-format -i xxx.cpp 指定配置文件 clang-format -i xxx.cpp # 使用工程默认 ``` 使用脚本格式化以有文件 现有代码可能格式不一致，可以使用提供的脚本进行统一格式化做单次提交到服务器。可以使用 tools/format 文件夹下 format.sh 对文件夹内文件递归进行格式化。 1 ./format.sh /home/didi/work/http/src/http 静态扫描工具 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:3","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"cppcheck CppCheck是一个C/C++代码缺陷静态检查工具。不同于C/C++编译器及其它分析工具，CppCheck只检查编译器检查不出来的bug，不检查语法错误。所谓静态代码检查就是使用一个工具检查我们写的代码是否安全和健壮，是否有隐藏的问题 源码下载地址：cppcheck ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 2 3 4 5 6 # 安装 sudo apt-get install cppcheck # 查看版本 cppcheck --version # Cppcheck 1.82 c++11 最好使用1.8 异常版本，如果apt 安装非最新版本可以下载源码安装 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 使用参考 1 cppcheck xxx/ --enable=all --output-file=./xxxx.txt ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"Tscancode TscanCode是一款腾讯开源的静态代码扫描工具，TscanCode旨在助力开发与测试人员从代码层面挖掘问题，将那些长期困扰项目的诸如空指针宕机等问题，扼杀于萌芽阶段。支持用户根据不同需求自定义配置检查项，有极强的扩展性和可维护性。平均扫描速度10W行/分钟。 TscanCode支持以下类型规则扫描： 空指针检查，包含可疑的空指针，判空后解引用比如Crash等共3类subid检查。 数据越界，Sprintf_S越界共1类subid检查。 内存泄漏，分配和释放不匹配同1类subid检查。 逻辑错误，重复的代码分支，bool类型和INT进行比较，表达式永远True或者false等共18类检查。 可疑代码检查，if判断中含有可疑的=号，自由变量返回局部变量等共计15类检查。 运算错误，判断无符号数小于0,对bool类型进行++自增等，共计11类检查。 代码仓库 ：TscanCode ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 release 文件下载地址 ：release 文件下载 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 工具 使用参考 1 ./tscancode --xml --enable=all -q ../../../src/ \u003escan_result.xml 2\u003e\u00261 说明 ： 工程里集成了脚本和生成的文件 见 ： tools/codescan/ 路径 文档自动生成工具 doxygen ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 安装doxygen—\u003e 安装Graphviz—\u003e生成doxygen配置文件—\u003e修改doxygen配置文件—\u003e生成doxygen文档 安装doxygen 1 sudo apt-get install doxygen 安装Graphviz 1 sudo apt-get install graphviz 生成doxygen配置文件 1 doxygen -s -g 注释：上述s 和 g 分别表示simple和generate ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"常用配置 常用选项如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 项目名称，将作为于所生成的程序文档首页标题 PROJECT_NAME = “Test” # 文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号 PROJECT_NUMBER = \"1.0.0 # 程序文档输出目录 OUTPUT_DIRECTORY = /home/user1/docs # 程序文档输入目录 INPUT = /home/user1/project/kernel # 程序文档语言环境 OUTPUT_LANGUAGE = Chinese # 只对头文件中的文档化信息生成程序文档 FILE_PATTERNS = # 递归遍历当前目录的子目录，寻找被文档化的程序源文件 RECURSIVE = YES # 如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式 OPTIMIZE_OUTPUT_FOR_C = YES #提取信息，包含类的私有数据成员和静态成员 EXTRACT_ALL = yes EXTRACT_PRIVATE = yes EXTRACT_STATIC = yes # 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化 TYPEDEF_HIDES_STRUCT = YES # 在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES HIDE_SCOPE_NAMES = YES # 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息 QUIET = YES # 递归遍历示例程序目录的子目录，寻找被文档化的程序源文件 EXAMPLE_RECURSIVE = YES # 允许程序文档中显示本文档化的函数相互调用关系 REFERENCED_BY_RELATION = YES REFERENCES_RELATION = YES REFERENCES_LINK_SOURCE = YES # 不生成 latex 格式的程序文档 GENERATE_LATEX = NO # 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包 HAVE_DOT = YES CALL_GRAPH = YES CALLER_GRAPH = YES #在最后生成的文档中，把所有的源代码包含在其中 SOURCE BROWSER = YES $这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系 GENERATE TREEVIEW ＝ ALL ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"根据配置生成doxygen文档 1 doxygen Doxyfile 效果 文件 class namespase ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"vscode 自动生成 Doxygen 注释 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"下载 vscode 下载插件 ：Generate Doxygen Comments ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"配置文件 安装插件后，File–Preferences–Settings– 中打开 用户 setting.json文件 ,增加如下内容 (配置可以根据自己需要修改): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Doxygen documentation generator set \"doxdocgen.file.copyrightTag\" : [ \"@copyright Copyright (c) 2012-2021 Beijing Xiaoju Technology Co, Ltd.\" ], \"doxdocgen.file.customTag\": [ \"@par 修改日志:\", \"\u003ctable\u003e\", \"\u003ctr\u003e\u003cth\u003eDate \u003cth\u003eVersion \u003cth\u003eAuthor \u003cth\u003eDescription\", \"\u003ctr\u003e\u003ctd\u003e{date} \u003ctd\u003ev1.0 \u003ctd\u003ezhangyuhu \u003ctd\u003e内容\", \"\u003c/table\u003e\", ], \"doxdocgen.file.fileOrder\": [ \"file\", \"brief\", \"author\", \"version\", \"date\", \"copyright\", \"empty\", \"custom\", ], \"doxdocgen.file.fileTemplate\": \"@file {name}\", \"doxdocgen.file.versionTag\": \"@version v1.0\", \"doxdocgen.generic.authorEmail\": \"zhangyuhu@didiglobal.com\", \"doxdocgen.generic.authorName\": \"zhangyuhu\", \"doxdocgen.generic.authorTag\": \"@author {author} ({email})\", \"doxdocgen.generic.order\": [ \"brief\", \"tparam\", \"param\", \"return\" ], \"doxdocgen.generic.paramTemplate\": \"@param{indent:8}{param}{indent:25}My Param doc\", \"doxdocgen.generic.returnTemplate\": \"@return {type} \", \"doxdocgen.generic.splitCasingSmartText\": true, ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 Vs code自动生成Doxygen格式注释 在文件 / 函数等 输入 /** 回车可自动生成注释 建议安装的插件及配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:3","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"Code Spell Checker 拼写检查工具 示例1: 示例2: 其他配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:9:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"保存去除行尾字符 设置中搜索 trimTrailingWhitespace ，并启用。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:10:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"保存文件在文件末尾插入最终行 设置中搜索 insert final newline ，并启用。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:11:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 gdb 调试","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 GDB 概述 调试示例 使用GDB 1. 编译程序 2. 启动GDB的方法 常用指令 1. 查看代码 2. 断点设置 2.1. 设置断点 2.2. 查看断点 2.3. 删除断点： 2.4. 禁用与启用断点 2.5. 断点命令列表 3. 调试 3.1. 启动 3.2. 查看栈帧 3.3. 输出当前值 3.4. 浏览以前的GDB命令 3.5. 运行 参考 GDB 概述 GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。 一般来说，GDB主要帮忙你完成下面四个方面的功能： 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3、当程序被停住时，可以检查此时你的程序中所发生的事。 4、动态的改变你程序的执行环境。 调试示例 原程序 ： gdb_test.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u003cstdio.h\u003e int func(int n) { int sum = 0, i; for (i = 0; i \u003c n; i++) { sum += i; } return sum; } main() { int i; long result = 0; for (i = 1; i \u003c= 100; i++) { result += i; } printf(\"result[1-100] = %d /n\", result); printf(\"result[1-250] = %d /n\", func(250)); } 编译 ： gcc -g gdb_test.c -o test 使用GDB调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 zyh@zyh gdb (master) $ gdb test \u003c---------- 启动GDB GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttp://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e. Find the GDB manual and other documentation resources online at: \u003chttp://www.gnu.org/software/gdb/documentation/\u003e. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from test...done. (gdb) l \u003c-------------------- l命令相当于list，从第一行开始例出原码。 1 #include \u003cstdio.h\u003e 2 3 int func(int n) 4 { 5 int sum=0,i; 6 for(i=0; i\u003cn; i++) 7 { 8 sum+=i; 9 } 10 return sum; (gdb) \u003c-------------------- 直接回车表示，重复上一次命令 11 } 12 13 14 main() 15 { 16 int i; 17 long result = 0; 18 for(i=1; i\u003c=100; i++) 19 { 20 result += i; (gdb) break 16 \u003c-------------------- 设置断点，在源程序第16行处。 Breakpoint 1 at 0x8048496: file tst.c, line 16. (gdb) break func \u003c-------------------- 设置断点，在函数func()入口处。 Breakpoint 2 at 0x8048456: file tst.c, line 5. (gdb) info break \u003c-------------------- 查看断点信息。 Num Type Disp Enb Address What 1 breakpoint keep y 0x08048496 in main at tst.c:16 2 breakpoint keep y 0x08048456 in func at tst.c:5 (gdb) r \u003c--------------------- 运行程序，run命令简写 Starting program: /home/hchen/test/tst Breakpoint 1, main () at tst.c:17 \u003c---------- 在断点处停住。 17 long result = 0; (gdb) n \u003c--------------------- 单条语句执行，next命令简写。 18 for(i=1; i\u003c=100; i++) (gdb) n 20 result += i; (gdb) n 18 for(i=1; i\u003c=100; i++) (gdb) n 20 result += i; (gdb) c \u003c--------------------- 继续运行程序，continue命令简写。 Continuing. result[1-100] = 5050 \u003c----------程序输出。 Breakpoint 2, func (n=250) at tst.c:5 5 int sum=0,i; (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p i \u003c--------------------- 打印变量i的值，print命令简写。 $1 = 134513808 (gdb) n 8 sum+=i; (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p sum $2 = 1 (gdb) n 8 sum+=i; (gdb) p i $3 = 2 (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p sum $4 = 3 (gdb) bt \u003c--------------------- 查看函数堆栈。 #0 func (n=250) at tst.c:5 #1 0x080484e4 in main () at tst.c:24 #2 0x400409ed in __libc_start_main () from /lib/libc.so.6 (gdb) finish \u003c--------------------- 退出函数。 Run till exit from #0 func (n=250) at tst.c:5 0x080484e4 in main () at tst.c:24 24 printf(\"result[1-250] = %d /n\", func(250) ); Value returned is $6 = 31375 (gdb) c \u003c--------------------- 继续运行。 Continuing. result[1-250] = 31375 \u003c----------程序输出。 Program exited with code 027. \u003c--------程序退出，调试结束。 (gdb) q \u003c--------------------- 退出gdb。 使用GDB ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:0:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"编译程序 一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如： 1 2 \u003e gcc -g hello.c -o hello \u003e g++ -g hello.cpp -o hello 如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:1:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"启动GDB的方法 gdb + ProgramName 说明：ProgramName 也就是你的执行文件，一般在当前目录下。 gdb + ProgramName +core 说明：用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 gdb + ProgramName +PID 说明：如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 gdb -command=z x 说明：在调用GDB时可以指定启动文件，如：$gdb-command=z x 表示要在可执行文件x上运行GDB，首先要从文件z中读取命令。 gdb启动文件 \u003e 有时候我们在完成调试前可能需要退出GDB，比如需要离开比较长的一段时间而且不能保持登录在计算机中。为了不丢失某些信息，可以将断点和设置的其他命令放在一个GDB启动文件中，然后每次启动GDB时会自动加载它们。 \u003e GDB启动文件默认名为.gdbinit。可以将一个文件放在主目录中用于一般用途，另一个文件放在特定项目专用的目录中。例如，可以将设置断点的命令放在后一个目录的启动文件中，在主目录的.gdbinit文件中存储开发的一些通用的宏。最好不要将编程项目放在主目录中，因为不能将项目特有的信息放在.gdbinit中。 GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。下面只列举一些比较常用的参数： –symbols=SYMFILE 从指定文件中读取符号表。 –se=FILE 从指定文件中读取符号表信息，并把他用在可执行文件中。 –core=COREFILE 调试时core dump的core文件。 –directory=DIR 加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。 常用指令 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:2:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看代码 list 命令可用于显示指定位置处的源代码。list命令会影响当前行和当前文件。list命令有多种方式指定要显示的源代码范围，可以是行号，函数名，甚至是指令地址。常用的如下： list linenum：显示指定行数附近的代码。 list function：显示指定函数附近的代码。 list + 列出当前行的后面代码行。 list - 列出当前行的前面代码行。 list ＊addr：显示指定地址附近的代码。默认情况下，GDB显示指定位置处以及其前后的10行代码，但是这是一个可设置的值。 set listsize count：设置list命令显示的源代码数量最多为count行，0表示不限制行数。 show listsize：显示listsize的值。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:3:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"断点设置 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"设置断点 break line_number：在某一行设置断点。 break function（函数名）：在某个函数的入口（第一行可执行代码）处设置断点。 break filename:function：在源代码文件filename的函数function入口处处设置断点。 conditionbreak_p_num（断点编号） cond（条件）：将正常断点转变为条件断点 举例：condition 30 index == 5 break line_num（行号） if cond（条件）：用break if可以将break和condition命令组合成一个步骤：举例：(gdb) break 30 if index == 5 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:1","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看断点 info break：显示所有断点信息 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:2","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"删除断点： deletebreak_point_num:删除编号为break_point_num的断点； delete:删除所有断点； clear function:删除在function函数处设定的断点 clearfilename:funtion删除在filename文件的function函数处设定的断点 clear line_number:删除在line_number行设定的断点 clearfilename:line_number:删除在filename文件的line_number行设定的断点 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:3","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"禁用与启用断点 disablebreakpoint-list（是用空格分隔开的多个断点标识符）：禁用断点 disable：禁用所有现存断点 enablebreakpoint-list：启用断点 enable oncebreakpoint-list：在下次引起GDB暂停执行后禁用 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:4","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"断点命令列表 让GDB在每次到达某个断点时自动执行一组命令，从而自动完成某一任务。 使用commands命令设置命令列表： commands breakpoint_number … commands … end 如果嫌GDB输出太冗长，可以使用silent命令，只需将其添加到设置的命令列表最开始处即可。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:5","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"调试 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"启动 run ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:1","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看栈帧 frame num（栈帧编号） 注意栈帧编号规则，当前正在执行的函数的帧被编号为0，其父帧（即该函数的调用者的栈帧）被编号为1，父帧的父帧被编号为2，以此类推。 跳到调用栈中的下一个父帧：up 引向相反方向：down 显示整个栈，即当前存在的所有帧的集合 ：backtrace ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:2","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"输出当前值 print或者p ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:3","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"浏览以前的GDB命令 上一个Ctrl+P、下一个Ctrl+N 可以直接按下回车再次执行最近执行过的那条命令 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:4","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"运行 单步执行： step（s）、next（n），仅执行到代码的下一行后再次暂停。 注意二者区别：在函数调用时step会进入函数，next导致下一次暂停出现在调用函数之后。next被称为单步越过（stepping over）函数，而step被称为单步进入（stepping into）函数。next和step都可以采用一个可选的数值参数，来表示要使用next或step执行的额外行数。 无条件恢复程序的执行： continue（c） 直到遇到另一个断点或者程序结束。continue可以接受一个可选的数值参数n，要求GDB忽略下面n个断点。 用finish（fin）或until（u）命令恢复 finish命令指示GDB恢复执行，直到恰好在当前帧完成之后为止。 until命令通常用来在不进一步在循环中暂停（除了循环中的中间断点）的情况下完成正在执行的循环。until会执行循环的其余部分（如果遇到断点，还是会暂停），让GDB在循环后面的第一行代码处暂停。 until命令也可以接受源代码中的位置作为参数，其用法与break命令同。 如果GDB触发了main函数入口处的一个断点，那么可以使用下面这些命令方便地使程序一直执行到swap()的入口： until 13 until swap until swapflaw.c:13 until swapflaw.c:swap 跳出循环 until NUM 执行到一个比当前行号大的行，或者也可以指定在当前frame（我理解成函数）中的某一行 跳出函数 finish 执行，直到选定的frame执行结束，然后打印返回值，将其放入历史值中，停止 退出 quit(q) 参考 【Linux】GDB用法详解(5小时快速教程) ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:5","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":null,"content":"关于","date":"2023-01-15","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"nothing … ","date":"2023-01-15","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"工具资源列表","date":"2023-01-15","objectID":"/posts/tools/blogs/tools_index/","tags":null,"title":"工具资源列表","uri":"/posts/tools/blogs/tools_index/"},{"categories":null,"content":" 提示 工具资源，奇门遁甲。 常用网址 编程 工具导航站 学术资源 quora cppreference 我爱运营 scihub检1 scihub检2 动手学深度学习 cplusplus 及时工具 Oalib OpenCV c-cpp 果汁实验室 iData 开源软件汇总 purecpp 创造师导航 谷歌学术镜像 金步国作品集 refactoring 工具达人 Library genesis Google 开源项目风格指南 C语言中文网 公众号 Markdown 编辑器 网站检测 360 安全规则集合 菜鸟教程 apiref blogs GitHub 网盘 其他 一面之猿网 文叔叔 z-library 电子书 thisPointer 钛盘 迅捷画图 轻松传 在线流程图 airportal 地址信息生成 临时邮箱 云短信 视频压缩 在线抠图 ","date":"2023-01-15","objectID":"/posts/tools/blogs/tools_index/:0:0","tags":null,"title":"工具资源列表","uri":"/posts/tools/blogs/tools_index/"},{"categories":null,"content":"工具资源列表","date":"2023-01-15","objectID":"/tool/","tags":null,"title":"工具资源列表","uri":"/tool/"},{"categories":null,"content":" 在线搜索 常用网址 编程 工具导航站 学术资源 quora cppreference 我爱运营 scihub检1 scihub检2 动手学深度学习 cplusplus 及时工具 Oalib OpenCV c-cpp 果汁实验室 iData 开源软件汇总 purecpp 创造师导航 谷歌学术镜像 金步国作品集 refactoring 工具达人 Library genesis Google 开源项目风格指南 C语言中文网 公众号 Markdown 编辑器 网站检测 360 安全规则集合 菜鸟教程 blogs GitHub 网盘 其他 一面之猿网 文叔叔 z-library 电子书 thisPointer 钛盘 迅捷画图 轻松传 在线流程图 airportal 地址信息生成 临时邮箱 云短信 视频压缩 在线抠图 ","date":"2023-01-15","objectID":"/tool/:0:0","tags":null,"title":"工具资源列表","uri":"/tool/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Modern CMake 简体中文版 CMake菜谱（CMake Cookbook中文版） ARM SIMD 指令集：NEON 简介 现代的 CMake 现代的 CMake 。是 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！ 运行 CMake ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:0:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"设置选项 在 CMake 中，你可以使用 -D 设置选项。你能使用 -L 列出所有选项，或者用 -LH 列出人类更易读的选项列表。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:1:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"详细和部分的构建 我们已经提到了在构建时可以有详细输出，但你也可以看到详细的 CMake 配置输出。--trace 选项能够打印出运行的 CMake 的每一行。由于它过于冗长，CMake 3.7 添加了 --trace-source=\"filename\" 选项，这让你可以打印出你想看的特定文件运行时执行的每一行。如果你选择了要调试的文件的名称（在调试一个 CMakeLists.txt 时通常选择父目录，因为它们名字都一样），你就会只看到这个文件里运行的那些行。这很实用！ 1 2 cmake --trace --trace-source=\"filename\" .. make VERBOSE=1 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:2:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"选项 CMake 支持缓存选项。CMake 中的变量可以被标记为 “cached”，这意味着它会被写入缓存（构建目录中名为 CMakeCache.txt 的文件）。你可以在命令行中用 -D 预先设定（或更改）缓存选项的值。CMake 查找一个缓存的变量时，它就会使用已有的值并且不会覆盖这个值。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:3:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"标准选项 大部分软件包中都会用到以下的 CMake 选项： -DCMAKE_BUILD_TYPE= 从 Release， RelWithDebInfo， Debug， 或者可能存在的更多参数中选择。 -DCMAKE_INSTALL_PREFIX= 这是安装位置。UNIX 系统默认的位置是 /usr/local，用户目录是 ~/.local，也可以是你自己指定的文件夹。 -DBUILD_SHARED_LIBS= 你可以把这里设置为 ON 或 OFF 来控制共享库的默认值（不过，你也可以明确选择其他值而不是默认值） -DBUILD_TESTING= 这是启用测试的通用名称，当然不会所有软件包都会使用它，有时这样做确实不错。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:3:1","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"CMake 行为准则(Do’s and Don’ts) 基础知识简介 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:4:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"最低版本要求 1 cmake_minimum_required(VERSION 3.1) 从 CMake 3.12 开始，版本号可以声明为一个范围，例如 VERSION 3.1...3.15；这意味着这个工程最低可以支持 3.1 版本，但是也最高在 3.15 版本上测试成功过。 1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.7) if(${CMAKE_VERSION} VERSION_LESS 3.21) cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}) else() cmake_policy(VERSION 3.21) endif() ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:5:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"设置一个项目 1 2 3 project(MyProject VERSION 1.0 DESCRIPTION \"Very nice project\" LANGUAGES CXX) 这里的字符串是带引号的，因此内容中可以带有空格。项目名称是这里的第一个参数。所有的关键字参数都可选的。VERSION 设置了一系列变量，例如 MyProject_VERSION 和 PROJECT_VERSION。语言可以是 C,CXX,Fortran,ASM,CUDA(CMake 3.8+),CSharp(3.8+),SWIFT(CMake 3.15+ experimental)，默认是C CXX。在 CMake 3.9，可以通过DESCRIPTION 关键词来添加项目的描述。这个关于 project 的文档可能会有用。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:6:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"生成一个可执行文件 1 add_executable(one two.cpp three.h) one 既是生成的可执行文件的名称，也是创建的 CMake 目标(target)的名称。紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。在大多数情况下，头文件将会被忽略；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。你可以在 buildsystem 中找到更多关于一般构建系统与目标的信息。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:7:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"生成一个库 1 add_library(one STATIC two.cpp three.h) 你可以选择库的类型，可以是 STATIC,SHARED, 或者MODULE.如果你不选择它，CMake 将会通过BUILD_SHARED_LIBS 的值来选择构建 STATIC 还是 SHARED 类型的库。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:8:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"目标时常伴随着你 1 target_include_directories(one PUBLIC include) target_include_directories 为目标添加了一个目录。 PUBLIC 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。其他选项还有 PRIVATE（只影响当前目标，不影响依赖），以及 INTERFACE（只影响依赖）。 接下来我们可以将目标之间链接起来： 1 2 add_library(another STATIC another.cpp another.h) target_link_libraries(another PUBLIC one) target_link_libraries 可能是 CMake 中最有用也最令人迷惑的命令。它指定一个目标，并且在给出目标的情况下添加一个依赖关系。如果不存在名称为 one 的目标，那他会添加一个链接到你路径中 one 库（这也是命令叫 target_link_libraries 的原因）。或者你可以给定一个库的完整路径，或者是链接器标志。最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 PUBLIC 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。 只要记得在任何使用目标的地方都指定关键字，那么就不会有问题。 目标可以有包含的目录、链接库（或链接目标）、编译选项、编译定义、编译特性等等。正如你将在之后的两个项目章节中看到的，你经常可以得到目标（并且经常是指定目标）来代表所有你使用的库。甚至有些不是真正的库，像 OpenMP，就可以用目标来表示。这也是为什么现代 CMake 如此的棒！ ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:9:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"更进一步 1 2 3 4 5 6 7 8 9 10 cmake_minimum_required(VERSION 3.8) project(Calculator LANGUAGES CXX) add_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp) target_include_directories(calclib PUBLIC include) target_compile_features(calclib PUBLIC cxx_std_11) add_executable(calc apps/calc.cpp) target_link_libraries(calc PUBLIC calclib) 为 CMake 项目添加特性 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:10:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"默认的构建类型 1 2 3 4 5 6 7 8 9 set(default_build_type \"Release\") if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES) message(STATUS \"Setting build type to '${default_build_type}' as none was specified.\") set(CMAKE_BUILD_TYPE \"${default_build_type}\" CACHE STRING \"Choose the type of build.\" FORCE) # Set the possible values of build type for cmake-gui set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\") endif() 为 CMake 项目添加选项 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:11:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"地址无关代码(Position independent code) 用标志 -fPIC 来设置这个是最常见的。大部分情况下，你不需要去显式的声明它的值。CMake 将会在 SHARED 以及 MODULE 类型的库中自动的包含此标志。如果你需要显式的声明，可以这么写： 1 set(CMAKE_POSITION_INDEPENDENT_CODE ON) 这样会对全局的目标进行此设置，或者可以这么写： 1 set_target_properties(lib1 PROPERTIES POSITION_INDEPENDENT_CODE ON) 来对某个目标进行设置是否开启此标志。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:12:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"Little libraries 如果你需要链接到 dl 库，在 Linux 上可以使用 -ldl 标志，不过在 CMake 中只需要在 target_link_libraries 命令中使用内置的 CMake 变量 ${CMAKE_DL_LIBS} 。这里不需要模组或者使用 find_package 来寻找它。（这个命令包含了调用 dlopen 与 dlclose 的一切依赖） 不幸的是，想要链接到数学库没这么简单。如果你需要明确地链接到它，你可以使用 target_link_libraries(MyTarget PUBLIC m)，但是使用 CMake 通用的 find_library 可能更好，如下是一个例子： 1 2 3 4 find_library(MATH_LIBRARY m) if(MATH_LIBRARY) target_link_libraries(MyTarget PUBLIC ${MATH_LIBRARY}) endif() 通过快速搜索，你可以很容易地找到这个和其他你需要的库的 Find*.cmake 文件，大多数主要软件包都具有这个 CMake 模组的辅助库 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:13:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"程序间优化(Interprocedural optimization) INTERPROCEDURAL_OPTIMIZATION，最有名的是 链接时间优化 以及 -flto 标志，这在最新的几个 CMake 版本中可用。你可以通过变量 CMAKE_INTERPROCEDURAL_OPTIMIZATION（ CMake 3.9+ 可用）或对目标指定 INTERPROCEDURAL_OPTIMIZATION 属性来打开它。在 CMake 3.8 中添加了对 GCC 及 Clang 的支持。如果你设置了 cmake_minimum_required(VERSION 3.9) 或者更高的版本（参考 CMP0069），当在编译器不支持 INTERPROCEDURAL_OPTIMIZATION 时，通过变量或属性启用该优化会产生报错。你可以使用内置模块 CheckIPOSupported 中的 check_ipo_supported() 来检查编译器是否支持 IPO 。下面是基于 CMake 3.9 的一个例子： 1 2 3 4 5 include(CheckIPOSupported) check_ipo_supported(RESULT result) if(result) set_target_properties(foo PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE) endif() CCache 和一些其他的实用工具 CMake 中一些有用的模组","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:14:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":null,"content":"使用清华源 1 2 pip3 install numpy -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip3 install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple/ ","date":"0001-01-01","objectID":"/posts/program/python/0_python%E5%8C%85%E5%AE%89%E8%A3%85/:1:0","tags":null,"title":"","uri":"/posts/program/python/0_python%E5%8C%85%E5%AE%89%E8%A3%85/"}]