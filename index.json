[{"categories":["计算机视觉"],"content":"ffmpeg介绍及使用","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 安装 测试 应用 ffmpeg 使用 ffmpeg 常用脚本 H264 转 PNG/jpg PNG/jpg 转 MP4 按帧数剪切视频 按赛时间剪切视频 视频转换 提取视频 视频和合成 修改帧率 提取音频 码率控制 安装 安装 1 2 3 4 5 sudo add-apt-repository ppa:mc3man/trusty-media sudo apt-get update sudo apt-get dist-upgrade sudo apt-get install ffmpeg 查看版本 1 ffmpeg -version 输出 1 2 3 4 5 6 7 8 9 10 11 12 ffmpeg version 3.4.8-0ubuntu0.2 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 7 (Ubuntu 7.5.0-3ubuntu1~18.04) configuration: --prefix=/usr --extra-version=0ubuntu0.2 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --enable-gpl --disable-stripping --enable-avresample --enable-avisynth --enable-gnutls --enable-ladspa --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librubberband --enable-librsvg --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-omx --enable-openal --enable-opengl --enable-sdl2 --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-chromaprint --enable-frei0r --enable-libopencv --enable-libx264 --enable-shared libavutil 55. 78.100 / 55. 78.100 libavcodec 57.107.100 / 57.107.100 libavformat 57. 83.100 / 57. 83.100 libavdevice 57. 10.100 / 57. 10.100 libavfilter 6.107.100 / 6.107.100 libavresample 3. 7. 0 / 3. 7. 0 libswscale 4. 8.100 / 4. 8.100 libswresample 2. 9.100 / 2. 9.100 libpostproc 54. 7.100 / 54. 7.100 测试 1 ffmpeg -i GstTest.mp4 output.avi 输出： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 ffmpeg version 4.2.4-1ubuntu0.1 Copyright (c) 2000-2020 the FFmpeg developers built with gcc 9 (Ubuntu 9.3.0-10ubuntu2) configuration: --prefix=/usr --extra-version=1ubuntu0.1 --toolchain=hardened --libdir=/usr/lib/x86_64-linux-gnu --incdir=/usr/include/x86_64-linux-gnu --arch=amd64 --enable-gpl --disable-stripping --enable-avresample --disable-filter=resample --enable-avisynth --enable-gnutls --enable-ladspa --enable-libaom --enable-libass --enable-libbluray --enable-libbs2b --enable-libcaca --enable-libcdio --enable-libcodec2 --enable-libflite --enable-libfontconfig --enable-libfreetype --enable-libfribidi --enable-libgme --enable-libgsm --enable-libjack --enable-libmp3lame --enable-libmysofa --enable-libopenjpeg --enable-libopenmpt --enable-libopus --enable-libpulse --enable-librsvg --enable-librubberband --enable-libshine --enable-libsnappy --enable-libsoxr --enable-libspeex --enable-libssh --enable-libtheora --enable-libtwolame --enable-libvidstab --enable-libvorbis --enable-libvpx --enable-libwavpack --enable-libwebp --enable-libx265 --enable-libxml2 --enable-libxvid --enable-libzmq --enable-libzvbi --enable-lv2 --enable-omx --enable-openal --enable-opencl --enable-opengl --enable-sdl2 --enable-libdc1394 --enable-libdrm --enable-libiec61883 --enable-nvenc --enable-chromaprint --enable-frei0r --enable-libx264 --enable-shared libavutil 56. 31.100 / 56. 31.100 libavcodec 58. 54.100 / 58. 54.100 libavformat 58. 29.100 / 58. 29.100 libavdevice 58. 8.100 / 58. 8.100 libavfilter 7. 57.100 / 7. 57.100 libavresample 4. 0. 0 / 4. 0. 0 libswscale 5. 5.100 / 5. 5.100 libswresample 3. 5.100 / 3. 5.100 libpostproc 55. 5.100 / 55. 5.100 Input #0, mov,mp4,m4a,3gp,3g2,mj2, from 'GstTest.mp4': Metadata: major_brand : mp42 minor_version : 0 compatible_brands: mp42isom creation_time : 2020-07-26T12:09:43.000000Z Duration: 00:00:09.17, start: 0.000000, bitrate: 900 kb/s Stream #0:0(und): Audio: aac (LC) ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:0:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"ffmpeg 使用 1 2 3 4 5 6 7 8 9 10 ffmpeg {1} {2} -i {3} {4} {5} ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ... $ ffmpeg \\ [全局参数] \\ [输入文件参数] \\ -i [输入文件] \\ [输出文件参数] \\ [输出文件] ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:1:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"ffmpeg 常用脚本 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:0","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"H264 转 PNG/jpg 1 2 3 4 5 ffmpeg -i ../20200910162907037_dir.h264 -r 10 -f image2 h264_%03d.png ffmpeg -i ../20200910162907037_dir.h264 -r 10 -f image2 h264_%03d.jpg ffmpeg -i ../20200909145247237_dir.h264 -r 25 -f image2 h264_%03d.jpg ffmpeg -i ../*.h264 -r 25 -f image2 h264_%03d.png ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:1","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"PNG/jpg 转 MP4 1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/bash # Convert a series of png images to into an mp4 movie. # # On OSX you can use \"brew install ffmpeg\" to install ffmpeg # -r 10 means 10 fps # -crf 20 determines the quality 0 = lossless, 23 = default # -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" is to deal with widths and heights not divisible by 2 # -pix_fmt yuv420p is for compatibility with QuickTime and other old players. Drop it if you only use VLC or something modern. # -i \"movie%04d.png\" is a placeholder for movie0000.png, movie0001.png, ... ffmpeg -r 10 -i \"movie%04d.png\" -c:v libx264 -crf 20 -vf \"scale=trunc(iw/2)*2:trunc(ih/2)*2\" -pix_fmt yuv420p imovie2.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:2","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"按帧数剪切视频 1 2 3 ffmpeg -i ./20200909080831116_dir.h264 -vf \"select=between(n\\,1150\\,1450)\" -y -acodec copy ./output.h264 # \"select=between(n\\,1150\\,1450)\" 1150 起始帧 1450 结束帧 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:3","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"按赛时间剪切视频 1 2 3 # 下面的命令，可以从时间为00:00:15开始，截取5秒钟的视频。 ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4 # -ss表示开始切割的时间，-t表示要切多少。上面就是从15秒开始，切5秒钟出来。 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:4","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"视频转换 1 2 3 ffmpeg -i output.h264 -vcodec copy -f mp4 test.mp4 ffmpeg -i input.avi output.mp4 ffmpeg -i input.mp4 output.ts ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:5","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"提取视频 1 ffmpeg -i input.mp4 -vcodec copy -an output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:6","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"视频和合成 1 ffmpeg -i output.h264 -i T1-OUT.oni.h264 -filter_complex \"[0:v]pad=iw*2:ih*1[a];[a][1:v]overlay=w\" out.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:7","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"修改帧率 1 ffmpeg -i input.mp4 -vcodec copy -an output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:8","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"提取音频 1 2 3 ffmpeg -i test.mp4 -acodec copy -vn output.aac # 上面的命令，默认mp4的audio codec是aac,如果不是，可以都转为最常见的aac。 ffmpeg -i test.mp4 -acodec aac -vn output.aac ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:9","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["计算机视觉"],"content":"码率控制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。 那么，什么是码率？很简单： bitrate = file size / duration 比如一个文件20.8M，时长1分钟，那么，码率就是： biterate = 20.8M bit/60s = 20.8*1024*1024*8 bit/60s= 2831Kbps 一般音频的码率只有固定几种，比如是128Kbps， 那么，video的就是 video biterate = 2831Kbps -128Kbps = 2703Kbps。 那么ffmpeg如何控制码率。 ffmpg控制码率有3种选择，-minrate -b:v -maxrate -b:v主要是控制平均码率。 比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。 ffmpeg -i input.mp4 -b:v 2000k output.mp4 上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。 不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize -bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好） ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4 -minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。 ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4 ","date":"2023-02-01","objectID":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/:2:10","tags":["multimedia"],"title":"multimedia:ffmpeg介绍及使用","uri":"/posts/computer_vision/multimedia/ffmpeg/ffmpeg/"},{"categories":["cpp"],"content":"C++ 并行开发介绍","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 参考资料 code 并发与并行 多进程并发 多线程并发 C++中的并发与多线程 thread std::thread std:🧵:join std:🧵:joinable std:🧵:detach ~thread()分析 Mutex Mutex 系列类(四种) Lock 类（两种） 其他类型 mutex函数 std::recursive_mutex std::time_mutex std::recursive_timed_mutex lock_guard / unique_lock std::lock_guard std::unique_lock 注意 多线程下生产者消费者模型 单生产者-单消费者模型 单生产者-多消费者模型 多生产者-单消费者模型 多生产者-多消费者模型 future std::future 资料 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:0:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"参考资料 C++11并发之std::thread 基于C++11并发库的线程池与消息队列多线程框架——std::thread类 C++11 并发指南一(C++11 多线程初探) [c++11]多线程编程(五)——unique_lock ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:1:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"code CplusParallel 并发与并行 并发：同一时间段内可以交替处理多个操作 并行：同一时间段内同时处理多个操作 如果程序的结构设计为可以并发执行的，那么在支持并行的机器上，程序可以并行地执行。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:2:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多进程并发 多个进程独立地运行，它们之间通过进程间常规的通信渠道传递讯息（信号，套接字，文件，管道等），这种进程间通信不是设置复杂就是速度慢，这是因为为了避免一个进程去修改另一个进程，操作系统在进程间提供了一定的保护措施，当然，这也使得编写安全的并发代码更容易。运行多个进程也需要固定的开销：进程的启动时间，进程管理的资源消耗。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:3:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多线程并发 在当个进程中运行多个线程也可以并发。线程就像轻量级的进程，每个线程相互独立运行，但它们共享地址空间，所有线程访问到的大部分数据如指针、对象引用或其他数据可以在线程之间进行传递，它们都可以访问全局变量。进程之间通常共享内存，但这种共享通常难以建立且难以管理，缺少线程间数据的保护。因此，在多线程编程中，我们必须确保每个线程锁访问到的数据是一致的。 C++中的并发与多线程 C++11标准提供了一个新的线程库，内容包括了管理线程、保护共享数据、线程间的同步操作、低级原子操作等各种类。 1 2 3 4 5 \u003cthread\u003e : 包含std::thread类以及std::this_thread命名空间。管理线程的函数和类在该头文件中有声明； \u003catomic\u003e :包含std::atomic和std::atomic_flag类，以及一套C风格的原子类型和与C兼容的原子操作的函数； \u003cmutex\u003e ：包含了与互斥量相关的类以及其他类型的函数； \u003cfuture\u003e: 包含两个Provider类（std::promise和std::package_task）和两个Future类（std::future和std::shared_future）以及相关的类型和函数； \u003ccondition_variable\u003e : 包含与条件变量相关的类，包括std::condition_variable和std::condition_variable_any thread ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:4:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::thread 1 2 3 4 5 int n = 0; std::thread t1; // t1 is not a thread std::thread t2(f1, n + 1); // pass by value std::thread t3(f2, std::ref(n)); // pass by reference std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:5:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:join join 是让当前主线程等待所有的子线程执行完，才能退出。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:6:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:joinable 用于检测线程是否有效,true : 代表该线程是可执行线程 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:7:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std:🧵:detach 线程 detach 脱离主线程的绑定，主线程挂了，子线程不报错，子线程执行完自动退出。 线程 detach以后，子线程会成为孤儿线程，线程之间将无法通信。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:8:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"~thread()分析 1 2 3 4 ~thread() _NOEXCEPT { // 析构函数 if (joinable()) // 线程是可结合的(可执行线程)，析构异常（也就是说只能析构不可结合的线程） _XSTD terminate(); // terminate会调用abort()来终止程序 } joinable() = false : 空线程 move后的线程，即move(t),则t是不可结合的 join后的线程 detach后的线程 Mutex std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:9:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"Mutex 系列类(四种) 1 2 3 4 std::mutex，最基本的 Mutex 类。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:10:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"Lock 类（两种） 1 2 std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。 std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:11:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"其他类型 1 2 3 4 std::once_flag std::adopt_lock_t std::defer_lock_t std::try_to_lock_t ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:12:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"mutex函数 构造函数 std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 std::try_lock 尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::lock 可以同时对多个互斥量上锁。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 std::unlock 解锁，释放对互斥量的所有权。 std::call_once 如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:13:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::recursive_mutex std::recursive_mutex 与 std::mutex 一样，也是一种可以被上锁的对象，但是和 std::mutex 不同的是，std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁），来获得对互斥量对象的多层所有权，std::recursive_mutex 释放互斥量时需要调用与该锁层次深度相同次数的 unlock()，可理解为 lock() 次数和 unlock() 次数相同，除此之外，std::recursive_mutex 的特性和 std::mutex 大致相同。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:14:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::time_mutex std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数 接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 try_lock_until 函数 接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:15:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::recursive_timed_mutex 和 std:recursive_mutex 与 std::mutex 的关系一样，std::recursive_timed_mutex 的特性也可以从 std::timed_mutex 推导出来。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:16:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"lock_guard / unique_lock ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::lock_guard 与 Mutex RAII 相关，方便线程对互斥量上锁。 其原理是：声明一个局部的lock_guard对象，在其构造函数中进行加锁，在其析构函数中进行解锁。最终的结果就是：在定义该局部对象的时候加锁（调用构造函数），出了该对象作用域的时候解锁（调用析构函数）。 使用方法: 首先需要包含mutex头文件 然后创建一个锁 std::mutex mutex 在需要被加锁的作用域内 将mutex传入到创建的std::lock_guard局部对象中 1 2 3 4 5 6 7 8 9 10 11 12 #include \u003cmutex\u003e /*std::mutex、 std::lock_guard*/ std::mutex mutex; void func() { //lock_guard 互斥锁 作用域内不可拷贝构造 { std::lock_guard\u003cstd::mutex\u003e lg(m_mutex); //函数内容 } } ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:1","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::unique_lock 与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 互斥锁保证了线程间的同步，但是却将并行操作变成了串行操作，这对性能有很大的影响，所以我们要尽可能的减小锁定的区域，也就是使用细粒度。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class LogFile { std::mutex _mu; ofstream f; public: LogFile() { f.open(\"log.txt\"); } ~LogFile() { f.close(); } void shared_print(string msg, int id) { { std::lock_guard\u003cstd::mutex\u003e guard(_mu); //do something 1 } //do something 2 { std::lock_guard\u003cstd::mutex\u003e guard(_mu); // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; } } }; 上面的代码中，一个函数内部有两段代码需要进行保护，这个时候使用lock_guard就需要创建两个局部对象来管理同一个互斥锁（其实也可以只创建一个，但是锁的力度太大，效率不行），修改方法是使用unique_lock。它提供了lock()和unlock()接口，能记录现在处于上锁还是没上锁状态，在析构的时候，会根据当前状态来决定是否要进行解锁（lock_guard就一定会解锁）。上面的代码修改如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class LogFile { std::mutex _mu; ofstream f; public: LogFile() { f.open(\"log.txt\"); } ~LogFile() { f.close(); } void shared_print(string msg, int id) { std::unique_lock\u003cstd::mutex\u003e guard(_mu); //do something 1 guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; // 结束时析构guard会临时解锁 // 这句话可要可不要，不写，析构的时候也会自动执行 // guard.ulock(); } }; 上面的代码可以看到，在无需加锁的操作时，可以先临时释放锁，然后需要继续保护的时候，可以继续上锁，这样就无需重复的实例化lock_guard对象，还能减少锁的区域。同样，可以使用std::defer_lock设置初始化的时候不进行默认的上锁操作： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void shared_print(string msg, int id) { std::unique_lock\u003cstd::mutex\u003e guard(_mu, std::defer_lock); //do something 1 guard.lock(); // do something protected guard.unlock(); //临时解锁 //do something 2 guard.lock(); //继续上锁 // do something 3 f \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; cout \u003c\u003c msg \u003c\u003c id \u003c\u003c endl; // 结束时析构guard会临时解锁 } 这样使用起来就比lock_guard更加灵活！然后这也是有代价的，因为它内部需要维护锁的状态，所以效率要比lock_guard低一点，在lock_guard能解决问题的时候，就是用lock_guard，反之，使用unique_lock。 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:2","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"注意 unique_lock和lock_guard都不能复制，lock_guard不能移动，但是unique_lock可以。 1 2 3 4 5 6 7 8 9 // unique_lock 可以移动，不能复制 std::unique_lock\u003cstd::mutex\u003e guard1(_mu); std::unique_lock\u003cstd::mutex\u003e guard2 = guard1; // error std::unique_lock\u003cstd::mutex\u003e guard2 = std::move(guard1); // ok // lock_guard 不能移动，不能复制 std::lock_guard\u003cstd::mutex\u003e guard1(_mu); std::lock_guard\u003cstd::mutex\u003e guard2 = guard1; // error std::lock_guard\u003cstd::mutex\u003e guard2 = std::move(guard1); // error 多线程下生产者消费者模型 ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:17:3","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"单生产者-单消费者模型 单生产者-单消费者模型中只有一个生产者和一个消费者，生产者不停地往产品库中放入产品，消费者则从产品库中取走产品，产品库容积有限制，只能容纳一定数目的产品，如果生产者生产产品的速度过快，则需要等待消费者取走产品之后，产品库不为空才能继续往产品库中放置新的产品，相反，如果消费者取走产品的速度过快，则可能面临产品库中没有产品可使用的情况，此时需要等待生产者放入一个产品后，消费者才能继续工作。 code:SingleProducer-SingleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:18:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"单生产者-多消费者模型 与单生产者和单消费者模型不同的是，单生产者-多消费者模型中可以允许多个消费者同时从产品库中取走产品。所以除了保护产品库在多个读写线程下互斥之外，还需要维护消费者取走产品的计数器。 code:SingleProducer-MultipleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:19:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多生产者-单消费者模型 与单生产者和单消费者模型不同的是，多生产者-单消费者模型中可以允许多个生产者同时向产品库中放入产品。所以除了保护产品库在多个读写线程下互斥之外，还需要维护生产者放入产品的计数器。 code:MultipleProducer-SingleConsumer ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:20:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"多生产者-多消费者模型 该模型可以说是前面两种模型的综合，程序需要维护两个计数器，分别是生产者已生产产品的数目和消费者已取走产品的数目。另外也需要保护产品库在多个生产者和多个消费者互斥地访问。 code:MultipleProducer-MultipleConsumer future thread对象，它是C++11中提供异步创建多线程的工具。但是我们想要从线程中返回异步任务结果，一般需要依靠全局变量；从安全角度看，有些不妥；为此C++11提供了std::future类模板，future对象提供访问异步操作结果的机制，很轻松解决从异步任务中返回结果。 在C++标准库中，有两种“期望”，使用两种类型模板实现: 唯一期望(unique futures，std::future\u003c\u003e) std::future的实例只能与一个指定事件相关联。 共享期望(shared futures)(std::shared_future\u003c\u003e) std::shared_future的实例就能关联多个事件。 future 头文件中包含了以下几个类和函数： Providers 类：std::promise, std::package_task Futures 类：std::future, shared_future. Providers 函数：std::async() 其他类型：std::future_error, std::future_errc, std::future_status, std::launch. ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:21:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"std::future 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 //通过async来获取异步操作结果 std::future\u003cint\u003e result = std::async([](){ std::this_thread::sleep_for(std::chrono::milliseconds(500)); return 8; }); std::cout \u003c\u003c \"the future result : \" \u003c\u003c result.get() \u003c\u003c std::endl; std::cout \u003c\u003c \"the future status : \" \u003c\u003c result.valid() \u003c\u003c std::endl; try { result.wait(); //或者 result.get() ,会异常 //因此std::future只能用于单线程中调用 ，多线程调用使用std::share_future(); } catch (...) { std::cout \u003c\u003c \"get error....\\n \"; } ","date":"2023-01-31","objectID":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/:22:0","tags":["cpp thread"],"title":"C++:并行开发","uri":"/posts/program/cpp/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B/c++%E5%B9%B6%E8%A1%8C%E5%BC%80%E5%8F%91/"},{"categories":["cpp"],"content":"C++部分编译几运行期的错误收集","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/","tags":["cpp"],"title":"C++:错误收集","uri":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 basic_string::_M_construct 1 2 3 terminate called after throwing an instance of 'std::logic_error' what(): basic_string::_M_construct null not valid Aborted (core dumped) string构造不能传入空指针xxx，即在xxx为空时会报上面错误，保证func返回不为空即可。 多态失效问题的 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class vehicle{ public: void run(){ std::cout\u003c\u003c\"from vehicle:run\"\u003c\u003cstd::endl; } }; class car:public vehicle{ public: void run(){ std::cout\u003c\u003c\"from car:public vehicle:run\"\u003c\u003cstd::endl; } }; void call_fun(vehicle *pvehicle){ pvehicle-\u003erun(); } int main(){ vehicle *_pvehicle = new vehicle(); car *_pcar = new car(); call_fun(_pvehicle); call_fun(_pcar); delete _pvehicle; delete _pcar; return 0; } 输出 1 2 from vehicle:run from vehicle:run 在C++中，如果在基类和派生类中对同一个函数都进行了定义时，通过基类和派生类指针对象调用成员函数时具体是执行哪一个类实例的成员函数是根据接口函数的参数类型而定，而不是实际的类实例指针对象。 C++ const函数返回值必须为const引用 参考： C++ const函数返回值必须为const引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u003ciostream\u003e class MyString { public: MyString(std::string T):text(T){} const char\u0026 operator[](std::size_t position) const // operator[] for const 对象 { return text[position]; } char\u0026 operator[](std::size_t position) // operator[] for non-const 对象 { return text[position]; } private: std::string text; }; int main(){ MyString ms(\"coding\"); // non-const 对象 MyString test(\"testing\"); std::cout \u003c\u003c ms[0]\u003c\u003c std::endl; // 调用 non-const MyString::operator[] ms[0] = 'x'; // 没问题，写一个 non-const MyString const MyString cms(\"coding\"); // const 对象 std::cout \u003c\u003c cms[0]\u003c\u003cstd::endl; // 调用 const MyString::operator[] //cms[0] = 'x'; // 错误！ 写一个 const MyString } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/:0:0","tags":["cpp"],"title":"C++:错误收集","uri":"/posts/program/cpp/c++%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/"},{"categories":["开源软件"],"content":"CGraph 名词解释","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 扇入扇出 DAG 调度 Aspect(切面) AOP 检索算法 HNSW算法 ANNS算法 扇入扇出 在软件设计中，扇入和扇出的概念是指应用程序模块之间的层次调用情况。 按照结构化设计方法，一个应用程序是由多个功能相对独立的模块所组成。 扇入： 是指直接调用该模块的上级模块的个数；扇入大表示模块的复用程序高。 扇出： 是指该模块直接调用的下级模块的个数；扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好； 扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块； 扇出太小时可以把下级模块进一步分解成若干个子功能模块， 或者合并到它的上级模块中去。 DAG 调度 DAG : Directed acyclic graph (有向无环图)。 图中TaskB 算子输入参数依赖TaskA算子输出参数，Task C与 TaskA/TaskB算子相互独立可并行执行，最终所有计算结果在End处执行。 Aspect(切面) Aspect表示切面，给业务方法增加的功能，叫做切面。切面一般都是非业务功能，而且切面功能一般都是可以复用的。例如日志功能，事务功能，权限检查，参数检查，统计信息等等 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:0:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"AOP AOP：Aspect Oriented Programming（面向切面编程） Aspect：切面，指给业务方法增加的功能 JoinPoint：连接点，连接切面的业务方法，在这个业务方法执行时会同时执行切面的功能 Poingcut：切入点，是一个或多个连接点的集合，表示这些方法执行时都能增加切面的功能。。表示切面执行的位置(这里的位置不是指具体业务逻辑里执行切面的位置，是指哪些方法需要执行切面的位置) target：目标对象，给哪个对象增加切面的功能，这个对象就是目标对象 Advice：通知(增强)，表示切面的执行时间。在目标方法之前执行切面，还是目标方法之后执行切面 检索算法 程序员王同学 CSDN ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:1:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"HNSW算法 一文看懂HNSW算法理论的来龙去脉 HNSW算法—-Hierarchcal Navigable Small World graphs 。 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:2:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"ANNS算法 向量检索算法（ANNS）优化思路之我见 ANNS（Approximate Nearest Neighbor Search）算法，向量检索算法的。 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/:3:0","tags":["并行编程框架"],"title":"开源软件:CGraph 名词解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"CGraph 语法解释","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++ ()和{} CGraph 中使用 [[nodiscard]] friend class C++ ()和 cppreference.com : Punctuation （）用来表示函数调用，包括普通函数和构建函数，以及可以给内建类型初始化 1 int *p = new int[1000](); // 内建类型圆括号初始化是语法，是标准 {} 提供列表初始化的功能，最终调用的是构造函数 1 2 Point{} // 调用的是Point::Point()构造函数 Point{x, y} // 嗲用的是Point::Point(x, y)构造函数 构造一个匿名的类直接使用Point{}即可，它调用构造函数，但是是临时的，并没有名字指向它，调用完之后再无法找到这个匿名类。 ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:0:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["开源软件"],"content":"CGraph 中使用 1 2 3 /* 定义GElementPtr类型的变量 */ GElementPtr a, b, c, d = nullptr; status += pipeline-\u003eregisterGElement\u003cMyNode2\u003e(\u0026d, {b, c}, \"nodeD\"); // 将名为nodeD，依赖{b,c}执行的node信息，注册入pipeline中 函数原型： 1 2 3 4 5 template\u003ctypename T, CLevel level, c_enable_if_t\u003cstd::is_base_of\u003cGElement, T\u003e::value, int\u003e\u003e CStatus GPipeline::registerGElement(GElementPtr *elementRef, const GElementPtrSet \u0026dependElements, const std::string \u0026name, CSize loop) GElementPtrSet 定义： 1 using GElementPtrSet = std::set\u003cGElementPtr\u003e; 所以这里 pipeline-\u003eregisterGElement\u003cMyNode2\u003e(\u0026d, {b, c}, \"nodeD\"); 是使用 b, c 直接构造了 GElementPtrSet 作为函数参数。 [[nodiscard]] friend class ","date":"2023-01-30","objectID":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/:1:0","tags":["并行编程框架"],"title":"开源软件:CGraph 语法解释","uri":"/posts/open_source_software/parallel_computing/cgraph/cgraph-cgraph-%E8%AF%AD%E6%B3%95%E8%A7%A3%E9%87%8A/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 认识 lambda Lambda 语法分析 [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u003e 返回值类型 {函数体} 示例 示例 1 示例 2 示例 3 总结 资料 代码及编译 认识 lambda C++ 11 中的 Lambda 表达式用于定义并创建匿名的函数对象，以简化编程工作。 Lambda 的语法形式如下： 1 [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -\u003e 返回值类型 {函数体} 可以看到，Lambda 主要分为五个部分：[函数对象参数]、(操作符重载函数参数)、mutable 或 exception 声明、-\u003e 返回值类型、{函数体}. Lambda 语法分析 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"[函数对象参数] 标识一个 Lambda 表达式的开始，这部分必须存在，不能省略。函数对象参数是传递给编译器自动生成的函数对象类的构造 函数的。函数对象参数只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的局部变量(包括 Lambda 所在类的 this)。函数对象参数有以下形式： 空。没有任何函数对象参数。 =。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。 \u0026。函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。 this。函数体内可以使用 Lambda 所在类中的成员变量。 a。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要 修改传递进来的拷贝，可以添加 mutable 修饰符。 \u0026a。将 a 按引用进行传递。 a，\u0026b。将 a 按值传递，b 按引用进行传递。 =，\u0026a，\u0026b。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。 \u0026，a，b。除 a 和 b 按值进行传递外，其他参数都按引用进行传递。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"(操作符重载函数参数) 标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (\u0026a, \u0026b)) 两种方式进行传递。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"mutable 或 exception 声明 这部分可以省略。按值传递函数对象参数时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"-\u003e 返回值类型 标识函数返回值的类型，当返回值为 void，或者函数体中只有一处 return 的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:4:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"{函数体} 标识函数的实现，这部分不能省略，但函数体可以为空。 示例 1 2 3 4 [] (int x, int y) { return x + y; } // 隐式返回类型 [] (int\u0026 x) { ++x; } // 没有 return 语句 -\u003e Lambda 函数的返回类型是 'void' [] () { ++global_x; } // 没有参数，仅访问某个全局变量 [] { ++global_x; } // 与上一个相同，省略了 (操作符重载函数参数) 可以像下面这样显示指定返回类型： 1 [] (int x, int y) -\u003e int { int z = x + y; return z; } 在这个例子中创建了一个临时变量 z 来存储中间值。和普通函数一样，这个中间值不会保存到下次调用。什么也不返回的Lambda 函数可以省略返回类型，而不需要使用 -\u003e void 形式。 Lambda 函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在 Lambda 表达式声明中的方括号 [] 内。这个机制允许这些变量被按值或按引用捕获。如下例子： 1 2 3 4 5 6 [] //未定义变量.试图在Lambda内使用任何外部变量都是错误的. [x, \u0026y] //x 按值捕获, y 按引用捕获. [\u0026] //用到的任何外部变量都隐式按引用捕获 [=] //用到的任何外部变量都隐式按值捕获 [\u0026, x] //x显式地按值捕获. 其它变量按引用捕获 [=, \u0026z] //z按引用捕获. 其它变量按值捕获 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:5:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 1 1 2 3 4 5 6 7 std::vector\u003cint\u003e some_list; int total = 0; for (int i = 0; i \u003c 5; ++i) some_list.push_back(i); std::for_each(begin(some_list), end(some_list), [\u0026total](int x) { total += x; }); 此例计算 list 中所有元素的总和。变量 total 被存为 Lambda 函数闭包的一部分。因为它是栈变量（局部变量）total 引用，所以可以改变它的值。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:6:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 2 1 2 3 4 5 6 7 std::vector\u003cint\u003e some_list; int total = 0; int value = 5; std::for_each(begin(some_list), end(some_list), [\u0026, value, this](int x) { total += x * value * this-\u003esome_func(); }); 此例中 total 会存为引用, value 则会存一份值拷贝。对 this 的捕获比较特殊，它只能按值捕获。this 只有当包含它的最靠近它的函数不是静态成员函数时才能被捕获。对 protect 和 private 成员来说，这个 Lambda 函数与创建它的成员函数有相同的访问控制。如果 this 被捕获了，不管是显式还是隐式的，那么它的类的作用域对 Lambda 函数就是可见的。访问 this 的成员不必使用 this-\u003e 语法，可以直接访问。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:7:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["cpp"],"content":"示例 3 泛型的 lambda在 C++14 里，lambda 表达式又多了一项新本领，可以实现“泛型化”，相当于简化了的模板函数，具体语法还是利用了“多才多艺”的 auto： 1 2 3 4 5 6 7 8 9 10 auto f = [](const auto\u0026 x) // 参数使用auto声明，泛型化 { return x + x; }; cout \u003c\u003c f(3) \u003c\u003c endl; // 参数类型是int cout \u003c\u003c f(0.618) \u003c\u003c endl; // 参数类型是double string str = \"matrix\"; cout \u003c\u003c f(str) \u003c\u003c endl; // 参数类型是string 这个新特性在写泛型函数的时候非常方便，摆脱了冗长的模板参数和函数参数列表。如果你愿意的话，可以尝试在今后的代码里都使用 lambda 来代替普通函数，能够少写很多代码。 总结 不同编译器的具体实现可以有所不同，但期望的结果是: 按引用捕获的任何变量，Lambda 函数实际存储的应该是这些变量在创建这个 Lambda 函数的函数的栈指针，而不是 Lambda 函数本身栈变量的引用。不管怎样，因为大多数 Lambda 函数都很小且在局部作用中，与候选的内联函数很类似，所以按引用捕获的那些变量不需要额外的存储空间。 因为 lambda 表达式是一个变量，所以，我们就可以“按需分配”，随时随地在调用点“就地”定义函数，限制它的作用域和生命周期，实现函数的局部化。 如果一个闭包含有局部变量的引用，在超出创建它的作用域之外的地方被使用的话，这种行为是未定义的! Lambda 函数是一个依赖于实现的函数对象类型,这个类型的名字只有编译器知道. 如果用户想把 lambda 函数做为一个参数来传递, 那么形参的类型必须是模板类型或者必须能创建一个 std::function 类似的对象去捕获 lambda 函数.使用 auto 关键字可以帮助存储 lambda 函数, 1 2 auto my_lambda_func = [\u0026](int x) { /* ... */ }; auto my_onheap_lambda_func = new auto([=](int x) { /* ... */ }); 这里有一个例子, 把匿名函数存储在变量、数组或 vector 中,并把它们当做命名参数来传递 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include \u003cfunctional\u003e #include \u003cvector\u003e #include \u003ciostream\u003e double eval(std::function \u003cdouble(double)\u003e f, double x = 2.0) { return f(x); } int main() { //explicit type std::function\u003cdouble(double)\u003e f0 = [](double x){return 1;}; //auto (deduced) type same as before auto f1 = [](double x){return x;}; decltype(f0) fa[3] = {f0,f1,[](double x){return x*x;}}; //Something like NSt3__18functionIFddEEE std::cout \u003c\u003c typeid(decltype(f0)).name() \u003c\u003c std::endl; std::vector\u003cdecltype(f0)\u003e fv = {f0,f1}; fv.push_back ([](double x){return x*x;}); for(int i=0;i\u003cfv.size();i++) std::cout \u003c\u003c fv[i](2.0) \u003c\u003c std::endl; for(int i=0;i\u003c3;i++) std::cout \u003c\u003c fa[i](2.0) \u003c\u003c std::endl; for(auto \u0026f : fv) std::cout \u003c\u003c f(2.0) \u003c\u003c std::endl; for(auto \u0026f : fa) std::cout \u003c\u003c f(2.0) \u003c\u003c std::endl; std::cout \u003c\u003c eval(f0) \u003c\u003c std::endl; std::cout \u003c\u003c eval(f1) \u003c\u003c std::endl; std::cout \u003c\u003c eval([](double x){return x*x;}) \u003c\u003c std::endl; return 0; } 一个没有指定任何捕获的 lambda 函数,可以显式转换成一个具有相同声明形式函数指针.所以,像下面这样做是合法的: 1 2 3 auto a_lambda_func = [](int x) { /* ... */ }; void (*func_ptr)(int) = a_lambda_func; func_ptr(4); // calls the lambda 资料 C++之Lambda表达式 罗剑锋的C++实战笔记 C语言实现C++多态——函数指针 代码及编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include\u003cfunctional\u003e #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; //lambda表达式简单案例 int main(){ //[函数对象参数]、(操作符重载函数参数)、mutable或exception声明、-\u003e返回值类型、{函数体 } auto fun1 = []()-\u003e int{cout \u003c\u003c\"hellochina\"\u003c\u003cendl; return 0;}; fun1(); auto fun2 = [](int a,int b){return a +b; }; cout \u003c\u003cfun2(10, 9) \u003c\u003cendl; std::cin.get(); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include\u003cfunctional\u003e #include\u003ciostream\u003e #include\u003cvector\u003e #include\u003calgorithm\u003e using namespace std; //lambda表达式简单案例 int main() { class __lambda_11_15 { public: inline int operator()() const { std::operator\u003c\u003c(std::cout, \"hellochina\").operator\u003c\u003c(std::endl); return 0; } using retType_11_15 = auto (*)() -\u003e int; inline operator retType_11_15 () const noexcept { return __invoke; }; private: static inline int __invoke() { std::operator\u003c\u003c(std::cout, \"hellochina\").operator\u003c\u003c(std::endl); return 0; } public: // inline /*constexpr */ __lambda_11_15(__lambda_11_15 \u0026\u0026) noexcept = default; }; __lambda_11_15 fun1 = __lambda_11_15(__lambda_11_15{}); fun1.operator()(); class __lambda_14_15 { public: inline int operator()(int a, int b) const { return a + b; } using retType_14_15 = int (*)(int, int); inline operator retType_14_15 () const noexcept { return __invoke; }; private: static inline int __invoke(int a, int b) { return a + b; } public: // inline /*constexpr */ __lambda_14_15(__lambda_14_15 \u0026\u0026) noexcept = default; }; __lambda_14_15 fun2 = __lambda_14_15(__lambda_14_15{}); std::cout.operator\u003c\u003c(fun2.operator()(10, 9)).operator\u003c\u003c(std::endl","date":"2023-01-30","objectID":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/:8:0","tags":["cpp"],"title":"C++:Lambda表达式","uri":"/posts/program/cpp/c++lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":["计算机视觉"],"content":"深度学习开发环境搭建","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 硬件环境 深度学习开发环境搭建 更改系统软件源 安装Python和pip 安装Nvidia显卡驱动 安装CUDA 安装CuDNN 安装Conda环境 什么是Conda 安装conda conda 简单使用 测试一下GPU训练 硬件环境 处理器：AMD® Ryzen 5 3600 6-core processor × 12 显卡：NVIDIA Corporation TU104 [GeForce RTX 2060] 内存：16G DDR4 硬盘：1T SSD 系统：Ubuntu 20.04.1 LTS 深度学习开发环境搭建 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"更改系统软件源 备份原来的源： 1 cp /etc/apt/sources.list /etc/apt/sources.list.bak 将源的内容设置为阿里云镜像： 1 sudo vim /etc/apt/sources.list 内容改为： 1 deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse 更新软件列表： 1 2 sudo apt update sudo apt upgrade ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Python和pip Ubuntu系统默认自带python，有版本需求的话也可以自己安装一下 1 sudo apt install python3sudo apt install python3-pip 不管是不是自己安装的python，替换python的pip源建议是一定操作一下的，pip安装速度会快很多： 1 cd ~mkdir .pip 直接新建并编辑pip.conf： 1 sudo vim ~/.pip/pip.conf 改为以下内容（这里用的清华源，也可以试一下阿里、豆瓣等源）： 1 [global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ [install]trusted-host = pypi.tuna.tsinghua.edu.cn 更改默认python版本，python目录默认链接的是python2，而现在基本都是用python3开发了 1 sudo apt install python-is-python3 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Nvidia显卡驱动 打开软件和更新 选择安装Nvidia官方驱动（第二个是开源驱动） 禁止nouveau 驱动 1 sudo gedit /etc/modprobe.d/blacklist.conf 添加 1 2 3 4 5 blacklist nouveau blacklist lbm-nouveau options nouveau modeset=0 alias nouveau off alias lbm-nouveau off 执行如下命令，更新系统，来禁用nouveau 1 sudo update-initramfs -u 重启完之后更新一下软件： 1 2 sudo apt update sudo apt upgrade 查看驱动 1 nvidia-smi 输出： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.102.04 Driver Version: 450.102.04 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 GeForce RTX 2060 Off | 00000000:26:00.0 On | N/A | | 0% 41C P8 7W / 160W | 675MiB / 5931MiB | 7% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| | 0 N/A N/A 908 G /usr/lib/xorg/Xorg 53MiB | | 0 N/A N/A 1457 G /usr/lib/xorg/Xorg 219MiB | | 0 N/A N/A 1585 G /usr/bin/gnome-shell 178MiB | | 0 N/A N/A 31707 G ...cent\\WeChat\\WeChatApp.exe 10MiB | | 0 N/A N/A 37422 G ...AAAAAAAA== --shared-files 36MiB | | 0 N/A N/A 42882 G ...AAAAAAAAA= --shared-files 48MiB | | 0 N/A N/A 44445 G ...AAAAAAAAA= --shared-files 104MiB | | 0 N/A N/A 45053 G gnome-control-center 3MiB | +-----------------------------------------------------------------------------+ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装CUDA 去官网下载cuda安装包：CUDA Toolkit 11.0 Download | NVIDIA Developer 运行下面的命令进行安装： 1 2 3 wget http://developer.download.nvidia.com/compute/cuda/11.0.2/local_installers/cuda_11.0.2_450.51.05_linux.run chmod +x cuda_11.0.2_450.51.05_linux.run sudo sh ./cuda_11.0.2_450.51.05_linux.run 根据上图提示需要配置环境变量： 1 gedit ~/.bashrc 再文件最后加入以下语句： 1 2 3 export CUDA_HOME=/usr/local/cuda-11.0 export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 export PATH=${CUDA_HOME}/bin:${PATH} 然后使其生效： 1 source ~/.bashrc 可以使用命令nvcc -V查看安装的版本信息： 1 2 3 4 5 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Thu_Jun_11_22:26:38_PDT_2020 Cuda compilation tools, release 11.0, V11.0.194 Build cuda_11.0_bu.TC445_37.28540450_0 也可以编译一个程序测试安装是否成功 找到 NVIDIA_CUDA-11.0_Samples 安装位置 1 locate NVIDIA_CUDA-11.0_Samples 1 2 3 cd NVIDIA_CUDA-11.0_Samples/1_Utilities/deviceQuery make ./deviceQuery 输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 ./deviceQuery Starting... CUDA Device Query (Runtime API) version (CUDART static linking) Detected 1 CUDA Capable device(s) Device 0: \"GeForce RTX 2060\" CUDA Driver Version / Runtime Version 11.0 / 11.0 CUDA Capability Major/Minor version number: 7.5 Total amount of global memory: 5931 MBytes (6219563008 bytes) (30) Multiprocessors, ( 64) CUDA Cores/MP: 1920 CUDA Cores GPU Max Clock rate: 1695 MHz (1.70 GHz) Memory Clock rate: 7001 Mhz Memory Bus Width: 192-bit L2 Cache Size: 3145728 bytes Maximum Texture Dimension Size (x,y,z) 1D=(131072), 2D=(131072, 65536), 3D=(16384, 16384, 16384) Maximum Layered 1D Texture Size, (num) layers 1D=(32768), 2048 layers Maximum Layered 2D Texture Size, (num) layers 2D=(32768, 32768), 2048 layers Total amount of constant memory: 65536 bytes Total amount of shared memory per block: 49152 bytes Total number of registers available per block: 65536 Warp size: 32 Maximum number of threads per multiprocessor: 1024 Maximum number of threads per block: 1024 Max dimension size of a thread block (x,y,z): (1024, 1024, 64) Max dimension size of a grid size (x,y,z): (2147483647, 65535, 65535) Maximum memory pitch: 2147483647 bytes Texture alignment: 512 bytes Concurrent copy and kernel execution: Yes with 3 copy engine(s) Run time limit on kernels: Yes Integrated GPU sharing Host Memory: No Support host page-locked memory mapping: Yes Alignment requirement for Surfaces: Yes Device has ECC support: Disabled Device supports Unified Addressing (UVA): Yes Device supports Managed Memory: Yes Device supports Compute Preemption: Yes Supports Cooperative Kernel Launch: Yes Supports MultiDevice Co-op Kernel Launch: Yes Device PCI Domain ID / Bus ID / location ID: 0 / 38 / 0 Compute Mode: \u003c Default (multiple host threads can use ::cudaSetDevice() with device simultaneously) \u003e deviceQuery, CUDA Driver = CUDART, CUDA Driver Version = 11.0, CUDA Runtime Version = 11.0, NumDevs = 1 Result = PASS ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装CuDNN 进入到CUDNN的下载官网： cuDNN Download | NVIDIA Developer，登陆下载 下载之后是一个压缩包，对它进行解压，命令如下： 1 tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz 使用以下两条命令复制这些文件到CUDA目录下： 1 sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/ sudo cp cuda/include/* /usr/local/cuda-11.0/include/ 拷贝完成之后，可以使用以下命令查看CUDNN的版本信息： 1 cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 输出 1 2 3 4 5 6 7 #define CUDNN_MAJOR 8 #define CUDNN_MINOR 0 #define CUDNN_PATCHLEVEL 4 -- #define CUDNN_VERSION (CUDNN_MAJOR * 1000 + CUDNN_MINOR * 100 + CUDNN_PATCHLEVEL) #endif /* CUDNN_VERSION_H */ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装Conda环境 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"什么是Conda Conda是Python中用于管理包和环境的一大利器。使用Conda，我们还可以非常便利的使用数据科学相关的包。Conda可以帮助我们创建虚拟环境，从而方便的应用于多个项目中。 Anaconda实际上是一个软件的发行版，附带了Conda、python和150多个科学软件包及其相关的包。Conda是一个包和环境管理器。Anaconda是一个本身很大（大约500M），因为它附带了Python中最常见的数据科学包。如果您不需要所有的软件包，或者需要节省带宽或存储空间，那么也有miniconda，一个只包含conda和python的发行版。我们同样可以用Conda安装任何可用的软件包。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:1","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"安装conda 在Anaconda官网下载Linux安装包：Anaconda | Individual Edition 运行下面的命令安装： 1 2 chmod +x Anaconda3-2020.11-Linux-x86_64.sh ./Anaconda3-2020.11-Linux-x86_64.sh 一路按ENTER确认，然后根据提示输入yes，这里我为了目录整洁不安装在默认路径，设置为下面的路径：/home/zyh/app/anaconda3 然后会询问你是否要初始化conda，输入yes确认，重开终端窗口之后，就可以看到conda环境可用了 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:2","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"conda 简单使用 **包管里 ** 当我们成功安装anaconda后，我们可以很容易的使用conda来进行包管理。例如： 1 conda install numpy 除了每次安装一个包外，我们还可以一次性安装多个包，例如： 1 conda install numpy pandas 此外，我们还可以安装某个指定版本的包： 1 conda install numpy=1.10 Ps：使用conda安装指定包时，conda可以自动处理相关的包依赖。假设本身没有安装numpy时，若我们使用conda install scipy，则此时conda会自动安装numpy，因为scipy本身依赖numpy。 此外，conda还有一些其他的常用命令： 删除某个包：conda remove package_name 升级某个包：conda upgrade package_name 升级全部包：conda upgrade --all 查看包列表：conda list 模糊查询包：conda search 'keywords' **环境管里 ** conda可以用于创建多个环境而从进行项目隔离。 创建一个新的环境的格式如下： 1 conda create -n env_name list_of_packages 其中，-n后的参数env_name表示环境名称。 接着可以跟着0个或多个包名称。 一个示例如下： 1 conda create -n my_env numpy 表示创建了一个新的环境：my_env。并同时在该环境中安装一个包：numpy。 此外，在创建环境时，我们可以指定Python的版本。例如： 1 conda create -n my_env python=2.7 其中，我们可以在conda命令中，增加python=x的信息用于指定Python的版本号。 此时，我们可以轻松的实现在一台机器上兼容Python2和Python3了。 当我们使用conda创建了一个新的环境后，可以使用如下命令进入该环境： 1 conda activate env_name 此时，当我们进行该环境后，可以看命令行中的引导符中已经提示出了当前所属的conda环境： 1 conda list 想要离开当前环境时，则只需要执行如下命令即可： 1 conda deactivate 环境的保存与加载 对于conda环境，其有着一个如下特性：环境共享。 通过以配置文件的形式可以保存环境相关的全部信息。 我们可以使用如下命令将相关的环境信息保存在一个yaml文件中： 1 conda env export \u003e env.yaml 此时，我们已经将当前环境相关的信息全部存储在env.yaml文件中。当我们希望在其他机器中创建一个相同的环境时，可以直接执行如下命令： 1 conda env create -f env.yaml 当你不记得在当前机器上存在哪些conda环境时，可以执行如下命令列出全部环境： 1 conda env list 此时，*号所在的行表示当前所属的环境。 当某个环境我们不再需要时，可以直接执行如下命令来删除该环境： 1 conda env remove -n env_name 测试一下GPU训练 本地Conda环境方式 用conda新建一个python3.8+pytorch1.7+cuda11.0的虚拟环境： 1 conda create --name python_38-pytorch_1.7.0 python=3.8 1 2 3 4 5 6 7 8 # # To activate this environment, use # # $ conda activate python_38-pytorch_1.7.0 # # To deactivate an active environment, use # # $ conda deactivate 进入环境 1 conda activate python_38-pytorch_1.7.0 检查一下是否切换到所需环境了 1 which pip 如果看到使用的确实是我们设置的环境目录中的pip的话说明就ok。 接下来在环境中安装pytorch，可以参考官网的安装命令：Start Locally | PyTorch 输入以下命令进行安装： 1 pip install torch==1.7.0+cu110 torchvision==0.8.1+cu110 torchaudio===0.7.0 -f https://download.pytorch.org/whl/torch_stable.html 环境配置就完成了，下面新建一个简单的测试脚本验证功能，新建mnist_train.py，内容如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 import argparse import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) def train(args, model, device, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % args.log_interval == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) def test(args, model, device, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) # sum up batch loss test_loss += F.nll_loss(output, target, reduction='sum').item() # get the index of the max log-probability pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format( t","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:3","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["计算机视觉"],"content":"深度学习开发环境搭建","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 硬件环境 深度学习开发环境搭建docker Docker NVIDIA Docker 安装 Docker基本使用 启动已停止运行的容器 停止一个容器 进入容器 导出和导入容器 删除容器 docker 训练模型 硬件环境 处理器：AMD® Ryzen 5 3600 6-core processor × 12 显卡：NVIDIA Corporation TU104 [GeForce RTX 2060] 内存：16G DDR4 硬盘：1T SSD 系统：Ubuntu 20.04.1 LTS 深度学习开发环境搭建docker ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:0:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"Docker Docker 是一个开源的应用容器引擎，基于 go语言并遵从 Apache2.0 协议开源。 Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。 容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:1:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"NVIDIA Docker 安装 docker安装 官网上有详细的介绍：Install Docker Engine on Ubuntudocs.docker.com 或者运行下面的命令安装： 1 2 3 4 sudo apt-get updatesudo apt-get install docker.io systemctl start docker systemctl enable docker 可以运行这条命令检查是否安装成功： 1 docker version 安装NVIDIA Container Toolkit NVIDIA/nvidia-docker 1 2 3 4 #首先要确保已经安装了 nvidia driver # 2. 添加源 distribution=$(. /etc/os-release;echo $ID$VERSION_ID) curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add - curl -s -L https://nvidia.github.io/nvidia-docker/$distribution/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list # 2. 安装并重启 sudo apt-get update \u0026\u0026 sudo apt-get install -y nvidia-container-toolkit sudo systemctl restart docker 1 sudo docker run -it --name test_nvidia_docker --gpus all nvidia/cuda:11.0-base 其中最后的参数nvidia/cuda:11.0-base 是Nvidia官方的镜像，需要根据工作站主机中实际安装的cuda版本进行修改，版本可以用nvcc -V查看。 进入容器之后可以跑一下nvidia-smi命令看看： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Mon Jan 18 22:59:37 2021 +-----------------------------------------------------------------------------+ | NVIDIA-SMI 450.102.04 Driver Version: 450.102.04 CUDA Version: 11.0 | |-------------------------------+----------------------+----------------------+ | GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC | | Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. | | | | MIG M. | |===============================+======================+======================| | 0 GeForce RTX 2060 Off | 00000000:26:00.0 On | N/A | | 0% 41C P8 8W / 160W | 947MiB / 5931MiB | 5% Default | | | | N/A | +-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | | ID ID Usage | |=============================================================================| +-----------------------------------------------------------------------------+ ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:2:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"Docker基本使用 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:0","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"启动已停止运行的容器 查看所有的容器命令如下： 1 $ docker ps -a 点击图片查看大图： 1 2 3 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e8240c787e2f nvidia/cuda:11.0-base \"/bin/bash\" 26 minutes ago Exited (0) 52 seconds ago train_mnist ae3d00922c08 nvidia/cuda:11.0-base \"/bin/bash\" 37 hours ago Exited (0) 37 hours ago test_nvidia_docker 使用 docker start 启动一个已停止的容器： 1 $ docker start ae3d00922c08 1 2 zyh@zyh:~$ sudo docker start ae3d00922c08 ae3d00922c08 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:1","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"停止一个容器 停止容器的命令如下： 1 $ docker stop \u003c容器 ID\u003e 停止的容器可以通过 docker restart 重启： 1 $ docker restart \u003c容器 ID\u003e ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:2","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"进入容器 在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入： docker attach docker exec：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。 attach 命令 下面演示了使用 docker attach 命令。 1 $ docker attach e8240c787e2f 注意： 如果从这个容器退出，会导致容器的停止。 exec 命令 下面演示了使用 docker exec 命令。 1 docker exec -it e8240c787e2f /bin/bash 注意： 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 docker exec 的原因。 更多参数说明请使用 docker exec –help 命令查看。 ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:3","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"导出和导入容器 导出容器 如果要导出本地某个容器，可以使用 docker export 命令。 1 $ docker export e8240c787e2f \u003e train_mnist.tar 导出容器 e8240c787e2f 快照到本地文件 train_mnist.tar。 这样将导出容器快照到本地文件。 导入容器快照 可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1: 1 $ cat docker/train_mnist.tar | docker import - test/train_mnist:v1 此外，也可以通过指定 URL 或者某个目录来导入，例如： 1 $ docker import http://example.com/exampleimage.tgz example/imagerepo ","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:4","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"删除容器 删除容器使用 docker rm 命令： 1 $ docker rm -f ae3d00922c08 下面的命令可以清理掉所有处于终止状态的容器。 1 $ docker container prune 拷贝本地文件到docker 查找容器 1 docker ps -a 1 2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES e8240c787e2f nvidia/cuda:11.0-base \"/bin/bash\" 42 minutes ago Up 8 minutes train_mnist 确定我们的容器名，并获取容器长ID 1 docker inspect -f '{{.ID}}' train_mnist 1 2 zyh@zyh:~/temp$ sudo docker inspect -f '{{.ID}}' train_mnist e8240c787e2fde06a3f1066db71bc63cb52514c3cb0175d51713f248a2e2b56c 复制文件 1 sudo docker cp /home/zyh/temp/cuda_11.0.2_450.51.05_linux.run e8240c787e2fde06a3f1066db71bc63cb52514c3cb0175d51713f248a2e2b56c:/home/zyh docker 训练模型 创建docker 1 2 3 4 5 sudo docker run -it --name train_mnist \\ -v /etc/timezone:/etc/timezone \\ -v /etc/localtime:/etc/localtime \\ -v /home/zyh/WorkSpace/_share:/home/workspace/_share \\ --gpus all nvidia/cuda:11.0-base 查看 nvidia 驱动 1 nvidia-smi 安装 cuda 1 sudo sh ./cuda_11.0.2_450.51.05_linux.run 配置环境变量 1 2 3 4 5 6 7 vim ~/.bashrc export CUDA_HOME=/usr/local/cuda-11.0 export LD_LIBRARY_PATH=${CUDA_HOME}/lib64 export PATH=${CUDA_HOME}/bin:${PATH} source ~/.bashrc 查看安装版本 1 nvcc -V 安装 CuDNN 1 2 3 4 tar -xzvf cudnn-11.0-linux-x64-v8.0.5.39.tgz sudo cp cuda/lib64/* /usr/local/cuda-11.0/lib64/ sudo cp cuda/include/* /usr/local/cuda-11.0/include/ 查看 CUDNN的版本 1 cat /usr/local/cuda/include/cudnn_version.h | grep CUDNN_MAJOR -A 2 安装conda 1 2 3 chmod +x Anaconda3-2020.11-Linux-x86_64.sh ./Anaconda3-2020.11-Linux-x86_64.sh 测试 创建 python3.8+pytorch1.7+cuda11.0的虚拟环境 1 conda create --name python_38-pytorch_1.7.0 python=3.8 进入环境 1 conda activate python_38-pytorch_1.7.0 安装pytorch 1 pip install torch==1.7.0+cu110 torchvision==0.8.1+cu110 torchaudio===0.7.0 -f https://download.pytorch.org/whl/torch_stable.html 测试文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 import argparse import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms class Net(nn.Module): def __init__(self): super(Net, self).__init__() self.conv1 = nn.Conv2d(1, 20, 5, 1) self.conv2 = nn.Conv2d(20, 50, 5, 1) self.fc1 = nn.Linear(4 * 4 * 50, 500) self.fc2 = nn.Linear(500, 10) def forward(self, x): x = F.relu(self.conv1(x)) x = F.max_pool2d(x, 2, 2) x = F.relu(self.conv2(x)) x = F.max_pool2d(x, 2, 2) x = x.view(-1, 4 * 4 * 50) x = F.relu(self.fc1(x)) x = self.fc2(x) return F.log_softmax(x, dim=1) def train(args, model, device, train_loader, optimizer, epoch): model.train() for batch_idx, (data, target) in enumerate(train_loader): data, target = data.to(device), target.to(device) optimizer.zero_grad() output = model(data) loss = F.nll_loss(output, target) loss.backward() optimizer.step() if batch_idx % args.log_interval == 0: print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format( epoch, batch_idx * len(data), len(train_loader.dataset), 100. * batch_idx / len(train_loader), loss.item())) def test(args, model, device, test_loader): model.eval() test_loss = 0 correct = 0 with torch.no_grad(): for data, target in test_loader: data, target = data.to(device), target.to(device) output = model(data) # sum up batch loss test_loss += F.nll_loss(output, target, reduction='sum').item() # get the index of the max log-probability pred = output.argmax(dim=1, keepdim=True) correct += pred.eq(target.view_as(pred)).sum().item() test_loss /= len(test_loader.dataset) print('\\nTest set: Average loss: {:.4f}, Accuracy: {}/{} ({:.0f}%)\\n'.format( test_loss, correct, len(test_loader.dataset), 100. * correct / len(test_loader.dataset))) def main(): parser = argparse.ArgumentParser(description='PyTorch MNIST Example') parser.add_argument('--batch-size', type=int, default=64, metavar='N', help='","date":"2023-01-30","objectID":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/:3:5","tags":["环境搭建"],"title":"DL:深度学习开发环境搭建(docker)","uri":"/posts/computer_vision/deeplearning/01-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAdocker/"},{"categories":["计算机视觉"],"content":"realsense(D450)深度对齐优化","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/","tags":["camera"],"title":"camera:realsense(D450)深度对齐优化","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 SDK 中的对齐实现 转化为opencv Mat格式 realsense 对齐流程 SDK 中的对齐实现 源码位置 align_z_to_other 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void align::align_z_to_other(rs2::video_frame\u0026 aligned, const rs2::video_frame\u0026 depth, const rs2::video_stream_profile\u0026 other_profile, float z_scale) { byte* aligned_data = reinterpret_cast\u003cbyte*\u003e(const_cast\u003cvoid*\u003e(aligned.get_data())); auto aligned_profile = aligned.get_profile().as\u003crs2::video_stream_profile\u003e(); memset(aligned_data, 0, aligned_profile.height() * aligned_profile.width() * aligned.get_bytes_per_pixel()); auto depth_profile = depth.get_profile().as\u003crs2::video_stream_profile\u003e(); auto z_intrin = depth_profile.get_intrinsics(); auto other_intrin = other_profile.get_intrinsics(); auto z_to_other = depth_profile.get_extrinsics_to(other_profile); auto z_pixels = reinterpret_cast\u003cconst uint16_t*\u003e(depth.get_data()); auto out_z = (uint16_t *)(aligned_data); align_images(z_intrin, z_to_other, other_intrin, [z_pixels, z_scale](int z_pixel_index) { return z_scale * z_pixels[z_pixel_index]; }, [out_z, z_pixels](int z_pixel_index, int other_pixel_index) { out_z[other_pixel_index] = out_z[other_pixel_index] ? std::min((int)out_z[other_pixel_index], (int)z_pixels[z_pixel_index]) : z_pixels[z_pixel_index]; }); } align_images 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 template\u003cclass GET_DEPTH, class TRANSFER_PIXEL\u003e void align_images(const rs2_intrinsics\u0026 depth_intrin, const rs2_extrinsics\u0026 depth_to_other, const rs2_intrinsics\u0026 other_intrin, GET_DEPTH get_depth, TRANSFER_PIXEL transfer_pixel) { // Iterate over the pixels of the depth image #pragma omp parallel for schedule(dynamic) for (int depth_y = 0; depth_y \u003c depth_intrin.height; ++depth_y) { int depth_pixel_index = depth_y * depth_intrin.width; for (int depth_x = 0; depth_x \u003c depth_intrin.width; ++depth_x, ++depth_pixel_index) { // Skip over depth pixels with the value of zero, we have no depth data so we will not write anything into our aligned images if (float depth = get_depth(depth_pixel_index)) { // Map the top-left corner of the depth pixel onto the other image float depth_pixel[2] = { depth_x - 0.5f, depth_y - 0.5f }, depth_point[3], other_point[3], other_pixel[2]; rs2_deproject_pixel_to_point(depth_point, \u0026depth_intrin, depth_pixel, depth); rs2_transform_point_to_point(other_point, \u0026depth_to_other, depth_point); rs2_project_point_to_pixel(other_pixel, \u0026other_intrin, other_point); const int other_x0 = static_cast\u003cint\u003e(other_pixel[0] + 0.5f); const int other_y0 = static_cast\u003cint\u003e(other_pixel[1] + 0.5f); // Map the bottom-right corner of the depth pixel onto the other image depth_pixel[0] = depth_x + 0.5f; depth_pixel[1] = depth_y + 0.5f; rs2_deproject_pixel_to_point(depth_point, \u0026depth_intrin, depth_pixel, depth); rs2_transform_point_to_point(other_point, \u0026depth_to_other, depth_point); rs2_project_point_to_pixel(other_pixel, \u0026other_intrin, other_point); const int other_x1 = static_cast\u003cint\u003e(other_pixel[0] + 0.5f); const int other_y1 = static_cast\u003cint\u003e(other_pixel[1] + 0.5f); if (other_x0 \u003c 0 || other_y0 \u003c 0 || other_x1 \u003e= other_intrin.width || other_y1 \u003e= other_intrin.height) continue; // Transfer between the depth pixels and the pixels inside the rectangle on the other image for (int y = other_y0; y \u003c= other_y1; ++y) { for (int x = other_x0; x \u003c= other_x1; ++x) { transfer_pixel(depth_pixel_index, y * other_intrin.width + x); } } } } } } 目的：将深度坐标系下的点转换到彩色坐标系下 基本步骤： （1）将深度图的像素点还原到深度坐标系下 （2）深度坐标系下的深度点还原到世界坐标系 （3）世界坐标系的深度点转换到彩色坐标系下 （4）彩色坐标系的深度点映射到Z=1的平面上，即与彩色图像的像素点对应起来 由目标像素坐标和深度值（使用内参INTRINSICS）获取目标点的真实坐标原理： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 //深度图对齐到彩色图函数 Mat align_Depth2Color(Mat depth,Mat color,rs2::p","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/:0:0","tags":["camera"],"title":"camera:realsense(D450)深度对齐优化","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E6%B7%B1%E5%BA%A6%E5%AF%B9%E9%BD%90/"},{"categories":["计算机视觉"],"content":"单目相机标定","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 相机标定内容 相机标定步骤 提取角点 棋盘格角点检测 对粗提取的角点进行精确化 亚像素检测 棋盘格角点的绘制 相机标定 生成 objectPoints 求相机的内参外参 相机矫正 - 计算无畸变和修正转换映射 remap 代码工程 相机标定内容 相机标定即获取相机的内参,外参和畸变矩阵等相机参数 内参 相机内参矩阵是相机自身的属性，内参分别为： f:焦距，单位毫米； fx:使用像素来描述x轴方向焦距的长度； fy:使用像素来描述y轴方向焦距的长度 u0,v0: 主点坐标（相对于成像平面），单位也是像素； γ:为坐标轴倾斜参数，理想情况下为0； 外参 相机的旋转矩阵R和平移向量t 旋转矩阵：描述了世界坐标系的坐标轴相对于摄像机坐标轴的方向 平移矩阵：描述了在摄像机坐标系下，空间原点的位置 畸变参数 畸变参数：k1,k2,k3径向畸变系数，p1,p2是切向畸变系数。径向畸变发生在相机坐标系转图像物理坐标系的过程中。而切向畸变是发生在相机制作过程，其是由于感光元平面跟透镜不平行。径向畸变，即由于透镜的不同区域的焦距的不同而引起的畸变，分为枕形畸变和桶形畸变如下图所示，越靠近镜头边缘畸变越明显。 相机内参和外参的解释 相机内参的标定方法 相机标定步骤 https://docs.opencv.org/3.4.0/d9/d0c/group__calib3d.html ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:0:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"提取角点 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"棋盘格角点检测 1 2 3 4 5 bool findChessboardCorners( InputArray image, Size patternSize, OutputArray corners, int flags = CALIB_CB_ADAPTIVE_THRESH + CALIB_CB_NORMALIZE_IMAGE ); 第一个参数是输入的棋盘格图像（可以是8位单通道或三通道图像）； 第二个参数是棋盘格内部的角点的行列数（注意：不是棋盘格的行列数，如棋盘格的行列数分别为4、8，而内部角点的行列数分别是3、7，因此这里应该指定为cv::Size(3, 7)）； 第三个参数是检测到的棋盘格角点，类型为std::vectorcv::Point2f。 第四个参数flag，用于指定在检测棋盘格角点的过程中所应用的一种或多种过滤方法，可以使用下面的一种或多种，如果都是用则使用OR： cv::CALIB_CB_ADAPTIVE_THRESH：使用自适应阈值将图像转化成二值图像 cv::CALIB_CB_NORMALIZE_IMAGE：归一化图像灰度系数(用直方图均衡化或者自适应阈值) cv::CALIB_CB_FILTER_QUADS：在轮廓提取阶段，使用附加条件排除错误的假设 cv::CALIB_CV_FAST_CHECK：快速检测 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:1","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"对粗提取的角点进行精确化 1 2 3 bool find4QuadCornerSubpix( InputArray img, InputOutputArray corners, Size region_size ); image源图像 corners，提供角点的初始坐标 region_size： 搜索窗口的一般尺寸\\ ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:2","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"亚像素检测 1 2 3 4 5 void cornerSubPix( InputArray image, InputOutputArray corners, Size winSize, Size zeroZone, TermCriteria criteria ); image源图像 corners，提供角点的初始坐标，返回更加精确的点 winSize，搜索窗口的一般尺寸，如果winSize=Size(5,5),则search windows为11*11 winSize,死区的一般尺寸，用来避免自相关矩阵的奇点，(-1,-1)表示没有死区 criteria，控制迭代次数和精度 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:3","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"棋盘格角点的绘制 1 2 3 4 void drawChessboardCorners( InputOutputArray image, Size patternSize, InputArray corners, bool patternWasFound ); image为8-bit，三通道图像 patternSize，每一行每一列的角 corners，已经检测到的角 patternWasFound，findChessboardCorners的返回值 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:1:4","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"相机标定 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"生成 objectPoints 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void CCalibration::init3DPoints(cv::Size boardSize, cv::Size squareSize, vector\u003ccv::Point3f\u003e \u0026singlePatternPoint) { for (int i = 0; i \u003c boardSize.height; i++) { for (int j = 0; j \u003c boardSize.width; j++) { cv::Point3f tempPoint; //单个角点的三维坐标 tempPoint.x = float(i * squareSize.width); tempPoint.y = float(j * squareSize.height); tempPoint.z = 0; singlePatternPoint.push_back(tempPoint); } } } ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:1","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"求相机的内参外参 1 2 3 4 5 6 7 8 9 double calibrateCamera( InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints, Size imageSize, InputOutputArray cameraMatrix, InputOutputArray distCoeffs, OutputArrayOfArrays rvecs, OutputArrayOfArrays tvecs, int flags = 0, TermCriteria criteria = TermCriteria(TermCriteria::COUNT + TermCriteria::EPS, 30, DBL_EPSILON) ); objectPoints，世界坐标，用vector，输入x,y坐标，z坐标为0 imagePoints，图像坐标，vector imageSize，图像的大小用于初始化标定摄像机的image的size cameraMatrix，内参数矩阵 distCoeffs，畸变矩阵 rvecs，位移向量 tvecs，旋转向量 flags，可以组合： CV_CALIB_USE_INTRINSIC_GUESS：使用该参数时，将包含有效的fx,fy,cx,cy的估计值的内参矩阵cameraMatrix，作为初始值输入，然后函数对其做进一步优化。如果不使用这个参数，用图像的中心点初始化光轴点坐标(cx, cy)，使用最小二乘估算出fx，fy（这种求法好像和张正友的论文不一样，不知道为何要这样处理）。注意，如果已知内部参数（内参矩阵和畸变系数），就不需要使用这个函数来估计外参，可以使用solvepnp()函数计算外参数矩阵。 CV_CALIB_FIX_PRINCIPAL_POINT：在进行优化时会固定光轴点，光轴点将保持为图像的中心点。当CV_CALIB_USE_INTRINSIC_GUESS参数被设置，保持为输入的值。 CV_CALIB_FIX_ASPECT_RATIO：固定fx/fy的比值，只将fy作为可变量，进行优化计算。当 CV_CALIB_USE_INTRINSIC_GUESS没有被设置，fx和fy的实际输入值将会被忽略，只有fx/fy的比值被计算和使用。 CV_CALIB_ZERO_TANGENT_DIST：切向畸变系数（P1，P2）被设置为零并保持为零。 CV_CALIB_FIX_K1,…,CV_CALIB_FIX_K6：对应的径向畸变系数在优化中保持不变。如果设置了CV_CALIB_USE_INTRINSIC_GUESS参数，就从提供的畸变系数矩阵中得到。否则，设置为0。 CV_CALIB_RATIONAL_MODEL（理想模型）：启用畸变k4，k5，k6三个畸变参数。使标定函数使用有理模型，返回8个系数。如果没有设置，则只计算其它5个畸变参数。 CALIB_THIN_PRISM_MODEL （薄棱镜畸变模型）：启用畸变系数S1、S2、S3和S4。使标定函数使用薄棱柱模型并返回12个系数。如果不设置标志，则函数计算并返回只有5个失真系数。 CALIB_FIX_S1_S2_S3_S4 ：优化过程中不改变薄棱镜畸变系数S1、S2、S3、S4。如果cv_calib_use_intrinsic_guess设置，使用提供的畸变系数矩阵中的值。否则，设置为0。 CALIB_TILTED_MODEL （倾斜模型）：启用畸变系数tauX and tauY。标定函数使用倾斜传感器模型并返回14个系数。如果不设置标志，则函数计算并返回只有5个失真系数。 CALIB_FIX_TAUX_TAUY ：在优化过程中，倾斜传感器模型的系数不被改变。如果cv_calib_use_intrinsic_guess设置，从提供的畸变系数矩阵中得到。否则，设置为0。 相机矫正 参考： 相机标定（4） 矫正畸变 undistort()和initUndistortRectifyMap() initUndistortRectifyMap ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:2","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"计算无畸变和修正转换映射 1 2 3 4 5 6 7 8 9 CV_EXPORTS_W void initUndistortRectifyMap( InputArray cameraMatrix, InputArray distCoeffs, InputArray R, InputArray newCameraMatrix, Size size, int m1type, OutputArray map1, OutputArray map2 ); //! initializes maps for cv::remap() for wide-angle CV_EXPORTS_W float initWideAngleProjMap( InputArray cameraMatrix, InputArray distCoeffs, Size imageSize, int destImageWidth, int m1type, OutputArray map1, OutputArray map2, int projType = PROJ_SPHERICAL_EQRECT, double alpha = 0); 1.cameraMatrix：输入相机矩阵 2.distCoeffs：输入参数，相机的畸变系数： (k1,k2,p1,p2[,k3[,k4,k5,k6[,s1,s2,s3,s4[,τ**x,τ**y]]]]) ，有4，5,8,12或14个元素。如果这个向量是空的，就认为是零畸变系数。 3.R：可选的修正变换矩阵，是个3*3的矩阵。通过stereoRectify计算得来的R1或R2可以放在这里。如果这个矩阵是空的，就假设为单位矩阵。在cvInitUndistortMap中，R被认为是单位矩阵。 4.newCameraMatrix：新的相机矩阵 5.size：未畸变的图像尺寸。 6.m1type：第一个输出的映射的类型，可以为 CV_32FC1, CV_32FC2或CV_16SC2，参见cv::convertMaps。 7.map1：第一个输出映射。 8.map2：第二个输出映射。 这个函数用于计算无畸变和修正转换关系，为了重映射，将结果以映射的形式表达。无畸变的图像看起来就像原始的图像，就像这个图像是用内参为newCameraMatrix的且无畸变的相机采集得到的。 在单目相机例子中，newCameraMatrix一般和cameraMatrix相等，或者可以用cv::getOptimalNewCameraMatrix来计算，获得一个更好的有尺度的控制结果。 在双目相机例子中，newCameraMatrix一般是用cv::stereoRectify计算而来的，设置为P1或P2。 此外，根据R，新的相机在坐标空间中的取向是不同的。例如，它帮助配准双目相机的两个相机方向，从而使得两个图像的极线是水平的，且y坐标相同（在双目相机的两个相机谁水平放置的情况下）。 该函数实际上为反向映射算法构建映射，供反向映射使用。也就是，对于在已经修正畸变的图像中的每个像素(u,v)，该函数计算原来图像（从相机中获得的原始图像）中对应的坐标系。 函数输出得到map1和map2,然后使用remap()函数 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:2:3","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"remap 1 2 3 4 void remap( InputArray src, OutputArray dst, InputArray map1, InputArray map2, int interpolation, int borderMode=BORDER_CONSTANT, const Scalar\u0026 borderValue=Scalar()); 第一个参数：输入图像，即原图像，需要单通道8位或者浮点类型的图像 第二个参数：输出图像，即目标图像，需和原图形一样的尺寸和类型 第三个参数：它有两种可能表示的对象：（1）表示点（x,y）的第一个映射；（2）表示CV_16SC2，CV_32FC1等 第四个参数：它有两种可能表示的对象：（1）若map1表示点（x,y）时，这个参数不代表任何值；（2）表示 CV_16UC1，CV_32FC1类型的Y值 第五个参数：插值方式，有四种插值方式： （1）INTER_NEAREST——最近邻插值 （2）INTER_LINEAR——双线性插值（默认） （3）INTER_CUBIC——双三样条插值（默认） （4）INTER_LANCZOS4——lanczos插值（默认） 第六个参数：边界模式，默认BORDER_CONSTANT 第七个参数：边界颜色，默认Scalar()黑色 代码工程 完整代码工程（包含标定图片）： camera-calibration ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/:3:0","tags":["camera"],"title":"camera:单目相机标定","uri":"/posts/computer_vision/camera/cameracalibration/%E5%8D%95%E7%9B%AE%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"},{"categories":["计算机视觉"],"content":"深度相机realsense(D450)介绍","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 D455/450技术规格 参数表 Invalid Depth Band Depth Quality Specification 软件开发 sdk 及开发者文档 PC 安装realsense SDK realsense 获取深度、彩色相机内参外参 realsense 设置laser开关 原理 Interl RealSence D4×× 系列，都是采用经典的双目视觉的方式测量深度。尽管具有红外投射器，但并不是采用红外反射测距。它的作用仅仅是投射不可见的固定的红外纹理样式，提高在纹理不明显的1环境中（例如白墙）的深度计算精度，辅助双目视觉测距。左右两个相机将图像数据送入内置的深度处理器，在其中基于双目测距的原理计算每个像素的深度值。 D455/450技术规格 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:0:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"参数表 特性 使用环境： 室内/室外 深度快门类型： 全局快门，3μm × 3μm 像素大小 推荐范围： 0.6-6 米 惯性量测单元： Bosch BMI055 深度 深度技术： 主动 IR 立体 最小深度距离 (Min-Z)： ~0.52 米 深度精度 \u003c2% 位于4 米1 深度视场 (FOV)： 86° × 57° (±3°) 深度输出分辨率： 高达 1280 x 720 深度帧率： 高达 90 帧/秒 RGB RGB帧分辨率： 高达 1280 × 800 RGB 帧速率： 30 帧/秒 RGB 传感器技术： 全局快门 RGB 传感器 FOV (H × V)： 90° × 65° (±3) RGB传感器分辨率: 1 MP 主要组件 摄像头模块： 英特尔实感模块 D450 计算处理器板： 英特尔实感视觉处理器 D4 物理 外形： 摄像头外设 长度 × 深度 × 高度： 124 毫米 × 26 毫米 × 29 毫米 接头： USB‑C* 3.1 Gen 1* 安装机构： – 一个 1/4‑20 UNC 螺纹安装点。 – 两个 M3 螺纹安装点。 – 三脚架 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:1:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"Invalid Depth Band The depth data generated with stereo vision uses the left imager as the reference for stereo matching resulting in a non-overlap region in the field of view of left and right imagers where we will not have depth data at the left edge of the frame. Closer scenes result in a wider invalid depth band than scenes at larger distances. ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:2:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"Depth Quality Specification FOV 80% 做评估 METRIC DEFINITION Depth Accuracy ： 深度精度 测量相对于地面真实表面的有效像素的差异。 Fill Rate：Fill Rate 具有有效深度值的像素百分比。 Depth Standard Deviation ：深度标准差 测量每个有效像素相对于最佳拟合平面的总空间噪声。 Pixel Temporal Noise：像素时间噪声 测量相对于最佳拟合平面的每个有效像素的总时间噪声。 软件开发 ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:3:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"sdk 及开发者文档 开发者支持 Linux/Ubuntu - RealSense SDK 2.0 Build Guide List of Intel RealSense SDK 2.0 Examples API How To ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:4:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"PC 安装realsense SDK Ubuntu下Realsense SDK的安装 下载源码 1 git clone https://github.com/IntelRealSense/librealsense.git 安装依赖环境 1 sudo apt-get install libusb-1.0-0-dev libglfw3-dev libgtk-3-dev libusb是一个USB设备访问接口库 gtk是一个图形工具包 glfw是一个OpenGL应用框架 将英特尔服务器添加到存储库列表中 1 echo 'deb http://realsense-hw-public.s3.amazonaws.com/Debian/apt-repo xenial main' | sudo tee /etc/apt/sources.list.d/realsense-public.list 注册服务器的公钥 1 sudo apt-key adv --keyserver keys.gnupg.net --recv-key 6F3EFCDE 刷新apt列表 1 sudo apt-get update 安装相关包 1 2 sudo apt-get install librealsense2-dkms sudo apt-get install librealsense2-utils dkms是内核驱动包，utils是工具包 检查安装 1 modinfo uvcvideo | grep \"version:\" 终端会返回相关版本信息 比如我的电脑上会返回 1 2 3 zyh@zyh ~ $ modinfo uvcvideo | grep \"version:\" version: 1.1.1 srcversion: 32217DB1DE9B0BC725EDF5D 编译 1 2 3 4 5 6 cd librealsense mkdir build cd build cmake .. make -j8 sudo make install ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:5:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"realsense 获取深度、彩色相机内参外参 1 2 3 4 rs2_intrinsics depth_intrin = depth_profile.as\u003crs2::video_stream_profile\u003e().get_intrinsics(); rs2_intrinsics color_intrin = color_profile.as\u003crs2::video_stream_profile\u003e().get_intrinsics(); rs2_extrinsics depth_extrin_to_color = depth_profile.as\u003crs2::video_stream_profile\u003e().get_extrinsics_to(color_profile); rs2_extrinsics color_extrin_to_depth = color_profile.as\u003crs2::video_stream_profile\u003e().get_extrinsics_to(depth_profile); rs2_intrinsics: 1 2 3 4 5 6 7 8 9 10 11 12 /** \\brief Video stream intrinsics. */ typedef struct rs2_intrinsics { int width; /**\u003c Width of the image in pixels */ int height; /**\u003c Height of the image in pixels */ float ppx; /**\u003c Horizontal coordinate of the principal point of the image, as a pixel offset from the left edge */ float ppy; /**\u003c Vertical coordinate of the principal point of the image, as a pixel offset from the top edge */ float fx; /**\u003c Focal length of the image plane, as a multiple of pixel width */ float fy; /**\u003c Focal length of the image plane, as a multiple of pixel height */ rs2_distortion model; /**\u003c Distortion model of the image */ float coeffs[5]; /**\u003c Distortion coefficients. Order for Brown-Conrady: [k1, k2, p1, p2, k3]. Order for F-Theta Fish-eye: [k1, k2, k3, k4, 0]. Other models are subject to their own interpretations */ } rs2_intrinsics; rs2_extrinsics: 1 2 3 4 5 6 /** \\brief Cross-stream extrinsics: encodes the topology describing how the different devices are oriented. */ typedef struct rs2_extrinsics { float rotation[9]; /**\u003c Column-major 3x3 rotation matrix */ float translation[3]; /**\u003c Three-element translation vector, in meters */ } rs2_extrinsics; ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:6:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"realsense 设置laser开关 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 rs2::pipeline pipe; rs2::pipeline_profile selection = pipe.start(); rs2::device selected_device = selection.get_device(); auto depth_sensor = selected_device.first\u003crs2::depth_sensor\u003e(); if (depth_sensor.supports(RS2_OPTION_EMITTER_ENABLED)) { depth_sensor.set_option(RS2_OPTION_EMITTER_ENABLED, 1.f); // Enable emitter depth_sensor.set_option(RS2_OPTION_EMITTER_ENABLED, 0.f); // Disable emitter } if (depth_sensor.supports(RS2_OPTION_LASER_POWER)) { // Query min and max values: auto range = depth_sensor.get_option_range(RS2_OPTION_LASER_POWER); depth_sensor.set_option(RS2_OPTION_LASER_POWER, range.max); // Set max power depth_sensor.set_option(RS2_OPTION_LASER_POWER, 0.f); // Disable laser } ","date":"2023-01-30","objectID":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/:7:0","tags":["camera"],"title":"camera:深度相机realsense(D450)介绍","uri":"/posts/computer_vision/camera/stereocamera/realsense/realsensed450%E4%BB%8B%E7%BB%8D/"},{"categories":["计算机视觉"],"content":"图像及视频等相关基础知识","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 视频编码 运动静止图像专家组的 M-JPEG 国际标准化组织(ISO)运动图像专家组的 MPEG 系列标准 国际电联(ITU-T)的 H.26X 音频编码 常见的多媒体框架及解决方案 颜色空间 RGB24/RGB32/I420(YUV) I420/YV12 YUV420 图像色彩模式 位图模式 灰度模式 RGB模式 CMYK模式 HSB模式 YUV格式 帧率 分辨率 刷新率 编码格式 封装格式 码率 采样率 量化精度 声道 部分参考资料 视频编码 而编码主要从两个维度压缩数据: 1、单一图像某一个区域的相邻像素相似，如一片红色区域只记录红色的色值以及区域，不记录这个区域的每一个像素点。 2、相邻的的两张图像比较相似，对图像方法的第一帧进行编码，然后用某种方式描述接下来的帧相对于附近的帧有什么区别。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:0:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"运动静止图像专家组的 M-JPEG M-JPEG 是一种图像压缩编码标准，是 Motion-JPEG 的简称，JPEG 标准主要是用来处理静止图像，而 M-JPEG 把运动的视频序列作为连续的静止图像来处理，这种压缩方式单独完整地压缩每一帧，在编辑过程中可随机存储每一帧，可进行精确到帧的编辑，M-JPEG 只对帧内的空间冗余进行压缩，不对帧间的时间冗余进行压缩，故压缩效率不高。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:1:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"国际标准化组织(ISO)运动图像专家组的 MPEG 系列标准 由ISO（国际标准组织机构）下属的MPEG（运动图象专家组）开发 视频编码方面主要是Mpeg1（vcd）、Mpeg2（DVD）、Mpeg4（DVDRIP使用的都是它的变种，如：divx，xvid等）、Mpeg4 AVC；音频编码方面主要是MPEG Audio Layer 1/2、MPEG Audio Layer 3（mp3）、MPEG-2 AAC 、MPEG-4 AAC等。注意：DVD音频没有采用Mpeg的。 MPEG 标准的视频压缩编码技术主要利用了具有运动补偿的帧间压缩编码技术以减小时间冗余度，利用 DCT 技术以减小图像的空间冗余度，利用熵编码则在信息表示方面减小了统计冗余度。这几种技术的综合运用，大大增强了压缩性能。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:2:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"国际电联(ITU-T)的 H.26X H.261：第一个实用的数字视频解码标准，采用的压缩算法是运动补偿帧间预测与分块 DCT 相结合的混合编码，其运动补偿使用用全像素精度和环路滤波，支持 CIF 和 QCIF 两种分辨率。 H.263：H.263 与 H.261 编码算法一样，但是做了一点改善，使得 H.263 标准在低码率下能够提供比 H.261 更好的图像效果，其运动补偿使用半像素精度，支持 CIF、QCIF 、SQCIF、4CIF和16CIF 五种分辨率。 H.264：H.264则是由两个组织 ISO 和 ITU-T 联合组建的联合视频组（JVT）共同制定的新数字视频编码标准，所以它既是 ITU-T 的H.264，又是 ISO/IEC 的 MPEG-4 高级视频编码（Advanced Video Coding，AVC）的第 10 部分，因此，不论是MPEG-4 AVC、MPEG-4 Part 10，还是 ISO/IEC 14496-10，都是指 H.264，H.264 是基于传统框架的混合编码系统，做了局部优化，注重编码效率和可靠性。H.264 在具有高压缩比的同时还拥有高质量流畅的图像，经过 H.264 压缩的视频数据，在网络传输过程中所需要的带宽更少，是压缩率最高的视频压缩标准。 音频编码 常见的音频编解码标准如下： ITU：G.711、G.729 等 MPEG：MP3、AAC 等 3GPP：AMR、AMR-WB、AMR-WB+等 还有企业制定的标准，如 Dolby AC-3、DTS 、WMA 等 常见的介绍如下： MP3（MPEG-1 audio layer 3）：一种音频压缩技术，它被设计用来大幅度地降低音频数据量，利用 MPEG Audio Layer 3 的技术，将音乐以 1:10 甚至 1:12 的压缩率，压缩成容量较小的文件，而对于大多数用户来说重放的音质与最初的不压缩音频相比没有明显的下降，它是利用人耳对高频声音信号不敏感的特性，将时域波形信号转换成频域信号，并划分成多个频段，对不同的频段使用不同的压缩率，对高频加大压缩比（甚至忽略信号），对低频信号使用小压缩比，保证信号不失真，这样就相当于抛弃人耳基本听不到的高频声音，只保留能听到的低频部分，从而对音频进行一定压缩，此外 MP3 属于有损压缩的文件格式。 AAC：Advanced Audio Coding 的缩写，最初是基于 MPEG-2 的音频编码技术，MPEG-4 出现后，AAC 重新集成了其特性，且加入了SBR 技术和 PS 技术，为了区别于传统的 MPEG-2 AAC 又称为MPEG-4 AAC，AAC 是一种专为声音数据设计的文件压缩格式，相较 MP3，AAC 格式的音质更佳，文件更小，但是 AAC 是一种有损压缩格式，随着大容量设备的出现，其优势将越来越小。 WMA：Windows Media Audio 的缩写，是微软公司开发的一系列音频编解码器，也指相应的数字音频编码格式，WMA 包括四种不同的编解码器：WMA，原始的WMA编解码器，作为 MP3 和 RealAudio 编解码器的竞争者；WMA Pro，支持更多声道和更高质量的音频[；WMA Lossless，无损编解码器；WMA Voice，用于储存语音，使用的是低码率压缩。一些使用 Windows Media Audio 编码格式编码其所有内容的纯音频 ASF 文件也使用 WMA 作为扩展名，其特点是支持加密，非法拷贝到本地是无法播放的，WMA 也属于有损压缩的文件格式。 常见的多媒体框架及解决方案 常见的多媒体框架及解决方案有 VLC 、 FFmpeg 、 GStream 等，具体如下： VLC ：即 Video LAN Client，是一款自由、开源的跨平台多媒体播放器及框架 。 FFmpeg：多媒体解决方案，不是多媒体框架，广泛用于音视频开发中。 GStreamer ：一套构建流媒体应用的开源多媒体框架 。 颜色空间 YUV：一种颜色编码方法，一般使用在在影像处理组件中，YUV 在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽，其中 Y 表示明亮度、U 表示色度、V 表示浓度，Y′UV、YUV、YCbCr、YPbPr 所指涉的范围，常有混淆或重叠的情况。从历史的演变来说，其中 YUV 和 Y’UV 通常用来编码电视的模拟信号，而 YCbCr 则是用来描述数字的影像信号，适合视频与图片压缩以及传输，例如 MPEG、JPEG，现在 YUV 通常已经在电脑系统上广泛使用。 RGB：原色光模式，又称 RGB 颜色模型或红绿蓝颜色模型，是一种加色模型，将红（Red）、绿（Green）、[蓝（Blue）三原色的色光以不同的比例相加，以合成产生各种色彩光，目前的大多数显示器都采用 RGB 这种颜色标准。 YUV 主要用于优化彩色视频信号的传输，使其向后相容老式黑白电视，与 RGB 视频信号传输相比，它最大的优点在于只需占用极少的带宽。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:3:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"RGB24/RGB32/I420(YUV) 一般来说，直接采集到的视频数据是RGB24的格式，RGB24一帧的大小size＝width× heighth ×3 Byte，RGB32的size＝width× heighth ×4，如果是I420（即YUV标准格式4：2：0）的数据量是 size＝width× heighth ×1.5 Byte。 X264在进行编码的时候需要标准的YUV（4：2：0）。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:4:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"I420/YV12 YV12和I420基本上是一样的，就是UV的顺序不同。 YV12 ： 亮度（行×列） ＋ V（行×列/4) + U（行×列/4） I420 ： 亮度（行×列） ＋ U（行×列/4) + V（行×列/4） ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:5:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"YUV420 YUV，是一种颜色编码方法。常使用在各个视频处理组件中。 YUV在对照片或视频编码时，考虑到人类的感知能力，允许降低色度的带宽。 “Y”表示明亮度（Luminance或Luma），也就是灰阶值，“U”和“V”表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。 YUV420格式是指，每个像素都保留一个Y（亮度）分量，而在水平方向上，不是每行都取U和V分量，而是一行只取U分量，则其接着一行就只取V分量，以此重复(即4:2:0, 4:0:2, 4:2:0, 4:0:2 …….)，所以420不是指没有V，而是指一行采样只取U，另一行采样只取V。在取U和V时，每两个Y之间取一个U或V。但从4x4矩阵列来看，每4个矩阵点Y区域中，只有一个U和V，所以它们的比值是4:1。所以对于一个像素，RGB需要8 * 3 = 24位，即占3个字节；而YUV420P，8 + 8/4 + 8/4 = 12位，即占2个字节，其中8指Y分量，8/4指U和V分量。 图像色彩模式 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:6:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"位图模式 位图模式是图像中最基本的格式，图像只有黑色和白色像素，是色彩模式中占有空间最小的，同样也叫做黑白图，它包含的信息量最少，无法包含图像中的细节，相当于只有0或者1 一副彩色图如果要转换成黑白模式，则一般不能直接转换，需要首先将图像转换成灰度模式 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:7:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"灰度模式 灰度模式即使用单一色调来表示图像，与位图模式不同，不像位图只有0和1，使用256级的灰度来表示图像，一个像素相当于占用8为一个字节，每个像素值使用0到255的亮度值代表，其中0为黑色，255为白色，相当于从黑-\u003e灰-\u003e白的过度，通常我们所说的黑白照片就是这种模式，与位图模式相比，能表现出一定的细节，占用空间也比位图模式较大 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:8:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"RGB模式 RGB模式为我们经常见到的，被称为真色彩。RGB模式的图像有3个颜色通道，分布为红（Red）,绿（Green）和蓝（Bule），每个都占用8位一个字节来表示颜色信息，这样每个颜色的取值范围为0~255，那么就三种颜色就可以有多种组合 当三种基色的值相等是，表现出为灰色，三种颜色都为255即为白色，三种颜色都为0，即为黑色 RGB模式的图像占用空间要比位图，灰度图都要大，但表现出的细节更加明显 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:9:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"CMYK模式 CMYK模式被称为印刷色彩模式，主要是来源于印刷行业，以打印油墨在纸张上的光线吸收特性为基础，与RGB类似，也是使用三种颜色，分别为青色（Cyan）,品红色（Magenta）,黄色（Yellow）,以及黑色（Black） 与RGB不同的是：RGB模式依靠的是自身发光的色彩模式，而CMYK是一种依靠反光的色彩模式。 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:10:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"HSB模式 是根据日常生活中人眼的视觉对色彩的观察得而制定的一套色彩模式，最接近与人类对色彩的辨认的思考方式，所有的颜色都是用色彩三属性来描述 H:(色相）：是指从物体反射或透过物体传播的颜色 S:(饱和度)：是指颜色的强度或纯度，表示色相中灰色成分所占的比例 B:(亮度)：是指颜色对相对明暗程度，通常 100%定义为白色；0%为黑色 除了上述以上之外，还有索引模式，多通道模式等等不再介绍 ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:11:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["计算机视觉"],"content":"YUV格式 除了上述图像模式之外，由于历史原因大部分摄像头输入的图片格式都是YUV格式，开始主要用于电视系统以及模拟视频领域。YUV，分为三个分量，“Y”表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。如果没用UV信息，只有Y信息，也可以进行成像不过只是黑白的，这样就能很好解决彩色电视与黑白电视的兼容问题，与RGB相比，YUV占用带宽较少，目前摄像头输出格式普遍采用YUV格式。 而在图像的处理过程中，其实很少使用YUV格式，一般都需要转成RGB格式或者灰度图格式进行转换，而opencv的cvtColor()函数支持这种转换 帧率 帧率是用于测量显示帧数的量度。单位为「每秒显示帧数」（Frame per Second，FPS）或「赫兹，Hz」，表示每秒的帧数（FPS）或者说帧率表示图形处理器处理场时每秒钟能够更新的次数，高的帧率可以得到更流畅、更逼真的动画，一般来说 30fps 就是可以接受的，但是将性能提升至 60fps 则可以明显提升交互感和逼真感，但是一般来说超过 75fps 一般就不容易察觉到有明显的流畅度提升了，如果帧率超过屏幕刷新率只会浪费图形处理的能力，因为监视器不能以这么快的速度更新，这样超过刷新率的帧率就浪费掉了。 分辨率 视频分辨率是指视频成像产品所形成的图像大小或尺寸，常见的 1080P、4K 等有代表什么呢，P 本身的含义是逐行扫描，表示视频像素的总行数，1080P 表示总共有 1080 行的像素数，而 K 表示视频像素的总列数，4K 表示有 4000 列的像素数，通常来说，1080P 就是指 1080 x 1920 的分辨率，4 k 指 3840 x 2160 的分辨率。 刷新率 刷新率就是屏幕每秒画面被刷新的次数，刷新率分为垂直刷新率和水平刷新率，一般提到的刷新率通常指垂直刷新率，垂直刷新率表示屏幕的图象每秒钟重绘多少次，也就是每秒钟屏幕刷新的次数，以 Hz（赫兹）为单位，刷新率越高越好，图象就越稳定，图像显示就越自然清晰，对眼睛的影响也越小，刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳得就越快，一般来说，如能达到 80Hz 以上的刷新频率就可完全消除图像闪烁和抖动感，眼睛也不会太容易疲劳。 编码格式 针对音视频来说，编码格式对应的就是音频编码和视频编码，对照前面的音频编码标准和视频编码标准，每种编码标准都对应的编码算法，其目的是通过一定编码算法实现数据的压缩、减少数据的冗余。 封装格式 直接看下百度百科的关于封装格式的介绍，封装格式（也叫容器），就是将已经编码压缩好的视频轨和音频轨按照一定的格式放到一个文件中，也就是说仅仅是一个外壳，或者大家把它当成一个放视频轨和音频轨的文件夹也可以，说得通俗点，视频轨相当于饭，而音频轨相当于菜，封装格式就是一个碗，或者一个锅，用来盛放饭菜的容器。 码率 码率，也就是比特率（Bit rate），指单位时间内传输或处理的比特的数量，单位为 bps（bit per second）也可表示为 b/s，比特率越高，单位时间传送的数据量（位数）越大，多媒体行业在指音频或视频在单位时间内的数据传输率时通常使用码率，单位是 kbps，一般来说，如果是 1M 的宽带，在网上只能看码流不超过 125kbps 的视频，超过 125kbps 的视频只能等视频缓冲才能顺利观看。 码率一般分为固定码率和可变码率： 固定码率会保证码流的码率恒定，但是会牺牲视频质量，比如为了保证码率恒定，某些图像丰富的内容就是失去某些图像细节而变得模糊。 可变码率指的是输出码流的码率是可变的，因为视频信源本身的高峰信息量是变化的，从确保视频传输质量和充分利用信息的角度来说，可变码率视频编码才是最合理的。 码率的高低与视频质量和文件提交成正比，但当码率超过一定数值后，对视频质量没有影响。 采样率 采样率，表示每秒从连续信号中提取并组成离散信号的采样个数，用赫兹（Hz）来表示，采样率是指将模拟信号转换成数字信号时的采样频率，人耳能听到的声音一般在 20Hz~20KHz 之间，根据采样定理，采样频率大于信号中最高频率的 2 倍时，采样之后的数字信号便能完整的反应真实信号，常见的采样率如下： 8000 Hz：电话所用采样率, 对于人的说话已经足够 11025 Hz：AM调幅广播所用采样率 22050 Hz 和 24,000 Hz：FM调频广播所用采样率 44100Hz：音频CD，常用于 MPEG-1 音频（VCD，SVCD，MP3）所用采样率 47,250 Hz：商用 PCM 录音机所用采样率 48,000 Hz：miniDV、数字电视、DVD、DAT、电影和专业音频所用的数字声音所用采样率 CD 音乐的标准采样频率为 44.1KHz，这也是目前声卡与计算机作业间最常用的采样频率，目前比较盛行的蓝光的采样率就相当的高，达到了 192kHz。而目前的声卡，绝大多数都可以支持 44.1kHz、48kHz、96kHz，高端产品可支持 192kHz 甚至更高，总之，采样率越高，获得的声音文件质量越好，占用存储空间也就越大。 量化精度 声波在转换为数字信号的过程中不只有采样率影响原始声音的完整性，还有一个重要影响因素是量化精度，采样频率针对的是每秒钟所采样的数量，而量化精度则是对于声波的振幅进行切割，切割的数量是以最大振幅切成 2 的 n 次方计算，n 就是 bit 数，而 bit 数就是音频分辨率。 另外，bit 的数目还决定了声波振幅的范围（即动态范围，最大音量与最小音量的差距），如果这个位数越大，则能够表示的数值越大，描述波形更精确，每一个 Bit 的数据可以记录约等于 6dB 动态的信号，一般来说，16Bit 可以提供最大 96dB 的动态范围（加高频颤动后 只有 92dB），据此可以推断出 20Bit 可以达到 120dB 的动态范围，动态范围大了，会有什么好处呢？动态范围是指系统的输出噪音功率和最大不失真音量功率的比值，这个值越大，则系统可以承受很高的动态。 声道 声道指声音在录制或播放时在不同空间位置采集或回放的相互独立的音频信号，所以声道数也就是声音录制时的音源数量或回放时相应的扬声器数量，常见声道有单声道、立体声道、4 声道、5.1 声道、7.1 声道等 ，具体如下： 单声道：设置一个扬声器。 立体声道：把单声道一个扬声器扩展为左右对称的两个扬声器，声音在录制过程中被分配到两个独立的声道，从而达到了很好的声音定位效果，这种技术在音乐欣赏中显得尤为有用，听众可以清晰地分辨出各种乐器来自何方，从而使音乐更富想象力，更加接近临场感受。立体声技术广泛应用于自 Sound Blaster Pro 以后的大量声卡，成为了 影响深远的音频标准。 4 声道：4 声道环绕规定了 4 个发音点，分别是前左、前右、后左、后右，听众则被包围在中间，同时还建议增加一个低音音箱，以加强对低频信号的回放处理，这也就是如今 4.1 声道音箱系统广泛流行的原因，就整体效果而言，4 声道系统可以为听众带来来自多个不 同方向的声音环绕，可以获得身 临各种不同环境的昕觉感受，给用户以全新的体验。 5.1 声道：其实 5.1 声道系统来源于 4.1 声道系统，将环绕声道一分为二，分为左环绕和右环绕，中央位置增加重低音效果。 7.1 声道：7.1 声道系统在 5.1 声道系统的基础上又增加了中左和中右两个发音点，简单来说就是在听者的周围建立起一套前后相对平衡的声场，增加了 后中声场声道。 部分参考资料 音视频基本概念 视频格式基础知识：让你了解MKV、MP4、H.265、码率、色深等等 图片格式之YUV420 转RGB格式 fourcc ","date":"2023-01-30","objectID":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/:12:0","tags":["音视频"],"title":"图像及视频等相关基础知识","uri":"/posts/computer_vision/basic/%E5%9B%BE%E5%83%8F%E5%8F%8A%E8%A7%86%E9%A2%91%E7%AD%89%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"categories":["cpp"],"content":"整理部分现代C++作用在函数后的关键字","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 标识符/语句/表达式 标识符 在声明中 在表达式中 无限定标识符 有限定标识符 名字 语句 表达式语句 复合语句 选择语句 迭代语句 跳转语句 声明语句 try块 表达式 初等表达式 不求值表达式 弃值表达式 常量表达式 code const 作用 const 的指针与引用 使用 static 作用 静态成员 静态成员函数 this 指针 inline 内联函数 特征 使用 编译器对 inline 函数的处理步骤 优缺点 虚函数（virtual）可以是内联函数（inline）吗？ volatile assert() sizeof() #pragma pack(n) pragma pack(n) 使用 位域 extern “C” struct 和 typedef struct C 中 C++ 中 C++ 中 struct 和 class 区别 类的默成员函数 union 联合 C 实现 C++ 类 explicit（显式）关键字 friend 友元类和友元函数 using using 声明 构造函数的 using 声明 using 指示 尽量少使用 using 指示 污染命名空间 :: 范围解析运算符 分类 enum 枚举类型 限定作用域的枚举类型 不限定作用域的枚举类型 decltype 推导出表达式类型 与using/typedef合用，用于定义类型 重用匿名类型 泛型编程中结合auto，用于追踪函数的返回值类型 decltype推导四规则 引用 左值引用 右值引用 引用折叠 宏 成员初始化列表 initializer_list 列表初始化 面向对象 封装 继承 多态 静态多态（编译期/早绑定） 动态多态（运行期期/晚绑定） 虚析构函数 纯虚函数 虚函数、纯虚函数 虚函数指针、虚函数表 虚继承 虚继承、虚函数 模板类、成员模板、虚函数 抽象类、接口类、聚合类 内存分配和管理 malloc、calloc、realloc、alloca malloc、free new、delete 定位 new delete this 合法吗？ 如何定义一个只能在堆上（栈上）生成对象的类？ 只能在堆上 只能在栈上 智能指针 C++ 标准库（STL）中 C++ 98 C++ 11 shared_ptr weak_ptr unique_ptr auto_ptr auto_ptr 与 unique_ptr 比较 强制类型转换运算符 static_cast dynamic_cast const_cast reinterpret_cast bad_cast 运行时类型信息 (RTTI) dynamic_cast typeid type_info 参考资料 标识符/语句/表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:0:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"标识符 标识符实际上是由一组字符组成的任意长度的字符串，规定是以非数字开头，以下划线字母Unicode开头，非关键字的字符串即可，但是要主要的是虽然引入了对Unicode字符的支持，但是各实现任是不定的，对于Unicode的处理，我们在翻译的第一阶段就知道了，映射成了一个通用转移序列开头的字符。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"在声明中 对于标识符在标准中也是有一定规定的，通常有两个下划线或一个下划线一个大写字母的标识符是被保留的，以一个下划线开头的标识符在全局作用域中是保留的，这里的保留的意思就是说，这写标识符可能都被声明或是被空白#define过的用于内部使用不对外给使用者使用，即使有些功能是已知的，但是具体实现，特性等都是未知的，故使用这类标识符是UB，同样，不能对关键字进行#define #undef 如果这么做的话则也是UB。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"在表达式中 一个命名函数，变量，枚举项的标识符是一个表达式，当这个标识符单独作为一个表达式时，表达式的结果是这个标识符所命名的实体，如果这个标识符指名的是变量，函数，模板形参对象，数据成员，那么这个表达式的值类别就是左值，否则就是纯右值。一个表达式的类型确定通常有规定，通常情况下表达式的类型就是它指名的实体类型，如果表达式是一个非静态局部变量并且在其作用域外被指名则会导致造成这个形式的lambda对象以复制捕获，那么这个表达式的类型就是其最内层穿插的lambda表达式的闭包对象捕获声明的一个非静态数据成员的成员访问表达式的类型。在非静态成员函数内，每个指名数据成员的都被隐式的转换成类成员表达式(this→mumber)。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"无限定标识符 无限定标识符除了上述声明了的标识符外还有以下标识表达式可以被用在表达式中： 函数写法的重载运算符名字 用户定义类型转换的函数名字 用户定义的字面量运算符的名字 带有实参表的模板名字 ～字符随类名 ～字符随decltype 这些都符号和标识符组合在一起成为无限定的标志表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"有限定标识符 有限定标识符则是在无限定标识符前加作用域解析符，或是以作用域解析副分隔的一系列枚举，类，名称空间的名字或者decltyle表达式。对于有限定标识符，可能会存在要求用templata来消除依赖的模板名的歧义。 //ToDo在代码中添加消除依赖相关内容 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:1:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"名字 名字可以代表一个实体或是一个标签 名字通常是一个标识符 或者是在无限定标识符中（实际上有无限定均属）详细说明的代名字的标志表达式 一个代表实体的名字是通过声明引入的，代表标签的则是可以通过goto或由标号标签（case）引入 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:2:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"语句 语句的大格式是： 1 attr statement 即在语句前可以用一系列属性对语句做修饰 语句是顺序执行C++程序片段，任意函数体是语句的序列，一个语句通常可以是： ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"表达式语句 一个表达式后跟随一个分号即可（只有跟随分号的一个最终表达式是表达式语句语句） ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"复合语句 当期望一个语句但是又要求这个语句内包含多个顺序执行的语句序列时就使用一个复合语句 复合语句需要由一对花括号包括，并引入一个块作用域，在复合语句结束后，声明于块内变量被销毁。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"选择语句 选择语句是if constexpr，switch，其中从C++17起，if可带初始化语句，其会被改编为 1 2 3 4 { 初始化语句 if constexpr（可选）… } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"迭代语句 迭代语句是for（包括C++11起的范围for) while do…while ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"跳转语句 continue break return goto ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:5","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"声明语句 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:6","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"try块 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:3:7","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"表达式 表达式是由运算符和运算数组成的一个序列。可对表达式求值产生结果，一个表达式也可以产生副作用。一表达式求值，可以推得一个值类别，同时，表达式遵循一个求值顺序规则来求得实参和子表达式的值作为表达式的中间值。 表达式的运算符包括： 所有支持的运算符 类型转换 分配内存 其他 其中一个表达式可以分为： ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"初等表达式 表达式通常是一个初等表达式和一个子表达式递归形成一个初等表达式可以是： 常量 字面量 标识符 lambda表达式 折叠表达式 括号内的表达式被当作一个初等表达式看待（所以在进行表达式求值即存在运算符时，通常会求得初等表达式的值，所以可以保证括号内的表达式被优先求值）。 字面量介绍： 字面量可以是:常数字面量，字符字面量，字符串字面量，nullptr，浮点字面量，bool字面量，用户定字面量。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"不求值表达式 一个不求值表达式通常是在运算符:sizeof/sizeof…/decltype/typeid/noexpect 之后的表达式，但是要注意两点： 如果tepeid的运算数是一个多态对象则会对该表达式求值，以确定其具体所属类型 一个不求值表达式是一个完全表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"弃值表达式 弃置表达式表明，只处理表达式相应的副作用，不对表达式求得的值做处理，所有的表达式语句和逗号运算符的左实参都是弃值表达式，即，非弃值表达式只会存在于子表达式中，由于表达式的值被抛弃（不使用）所以不会对其进行常规转换（规定上的）数组不会自动转为指针，函数不会自动转为函数的指针。弃值表达式可以是： 标识符表达式（单独有一个标识符构成的表达式） 成员访问表达式（使用到成员访问运算符系的） 成员指针操作 条件表达式（三目） 逗号表达式 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"常量表达式 概述而言，常量表达式是可以在编译期确定（求）其值的表达式，以此来确定一些编译器必须被确定的数据。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:4:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 #include \u003ciostream\u003e #include \"AllCore.h\" NS_STAT_IDENT static bool test_bool() { return true; } bool main_statement() { //一个语句可以是: [[]] int foo1,foo2; //声明语句 [[]] foo1 = foo2 = 2; //表达式语句 // 此处为了介绍，语句的基本格式实际上是attr(可选)所需求语句 //即，在语句前可以指定一个属性序列，对这条语句进行修饰 [[]]flag:int foo3 = 1; //或是在switch中的 //case constexpr： ... //default: ... //以上是标号，任何语句都可以有一个标号 ////注意标号和属性，如果属性出现在标号前，则这个属性应用到的是这个标号 //出现在标号后表明这个属性应用到语句 //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- if(int a = 2;a == foo1 == foo2); else std::cout\u003c\u003c\"Print!\"\u003c\u003cstd::endl; if (int foo32 = 1;test_bool()); if constexpr (1); //选择语句 //在C++17之后出现了可选带初始化语句的if语句和constexpr if //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- //以下包含了： int a[10][10]; for(int i = 0;i\u003c1;++i) { //迭代语句\u0026\u0026复合语句块 break; //跳转语句 for (int j = 0; j \u003c 1; ++j) a[i][j]; } for(int (\u0026it)[10]:a) //C++11的范围for迭代语句 for(int \u0026it1:it) { //复合语句块 it1; continue; //跳转语句 } try { //try块 while (1) { static int jd = 1; if (jd == 2) throw jd; ++jd; } } catch (int ct) { std::cout\u003c\u003c\"Catch!\"\u003c\u003cct\u003c\u003cstd::endl; goto ret; //跳转语句 } ret:return true; //标签+跳转语句 } //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- //标识符在声明中 enum E1{EM1,EM2}; struct C1{int member;}; namespace N1{} template\u003cclass ... _Tys\u003e struct TC1{TC1(_Tys ... _args){}}; static void func1(){} int a,_a,_87,中文; //以_，英文字母，通用转移序列\\uxxxx开头的都可以 //对于一个声明的规则如下: //以下划线+大写字母，+下划线，或在全局范围内的标识符，都是被保留的 //标识符可以命名，名称空间，枚举，枚举项，类，类成员，变量，模板，模板特化，参数包 bool main_identifier() { sg: //goto标签等其他实体 //对关键字进行#define or #undef 行为未定义 int esp = 4; //标识符在表达式中 a;_a;_87;中文; EM1;EM2; func1; //标识符命名了枚举项，变量，函数，则这个标识符就是表达式 //并且，当当前表达式（表达式可以嵌套）单独为当前标识符时，这个表达式代表的是标识符命名的实体 [=](){esp;}; //esp在其生存期外被lambda闭包对象捕获，此时，这个esp单独这个表达式的类型实际上时一个 //出现在其出现的最内存的lambda闭包对象的成员访问表达式的类型 //无限定标识符，有限定标识符，名字，请看本人简书，绪论。 return true; } //+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- template\u003cclass ...T\u003e auto fun(T ... args)-\u003eint {return (...+args);}; //初等表达式之一，折叠表达式 bool main_expression() { C1 Ca,*Cb = new C1(); int C1::*p_member = \u0026C1::member; //表达式的概念，在本人简书内有叙述，此处不再做陈述。 //初等表达式： //初等表达式存在在表达式嵌套中，作为表达式求值的基本单位 int j; 1; //字面量 j; //对一个实体命名的名字 [](){}; //lanbda表达式 fun(1,2,3,4,5,6); //使用了折叠表达式返回，这里的折叠表达式是初定表达式 (1+2+3); //括号内的表达式，整个括号当作一个初等表达式 //解释：为什么括号优先计算 //因为一个表达式通常都是由运算数和运算符组成 //表达式可以是一堆初等表达式嵌套，之后顺序执行，所以，我们需要知道每个初等表达式的值即可 //因此，括号内的值回在所结合的运算符进行表达式求值之前被求值 //不求值表达式： sizeof(std::cout\u003c\u003c1); decltype(std::cout\u003c\u003c2); typeid(j += 4); //以及noexpect和求包大小的sizeof //不求值表达式的意义就在于，在编译期获得一个数据，并不在运行时对运算数求值，以上的表达式都是运算符 //特例，typeid在存对存在多态的对行求类型时，回求动态类型，此时会对表达式求值 //弃值表达式 //概念，弃值表达式实际上就是表明，当前表达式的值不被运算符所需要而被丢弃 j; //一个大的表达式，单独由一个标识符的 Ca.member; Cb-\u003emember; Ca.*p_member; Cb-\u003e*p_member; //对于这一类的成员访问表达式 j == 2?1:2; //条件表达式 1,2,3,4; //逗号表达式 //表达式语句 //表达式语句，即所有以;结尾的表达式，是C++顺序执行的程序片段 //常量表达式，在简书中描述这里不再赘述。 return true; } bool main_statement_identifier_expression() { return main_statement() \u0026\u0026 main_identifier() \u0026\u0026 main_expression(); } const ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:5:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"作用 修饰变量，说明该变量不可以被改变； 修饰指针，分为指向常量的指针（pointer to const）和自身是常量的指针（常量指针，const pointer）； 修饰引用，指向常量的引用（reference to const），用于形参类型，即避免了拷贝，又避免了函数对值的修改； 修饰成员函数，说明该成员函数内不能修改成员变量。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:6:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"const 的指针与引用 指针 指向常量的指针（pointer to const） 自身是常量的指针（常量指针，const pointer） 引用 指向常量的引用（reference to const） 没有 const reference，因为引用本身就是 const pointer （为了方便记忆可以想成）被 const 修饰（在 const 后面）的值不可改变，如下文使用例子中的 p2、p3 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:7:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"使用 const 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // 类 class A { private: const int a; // 常对象成员，只能在初始化列表赋值 public: // 构造函数 A() : a(0) { }; A(int x) : a(x) { }; // 初始化列表 // const可用于对重载函数的区分 int getValue(); // 普通成员函数 int getValue() const; // 常成员函数，不得修改类中的任何数据成员的值 }; void function() { // 对象 A b; // 普通对象，可以调用全部成员函数、更新常成员变量 const A a; // 常对象，只能调用常成员函数 const A *p = \u0026a; // 指针变量，指向常对象 const A \u0026q = a; // 指向常对象的引用 // 指针 char greeting[] = \"Hello\"; char* p1 = greeting; // 指针变量，指向字符数组变量 const char* p2 = greeting; // 指针变量，指向字符数组常量（const 后面是 char，说明指向的字符（char）不可改变） char* const p3 = greeting; // 自身是常量的指针，指向字符数组变量（const 后面是 p3，说明 p3 指针自身不可改变） const char* const p4 = greeting; // 自身是常量的指针，指向字符数组常量 } // 函数 void function1(const int Var); // 传递过来的参数在函数内不可变 void function2(const char* Var); // 参数指针所指内容为常量 void function3(char* const Var); // 参数指针为常量 void function4(const int\u0026 Var); // 引用参数在函数内为常量 // 函数返回值 const int function5(); // 返回一个常数 const int* function6(); // 返回一个指向常量的指针变量，使用：const int *p = function6(); int* const function7(); // 返回一个指向变量的常指针，使用：int* const p = function7(); static ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:8:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"作用 修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 c++规定const静态类成员可以直接初始化，其他非const的静态类成员需要在类外初始化，且不能使用static关键字。 我们一般选择在类的实现文件中实现它。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:9:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态成员 C++中静态成员是属于整个类的而不是某个对象，静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则，保证了安全性还可以节省内存 static成员变量属于类（被存放在数据段中），不属于某个具体的对象（具体对象的内存是分配在堆中的），即使创建多个对象，也只为该变量分配一次内存，所有对象使用的都是这份内存中的数据。 若它为public类型，当某个对象修改了它，也会影响到其他对象，所有对象都是“同甘共苦的” ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:10:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态成员函数 态成员函数的出现就是为了处理静态成员变量的 当调用一个对象的非静态成员函数时，系统会把该对象的起始地址赋给成员函数的this指针。而静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针，不能访问本类中的非静态成员。 this 指针 this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向调用该成员函数的那个对象。 当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，都隐式使用 this 指针。 当一个成员函数被调用时，自动向它传递一个隐含的参数，该参数是一个指向这个成员函数所在的对象的指针。 this 指针被隐含地声明为: ClassName *const this，这意味着不能给 this 指针赋值；在 ClassName 类的 const 成员函数中，this 指针的类型为：const ClassName* const，这说明不能对 this 指针所指向的这种对象是不可修改的（即不能对这种对象的数据成员进行赋值操作）； this 并不是一个常规变量，而是个右值，所以不能取得 this 的地址（不能 \u0026this）。 在以下场景中，经常需要显式引用 this 指针： 为实现对象的链式引用； 为避免对同一对象进行赋值操作； 在实现一些数据结构时，如 list。 inline 内联函数 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:11:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"特征 相当于把内联函数里面的内容写在调用内联函数处； 相当于不用执行进入函数的步骤，直接执行函数体； 相当于宏，却比宏多了类型检查，真正具有函数特性； 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数； 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:12:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"使用 inline 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 声明1（加 inline，建议使用） inline int functionName(int first, int second,...); // 声明2（不加 inline） int functionName(int first, int second,...); // 定义 inline int functionName(int first, int second,...) {/****/}; // 类内定义，隐式内联 class A { int doA() { return 0; } // 隐式内联 } // 类外定义，需要显式内联 class A { int doA(); } inline int A::doA() { return 0; } // 需要显式内联 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:13:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"编译器对 inline 函数的处理步骤 将 inline 函数体复制到 inline 函数调用点处； 为所用 inline 函数中的局部变量分配内存空间； 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:14:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"优缺点 优点 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。 内联函数在运行时可调试，而宏定义不可以。 缺点 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。 inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:15:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"虚函数（virtual）可以是内联函数（inline）吗？ Are “inline virtual” member functions ever actually “inlined”? 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。 内联是在编译器建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。 inline virtual 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 Base::who()），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。 虚函数内联使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include \u003ciostream\u003e using namespace std; class Base { public: inline virtual void who() { cout \u003c\u003c \"I am Base\\n\"; } virtual ~Base() {} }; class Derived : public Base { public: inline void who() // 不写inline时隐式内联 { cout \u003c\u003c \"I am Derived\\n\"; } }; int main() { // 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 Base b; b.who(); // 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。 Base *ptr = new Derived(); ptr-\u003ewho(); // 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。 delete ptr; ptr = nullptr; system(\"pause\"); return 0; } volatile 1 volatile int i = 10; volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用 volatile 告诉编译器不应对这样的对象进行优化。 volatile 关键字声明的变量，每次访问时都必须从内存中取出值（没有被 volatile 修饰的变量，可能由于编译器的优化，从 CPU 寄存器中取值） const 可以是 volatile （如只读的状态寄存器） 指针可以是 volatile assert() 断言，是宏，而非函数。assert 宏的原型定义在 \u003cassert.h\u003e（C）、\u003ccassert\u003e（C++）中，其作用是如果它的条件返回错误，则终止程序执行。可以通过定义 NDEBUG 来关闭 assert，但是需要在源代码的开头，include \u003cassert.h\u003e 之前。 assert() 使用 1 2 3 4 #define NDEBUG // 加上这行，则 assert 不可用 #include \u003cassert.h\u003e assert( p != NULL ); // assert 不可用 sizeof() sizeof 对数组，得到整个数组所占空间大小。 sizeof 对指针，得到指针本身所占空间大小。 #pragma pack(n) 设定结构体、联合以及类成员变量以 n 字节方式对齐 #pragma pack(n) 使用 1 2 3 4 5 6 7 8 9 10 11 #pragma pack(push) // 保存对齐状态 #pragma pack(4) // 设定为 4 字节对齐 struct test { char m1; double m4; int m3; }; #pragma pack(pop) // 恢复对齐状态 位域 1 Bit mode: 2; // mode 占 2 位 类可以将其（非静态）数据成员定义为位域（bit-field），在一个位域中含有一定数量的二进制位。当一个程序需要向其他程序或硬件设备传递二进制数据时，通常会用到位域。 位域在内存中的布局是与机器有关的 位域的类型必须是整型或枚举类型，带符号类型中的位域的行为将因具体实现而定 取地址运算符（\u0026）不能作用于位域，任何指针都无法指向类的位域 extern “C” 被 extern 限定的函数或变量是 extern 类型的 被 extern \"C\" 修饰的变量和函数是按照 C 语言方式编译和链接的 extern \"C\" 的作用是让 C++ 编译器将 extern \"C\" 声明的代码当作 C 语言代码处理，可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题。 extern “C” 使用 1 2 3 4 5 6 7 8 9 #ifdef __cplusplus extern \"C\" { #endif void *memset(void *, int, size_t); #ifdef __cplusplus } #endif struct 和 typedef struct ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:16:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C 中 1 2 3 4 // c typedef struct Student { int age; } S; 等价于 1 2 3 4 5 6 // c struct Student { int age; }; typedef struct Student S; 此时 S 等价于 struct Student，但两个标识符名称空间不相同。 另外还可以定义与 struct Student 不冲突的 void Student() {}。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:17:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 中 由于编译器定位符号的规则（搜索规则）改变，导致不同于C语言。 一、如果在类标识符空间定义了 struct Student {...};，使用 Student me; 时，编译器将搜索全局标识符表，Student 未找到，则在类标识符内搜索。 即表现为可以使用 Student 也可以使用 struct Student，如下： 1 2 3 4 5 6 // cpp struct Student { int age; }; void f( Student me ); // 正确，\"struct\" 关键字可省略 二、若定义了与 Student 同名函数之后，则 Student 只代表函数，不代表结构体，如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct Student { int age; } S; void Student() {} // 正确，定义后 \"Student\" 只代表此函数 //void S() {} // 错误，符号 \"S\" 已经被定义为一个 \"struct Student\" 的别名 int main() { Student(); struct Student me; // 或者 \"S me\"; return 0; } C++ 中 struct 和 class 结构体和类都是是一种构造类型。 C语言中的 struct 只能包含变量(包括函数指针)。 C++ 中的类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象”。 类只是一张图纸，起到说明的作用，不占用内存空间；对象才是具体的零件，要有地方来存放，才会占用内存空间。 在 C++ 中，通过类名就可以创建对象，即将图纸生产成零件，这个过程叫做类的实例化，因此也称对象是类的一个实例（Instance）。有些资料也将类的成员变量称为属性（Property），将类的成员函数称为方法（Method）。 总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:18:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"区别 最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。 类的默成员函数 union 联合 联合（union）是一种节省空间的特殊的类，一个 union 可以有多个数据成员，但是在任意时刻只有一个数据成员可以有值。当某个成员被赋值后其他成员变为未定义状态。联合有如下特点： 默认访问控制符为 public 可以含有构造函数、析构函数 不能含有引用类型的成员 不能继承自其他类，不能作为基类 不能含有虚函数 匿名 union 在定义所在作用域可直接访问 union 成员 匿名 union 不能包含 protected 成员或 private 成员 全局匿名联合必须是静态（static）的 union 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include\u003ciostream\u003e union UnionTest { UnionTest() : i(10) {}; int i; double d; }; static union { int i; double d; }; int main() { UnionTest u; union { int i; double d; }; std::cout \u003c\u003c u.i \u003c\u003c std::endl; // 输出 UnionTest 联合的 10 ::i = 20; std::cout \u003c\u003c ::i \u003c\u003c std::endl; // 输出全局静态匿名联合的 20 i = 30; std::cout \u003c\u003c i \u003c\u003c std::endl; // 输出局部匿名联合的 30 return 0; } C 实现 C++ 类 C 实现 C++ 的面向对象特性（封装、继承、多态） 封装：使用函数指针把属性与方法封装到结构体中 继承：结构体嵌套 多态：父类与子类方法的函数指针不同 Can you write object-oriented code in C? [closed] explicit（显式）关键字 explicit 修饰构造函数时，可以防止隐式转换和复制初始化 explicit 修饰转换函数时，可以防止隐式转换，但 按语境转换 除外 explicit 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 struct A { A(int) { } operator bool() const { return true; } }; struct B { explicit B(int) {} explicit operator bool() const { return true; } }; void doA(A a) {} void doB(B b) {} int main() { A a1(1); // OK：直接初始化 A a2 = 1; // OK：复制初始化 A a3{ 1 }; // OK：直接列表初始化 A a4 = { 1 }; // OK：复制列表初始化 A a5 = (A)1; // OK：允许 static_cast 的显式转换 doA(1); // OK：允许从 int 到 A 的隐式转换 if (a1); // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a6（a1）; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a7 = a1; // OK：使用转换函数 A::operator bool() 的从 A 到 bool 的隐式转换 bool a8 = static_cast\u003cbool\u003e(a1); // OK ：static_cast 进行直接初始化 B b1(1); // OK：直接初始化 B b2 = 1; // 错误：被 explicit 修饰构造函数的对象不可以复制初始化 B b3{ 1 }; // OK：直接列表初始化 B b4 = { 1 }; // 错误：被 explicit 修饰构造函数的对象不可以复制列表初始化 B b5 = (B)1; // OK：允许 static_cast 的显式转换 doB(1); // 错误：被 explicit 修饰构造函数的对象不可以从 int 到 B 的隐式转换 if (b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b6(b1); // OK：被 explicit 修饰转换函数 B::operator bool() 的对象可以从 B 到 bool 的按语境转换 bool b7 = b1; // 错误：被 explicit 修饰转换函数 B::operator bool() 的对象不可以隐式转换 bool b8 = static_cast\u003cbool\u003e(b1); // OK：static_cast 进行直接初始化 return 0; } friend 友元类和友元函数 能访问私有成员 破坏封装性 友元关系不可传递 友元关系的单向性 友元声明的形式及数量不受限制 using ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:19:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"using 声明 一条 using 声明 语句一次只引入命名空间的一个成员。它使得我们可以清楚知道程序中所引用的到底是哪个名字。如： 1 using namespace_name::name; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:20:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"构造函数的 using 声明 在 C++11 中，派生类能够重用其直接基类定义的构造函数。 1 2 3 4 5 class Derived : Base { public: using Base::Base; /* ... */ }; 如上 using 声明，对于基类的每个构造函数，编译器都生成一个与之对应（形参列表完全相同）的派生类构造函数。生成如下类型构造函数： 1 Derived(parms) : Base(args) { } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:21:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"using 指示 using 指示 使得某个特定命名空间中所有名字都可见，这样我们就无需再为它们添加任何前缀限定符了。如： 1 using namespace_name name; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:22:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"尽量少使用 using 指示 污染命名空间 一般说来，使用 using 命令比使用 using 编译命令更安全，这是由于它只导入了指定的名称。如果该名称与局部名称发生冲突，编译器将发出指示。using编译命令导入所有的名称，包括可能并不需要的名称。如果与局部名称发生冲突，则局部名称将覆盖名称空间版本，而编译器并不会发出警告。另外，名称空间的开放性意味着名称空间的名称可能分散在多个地方，这使得难以准确知道添加了哪些名称。 using 使用 尽量少使用 using 指示 1 using namespace std; 应该多使用 using 声明 1 2 3 int x; std::cin \u003e\u003e x ; std::cout \u003c\u003c x \u003c\u003c std::endl; 或者 1 2 3 4 5 6 using std::cin; using std::cout; using std::endl; int x; cin \u003e\u003e x; cout \u003c\u003c x \u003c\u003c endl; :: 范围解析运算符 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:23:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"分类 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的 :: 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 int count = 11; // 全局（::）的 count class A { public: static int count; // 类 A 的 count（A::count） }; int A::count = 21; void fun() { int count = 31; // 初始化局部的 count 为 31 count = 32; // 设置局部的 count 的值为 32 } int main() { ::count = 12; // 测试 1：设置全局的 count 的值为 12 A::count = 22; // 测试 2：设置类 A 的 count 为 22 fun(); // 测试 3 return 0; } enum 枚举类型 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:24:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"限定作用域的枚举类型 1 enum class open_modes { input, output, append }; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:25:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"不限定作用域的枚举类型 1 2 enum color { red, yellow, green }; enum { floatPrec = 6, doublePrec = 10 }; decltype decltype 关键字用于检查实体的声明类型或表达式的类型及值分类。decltype与auto关键字一样，用于进行编译时类型推导，不过它与auto还是有一些区别的。decltype的类型推导并不是像auto一样是从变量声明的初始化表达式获得变量的类型，而是总是以一个普通表达式作为参数，返回该表达式的类型,而且decltype并不会对表达式进行求值。 语法： 1 decltype ( expression ) decltype 使用 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:26:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"推导出表达式类型 1 2 int i = 4; decltype(i) a; //推导结果为int。a的类型为int。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:27:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"与using/typedef合用，用于定义类型 1 2 3 4 5 6 7 8 9 10 using size_t = decltype(sizeof(0));//sizeof(a)的返回值为size_t类型 using ptrdiff_t = decltype((int*)0 - (int*)0); using nullptr_t = decltype(nullptr); vector\u003cint \u003evec; typedef decltype(vec.begin()) vectype; for (vectype i = vec.begin; i != vec.end(); i++) { //... } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:28:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"重用匿名类型 1 2 3 4 5 struct { int d ; doubel b; }anon_s; 而借助decltype，我们可以重新使用这个匿名的结构体： 1 decltype(anon_s) as ;//定义了一个上面匿名的结构体 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:29:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"泛型编程中结合auto，用于追踪函数的返回值类型 这也是decltype最大的用途 1 2 3 4 5 template \u003ctypename _Tx, typename _Ty\u003e auto multiply(_Tx x, _Ty y)-\u003edecltype(x*y) { return x*y; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 尾置返回允许我们在参数列表之后声明返回类型 template \u003ctypename It\u003e auto fcn(It beg, It end) -\u003e decltype(*beg) { // 处理序列 return *beg; // 返回序列中一个元素的引用 } // 为了使用模板参数成员，必须用 typename template \u003ctypename It\u003e auto fcn2(It beg, It end) -\u003e typename remove_reference\u003cdecltype(*beg)\u003e::type { // 处理序列 return *beg; // 返回序列中一个元素的拷贝 } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:30:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"decltype推导四规则 如果e是一个没有带括号的标记符表达式或者类成员访问表达式，那么的decltype（e）就是e所命名的实体的类型。此外，如果e是一个被重载的函数，则会导致编译错误。 否则 ，假设e的类型是T，如果e是一个将亡值，那么decltype（e）为T\u0026\u0026 否则，假设e的类型是T，如果e是一个左值，那么decltype（e）为T\u0026。 否则，假设e的类型是T，则decltype（e）为T。 标记符指的是除去关键字、字面量等编译器需要使用的标记之外的程序员自己定义的标记，而单个标记符对应的表达式即为标记符表达式。例如： 1 int arr[4] 则arr为一个标记符表达式，而arr[3]+0不是。 我们来看下面这段代码： 1 2 3 int i=10; decltype(i) a; //a推导为int decltype((i))b=i;//b推导为int\u0026，必须为其初始化，否则编译错误 仅仅为i加上了()，就导致类型推导结果的差异。这是因为，i是一个标记符表达式，根据推导规则1，类型被推导为int。而(i)为一个左值表达式，所以类型被推导为int\u0026。 通过下面这段代码可以对推导四个规则作进一步了解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 int i = 4; int arr[5] = { 0 }; int *ptr = arr; struct S{ double d; }s ; void Overloaded(int); void Overloaded(char);//重载的函数 int \u0026\u0026 RvalRef(); const bool Func(int); //规则一：推导为其类型 decltype (arr) var1; //int 标记符表达式 decltype (ptr) var2;//int * 标记符表达式 decltype(s.d) var3;//doubel 成员访问表达式 //decltype(Overloaded) var4;//重载函数。编译错误。 //规则二：将亡值。推导为类型的右值引用。 decltype (RvalRef()) var5 = 1; //规则三：左值，推导为类型的引用。 decltype ((i))var6 = i; //int\u0026 decltype (true ? i : i) var7 = i; //int\u0026 条件表达式返回左值。 decltype (++i) var8 = i; //int\u0026 ++i返回i的左值。 decltype(arr[5]) var9 = i;//int\u0026. []操作返回左值 decltype(*ptr)var10 = i;//int\u0026 *操作返回左值 decltype(\"hello\")var11 = \"hello\"; //const char(\u0026)[9] 字符串字面常量为左值，且为const左值。 //规则四：以上都不是，则推导为本类型 decltype(1) var12;//const int decltype(Func(1)) var13=true;//const bool decltype(i++) var14 = i;//int i++返回右值 这里需要提示的是，字符串字面值常量是个左值，且是const左值，而非字符串字面值常量则是个右值。 这么多规则，对于我们写代码的来说难免太难记了，特别是规则三。我们可以利用C++11标准库中添加的模板类is_lvalue_reference来判断表达式是否为左值： 1 cout \u003c\u003c is_lvalue_reference\u003cdecltype(++i)\u003e::value \u003c\u003c endl; 结果1表示为左值，结果为0为非右值。 同样的，也有is_rvalue_reference这样的模板类来判断decltype推断结果是否为右值。 引用 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:31:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"左值引用 常规引用，一般表示对象的身份。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:32:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"右值引用 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。 右值引用可实现转移语义（Move Sementics）和精确传递（Perfect Forwarding），它的主要目的有两个方面： 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。 能够更简洁明确地定义泛型函数。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:33:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"引用折叠 X\u0026 \u0026、X\u0026 \u0026\u0026、X\u0026\u0026 \u0026 可折叠成 X\u0026 X\u0026\u0026 \u0026\u0026 可折叠成 X\u0026\u0026 宏 宏定义可以实现类似于函数的功能，但是它终归不是函数，而宏定义中括弧中的“参数”也不是真的参数，在宏展开的时候对 “参数” 进行的是一对一的替换。 成员初始化列表 好处 更高效：少了一次调用默认构造函数的过程。 有些场合必须要用初始化列表： 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面 没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化 initializer_list 列表初始化 用花括号初始化器列表初始化一个对象，其中对应构造函数接受一个 std::initializer_list 参数. initializer_list 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cinitializer_list\u003e template \u003cclass T\u003e struct S { std::vector\u003cT\u003e v; S(std::initializer_list\u003cT\u003e l) : v(l) { std::cout \u003c\u003c \"constructed with a \" \u003c\u003c l.size() \u003c\u003c \"-element list\\n\"; } void append(std::initializer_list\u003cT\u003e l) { v.insert(v.end(), l.begin(), l.end()); } std::pair\u003cconst T*, std::size_t\u003e c_arr() const { return {\u0026v[0], v.size()}; // 在 return 语句中复制列表初始化 // 这不使用 std::initializer_list } }; template \u003ctypename T\u003e void templated_fn(T) {} int main() { S\u003cint\u003e s = {1, 2, 3, 4, 5}; // 复制初始化 s.append({6, 7, 8}); // 函数调用中的列表初始化 std::cout \u003c\u003c \"The vector size is now \" \u003c\u003c s.c_arr().second \u003c\u003c \" ints:\\n\"; for (auto n : s.v) std::cout \u003c\u003c n \u003c\u003c ' '; std::cout \u003c\u003c '\\n'; std::cout \u003c\u003c \"Range-for over brace-init-list: \\n\"; for (int x : {-1, -2, -3}) // auto 的规则令此带范围 for 工作 std::cout \u003c\u003c x \u003c\u003c ' '; std::cout \u003c\u003c '\\n'; auto al = {10, 11, 12}; // auto 的特殊规则 std::cout \u003c\u003c \"The list bound to auto has size() = \" \u003c\u003c al.size() \u003c\u003c '\\n'; // templated_fn({1, 2, 3}); // 编译错误！“ {1, 2, 3} ”不是表达式， // 它无类型，故 T 无法推导 templated_fn\u003cstd::initializer_list\u003cint\u003e\u003e({1, 2, 3}); // OK templated_fn\u003cstd::vector\u003cint\u003e\u003e({1, 2, 3}); // 也 OK } 面向对象 面向对象程序设计（Object-oriented programming，OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。 面向对象三大特征 —— 封装、继承、多态 封装 把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。关键字：public, protected, private。不写默认为 private。 public 成员：可以被任意实体访问 protected 成员：只允许被子类及本类的成员函数访问 private 成员：只允许被本类的成员函数、友元类或友元函数访问 继承 基类（父类）——\u003e 派生类（子类） 多态 多态，即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。 多态是以封装和继承为基础的。 C++ 多态分类及实现： 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载 子类型多态（Subtype Polymorphism，运行期）：虚函数 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换 The Four Polymorphisms in C++ ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:34:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"静态多态（编译期/早绑定） 函数重载 1 2 3 4 5 6 class A { public: void do(int a); void do(int a, int b); }; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:35:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"动态多态（运行期期/晚绑定） 虚函数：用 virtual 修饰成员函数，使其成为虚函数 注意： 普通函数（非类成员函数）不能是虚函数 静态函数（static）不能是虚函数 构造函数不能是虚函数（因为在调用构造函数时，虚表指针并没有在对象的内存空间中，必须要构造函数调用完成后才会形成虚表指针） 内联函数不能是表现多态性时的虚函数，解释见：虚函数（virtual）可以是内联函数（inline）吗？ 动态多态使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Shape // 形状类 { public: virtual double calcArea() { ... } virtual ~Shape(); }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; class Rect : public Shape // 矩形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); Shape * shape2 = new Rect(5.0, 6.0); shape1-\u003ecalcArea(); // 调用圆形类里面的方法 shape2-\u003ecalcArea(); // 调用矩形类里面的方法 delete shape1; shape1 = nullptr; delete shape2; shape2 = nullptr; return 0; } 虚析构函数 虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象。 虚析构函数使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Shape { public: Shape(); // 构造函数不能是虚函数 virtual double calcArea(); virtual ~Shape(); // 虚析构函数 }; class Circle : public Shape // 圆形类 { public: virtual double calcArea(); ... }; int main() { Shape * shape1 = new Circle(4.0); shape1-\u003ecalcArea(); delete shape1; // 因为Shape有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类析构函数，防止内存泄漏。 shape1 = NULL; return 0； } 纯虚函数 纯虚函数是一种特殊的虚函数，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。 1 virtual int A() = 0; 虚函数、纯虚函数 类里如果声明了虚函数，这个函数是实现的，哪怕是空实现，它的作用就是为了能让这个函数在它的子类里面可以被覆盖（override），这样的话，编译器就可以使用后期绑定来达到多态了。纯虚函数只是一个接口，是个函数的声明而已，它要留到子类里去实现。 虚函数在子类里面可以不重写；但纯虚函数必须在子类实现才可以实例化子类。 虚函数的类用于 “实作继承”，继承接口的同时也继承了父类的实现。纯虚函数关注的是接口的统一性，实现由子类完成。 带纯虚函数的类叫抽象类，这种类不能直接生成对象，而只有被继承，并重写其虚函数后，才能使用。抽象类被继承后，子类可以继续是抽象类，也可以是普通类。 虚基类是虚继承中的基类，具体见下文虚继承。 CSDN . C++ 中的虚函数、纯虚函数区别和联系 虚函数指针、虚函数表 虚函数指针：在含有虚函数类的对象中，指向虚函数表，在运行时确定。 虚函数表：在程序只读数据段（.rodata section，见：目标文件存储结构），存放虚函数指针，如果派生类实现了基类的某个虚函数，则在虚表中覆盖原本基类的那个虚函数指针，在编译时根据类的声明创建。 C++中的虚函数(表)实现机制以及用C语言对其进行的模拟实现 C++中的虚指针与虚函数表 虚继承 虚继承用于解决多继承条件下的菱形继承问题（浪费存储空间、存在二义性）。 底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针（占用一个指针的存储空间，4字节）和虚基类表（不占用类对象的存储空间）（需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了）；当虚继承的子类被当做父类继承时，虚基类指针也会被继承。 实际上，vbptr 指的是虚基类表指针（virtual base table pointer），该指针指向了一个虚基类表（virtual table），虚表中记录了虚基类与本类的偏移地址；通过偏移地址，这样就找到了虚基类成员，而虚继承也不用像普通多继承那样维持着公共基类（虚基类）的两份同样的拷贝，节省了存储空间。 虚继承、虚函数 相同之处：都利用了虚指针（均占用类的存储空间）和虚表（均不占用类的存储空间） 不同之处： 虚继承 虚基类依旧存在继承类中，只占用存储空间 虚基类表存储的是虚基类相对直接继承类的偏移 虚函数 虚函数不占用存储空间 虚函数表存储的是虚函数地址 模板类、成员模板、虚函数 模板类中可以使用虚函数 一个类（无论是普通类还是类模板）的成员模板（本身是模板的成员函数）不能是虚函数 抽象类、接口类、聚合类 抽象类：含有纯虚函数的类 接口类：仅含有纯虚函数的抽象类 聚合类：用户可以直接访问其成员，并且具有特殊的初始化语法形式。满足如下特点： 所有成员都是 public 没有定义任何构造函数 没有类内初始化 没有基类，也没有 virtual 函数 内存分配和管理 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:36:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"malloc、calloc、realloc、alloca malloc：申请指定字节数的内存。申请到的内存中的初始值不确定。 calloc：为指定长度的对象，分配能容纳其指定个数的内存。申请到的内存的每一位（bit）都初始化为 0。 realloc：更改以前分配的内存长度（增加或减少）。当增加长度时，可能需将以前分配区的内容移到另一个足够大的区域，而新增区域内的初始值则不确定。 alloca：在栈上申请内存。程序在出栈的时候，会自动释放内存。但是需要注意的是，alloca 不具可移植性, 而且在没有传统堆栈的机器上很难实现。alloca 不宜使用在必须广泛移植的程序中。C99 中支持变长数组 (VLA)，可以用来替代 alloca。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:37:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"malloc、free 用于分配、释放内存 malloc、free 使用 申请内存，确认是否申请成功 1 2 char *str = (char*) malloc(100); assert(str != nullptr); 释放内存后指针置空 1 2 free(p); p = nullptr; ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:38:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"new、delete new / new[]：完成两件事，先底层调用 malloc 分配了内存，然后调用构造函数（创建对象）。 delete/delete[]：也完成两件事，先调用析构函数（清理资源），然后底层调用 free 释放空间。 new 在申请内存时会自动计算所需字节数，而 malloc 则需我们自己输入申请内存空间的字节数。 new、delete 使用 申请内存，确认是否申请成功 1 2 3 4 5 6 int main() { T* t = new T(); // 先内存分配 ，再构造函数 delete t; // 先析构函数，再内存释放 return 0; } ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:39:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"定位 new 定位 new（placement new）允许我们向 new 传递额外的地址参数，从而在预先指定的内存区域创建对象。 1 2 3 4 new (place_address) type new (place_address) type (initializers) new (place_address) type [size] new (place_address) type [size] { braced initializer list } place_address 是个指针 initializers 提供一个（可能为空的）以逗号分隔的初始值列表 delete this 合法吗？ Is it legal (and moral) for a member function to say delete this? 合法，但： 必须保证 this 对象是通过 new（不是 new[]、不是 placement new、不是栈上、不是全局、不是其他对象成员）分配的 必须保证调用 delete this 的成员函数是最后一个调用 this 的成员函数 必须保证成员函数的 delete this 后面没有调用 this 了 必须保证 delete this 后没有人使用了 如何定义一个只能在堆上（栈上）生成对象的类？ 如何定义一个只能在堆上（栈上）生成对象的类? ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:40:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"只能在堆上 方法：将析构函数设置为私有 原因：C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:41:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"只能在栈上 方法：将 new 和 delete 重载为私有 原因：在堆上生成对象，使用 new 关键词操作，其过程分为两阶段：第一阶段，使用 new 在堆上寻找可用内存，分配给对象；第二阶段，调用构造函数生成对象。将 new 操作设置为私有，那么第一阶段就无法完成，就不能够在堆上生成对象。 智能指针 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:42:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 标准库（STL）中 头文件：#include \u003cmemory\u003e ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:43:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 98 1 std::auto_ptr\u003cstd::string\u003e ps (new std::string(str))； ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:44:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"C++ 11 shared_ptr unique_ptr weak_ptr auto_ptr（被 C++11 弃用） Class shared_ptr 实现共享式拥有（shared ownership）概念。多个智能指针指向相同对象，该对象和其相关资源会在 “最后一个 reference 被销毁” 时被释放。为了在结构较复杂的情景中执行上述工作，标准库提供 weak_ptr、bad_weak_ptr 和 enable_shared_from_this 等辅助类。 Class unique_ptr 实现独占式拥有（exclusive ownership）或严格拥有（strict ownership）概念，保证同一时间内只有一个智能指针可以指向该对象。你可以移交拥有权。它对于避免内存泄漏（resource leak）——如 new 后忘记 delete ——特别有用。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"shared_ptr 多个智能指针可以共享同一个对象，对象的最末一个拥有着有责任销毁对象，并清理与该对象相关的所有资源。 支持定制型删除器（custom deleter），可防范 Cross-DLL 问题（对象在动态链接库（DLL）中被 new 创建，却在另一个 DLL 内被 delete 销毁）、自动解除互斥锁 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:1","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"weak_ptr weak_ptr 允许你共享但不拥有某对象，一旦最末一个拥有该对象的智能指针失去了所有权，任何 weak_ptr 都会自动成空（empty）。因此，在 default 和 copy 构造函数之外，weak_ptr 只提供 “接受一个 shared_ptr” 的构造函数。 可打破环状引用（cycles of references，两个其实已经没有被使用的对象彼此互指，使之看似还在 “被使用” 的状态）的问题 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:2","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"unique_ptr unique_ptr 是 C++11 才开始提供的类型，是一种在异常时可以帮助避免资源泄漏的智能指针。采用独占式拥有，意味着可以确保一个对象和其相应的资源同一时间只被一个 pointer 拥有。一旦拥有着被销毁或编程 empty，或开始拥有另一个对象，先前拥有的那个对象就会被销毁，其任何相应资源亦会被释放。 unique_ptr 用于取代 auto_ptr ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:3","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"auto_ptr 被 c++11 弃用，原因是缺乏语言特性如 “针对构造和赋值” 的 std::move 语义，以及其他瑕疵。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:4","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"auto_ptr 与 unique_ptr 比较 auto_ptr 可以赋值拷贝，复制拷贝后所有权转移；unqiue_ptr 无拷贝赋值语义，但实现了move 语义； auto_ptr 对象不能管理数组（析构调用 delete），unique_ptr 可以管理数组（析构调用 delete[] ）； 强制类型转换运算符 MSDN . 强制转换运算符 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:45:5","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"static_cast 用于非多态类型的转换 不执行运行时类型检查（转换安全性不如 dynamic_cast） 通常用于转换数值数据类型（如 float -\u003e int） 可以在整个类层次结构中移动指针，子类转化为父类安全（向上转换），父类转化为子类不安全（因为子类可能有不在父类的字段或方法） 向上转换是一种隐式转换。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:46:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"dynamic_cast 用于多态类型的转换 执行行运行时类型检查 只适用于指针或引用 对不明确的指针的转换将失败（返回 nullptr），但不引发异常 可以在整个类层次结构中移动指针，包括向上转换、向下转换 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:47:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"const_cast 用于删除 const、volatile 和 __unaligned 特性（如将 const int 类型转换为 int 类型 ） ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:48:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"reinterpret_cast 用于位的简单重新解释 滥用 reinterpret_cast 运算符可能很容易带来风险。 除非所需转换本身是低级别的，否则应使用其他强制转换运算符之一。 允许将任何指针转换为任何其他指针类型（如 char* 到 int* 或 One_class* 到 Unrelated_class* 之类的转换，但其本身并不安全） 也允许将任何整数类型转换为任何指针类型以及反向转换。 reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性。 reinterpret_cast 的一个实际用途是在哈希函数中，即，通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引。 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:49:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"bad_cast 由于强制转换为引用类型失败，dynamic_cast 运算符引发 bad_cast 异常。 bad_cast 使用 1 2 3 4 5 6 try { Circle\u0026 ref_circle = dynamic_cast\u003cCircle\u0026\u003e(ref_shape); } catch (bad_cast b) { cout \u003c\u003c \"Caught: \" \u003c\u003c b.what(); } 运行时类型信息 (RTTI) ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:50:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"dynamic_cast 用于多态类型的转换 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:51:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"typeid typeid 运算符允许在运行时确定对象的类型 type_id 返回一个 type_info 对象的引用 如果想通过基类的指针获得派生类的数据类型，基类必须带有虚函数 只能获取对象的实际类型 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:52:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"type_info type_info 类描述编译器在程序中生成的类型信息。 此类的对象可以有效存储指向类型的名称的指针。 type_info 类还可存储适合比较两个类型是否相等或比较其排列顺序的编码值。 类型的编码规则和排列顺序是未指定的，并且可能因程序而异。 头文件：typeinfo typeid、type_info 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u003ciostream\u003e using namespace std; class Flyable // 能飞的 { public: virtual void takeoff() = 0; // 起飞 virtual void land() = 0; // 降落 }; class Bird : public Flyable // 鸟 { public: void foraging() {...} // 觅食 virtual void takeoff() {...} virtual void land() {...} virtual ~Bird(){} }; class Plane : public Flyable // 飞机 { public: void carry() {...} // 运输 virtual void takeoff() {...} virtual void land() {...} }; class type_info { public: const char* name() const; bool operator == (const type_info \u0026 rhs) const; bool operator != (const type_info \u0026 rhs) const; int before(const type_info \u0026 rhs) const; virtual ~type_info(); private: ... }; void doSomething(Flyable *obj) // 做些事情 { obj-\u003etakeoff(); cout \u003c\u003c typeid(*obj).name() \u003c\u003c endl; // 输出传入对象类型（\"class Bird\" or \"class Plane\"） if(typeid(*obj) == typeid(Bird)) // 判断对象类型 { Bird *bird = dynamic_cast\u003cBird *\u003e(obj); // 对象转化 bird-\u003eforaging(); } obj-\u003eland(); } int main(){ Bird *b = new Bird(); doSomething(b); delete b; b = nullptr; return 0; } 参考资料 C++：默认成员函数和this指针 C++类和对象的总结，拿去做笔记吧 ","date":"2023-01-30","objectID":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/:53:0","tags":["cpp"],"title":"C++:基础概念整理","uri":"/posts/program/cpp/c++%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%95%B4%E7%90%86/"},{"categories":["cpp"],"content":"Effective Cplus 摘要笔记","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 让自己习惯C++ 构造/析构/赋值运算 资源管理 设计与声明 实现 继承与面向对象设计 模板与泛型编程 定制new和delete 杂项讨论 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:0:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"让自己习惯C++ 视C++为一个语言联邦 C++高效编程守则视状况而变化，取决于你使用C++的哪一部分。 尽量以const，enums，inline替换#define 对于单纯常量，最好以const对象或enums替换#defines； 对于形似函数的宏（macros），最好改用inline函数替换#defines。 尽可能使用const 将某些东西声明为const可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体； 编译器强制实施bitwise constness，当你编写程序时应该使用“概念上的常量性”（conceptual constness） 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复。 确定对象被使用前已先被初始化 为内置性对象进行手工初始化，因为C++不保证初始化它们； 构造函数最好使用成员初值列（member initialization list），而不要在构造函数本体内使用赋值操作（assignment）。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同； 为免除“跨编译单元值初始化次序”问题，轻易local static对象替换non-local static对象。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:1:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"构造/析构/赋值运算 了解C++默默编写并调用哪些函数 编译器可以暗自为class创建default构造函数、copy构造函数、copy assignment操作符，以及析构函数。 若不想使用编译器自动生成的函数，就该明确拒绝 为驳回编译器自动（暗自）提供的机能，可将相应的成员函数声明为private并且不予以实现。 为多态基类声明virtual析构函数 polymorphic（带多态性质的）base classes应该声明一个virtual析构函数。如果class带有任何virtual函数，它就应该拥有一个virtual析构函数； Classes的设计目的如果不是作为base classes使用，或不是为了具备多态性（polymorphically），就不该声明virtual析构函数。 别让异常逃离析构函数 析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，然后吐下它们（不传播）或结束程序； 如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么class应该提供一个普通函数（而非在析构函数中）执行该操作。 绝不在构造和析构过程中调用virtual函数 在构造和析构期间不要调用virtual函数，因为这类调用从不下降至derived class（比起当前执行构造函数和析构函数的那层）。 令operator=返回一个reference to *this 令赋值（assignment）操作符返回一个reference to *this。 在operator=中处理“自我赋值” 确保当对象自我赋值时operator=有良好行为。其中技术包括比较“来源图像”和“目标对象”的地址、精心周到的语句顺序、以及copy-and-swap； 确定任何函数如果操作一个以上的对象，而其中多个对象时同一个对象时，其行为仍然正确。 复制对象时勿忘其每一个成分 Copying函数应该确保复制“对象内的所有成员变量”及“所有base class成分”； 不要尝试以某个copying函数实现另一个copying函数。应该讲共同机能放进第三个函数中，并由两个copying函数共同调用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:2:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"资源管理 以对象管理资源 为防止资源泄露，请使用RAII对象，它们在构造函数中获得资源并在析构函数中释放资源； 两个常常被使用的RAII classes分别是tr1::shared_ptr和auto_ptr。前者通常是较佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它（被复制物）指向null。 在资源管理类中小心copying行为 复制RAII对象必须一并复制它所管理的资源，所以资源的copying行为决定RAII对象的copying行为； 普遍而常见的RAII class copying行为是：抑制copying、施行引入计数法（reference counting）。不过其他行为也都可能被实现。 在资源管理类中提供对原始资源的访问 APIs往往要求访问原始资源（raw resources），所以每一个RAII class应该提供一个“取得其所管理之资源”的办法； 对原始资源的访问可能经由显示转换或隐式转换。一般而言显示转换比较安全，但隐式转换对客户比较方便。 成对使用new和delete时要采取相同的形式 如果你在new表达式中使用[]，必须在相应的delete表达式中也是用[]。如果你在new表达式中不使用[]，一定不要在相应的delete表达式中使用[]。 以独立语句将newed对象置入智能指针 以独立语句将newed对象存储于（置入）智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄露。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:3:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"设计与声明 让接口容易被正确使用，不容易被误用 好的接口很容易被正确使用，不容易被误用。你应该在你的所有接口中努力达成这些性质； “阻止误用”的办法是建立新类型、限制类型上的操作，束缚对象值，以及消除客户的资源管理任务； tr1::shared_ptr支持定制型删除器（custom deleter）。这可防范DLL问题，可被用来自动解除互斥锁（mutexes）等等。 设计class犹如设计type Class的设计就是type的设计。在定义一个新type之前，请确定考虑新type对象的创建和销毁、对象的初始化和赋值、合法值、继承关系等。 宁以pass-by-reference-to-const替换pass-by-value 尽量以pass-by-reference-to-const替换pass-by-value。前者通常比较高效，并可避免切割问题； 以上规则并不适用于内置类型，以及STL的迭代器和函数对象。对它们而言，pass-by-value往往比较适当。 必须返回对象时，别妄想返回其reference 绝不要返回pointer或reference指向一个local stack对象，或返回reference指向一个heap-allocated对象，或返回pointer或reference指向一个local static对象而有可能同时需要多个这样的对象。 将成员变量声明为private 切记将成员变量声明为private。这可赋予客户访问数据的一致性、可细微划分访问控制、允许约束条件获得保证，并提供class作者以充分的实现弹性； protected并不比public更具封装性。 宁以non-member、non-friend替换member函数 宁可拿non-member non-friend函数替换member函数。这样做可以增加封装性、包裹弹性（packaging flexibility）和机能扩充性。 若所有参数皆需类型转换，请以此采用non-member函数 如果你需要为某个函数的所有参数（包括被this指针所指的那个隐喻参数）进行类型转换，那么这个函数必须是个non-member。 考虑写出一个不抛出异常的swap函数 当std::swap对你的类型效率不高时，提供一个swap成员函数，并确定这个函数不抛出异常； 如果你提供一个member swap，也该提供一个non-member swap用来调用前者。对于classes（而非templates），也请特化std::swap； 调用swap时应针对std::swap使用using声明式，然后调用swap并且不带任何“命名空间资格修饰”； 为“用户定义类型”进行std templates全特化是好的，但千万不要尝试在std内加入某些对std而言全新的东西。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:4:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"实现 尽可能延后变量定义式的出现时间 尽可能延后变量定义式的出现。这样做可增加程序的清晰度并改善程序效率。 尽量少做转型动作 如果可以，尽量避免转型，特别是在注重效率的代码中避免dynamic_casts。如果有个设计需要转型动作，试着发展无需转型的替代设计； 如果转型是必要的，试着将它隐藏于某个函数背后。客户随后可以调用该函数，而不需要将转型放进他们自己的代码内； 宁可使用C++ style（新式）转型，不要使用旧式转型。前者很容易辨识出来，而且也比较有着分门别类的职掌。 避免返回handles指向对象内部成分 避免返回handles（包括references、指针、迭代器）指向对象内部。遵守这个条款可增加封装性，帮助const成员函数的行为像个const，并将发生“虚吊号码牌”的可能性降至最低。 为“异常安全”而努力是值得的 异常安全函数（Exception-safe functions）即使发生异常也不会泄露资源或允许任何数据结构败坏。这样的函数区分为三种可能的保证：基本型、强烈型、不抛异常型； “强烈保证”往往能够以copy-and-swap实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义； 函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。 透彻了解inlining的里里外外 将大多数inlining限制在小型、被频繁调用的函数身上。这可使日后的调试过程和二进制升级（binary upgradability）更容易，也可使潜在的代码膨胀问题最小化，使程序的速度提升机会最大化； 不要只因为function templates出现在头文件，就将它们声明为inline。 将文件间的编译依存关系降至最低 支持“编译依存性最小化”的一般构想是：相依于声明式，不要相依于定义式。基于此构想的两个手段是Handle classes和Interface classes； 程序库头文件应该以“完全且仅有声明式”（full and declaration-only forms）的形式存在。这种做法不论是否涉及templates都适用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:5:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"继承与面向对象设计 确定你的public继承塑模出is-a关系 “public继承”意味is-a。适用于base classes身上的每一件事情一定也适用于derived classes身上，因为每一个derived class对象也都是一个base class对象。 避免遮蔽继承而来的名称 derived classes内的名称会遮掩base classes内的名称。在public继承下从来没有人希望如此； 为了让被遮掩的名称再见天日，可使用using声明式或转交函数（forwarding functions)。 区分接口继承和实现继承 接口继承和实现继承不同。在public继承之下，derived classes总是继承base class的接口； pure virtual函数只具体指定接口继承； 简朴的（非纯）impure virtual函数具体指定接口继承及缺省实现继承； non-virtual函数具体指定接口继承以及强制性实现继承。 考虑virtual函数以外的其他选择 virtual函数的替代方案包括NVI手法及Strategy设计模式的多种形式。NVI手法自身是一个特殊形式的Template Method设计模式； 将机能从成员函数移到class外部函数，带来的一个缺点是，非成员函数无法访问class的non-public成员； tr1::function对象的行为就像一般函数指针。这样的对象可接纳“与给定之目标签名式（target signature）兼容”的所有可调用物（callable entities）。 绝不重定义继承而来的non-virtual函数 绝不要重新定义继承而来的non-virtual函数。 绝不重新定义继承而来的缺省参数值 绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而virtual函数——你唯一应该覆写的东西——却是动态绑定。 通过复合塑模出has-a或“根据某物出现” 复合（composition）的意义和public继承完全不同； 在应用域（application domain），复合意味has-a（有一个）。在实现域（implementation domain），复合意味着is-implemented-in-terms-of（根据某物实现出）。 明智而审慎地使用private继承 Private继承意味着is-implement-in-terms-of（根据某物实现出）。它通常比复合（composition）的级别低。但是当derived class需要访问protected base class的成员，或需要重新定义继承而来的virtual函数时，这么设计是合理的； 和复合（composition）不同，private继承可以造成empty base最优化。这对致力于“对象尺寸最小化”的程序开发者而言，可能很重要。 明智而审慎地使用多重继承 多重继承比单一继承复杂。它可能导致新的歧义性，以及对virtual继承的需要； virtual继承会增加大小、速度、初始化（及赋值）复杂度等等成本。如果virtual base classes不带任何数据，将是最具实用价值的情况； 多重继承的确有正当用途。其中一个情节涉及“public继承某个Interface class”和“private继承某个协助实现的class”的两相结合。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:6:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"模板与泛型编程 了解隐式接口和编译器多态 classes和template都支持接口（interfaces）和多态（polymorphism）； 对classes而言接口是显示的（explicit），以函数签名为中心。多态则是通过virtual函数发生于运行期； 对templates参数而言，接口是隐式的（implicit），奠基与有效表达式。对态则是通过template具现化和函数重载解析（function overloading resolution）发生于编译期。 了解typename的双重意义 声明template参数时，前缀关键字class和typename可互换； 请使用关键字typename标识嵌套从属类型名称；但不得在base class lists（基类列）或member initialization list（成员初值列）内以它作为base class修饰符。 学习处理模板化基类内的名称 可在derived class templates内通过“this-\u003e”指涉base class templates内的成员名称，或籍由一个明白写出的“base class资格修饰符”完成。 将与参数无关的代码抽离 Templates生成多个classes和多个函数，所以任何template代码都不该与某个造成膨胀的template参数产生相依关系； 因非类型模板参数（non-type template parameters）而造成的代码膨胀，往往可消除，做法是以函数参数或class成员变量替换template参数； 因类型参数（type parameters）而造成的代码膨胀，往往可以降低，做法是让带有完全相同二进制表示（binary representations）的具现类型（instantiation types）共享实现码。 运用成员函数模板接受所有兼容类型 请使用member function templates（成员函数模板）生成“可接受所有兼容类型”的函数； 如果你声明member templates用于“泛化copy构造”或“泛化assignment操作”，你还是需要声明正常的copy构造函数和copy assignment操作符。 需要类型转换时请为模板定义非成员函数 当我们编写一个class template，而它所提供之“与此template相关的”函数支持“所有参数之隐式类型转换”时，请将那些函数定义为“class template内部的friend函数”。 请使用traits classes表现类型信息 Traits classes使得“类型相关信息”在编译期可用。它们以templates和“templates特化”完成实现； 整个重载技术（overloading）后，traits classes有可能在编译期对类型执行if…else测试。 认识template元编程 Template metaprogramming（TMP，模板元编程）可将工作由运行期移往编译期，因而得以实现早期错误侦测和更高的执行效率； TMP可被用来生成“基于政策选择组合”（based on combinations of pilicy choices）的客户定制代码，也可用来避免生成对某些特殊类型并不适合的代码。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:7:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"定制new和delete 了解new-handler的行为 set_new_handler允许客户指定一个函数，在内存分配无法获得满足时被调用； Nothrow new是一个颇为局限的工具，因为它只适用于内存分配；后继的构造函数调用还是可能抛出异常。 了解new和delete的合理替换时机 有许多理由需要写个自定的new和delete，包括改善效能、对heap运用错误进行调试、收集heap使用信息。 编写new和delete时需固守常规 operator new应该内含一个无穷循环，并在其中尝试分配内存，如果它无法满足内存需求，就该调用new-handler。它也应该有能力处理0 bytes申请。Class专属版本则还应该处理“比正确大小更大的（错误）申请； operator delete应该在收到null指针时不做任何事。Class专属版本则还应该处理“比正确大小更大的（错误）申请。 写了placement new也要写placement delete 当你写一个placement operator new，请确定它也写出了对应的placement operator delete。如果没有这样做，你的程序可能会发生隐微而时断时续的内存泄露； 当声明placement new和placement delete，请确定不要无意识（非故意）地遮盖了它们的正常版本。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:8:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"杂项讨论 不要请勿编译器的警告 严肃对待编译器发生的警告信息。努力在你的编译器的最高（最苛刻）警告级别下争取“无任何警告”的荣誉； 不要过度依赖编译器的报警功能，因为不同的编译器对待事情的态度并不相同。一旦移植到另一个编译器上，你原本依赖的警告信息有可能消失。 让自己熟悉包括TR1在内的标准程序库 C++标准程序库的主要机能由STL、iostreams、locales组成。并包含C99标准程序库； TR1添加了只能指针（如tr1::shared_ptr）、一般化函数指针（tr1::function）、hash-based容器、正则表达式（regular expression）以及另外10个组件的支持； TR1自身只是一份规范。为获得TR1提供的好处，需要一份实物。一个好的实物来源是Boost。 让自己熟悉Boost Boost是一个社群，也是一个网站。致力于免费、源码开放、同僚复审的C++程序库开发。Boost在C++标准化过程中扮演具有影响力的角色； Boost提供许多TR1组件实现品，以及其他许多程序库。 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_cplus/:9:0","tags":["Effective Cplus"],"title":"C++:Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_cplus/"},{"categories":["cpp"],"content":"Effective Modern Cplus 摘要笔记","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 类型推导 auto 移步现代C++ 智能指针 右值引用，移动语意，完美转发 Lambda表达式 并发API 微调 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:0:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"类型推导 理解模板类型推导 理解auto类型推导 理解decltype 学会查看类型推导结果 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:1:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"auto 优先考虑auto而非显式类型声明 auto推导若非己愿，使用显式类型初始化惯用法 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:2:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"移步现代C++ 区别使用()和{}创建对象 优先考虑nullptr而非0和NULL 优先考虑别名声明而非typedefs 优先考虑限域枚举而非未限域枚举 优先考虑使用delete而非使用未定义的私有声明 使用override声明重载函数 优先考虑const_iterator而非iterator 如果函数不抛出异常请使用noexcept 尽可能的使用constexpr 确保const成员函数线程安全 理解特殊成员函数函数的生成 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:3:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"智能指针 对于占有性资源使用std::unique_ptr 对于共享性资源使用std::shared_ptr 对于类似于std::shared_ptr的指针使用std::weak_ptr可能造成悬置 优先考虑使用std::make_unique和std::make_shared而非new 当使用Pimpl惯用法，请在实现文件中定义特殊成员函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:4:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"右值引用，移动语意，完美转发 理解std::move和std::forward 区别通用引用和右值引用 对于右值引用使用std::move，对于通用引用使用std::forward 避免重载通用引用 熟悉重载通用引用的替代品 理解引用折叠 认识移动操作的缺点 熟悉完美转发失败的情况 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:5:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"Lambda表达式 避免使用默认捕获模式 使用初始化捕获来移动对象到闭包中 对于std::forward的auto\u0026\u0026形参使用decltype 有限考虑lambda表达式而非std::bind ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:6:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"并发API 优先考虑基于任务的编程而非基于线程的编程 如果有异步的必要请指定std::launch::threads 从各个方面使得std::threads unjoinable 知道不同线程句柄析构行为 考虑对于单次事件通信使用void 对于并发使用std::atomic，volatile用于特殊内存区 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:7:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"微调 对于那些可移动总是被拷贝的形参使用传值方式 考虑就地创建而非插入 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/effective_modern_cplus/:8:0","tags":["Effective Modern Cplus"],"title":"C++:Effective Modern Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/effective_modern_cplus/"},{"categories":["cpp"],"content":"More Effective Cplus","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 基础议题 运算符 异常 效率 技巧 杂项 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:0:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"基础议题 区分指针和引用 优先考虑C++风格的类型转换 决不要把多态用于数组 避免不必要的默认构造函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:1:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"运算符 小心用户自定义的转换函数 区分自增运算符和自减运算符的前缀形式与后缀形式 不要重载\"\u0026\u0026\"||“和”,\" 理解new和delete在不同情形下的含义 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:2:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"异常 使用析构函数防止资源泄漏 防止构造函数里的资源泄漏 阻止异常传递到析构函数以外 理解抛出异常与传递参数或者调用虚函数之间的不同 通过引用捕获异常 审慎地使用异常规格 理解异常处理所付出的代价 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:3:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"效率 记住80-20准则 考虑使用延迟计算 分期摊还预期的计算开销 了解临时对象的来源 协助编译器实现返回值优化 通过函数重载避免隐式类型转换 考虑使用op=来取代单独的op运算符 考虑使用其他等价的程序库 理解虚函数、多重继承、虚基类以及RTTI所带来的开销 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:4:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"技巧 使构造函数和非成员函数具有虚函数的行为 限制类对象的个数 要求或禁止对象分配在堆上 智能(smart)指针 引用计数 代理类 基于多个对象的虚函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:5:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":"杂项 在将来时态下开发程序 将非尾端类设计为抽象类 理解如何在同一程序中混合使用C 让自己熟悉C++语言标准 ","date":"2023-01-22","objectID":"/posts/program/cpp/effective_cplus/more_effective_cplus/:6:0","tags":["More Effective Cplus"],"title":"C++:More Effective Cplus 摘要笔记","uri":"/posts/program/cpp/effective_cplus/more_effective_cplus/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 拷贝构造函数 拷贝构造函数的调用时机 1. 当函数的参数为类的对象:以值传递的方式传入函数体 2. 函数的返回值是类的对象:以值传递的方式从函数返回 3. 对象需要通过另外一个对象进行初始化 : 赋值初始化 浅拷贝与深拷贝 1. 默认拷贝构造函数 拷贝赋值函数 copy constructor与copy assignment的区别与联系 拷贝构造函数 拷贝构造函数(复制构造函数)是构造函数的一种，它只有一个参数，参数类型是本类的引用。它由编译器调用来完成一些基于同一类的其他对象的构建及初始化。 复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。 如果类的设计者不写复制构造函数，编译器就会自动生成复制构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。 默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: //构造函数 CExample(int b) { a=b; printf(\"constructor is called\\n\"); } //拷贝构造函数 CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } //析构函数 ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; int main() { CExample A(100); CExample B=A; B.Show(); return 0; } 执行结果： constructor is called copy constructor is called 100 destructor is called destructor is called 拷贝构造函数的调用时机 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:0:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"1. 当函数的参数为类的对象:以值传递的方式传入函数体 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: CExample(int b) { a=b; printf(\"constructor is called\\n\"); } CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; void g_fun(CExample c) { cout\u003c\u003c\"g_func\"\u003c\u003cendl; } int main() { CExample A(100); CExample B=A; B.Show(); g_fun(A); return 0; } 执行结果： constructor is called copy constructor is called 100 copy constructor is called g_func destructor is called destructor is called destructor is called 调用g_fun()时，会产生以下几个重要步骤： A对象传入形参时，会先会产生一个临时变量，就叫 C 吧。 然后调用拷贝构造函数把A的值给C。 整个这两个步骤有点像：CExample C(A); 等g_fun()执行完后, 析构掉 C 对象。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:1:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"2. 函数的返回值是类的对象:以值传递的方式从函数返回 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include\u003ciostream\u003e using namespace std; class CExample { private: int a; public: //构造函数 CExample(int b) { a=b; printf(\"constructor is called\\n\"); } //拷贝构造函数 CExample(const CExample \u0026 c) { a=c.a; printf(\"copy constructor is called\\n\"); } //析构函数 ~CExample() { cout\u003c\u003c\"destructor is called\\n\"; } void Show() { cout\u003c\u003ca\u003c\u003cendl; } }; CExample g_fun() { CExample temp(0); return temp; } int main() { CExample example = g_fun(); example.Show(); return 0; } 运行结果： constructor is called copy constructor is called destructor is called copy constructor is called destructor is called 10 destructor is called 当g_Fun()函数执行到return时，会产生以下几个重要步骤： 先会产生一个临时变量，就叫XXXX吧。 然后调用拷贝构造函数把temp的值给XXXX。整个这两个步骤有点像：CExample XXXX(temp); 在函数执行到最后先析构temp局部变量。 等g_fun()执行完后再析构掉XXXX对象。 说明，由于g++ 编译是会进行优化，这里需要使用 ： g++ -fno-elide-constructors xx 进行编译 C++返回值为对象时复制构造函数不执行怎么破 命名返回值优化 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:2:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"3. 对象需要通过另外一个对象进行初始化 : 赋值初始化 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。 1 2 3 CExample A(100); CExample B=A; CExample C(A); 注意：赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。 1 2 CExample c1, c2; c1 = c2 ; c1=c2; 这条语句不会引发复制构造函数的调用，因为 c1 早已生成，已经初始化过了。 浅拷贝与深拷贝 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:3:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":"1. 默认拷贝构造函数 很多时候在我们都不知道拷贝构造函数的情况下，传递对象给函数参数或者函数返回对象都能很好的进行，这是因为编译器会给我们自动产生一个拷贝构造函数，这就是“默认拷贝构造函数”，这个构造函数很简单，仅仅使用“老对象”的数据成员的值对“新对象”的数据成员一一进行赋值，它一般具有以下形式： 1 2 3 4 5 Rect::Rect(const Rect\u0026 r) { width=r.width; height=r.height; } 当然，以上代码不用我们编写，编译器会为我们自动生成。但是如果认为这样就可以解决对象的复制问题，那就错了。 c++拷贝构造函数详解 C++拷贝构造函数（复制构造函数）详解 拷贝赋值函数 1 A\u0026 operator= (const A\u0026 a); //赋值构造函数 返回值的对象为引用是为了可以连续赋值 赋值函数中可以既可以使用引用也可以使用值传递，不过值传递会多生成一个对象，造成资源的浪费 1.对象以值传递方式从函数返回，且接受返回值的对象已经初始化过 1 2 A c; c = f(); 2.对象直接赋值给另一个对象，且接受值的对象已经初始化过 1 2 3 A a(1); A c; c = a; copy constructor与copy assignment的区别与联系 copy constructor： 从一个已有的对象来构造另一个对象； 包括： 用已有对象来初始化新声明的对象； 将对象按值传递给函数作为参数； 函数按值返回对象。 copy assignment： 将已有的对象赋值个另一个已有的对象； 实例： 1 2 3 4 5 6 7 8 9 10 11 Person A(B); // copy constructor Person C=B; //copy constructor Function1(D); //copy constructor B= Function2(…); //copy constructor Person D; D=B; //copy assignment 注意事项：编译器默认的copy constructor和copy assignment操作，是按照member-wise copy的方式逐个copy每个member，这种浅拷贝操作在有些情况下可能造成资源泄漏/指向重叠。 如果的确需要deep copy，需要自定义相应操作。这时需要清楚哪些地方用了copy constructor，哪些地方用了copy assignment，从而分别自定义copy constructor和copy assignment。一般来说，自定义的copy constructor、destructor和copy assignment操作常常同时出现。 区别与联系： copy constructor不用检测是否是用一个对象来初始化它自己； copy constructor不用对被构造对象做资源清理操作，如delete操作； ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/:4:0","tags":["cpp construct fun"],"title":"C++:拷贝构造函数和拷贝赋值函数","uri":"/posts/program/cpp/construct/c++%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%92%8C%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 最近遇到一个问题，time_t（__int64）类型与float类型直接相加得到的结果是错误的： 1 2 3 time_t curTime = 1563924292; float timeOffset = 3.56951; time_t result = curTime + timeOffset; //结果为1563924352，计算错误 错误原因涉及算术运算中的隐式转换规则，遂查阅资料整理了相关知识。 c++隐式转换分为以下类型： 算数转换：在混合类型的算数表达式中，最宽的数据类型成为目标转换类型。 1 2 3 time_t curTime = 1563924292; float timeOffset = 3.56951; curTime + timeOffset; //time_t(__int64)类型隐式转换为float类型 这就造成一个问题：float 精度最高为7位，运算结果中最后三位已经超出精度范围。所以即使再转换为time_t类型，计算结果后三位也会出问题。解决方法为对float显式转换为int或time_t类型。 1 curTime + (int)timeOffset; 赋值转换：将一种类型赋值给另一种类型，将会转换成被赋值类型。 1 2 float a(5.6); int b = a; //a转换为int类型 函数形参实参不一致转换：传给函数的实参与函数形参类型不一致，将会把实参转换为形参的类型。 1 2 3 double Function(double a); int b(5); double c = Function(b); //此处b转换为double类型计算 函数返回值与返回类型不一致：返回值转换为返回类型。 1 2 3 4 double difference(int ival1, int ival2) { return ival1 - ival2; //返回值转换为double类型 } 构造函数隐式转换 按照默认规定，只有一个参数的构造函数也定义了一个隐式转换，将该构造函数对应数据类型的数据转换为该类对象，如下面所示： 1 2 3 4 5 class String { String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } String s1 = “hello”; //OK 隐式转换，等价于String s1 = String（“hello”） 但是有的时候可能会不需要这种隐式转换，如下： 1 2 3 4 5 class String { String ( int n ); //本意是预先分配n个字节给字符串 String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } 下面两种写法比较正常： 1 2 String s2 ( 10 ); //OK 分配10个字节的空字符串 String s3 = String ( 10 ); //OK 分配10个字节的空字符串 下面两种写法就比较疑惑了： 1 2 String s4 = 10; //编译通过，也是分配10个字节的空字符串 String s5 = ‘a’; //编译通过，分配int（‘a’）个字节的空字符串 s4 和s5 分别把一个int型和char型，隐式转换成了分配若干字节的空字符串，容易令人误解。 为了避免这种错误的发生，我们可以声明显示的转换，使用 explicit 关键字： 1 2 3 4 5 class String { explicit String ( int n ); //本意是预先分配n个字节给字符串 String ( const char* p ); // 用C风格的字符串p作为初始化值 //… } 加上 explicit ，就抑制了String ( int n )的隐式转换， 下面两种写法仍然正确： 1 2 String s2 ( 10 ); //OK 分配10个字节的空字符串 String s3 = String ( 10 ); //OK 分配10个字节的空字符串 下面两种写法就不允许了： 1 2 String s4 = 10; //编译不通过，不允许隐式的转换 String s5 = ‘a’; //编译不通过，不允许隐式的转换 因此，某些时候， explicit 可以有效得防止构造函数的隐式转换带来的错误或者误解。 ","date":"2023-01-22","objectID":"/posts/program/cpp/c++%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/:0:0","tags":["cpp"],"title":"c++:隐式转换问题","uri":"/posts/program/cpp/c++%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"},{"categories":["cpp"],"content":"右值引用移动构造完美转发及返回值优化","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++的左值与右值 通用引用和右值引用 右值引用 区分右值引用和左值引用 移动构造函数和移动赋值运算符 移动构造函数 移动构造函数的任务 移动操作和异常安全 移动操作和函数匹配 移动赋值运算符 何时该定义移动构造/赋值 the rule of zero the rule of five std::move 和 std::forward std::move 为什么要使用 std::move？ 使用 std::move 并不代表移动操作一定会发生 std::forward 和完美转发 std::forward 的实现 怎么判断该用 move 还是 forward？ 什么时候用 move 和 forward？ 名字查找和 move、forward 移动和返回值优化 RVO NRVO 移动和 NRVO C++的左值与右值 在 C 语言中，左值和右值即字面意思，左值是表达式左边的值，而右值是表达式右边的值。而 C++ 为了支撑移动语义，对值的类型做了新的划分。 区分左值和右值 C++ 中值有两个独立的属性： 有身份（has identity） 或者说，有地址，有指向它的指针 有身份的值统称为 glvalue （“generalized” lvalue） 可以被移动（can be moved from） 可以移动的值统称为 rvalue glvalue 和 rvalue 就是我们一般说的左值和右值。 根据是否有这两种属性，我们可以对 C++ 中的值做如下划分（i 表示有身份，m 表示可以被移动，大写字母表示没有这种属性，第四种类型 IM 在 C++中没有被使用）： lvalue（ iM ） 有身份，且不能被移动 包括 变量、函数或数据成员的名字 返回左值引用的表达式，比如 ++x、x = 1 字符串字面量，如 \"hello world\" prvalue(“pure” rvalue, Im) 一般译作纯右值 没有身份，可以被移动，也就是所谓的“临时对象” 包括 返回非引用类型的表达式，比如 x++、x + 1 除字符串字面量之外的字面量，比如 42、true 有趣的是 this 指针是 prvalue，你会发现没法对 this 指针求地址 xvalue(an “eXpiring” value, im) 一般译作将亡值 有身份，且可以被移动 包括 右值引用类型的返回值，比如 std::move(x) 虽然说，C++ 对值做了很细粒度的划分，但事实上，大多数时候只需要区分一个值是左值还是右值即可，因此，这里给出一个实践上可以用来区分左右值的法则： 如果你可以对某个表达式取地址，那么它是左值 如果一个表达式的类型是左值引用（ T\u0026 或 const T\u0026 等），那么它是左值 否则，这个表达式是右值 函数的返回值（非引用类型的或右值引用类型的） 通过隐式类型转换创建的值 除字符串以外的字面量（比如 10 和 5.3） 其他的理解如：在C++中右值指的的临时值或常量，更准确的说法是保存在CPU寄存器中的值为右值，而保存在内存中的值为左值。 一个常数5，我们在使用它时不会在内存中为其分配一个空间，而是直接把它放到寄存器中，所以它在C++中就是一个右值。 再比如说我们定义了一个变量 a，它在内存中会分配空间，因此它在C++中就是左值。 那么a+5是左值还是右值呢？当然是右值对吧，因为a+5的结果存放在寄存器中，它并没有在内存中分配新空间，所以它是右值。 1 2 3 4 5 6 7 8 9 10 int main(int argc, char *argv[]){ int \u0026\u0026 a = 5; // 正确，5会被直接存放在寄存器中，所以它是右值 int b = 10; int \u0026\u0026 c = b; // 错误，b在内存中有空间，所以是右值；右值不能赋值给左值 int \u0026\u0026 d = b + 5; // 正确，虽然 b 在内存中，但 b+5 的结果放在寄存器中，它没有在内存中分配空间，因此是右值 int \u0026\u0026 e = a; // 错误，因为a是左值而e必须接收右值。 int \u0026\u0026 e = std::move(a); // 正确，通过std::move可以将一个左值转成右值。e虽然接收的必须是右值，但它本身是左值。换句话说e是一种特殊的变量，它是只能接收右值的变量。我们再从左值的本质来看，e也是占内存空间的，所以它肯定是左值。 } 通用引用和右值引用 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:0:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"右值引用 伴随着新的右值定义，C++11 也引入了一种新的引用类型——右值引用，比如 int \u0026\u0026，右值引用的特点是它只能绑定到右值上，因此 C++11 中也就有了三种引用类型： 右值引用只能绑定到右值上，比如 int \u0026\u0026 非 const 的左值引用只能绑定到左值上，比如 int \u0026 const 的左值引用可以绑定到左值或右值上，比如 const int \u0026 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:1:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"区分右值引用和左值引用 04区分通用引用和右值引用 Scott Meyers的effective modern c++讲座摘要 条款24：区分通用引用和右值引用 右值引用 一定是 type\u0026\u0026 type\u0026\u0026 不一定是 右值引用（还有可能是通用引用） 1 2 3 4 5 6 7 8 9 10 11 12 13 void f(Widget\u0026\u0026 param); // 右值引用 Widget\u0026\u0026 var1 = Widget(); // 右值引用 auto\u0026\u0026 var2 = var1; // 不是右值引用！！！ decltype(var1) var3 = var1; // 无法编译通过 Widget\u0026\u0026 var4 = var1; // 无法编译通过 template\u003ctypename T\u003e void f(std::vector\u003cT\u003e\u0026\u0026 param); // 右值引用 template\u003ctypename T\u003e void f(T\u0026\u0026 param); // 不是右值引用！！！ 在这里，“type\u0026\u0026“中的”\u0026\u0026“意味着： 右值引用 绑定右值（Binds rvalues only.） 促进移动（Facilitates moves.） 通用引用 右值引用或左值引用（type\u0026\u0026 有可能是 type\u0026 或 type\u0026\u0026 ） 绑定所有值，不管是左值，右值，const, 非const... 即促进拷贝，也促进移动（May facilitate copies, may facilitate moves） 与转发引用（Forwarding Reference）相同 如何区分，简单来说: 如果一个变量或参数的声明类型是T\u0026\u0026，并且需要推导出类型T， 这就是通用引用，否则就是右值引用。 通用引用是需要初始化的，如果是左值，那就是左值引用，如果是右值，那就是右值引用。 移动构造函数和移动赋值运算符 为了支持移动语义，C++11 引用两个新的特殊成员函数，它们是移动构造函数和移动赋值运算符，想要支持移动操作的类必须定义它们。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Widget { private: int i{0}; string s{}; unique_ptr\u003cint\u003e pi{}; public: // Move constructor // 该构造函数的参数是 Widget \u0026\u0026w。\u0026\u0026它表示的是C++中的右值，也就是只有创建Widget对象时传入的是右值才会执行该构造函数。 // 需要注意的是，在移动构造函数操作之后原 Widget 对象的指针地址已经指向NULL了，因此此时就不能再通过其访问之前的堆空间了 Widget(Widget \u0026\u0026w) = default; // Move assignment operator Widget \u0026operator=(Widget \u0026\u0026w) = default; }; ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:2:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动构造函数 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动构造函数的任务 完成资源移动 资源的所有权移交给新创建的对象 确保移动操作完成后，销毁源对象是无害的 不再指向被移动的资源 确保移动操作完成后，源对象依然是有效的 可以赋予它一个新值 对留下的值没有任何要求 也就是说移动操作完成后，可以销毁移后源对象，也可以赋予它一个新值，但不能使用移后源对象的值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动操作和异常安全 移动操作一般不分配新资源，因此不会抛出异常 如果移动操作不抛异常，必须注明 noexcept 如果你的移动操作不注明 noexcept ，标准库就不敢调用你的移动构造函数，这是由于标准库的某些接口会做出异常安全的保障，比如 vector 的 push_back 接口做出的保证为： If an exception is thrown (which can be due to Allocator::allocate() or element copy/move constructor/assignment), this function has no effect (strong exception guarantee). 也就是说有异常抛出时（可能是由于内存分配或元素拷贝/移动），这个调用不产生任何效果。 push_back 可能会导致 vector 扩容，也就是说会申请一块新的内存空间，将现有的元素拷贝/移动到这块新的空间里。 如果我们的移动构造函数会抛异常，假设扩容的过程中，只有部分元素被移动到了新的空间里，这时候有异常抛出，不仅扩容操作没完成，而且原有空间里的部分元素还被已执行的移动操作破坏掉了，不符合 push_back 做出的异常保障。因此，这种情况下，vector 只会使用拷贝操作来完成扩容操作。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动操作和函数匹配 移动右值，拷贝左值 移动构造函数只能用于实参是右值的情况下，其他情况下，都会发生拷贝 但如果没有移动构造函数，则右值也被拷贝 拷贝构造函数的参数是 const 的左值引用，既能接受左值也能接受右值 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:3:3","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动赋值运算符 定义移动赋值运算符最简单的方法就是定义一个“拷贝并交换”的拷贝赋值运算符（如果你在疑惑该怎样自定义 swap 操作，请看 Effective C++ Item 25）： 1 2 3 4 5 ClassA\u0026 ClassA::operator=(ClassA rhs) { swap(*this, rhs); return *this; } “拷贝并交换”赋值运算符的参数不再是引用，而是传值 rhs 将是右侧运算对象的一个副本； 将 *this 与这个副本交换，也就是将右侧运算对象的值赋给了左侧运算对象； 函数返回时，rhs 被销毁，析构函数销毁 rhs 现在指向的内存，即左侧运算对象原来的内存。 “**拷贝并交换”**的优势是正确处理了自赋值而且是异常安全的。 赋值运算符的异常安全问题主要来自于拷贝时可能申请内存，如果 new 抛异常了，要确保左侧运算对象原本的数据结构还没有被破坏（显然， rhs 做拷贝的时候，左侧运算对象原有数据结构还没有做任何修改）。 如果你定义了移动构造函数，那么这个拷贝赋值运算符同时也是移动赋值运算符： 如果实参是右值，就会用移动构造函数来初始化 rhs； 相反，如果实参是左值，就会用拷贝构造函数来初始化 rhs ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:4:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"何时该定义移动构造/赋值 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"the rule of zero C.20: If you can avoid defining default operations, do 也就是说，如果默认行为够用，就不要再去定义自己的特殊成员函数。 1 2 3 4 5 6 7 8 9 10 struct Named_map { public: // ... no default operations declared ... private: string name; map\u003cint, int\u003e rep; }; Named_map nm; // default construct Named_map nm2 {nm}; // copy construct map 和 string 定义了所有的特殊成员函数，编译器生成的默认实现就已经够用了。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"the rule of five C.21: If you define or =delete any copy, move, or destructor function, define or =delete them all 如果定义拷贝、移动或析构中的任意一个，或将任意一个声明为 =delete 的；那么就需要将它们都定义出来或全部声明为 =delete 的。 实践 the rule of five 时，最简单的判断方法就是看析构函数，如果你析构函数里要做事，不管是释放资源还是关闭数据库连接，那么你就应该把析构函数的这些好兄弟都定义出来。 定义这些特殊成员时，如果你想要默认实现，就将它声明为 =default；如果你想要禁用某个特殊成员，就将它声明为 =delete（这两种情况都被编译器认为是用户定义的）。 the rule of five 背后的逻辑是这些特殊成员函数的语义是息息相关的： 规则 1：如果某个类有自定义拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了 根据函数匹配规则，这种情况下会调用拷贝操作来处理右值 规则 2：如果某个类定义了移动构造函数，没有定义拷贝构造函数，那么后者被编译器定义为删除的（对于赋值运算符也是一样的） 如果定义了这些操作中的某一个，就应该把其他的操作都定义出来，以避免所有（潜在的）可移动的场景都变成昂贵的拷贝（对应规则 1）或者使得类型变成仅能移动的（对应规则 2）。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct M2 { // bad: incomplete set of copy/move/destructor operations public: // ... // ... no copy or move operations ... ~M2() { delete[] rep; } private: pair\u003cint, int\u003e* rep; // zero-terminated set of pairs }; void use() { M2 x; M2 y; // ... x = y; // the default assignment // ... } 这段代码没能遵循 the rule of five，造成的后果是 rep 被 double free。 std::move 和 std::forward 虽然这两个函数的名字很有迷惑性，但事实上，从它们所做的事情上来看：move 不移动；forward 不转发，它们只是执行了类型转换操作罢了： std::move 无条件地将实参转换为右值； std::forward 在部分条件下将实参转换为右值 熟悉 C++ 类型转换的朋友应该知道 static_cast 事实上在运行时什么也不做，因此这俩函数也并不会在运行时做什么事情。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:5:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::move c++ 之 std::move 原理实现与用法总结 一个简化的 move 实现是这样的： 1 2 3 4 5 template \u003ctypename T\u003e typename remove_reference\u003cT\u003e::type \u0026\u0026move(T \u0026\u0026param) { using ReturnType = typename remove_reference\u003cT\u003e::type \u0026\u0026; return static_cast\u003cReturnType\u003e(param); } T\u0026\u0026 是通用引用，因此这个函数几乎可以接收任何类型的参数。 通过 remove_reference 去掉 T 的引用性质（并不会去掉 cv 限定符），然后给它加上 \u0026\u0026，形成 ReturnType 类型，由于右值引用类型的返回值是右值，因此结果是实参被无条件地转换为右值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"为什么要使用 std::move？ 既然 std::move 只是无条件地做 static_cast，那为什么不直接做类型转换，而要调用 std::move 呢？ std::move 允许我们截断左值，也就是说不再使用该左值，可以自由移动它所拥有的资源；这是非常特殊的类型操作，通过使用 std::move 方便我们确定在哪里对左值做了截断，语义上更加清晰。 C++ 标准库使用比如vector::push_back 等这类函数时,会对参数的对象进行复制,连数据也会复制.这就会造成对象内存的额外创建, 本来原意是想把参数push_back进去就行了,通过std::move，可以避免不必要的拷贝操作。 std::move是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存的搬迁或者内存拷贝所以可以提高利用效率,改善性能.。 对指针类型的标准库对象并不需要这么做. ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"使用 std::move 并不代表移动操作一定会发生 可能这个类型根本没有定义移动操作 std::move 并不会去除实参的 const 性质，因此把 const 的对象传给它，得到的返回值类型也是 const 的，对它的操作会变为拷贝操作 因为移动操作往往会修改源对象，所以我们不希望在 const 对象上触发移动操作 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:6:2","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::forward 和完美转发 某些函数需要将其一个或多个实参连同类型不变地转发给其他函数，转发后需要保持被转发实参的所有性质，包括 实参是否是 const 的； 实参是左值还是右值 这种场景我们往往称之为完美转发，C++11 可以通过 std::forward 来实现。 比如工厂函数需要将初始化参数传递给构造函数。一个常见的例子就是 make_unique C++14 才支持，如果我们想自己写一个 make_unique 应该怎么写呢？ 1 2 3 4 template \u003ctypename T, typename... Ts\u003e std::unique_ptr\u003cT\u003e make_unique(Ts \u0026\u0026... params) { return std::unique_ptr\u003cT\u003e(new T(std::forward\u003cTs\u003e(params)...)); } ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:7:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"std::forward 的实现 1 2 3 4 5 6 7 8 9 template\u003c class T \u003e T\u0026\u0026 forward( typename std::remove_reference\u003cT\u003e::type\u0026 t ) noexcept { return static_cast\u003cT\u0026\u0026\u003e(param); } template\u003c class T \u003e T\u0026\u0026 forward( typename std::remove_reference\u003cT\u003e::type\u0026\u0026 t ) noexcept { return static_cast\u003cT\u0026\u0026\u003e(param); } std::forward 的模板参数是没法推导的，称为无法推导的上下文（nondeduced context）。 理解这个实现的重点在于它的返回值类型是 T\u0026\u0026，我们看一个例子： 1 2 3 4 5 6 7 8 9 void g(int \u0026\u0026i, int\u0026 j); template \u003ctypename F, typename T1, typename T2\u003e void flip3(F f, T1 \u0026\u0026t1, T2 \u0026\u0026t2) { f(std::forward\u003cT2\u003e(t2), std::forward\u003cT1\u003e(t1)); } flip3(g, i, 42); flip3 接受一个可调用对象，以及两个额外实参，将参数逆序传递给可调用对象。 如果实参是 int 变量 i T1 的类型为 int\u0026，std::forward 的返回类型为 int\u0026 \u0026\u0026，根据引用折叠，结果是 int\u0026 t1 的类型为 int\u0026 参数的类型和返回值的类型相同，所以转换不会做任何事 而如果实参是 42 T2 的类型为 int，std::forward 的返回类型是 int \u0026\u0026 t2 的类型为 int \u0026\u0026 从函数返回的右值引用是右值，所以 t2 会被转换为右值 就此，我们也理解了为什么说 forward 是有条件地将实参转换为右值。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:7:1","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"怎么判断该用 move 还是 forward？ 对右值引用 move 右值引用只能绑定到右值上，所以可以无条件地将它转换为右值 对通用引用 forward 通用引用既能绑定到左值上，也能绑定到右值上，在后一种情况下，我们希望能将它转换为右值 在右值引用上调用 std::forward 表现出的行为是正确的，但由于 std::forward 没法自动做类型推导，写出来的代码会比较繁琐；但如果在通用引用上调用 std::move，可能会导致左值被错误地修改，导致异常的行为。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:8:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"什么时候用 move 和 forward？ 你可能需要在函数中多次使用某个右值引用或通用引用，那么只有在最后一次使用它的时候，才可以对它调 std::move 或 std::forward，因为将它转为右值后，它的内容就不能再被使用了。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sink(X\u0026\u0026 x); // sink takes ownership of x void user() { X x; // error: cannot bind an lvalue to a rvalue reference sink(x); // OK: sink takes the contents of x, x must now be assumed to be empty sink(std::move(x)); // ... // probably a mistake use(x); } ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:9:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"名字查找和 move、forward std::move 和 std::forward 的形参都是通用引用，它们几乎可以匹配任何类型的参数。 因此如果我们定义了自己的 move 或 forward 函数，如果它接受单一形参，不管类型如何，都将与标准库的版本冲突。 同时，move 和 forward 执行的是非常特殊的类型操作，用户特意去修改函数原有行为的概率非常小，因此最好使用带限定语的版本 std::move 和 std::forward 来明确指出使用标准库的版本。 移动和返回值优化 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:10:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"RVO 如果 return 语句的操作数是 prvalue ，且它和返回值的类型相同。 1 2 3 4 5 T f() { return T(); } f(); // only one call to default constructor of T 此时，编译器可以实施 copy elision（拷贝省略、拷贝消除），将对象直接构造到调用者的栈上去。 return 语句所在的地方，T 的析构函数必须是可访问的且没有被删除，尽管此处并没有 T 对象被析构掉。 C++17 强制编译器做 RVO，RVO 不再是一项可选的编译器优化，而是 C++ 对 prvalue 的新规定，即返回和使用 prvalue 时不再去实体化一个临时对象 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:11:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"NRVO 1 2 3 4 5 6 X bar() { X xx; // process xx ... return xx; } 对于上面的函数 bar，如果直接用参数 __result 代替命名的返回值 xx，即改写为： 1 2 3 4 5 6 7 8 9 10 11 void bar( X \u0026__result ) { // default constructor invocation // Pseudo C++ Code __result.X::X(); // ... process in __result directly return; } 也就是说返回值会被直接构造在调用者的栈上，少了一次拷贝操作，这种优化被称为 Named Return Value Optimization（NRVO）。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:12:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["cpp"],"content":"移动和 NRVO C++11 开始，NRVO 仍可以发生，但在没有 NRVO 的情况下，编译器将试图把本地对象移动出去，而不是拷贝出去。 这一移动行为不需要程序员手工用 std::move 进行干预，使用 std::move 对于移动行为没有帮助，反而会影响返回值优化，因为这种情况下，你返回的并不是局部对象，而是局部对象的引用。 ","date":"2023-01-22","objectID":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/:13:0","tags":["cpp construct fun"],"title":"C++:右值引用，移动构造，完美转发及返回值优化","uri":"/posts/program/cpp/construct/c++%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E7%AD%89/"},{"categories":["芯片架构"],"content":"ARMv7-A ARMv8-A  ARMv9-A","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ARMv7-A 构架 Cortex-A17 Cortex-A15 Cortex-A9 Cortex-A8 Cortex-A7 Cortex-A5 ARMv8-A构架 Cortex-A32 Cortex-A35 Cortex-A53 Cortex-A57 Cortex-A72 Cortex-A73 Cortex-A78 Cortex-A77 Cortex-A76 ARMv9-A 构架 特性 ARM V8 ARM V7 指令集 64位指令集 AArch64， 并且兼容32位指令集 AArch32 32位指令集 A32 和16位指令集 T16 支持地址长度 64位 32位 通用寄存器 31个 x0-x30（64位）或者 w0-w30（32位） 15个, r0-r14 (32位) 异常模式 4层结构 EL0-EL3 2层结构vector table NEON 默认支持 可选支持 LAPE 默认支持 可选支持 Virtualization 默认支持 可选支持 big.LITTLE 支持 支持 TrustZone 默认支持 默认支持 SIMD寄存器 32个 X 128位 32个 X 64位 ARMv7-A 构架 The Armv7-A architecture introduces the concept of architecture profiles, a concept that continues in Armv8-A and Armv9-A. The Armv7-A architecture: Implements a traditional Arm architecture with multiple modes Supports a Virtual Memory System Architecture (VMSA) based on a Memory Management Unit (MMU) Supports the Arm (A32) and Thumb (T32) instruction sets This architecture also supports multiple extensions: Security Extensions Multiprocessing Extensions Large Physical Address Extension Virtualization Extensions Generic Timer Extension Performance Monitors Extension All of these extensions are optional and most of the functionality they provide is included in the Armv8-A architecture. ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:0:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A17 A17仍然基于32位ARMv7-A指令集，初期会采用28nm工艺，后期进化到20nm。本质架构和A12一样都是双宽度、乱序发射，仅仅是改进了外部互联，引入了新的一致性总线AMBA4 ACE，可以更快速地连接内存控制器，从而改善性能和能效。得益于这个新的总线，A17可以支持多核心SoC的完整内存一致性操作，能够参与big.LITTLE双架构混合方案，在特定频率、工艺、内存条件下，A17的性能比A12提升大约40%。在某些特定的环境中，A17的性能已经可以和A15处于一个档次了，但是功耗更低、能效更高。虽然在命名上排在Cortex-A15之上，但其定位中端，而不是高端。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:1:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A15 Cortex-A15最早在2010年发布，基于32位ARMv7-A架构。A15和A9同样具备乱序执行，但是Cortex-A15具备（两倍）的指令发射端口和执行资源，指令解码能力也要高出50%，动态分支预测能力更强（采用了多层级分支表缓存），指令拾取带宽更强（128 bit vs 64 bit），这些都能让A15的流水线执行具备更高的效率。除此以外，A15采用了VFPv4浮点单元设计，能执行FMA指令以及硬件除法指令，相较而言A9的峰值向量浮点性能基本上只有A15的一半。Cortex-A15处理器可以应用在智能手机、平板电脑、移动计算、高端数字家电、服务器和无线基础结构等设备上。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:2:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A9 ARM Cortex-A9采用ARMv7-A架构，目前我们能见到的四核处理器大多都是属于Cortex-A9系列。 Cortex-A9 处理器的设计旨在打造最先进的、高效率的、长度动态可变的、多指令执行超标量体系结构，提供采用乱序猜测方式执行的 8 阶段管道处理器，凭借范围广泛的消费类、网络、企业和移动应用中的前沿产品所需的功能，它可以兼具高性能和高能效。Cortex-A9 微体系结构既可用于可伸缩的多核处理器（Cortex-A9 MPCore多核处理器），也可用于更传统的处理器（Cortex-A9单核处理器）。可伸缩的多核处理器和单核处理器支持 16、32 或 64KB 4 路关联的 L1 高速缓存配置，对于可选的 L2 高速缓存控制器，最多支持 8MB 的 L2 高速缓存配置，它们具有极高的灵活性，均适用于特定应用领域和市场。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:3:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A8 ARM Cortex-A8处理器，基于ARMv7-A架构，是目前使用的单核手机中最为常见的产品。Cortex-A8处理器是首款基于ARMv7体系结构的产品，能够将速度从600MHz提高到1GHz以上。Cortex-A8处理器可以满足需要在300mW以下运行的移动设备的功率优化要求；以及需要2000 Dhrystone MIPS的消费类应用领域的性能优化要求。Cortex-A8 高性能处理器目前已经非常成熟，从手机到上网本、DTV、打印机和汽车信息娱乐，Cortex-A8处理器都提供了可靠的高性能解决方案。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:4:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A7 Cortex-A7采用ARMv7-A架构，它的特点是在保证性能的基础上提供了出色的低功耗表现。Cortex-A7处理器的体系结构和功能集与Cortex-A15 处理器完全相同，不同这处在于，Cortex-A7 处理器的微体系结构侧重于提供最佳能效，因此这两种处理器可在big.LITTLE（大小核大小核心伴侣结构）配置中协同工作，从而提供高性能与超低功耗的终极组合。单个Cortex-A7处理器的能源效率是Cortex-A8处理器的5倍，性能提升50%，而尺寸仅为后者的五分之一。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:5:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A5 Cortex-A5处理器同样基于ARMv7-A架构，它是能效最高、成本最低的处理器，能够向最广泛的设备提供最基础的 Internet 访问。Cortex-A5 处理器在指令以及功能方面与更高性能的 Cortex-A8、Cortex-A9 和 Cortex-A15 处理器完全兼容 - 一直到操作系统级别。Cortex-A5 处理器还保持与经典 ARM 处理器（包括 ARM926EJ-S、ARM1176JZ-S 和 ARM7TDMI?）的向后应用程序兼容性。其定位于从入门级智能手机、低成本手机和智能移动设备以及基础工业设备。 ARMv8-A构架 ARMv8-A是ARM公司的首款支持64位指令集的处理器架构，包括ARM TrustZone技术、NEON、虚拟化和加密技术。 The Armv8-A architecture introduces the ability to use 64-bit and 32-bit Execution states, known as AArch64 and AArch32 respectively. The AArch64 Execution state supports the A64 instruction set. It holds addresses in 64-bit registers and allows instructions in the base instruction set to use 64-bit registers for their processing. The AArch32 Execution state is a 32-bit Execution state that preserves backwards compatibility with the Armv7-A architecture, enhancing that profile so that it can support some features included in the AArch64 state. It supports the T32 and A32 instruction sets. Armv8-A architecture allows different levels of AArch64 and AArch32 support, for example: AArch64 only designs AArch64 designs that also support AArch32 operating systems and virtual machines AArch64 support with AArch32 at (unprivileged) application level only ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:6:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A32 这是ARM 新一代构架中，唯一一个 32 位（ARMv8-A ）架构的处理器，但 A32 就像是 32 位版的 A35，目标很明显，就是在效能比本来就逆天的 A35 的基础上进一步控制功耗。A32 架构主打芯片面积、功耗控制和能耗比，其停留在 32 位（ARMv7-A 指令集），指令预取单元针对效率进行了重新设计，一、二级暂存、浮点和 DSP 操作性能则针对速度进行了改进，并引入了新的电源管理特性。其支持 TrustZone 安全加密、NEON SIMD 指令集、DSP / SIMD 扩展、VFPv4 浮点计算、虚拟硬件等。A32 可以在 32 位下提供和 A35 一样的性能。但更低功耗，让它的效能比（单位电能产出的性能）比 A35 还要高 10%、比 A5 高 30%、比 A7 高 25%。A35 可以透过提升频率达到 A53 80-100% 性能，也就是说，A32 也可以在 32 位下达到同样的性能等级，这时候的芯片面积只有 A53 的 68%，而功耗则只有 A53 的 61%。 在 64 位之下，A35 都有代替 A53 架构的实力，而在 32 位中，A32 就已经是完胜所有人的境界了，而且比起 64 位的 A35 架构，32 位的 A32 更适合用在穿戴设备和物联网产品上。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:7:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A35 Cortex-A35是基于ARMv8-A 64位架构设计的一款低功耗CPU，其目的是为了取代此前32位Cortex-A7和Cortex-A5两颗老核心，采用和A53/A7类似的顺序有限双发射设计，同时融入了A72的一些新特性，并在前端重新设计了指令预取单元，提升了分支预测精度。此外，A35还采用了A53的缓存、内存架构，可配置8-64KB一级指令和数据缓存、128KB-1MB二级缓存，加入了NEON/FP单元，改进了存储性能，支持完整流水线的双精度乘法，还为CPU核心、NEON流水线都配备了硬件保留状态(独立电源域)以提升电源管理效率。在同样的工艺、频率下，A35的功耗比A7低大约10%，同时性能提升6-40%。而对比A53，它可以保留80-100%的性能，但是功耗降低32%、面积缩小25%，能效提升25%。A35还可以和A53、A57、A72等大核心搭配，组成big.LITTLE混合架构系统，进一步提升系统能效。其主要定位于低功耗的低端手机、可穿戴、物联网等领域。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:8:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A53 Cortex-A53同样是采取了ARMv8-A架构，能够支持32位的ARMv7代码和64位代码的AArch64执行状态。A53架构特点是功耗降低、能效提高。其目标是28nm HPM制造工艺下、运行SPECint2000测试时，单个核心的功耗不超过0.13W。它提供的性能比Cortex-A7处理器的功率效率更高，并能够作为一个独立的主要的应用处理器，或者搭配Cortex-A57处理器构成big.LITTLE配置。Cortex-A53在相同的频率下，能提供比Cortex-A9更高的效能。其主要面对的是中高端电脑，平板电脑，机顶盒，数字电视等。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:9:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A57 发布时间： ？ A57是arm第一代64位大核,首次采用64位ARMv8-A架构CPU，而且通过Aarch32执行状态，保持与ARMv7架构的完全后向兼容性。除了ARMv8的架构优势之外，Cortex-A57还提高了单个时钟周期性能，比高性能的Cortex-A15 CPU高出了20%至40%。它还改进了二级高速缓存的的设计以及内存系统的其他组件，极大的提高了能效。Cortex-A57将为移动系统提供超高能的性能，而借助big.LITTLE，SoC能以很低的平均功耗做到这一点。其主要面对的是中高端电脑，平板电脑以及服务器产品。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:10:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A72 发布时间： 2015年年初 ARMv8-A构架 采用台积电16nm FinFET制造工艺，Cortex-A72可在芯片上单独实现性能，也可以搭配Cortex-A53处理器与ARMCoreLinkTMCCI高速缓存一致性互连（CacheCoherentInterconnect）构成ARMbig.LITTLETM配置，进一步提升能效。在相同的移动设备电池寿命限制下，Cortex-A72能相较基于Cortex-A15的设备提供3.5倍的性能表现，相比于Cortex-A57也有约1.8倍的性能提升，展现出了优异的整体功耗效率。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:11:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A73 发布时间： 2016 ARMv8-A构架 Cortex-A73都可以提供适应性最强的移动应用生态开发环境。Cortex-A73包括128位 AMBR 4 ACE接口和ARM的big.LITTLE系统一体化接口，采用了目前最先进的10nm技术制造，可以提供比Cortex-A72高出30%的持续处理能力，非常适合移动设备和消费级设备使用。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:12:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A78 发布时间： 2020 适用于5nm工艺，性能提升20%，功耗则降低了50%。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:13:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A77 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:14:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A76 ARMv9-A 构架 The Armv9-A architecture builds on and is backwards compatible with the Armv8-A architecture. The Armv9-A architecture forms the foundation for the Arm Base System Architecture – a specification outlining a standard that ensures hardware and firmware compatibility across a wide range of applications at the system level. The Armv9-A architecture introduces some major new features: SVE2: extending the benefit of scalable vectors to many more use cases Realm Management Extension (RME): extending Confidential Compute on Arm platforms to all developers. Read more about Confidential Compute and Arm architecture security features BRBE: providing profiling information, such as Auto FDO Embedded Trace Extension (ETE) and Trace Buffer Extension (TRBE): enhanced trace capabilities for Armv9 TME: hardware transactional memory support for the Arm architecture 参考： A-Profile Architectures 详解ARM Cortex-A32处理器，打造超高能效嵌入式环境 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a/cortex-a/:15:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:ARMv7-A ARMv8-A  ARMv9-A 架构","uri":"/posts/basic_knowledge/arm/cortex-a/cortex-a/"},{"categories":["芯片架构"],"content":"ARMv8 架构编程探索","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":" 整理自ARMv8 架构编程探索,感谢原作者分享。 ARMv8-A 架构基础 执行状态与异常级别 ARMv8 寄存器组 通用寄存器组 特殊功能寄存器组 NEON 与浮点寄存器 标量寄存器大小 向量寄存器大小 NEON 在 AArch32 运行模式下 ARMv8 指令集 A64 指令集 内存管理单元 基于分页的虚拟内存 虚拟地址的翻译过程 安全与非安全地址 Memory Ordering 内存类型 屏障指令 内存属性 安全系统 TrustZone 硬件架构 利用中断切换安全世界 在安全态和非安全态切换 随着开发工作逐渐迁移到 ARMv8 的 64 位平台，因此有必要尽快熟悉 ARMv8 架构。ARMv8 与先前较为熟悉的 ARMv7 架构有较大变化，其中非常重要的一点是支持了 A64 指令集，大大提升了处理器的性能。从目前的的了解来看，基本上 ARMv8 与上代架构的差别非常大的。除了 A64 指令集之外，还有许多地方都有较大改动，下面列出几个目前比较关注的点： 执行状态与异常级别（异常级别为 EL0 - EL3） ARMv8 寄存器组（和先前完全不同的 64 位寄存器） A64 指令集（新的 64 位指令集） 内存管理（毕竟地址空间变成 64 位了） Memory Ordering 安全系统（例如普通世界和安全世界的切换） 本篇就依据上面的关键点对 ARMv8 架构进行一番探索。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:0:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8-A 架构基础 从上图可以看到，ARMv8 架构兼容了 ARMv7 架构的关键特性，例如支持 A32 和 T32 指令集，单精度浮点操作以及基于单精度浮点的 SIMD 指令。 ARMv7 为什么不支持双精度浮点的 SIMD 指令呢？也许是可用的浮点寄存器不够吧，AArch64 使用了 32*128-bit 的浮点寄存器，比 ARMv7 要多了一倍。 下图展示了后续要使用的 Cortex-A53 与 Cortex-A57 处理器属性： 可用看出，无论是 A53 还是 A57 的性能都远远超过先前的处理器性能，甚至 A57 架构还配备了专用的 GPU。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:1:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"执行状态与异常级别 在 ARMv8 架构中定义了两种执行状态，AArch64 以及 AArch32。这两种执行状态分别用于描述执行使用 64 位宽的通用寄存器或者使用 32 位宽的通用寄存器。然而在 ARMv8 AArch32 中保留了 ARMv7 中定义的特权级，而在 AArch64 中，特权级通过异常等级被定义。因此执行在异常等级 ELn 对应于执行在特权等级 PLn。 在 AArch64 中，处理器模式在不同的异常等级间切换，就像指在 ARMv7（AArch32） 中当异常被处理时，处理器切换到相应的异常等级来处理异常。下图展示了两种架构在异常处理时的映射关系： 可以看出先前在 ARMv7 时有各种异常模式，而在 ARMv8 中，这些模式统统都属于 EL1 级别，处理的时候先进入 EL1 的处理函数，然后再通过寄存器信息判断现在发生了哪种异常，然后执行对应的处理函数。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:2:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8 寄存器组 AArch64 执行状态在所有的异常级别下提供了 31 个 64 位通用寄存器，每一个寄存器有 64 位宽，从 X0-X30。 下图展示了 AArch64 的 通用寄存器组与特殊寄存器： ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"通用寄存器组 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"特殊功能寄存器组 可以看出 AArch64 与先前的寄存器组有了非常大的变化，不仅通用寄存器组的宽度和个数变多了，特殊寄存器组也非常不同。特殊寄存器组最大的变化是，先前在 ARMv7 下各种不同模式下的 BANK 寄存器组都没有了，取而代之的是不同级别异常下的 SP 指针、SPSR 以及异常返回寄存器组。 同时为了兼容先前 ARMv7 下 AArch32 执行状态，支持从 AArch64 到 AArch32 寄存器组的映射，如下图所示： PSTATE at AArch32 在 AArch64 中，传统的 CPSR 寄存器被 PSTATE 取代。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"NEON 与浮点寄存器 除了通用寄存器组之外， ARMv8 也提供了 32 个 128 位的浮点寄存器组，V0-V31。这 32 个寄存器用户保存浮点操作数用于标量浮点执行或者标量和向量操作数用于 NEON 操作。 标量寄存器大小 向量寄存器大小 针对不同大小的向量操作： NEON 在 AArch32 运行模式下 在 AArch32 中，小的寄存器被打包成更大的寄存器，例如 D0 和 D1 被组合成 Q1。这就引入了一些复杂的循环依赖关系，会降低编译器向量化循环结构的能力。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:3:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv8 指令集 ARMv8 架构最大的变化之一就是引入了额外的 64 位指令集，补充了现有的 32 位指令集架构。这一添加提供了访问 64 位宽的整数寄存器和数据操作，以及使用 64 位大小的指针访问内存的能力。新的指令集称为 A64，运行在 AArch64 执行状态。ARMv8 也包括先前的 ARM 指令集，现在叫做 A32 和 T32 指令集，这两种指令集都运行在 AArch32 状态，提供对 ARMv7 的先后兼容。 另外有一点需要注意的是，A64 指令集的操作码的长度仍然是 32 位，而不是 64 位。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:4:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"A64 指令集 A64 的指令助记符与 ARMv7 没有太大变化，只是所操作的寄存器形式不同， AArch64 寄存器有不同的位宽，但是我们并不需要记住不同形式的指令，汇编器会根据我们操作的寄存器名称自动选择合适的编码。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:4:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存管理单元 MMU 的一个重要功能是使得系统可以运行多任务，作为一个独立的程序运行在它的私有虚拟地址空间上。这些独立程序不需要知道系统的物理内存映射，也就是那些实际被硬件使用的地址，也不用关心其他程序正在运行的程序。 有了 MMU ，我们可以使得每个应用程序都使用相同的虚拟地址。也可以使用连续的虚拟地址映射，即使这些物理内存是分离的。当将代码放置在内存中时，虚拟地址是那些被程序员、编译器和链接器使用的地址空间。而物理地址是那些被实际硬件系统使用的地址。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:5:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"基于分页的虚拟内存 在 RT-Smart 操作系统中采用了基于分页机制的内存设计与实现，而页表是分页机制中的关键部分，负责记录虚拟页到物理页的映射关系，操作系统负责对页表进行配置。 在以往较简单的宏内核版本中，我们往往将虚拟地址和物理地址配置成一一映射，也就是说 CPU 尝试访问指定位置的虚拟地址，经过 MMU 翻译，实际上也访问了实际的物理地址。但是这种方式在支持多进程的 RT-Smart 中是不够的，要想支持多进程，就需要让不同进程在访问相同虚拟地址时，实际上访问了不同的物理地址。 在 AArch64 架构下，我们使用多级页表的方式来解决多进程的内存分配问题，常见的设置是虚拟地址低 48 位参与地址翻译，页表级数为 4 级，虚拟页大小为 4 KB。在这种情况下，物理内存被划分为连续的、4 KB 大小的物理页，一个虚拟页可以映射对应一个物理页。正因为页的大小为 4 KB，所以虚拟地址的低 12 位对应于页内偏移量。 虚拟地址的翻译过程 建立页表是内存管理的一个关键过程，后续用一个专题来仔细研究一下 ARMv8 下多级页表的建立过程，下图展示了如何逐级查询页表最终找到一个正常的 64KB 物理页的过程。 每一个二级页表可以与一个或者多个一级页表所关联，我们可以用多个一级页表描述符指向同一个二级表，这也就是说可以让多个虚拟地址指向相同的物理地址。 安全与非安全地址 从理论上来说，安全和非安全的物理地址空间是相互独立且同时存在的。一个系统可以被设计成有两个完全分离的内存系统。然而大部分实际的系统将安全和非安全当做一个访问控制的属性。普通世界只能访问非安全的物理地址空间。安全世界可以访问两种物理地址空间。这些访问权限是被转换表配置控制的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:5:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"Memory Ordering 在操作系统的开发过程中，需要编写一些与硬件交互或者执行在其他核上的代码，或者直接加载或者写入要被执行的指令（例如加载应用程序），或者修改页表，在这些情况下都需要考虑内存访问顺序问题，也可以理解为观察值和实际执行情况的顺序差。 在上述情况下，程序员必须保证编写的代码有着清晰的内存访问顺序，可以通过正确地利用屏障（barriers）来实现这个目标。 在 ARMv8 架构中使用了内存弱序模型。总的来说，这就意味着内存访问的顺序并不用要求与程序的加载（load）和存储（store）操作一致。处理器可以重新调整内存读、写操作。这样做的结果是，使用一些硬件优化方法，例如 cache 和写缓冲区可以优化处理器的性能，这就意味着处理器和外部内存之间的带宽要求可以降低，而且与外部内存访问相关的延时可以被隐藏。 对普通内存的读写可以被硬件重新排序，只受数据依赖和显示的内存屏障指令的影响。在某些情况下需要更强的排序规则。程序员可以通通过描述该内存的转换表项的内存类型属性，向处理器核心提供相关信息。 一些非常高性能的系统支持包括内存读推测、多发指令或者乱序执行以及其他技术，提供了更进一步的可能性使得硬件重新调整内存访问顺序。 多条指令产生 乱序执行 执行预测 预测加载 加载和存储优化 外部内存系统 缓存一致性与多核处理 编译器优化 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存类型 所有的内存区域都被配置成两种类型之一，普通内存和设备内存。第三种内存类型，强序内存，是 ARMv7 架构的一部分。强序内存与设备内存的区别很小，因此在 ARMv8 中被省略了。 除了内存类型，属性还提供了对 cacheability、shareability、access 和执行权限的控制。可共享和可缓存属性仅适用于普通内存。设备区域永远是不能缓存和不能共享的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"屏障指令 ARM 架构在特定点使用屏障指令来强制指定访问顺序和访问完成。在一些其他架构中，也有类似的指令被称为 fence。 ARMv8 架构提供了三种类型的屏障指令： 指令同步屏障（ISB） 数据内存屏障（DMB） 数据同步屏障（DSB） ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"内存属性 系统的内存内存映射被分为许多区域，每一个区域都需要不同的内存属性，例如对不同优先级、内存类型、缓存策略的读写访问权限。 内存属性还包括 cacheable 和 shareable，关于 shareable 细分下来还有 Non-shareable、Inner shareable、Outer shareable 以及 full system。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:6:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"安全系统 一个系统提供一个特定的安全等级，一个受信的系统，是一个用来保护有价值的数据，例如密码和加密秘钥，信用卡数据，避免受到攻击，避免他们被复制、毁坏或者丢失。 在一个开放的系统中很难保证安全，因为在平台上会运行各种各样的软件，也会下载一些恶意的程序，这些程序可能会篡改系统。 ARM 处理器包括特殊的硬件扩展来构建一个受信的系统。软件以及硬件工具可以被分为如下三类： 软件攻击 简单硬件攻击 实验室硬件攻击 Trust Zone 技术就是被设计用于保护软件和简单硬件攻击。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:0","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"TrustZone 硬件架构 TrustZone 架构为系统设计者提供一种方法来帮助安全系统，使用 TrustZone 安全扩展和安全外设。ARM 安全模型分为设备硬件和软件资源，他们存在于安全世界为安全子系统，或者普通世界为非安全系统。系统硬件可以保证安全世界的数据都不可以被普通世界访问到。一个安全的设计会将所有敏感的资源放在安全世界。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:1","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"利用中断切换安全世界 因为代码会在两个世界中执行，因此需要利用硬件的异常机制，通过 SMC 指令来进行环境切换。下图展示了在非安全世界的上下文切换过程： 下图展示安全世界中的上下文切换过程： ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:2","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"在安全态和非安全态切换 使用 ARMv7 安全扩展，monitor 模式被软件使用与在安全和非安全态进行切换。这个模式与其他模式在安全态下有着同等的优先级。 对于 ARMv8 架构，当 EL3 在使用 AArch32 系统时与 ARMv7 完全兼容，安全状态的特权模式运行在 EL3，如下图所示： 下图展示了在 AArch64 架构下使用 EL3 提供安全监视器的情况。在 EL3 态下是不能运行 AArch32 的，按时 EL1 可以用作安全操作系统。当 EL3 在使用 AArch64，EL3 级别被用于执行切换安全态与非安全态的代码，如下图所示： 关于 ARM 的安全状态，后续还是要仔细研究的，因为通过 ATF 将系统从 EL3 切换到 EL1 的非安全状态后，才可以正常的运行 RT-Smart 操作系统，所以对 ATF 的研究是必不可少的。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/:7:3","tags":["ARMv8"],"title":"arm:ARMv8架构编程探索","uri":"/posts/basic_knowledge/arm/armv8/armv8_%E6%9E%B6%E6%9E%84%E7%BC%96%E7%A8%8B%E6%8E%A2%E7%B4%A2/"},{"categories":["芯片架构"],"content":"ARMv7-A ARMv8-A  ARMv9-A","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:0:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A characteristics - Cortex-A 特性 所有Cortex-A处理器们都有相同的架构和特性。 使用ARMv7-A架构的Cortex-A处理器支持32bit的ARM指令和寻址，同时也支持16/32混合的Thumb指令。 ARMv8-A架构的Cortex-A处理器支持64bit的寻址和AArch64执行状态，同时也向后兼容AArch32执行状态。 Cortex-A 系列处理器有以下扩展架构 ARM TrustZone®, to provide support for security SIMD and Advanced SIMD (NEON) technologies ARM Floating Point architecture (VFP) big.LITTLE technology Large Physical Address Extension (LPAE) addressing up to 1TB of physical memory on some of the 32-bit ARMv7-A processors. ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:1:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Multicore technology - 多核技术 从单核到4核具有硬件一致性 支持“对称多处理技术”和“非对称多处理技术” 通过Accelerator Coherency Port (ACP)技术，可以让外部无缓存总线主控器达到一致性 通过AMBA® 4 ACE(AMBA Coherency Extension) 和 AMBA 5 CHI(Coherent Hub Interface)，可以保证非同族间的CPU的使用也可以保持一致性。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:2:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Industry standard - 行业标准 Cortex-A 处理器是行业标准，成功归功于ARM的合作伙伴。 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:3:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["芯片架构"],"content":"Cortex-A 的应用 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/:4:0","tags":["ARMv7-A","ARMv8-A","ARMv9-A"],"title":"arm:Cortex-A性能对比","uri":"/posts/basic_knowledge/arm/cortex-a9/cortex-a/"},{"categories":["ros"],"content":"树莓派4B安装ROS2","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 使用安装脚本按装ros2 ROS2构建工具colcon 安装colcon工具 构建目录 常用命令 参考 使用安装脚本按装ros2 这里使用鱼香社区提供的一键安装脚本，脚本开源地址如下 ： 1 https://github.com/fishros/install 使用命令安装 1 wget http://fishros.com/install -O fishros \u0026\u0026 . fishros 按照提示按转即可。 ROS2构建工具colcon ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:0:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"安装colcon工具 1 sudo apt install python3-colcon-common-extensions ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:1:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"构建目录 一般情况下在工作空间目录下构建，它会创建与src目录平级的下列目录： build目录：是存储中间文件的目录，会为每个软件包在build目录中创建一个子目录，在该子目录中； install目录：这是每个软件包将被安装的目录，默认情况下，每个软件包都将会被安装到一个单独的子目录中； log目录：该目录包含有关每个colcon调用的各种日志信息； ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:2:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 全部编译 colcon build # packages-select 命令 colcon build --packages-select YOUR_PKG_NAME # 编译指定包，可以多个 # packages-ignore 命令 colcon build --packages-ignore YOUR_PKG_NAME # 忽略指定包，可以多个 # continue-on-error 命令 colcon build --continue-on-error # 在编译出错之后继续编译其他模块 # symlink-install 命令 colcon build --symlink-install # 表示编译时如果 install 中文件已经存在于 src 或者 build 文件夹中，就用超链接指向该文件，避免浪费空间，也可以实现同步更新 # merge-install 命令 colcon build --merge-install # 默认会使用install使用作为所有软件包的安装前缀，而不是 安装库中特定于软件包的子目录； 如果没有这个选项，每个包都会贡献自己的环境路径，导致环境变量特别长；使用此选项，环境变量更短； # parallel-workers 命令 colcon build --parallel-workers NUMBER # 要并行处理的最大作业数， 默认值是逻辑 CPU 内核数 # cmake-args 命令 colcon build --cmake-args -DCMAKE_BUILD_TYPE=Release # 表示传入cmake编译选项参数 参考 originbot 鱼香社区 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/:3:0","tags":["ros"],"title":"ros:树莓派4B安装ROS2","uri":"/posts/basic_knowledge/ros/%E6%A0%91%E8%8E%93%E6%B4%BE4b%E5%AE%89%E8%A3%85ros2/"},{"categories":["ros"],"content":"ubuntu 18.04 安装 ROS Melodic","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 ubuntu 18.04 安装ROS 设置安装源 添加秘钥 安装ROS 更新列表 依赖库 安装ROS Melodic 安装特定的ROS程序包 安装核心组件rosdep 配置ROS环境变量 安装rosinstall 学习ROS源码 资料 ros小课堂 ROS机器人操作系统 github ubuntu 18.04 安装ROS ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:0:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"设置安装源 中国科学技术大学的安装源 1 sudo sh -c '. /etc/lsb-release \u0026\u0026 echo \"deb http://mirrors.ustc.edu.cn/ros/ubuntu/ $DISTRIB_CODENAME main\" \u003e /etc/apt/sources.list.d/ros-latest.list' ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:1:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"添加秘钥 添加秘钥到本地的trusted数据库中并加以验证，方法如下 1 sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116 若密钥服务器hkp://ha.pool.sks-keyservers.net:80无法添加成功，则可以尝试hkp://pgp.mit.edu:80或者hkp://keyserver.ubuntu.com:80。 在更新之前，需要安装公钥，否则无法验证签名，这一步也是原书没有的，需要朋友们注意，命令如下： 1 sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-keys F42ED6FBAB17C654 ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:2:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装ROS ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"更新列表 1 sudo apt update ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:1","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"依赖库 1 2 sudo apt install libvtk6-jni libvtk6-java libvtk6-dev libvtk6-qt-dev libpcl-dev sudo apt install ros-melodic-pcl-conversions ros-melodic-pcl-ros ros-melodic-perception-pcl ros-melodic-perception ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:2","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装ROS Melodic 1 sudo apt install ros-melodic-desktop-full ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:3","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装特定的ROS程序包 如果希望安装特定的ROS程序包，则可以首先查看当前可用的程序包列表，然后选择自己需要的程序包进行安装，示例代码如下： 1 2 apt-cache search ros-melodic sudo apt install ros-melodic-slam-gmapping ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:4","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装核心组件rosdep rosdep是ROS一些核心组件的运行基础，会在编译ROS源码时检查和安装程序包依赖。安装ROS方法如下： 1 2 3 4 5 sudo rosdep init # fix-permission限制权限为当前用户 sudo rosdep fix-permissions # 可能由于网络原因会失败，多运行几次即可 rosdep update ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:3:5","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"配置ROS环境变量 默认情况下，ROS_HOME的路径为\"~/.ros\"，该目录保存着日志文件和测试结果文件。另外，第一次启动ROS时，需要进行环境变量配置，命令如下： 1 2 echo \"source /opt/ros/melodic/setup.bash\" \u003e\u003e ~/.bashrc source ~/.bashrc 查看环境变量是否设置正确，命令如下： 1 env | grep ROS 输出： 1 2 3 4 5 6 7 8 ROS_ETC_DIR=/opt/ros/melodic/etc/ros ROS_ROOT=/opt/ros/melodic/share/ros ROS_MASTER_URI=http://localhost:11311 ROS_VERSION=1 ROS_PYTHON_VERSION=2 ROS_PACKAGE_PATH=/opt/ros/melodic/share ROSLISP_PACKAGE_DIRECTORIES= ROS_DISTRO=melodic ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:4:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["ros"],"content":"安装rosinstall 为了构建和管理开发者自己的ROS工作空间，还需要安装rosinstall，方法如下 1 sudo apt-get install python-rosinstall python-rosinstall-generator python-wstool build-essential 学习ROS源码 如果希望基于ROS源代码进行学习，则可以下载完整的ROS源代码，方法如下： 1 2 3 4 sudo apt-get install python-rosdep python-rosinstall-generator python-rosinstall python-wstool build-essential mkdir ~/ros_catkin_ws/ \u0026\u0026 cd ~/ros_catkin_ws/ rosinstall_generator desktop_full --rosdistro melodic --deps --tar \u003e melodic-desktop-full.rosinstall wstool init -j8 src melodic-desktop-full.rosinstall ROS将使用wstool进行版本管理。如果希望在网络发生中断后可以以断点续传的方式继续下载，那么命令如下： 1 wstool update -j 8 -t src ","date":"2023-01-22","objectID":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/:5:0","tags":["ros"],"title":"ros:ubuntu 18.04 安装 ROS Melodic","uri":"/posts/basic_knowledge/ros/ubuntu-18.04-%E5%AE%89%E8%A3%85-ros-melodic-/"},{"categories":["java"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. VSCODE 插件 2. ubuntu20.04安装Java 3. java 编译 4. JNI 4.1. JAVA调用C++ 4.2. 生成 头文件 com_huhu_test_JNIDemo 4.3. 实现 com_huhu_test_JNIDemo 4.4. 编译 com_huhu_test_JNIDemo.cpp 4.5. 编译运行 java 4.6. JNI GetFieldID和GetMethodID 所需签名参数 1. VSCODE 插件 Code Runner Extension Pack for Java Maven for Java Debugger for Java Test Runner for Java Project Manager for Java Language Support for Java(TM) by Red Hat Java Debugger 2. ubuntu20.04安装Java ​ 默认的ubuntu20.04源仓库包含了两个openJDK软件包，Java Runtime Environment(JRE)和Java Development Kit(JDK)。JRE主要包含了Java虚拟机(JVM),类和允许你允许Java程序的二进制包。JDK包含JRE和用于构建Java应用的开发/调试工具和库文件. Java11s java的一个长期支持版本，同时也是Ubuntu20.04的默认Java开发和运行环境。 安装 1 2 3 sudo apt-get update sudo apt-get -y install openjdk-11-jdk java --version 设置Java默认版本 1 2 java --version sudo update-alternatives --config java 已经安装的Java版本都会输出，输入想要设置为默认的序列化，按enter即可 Java_HOME环境变量 1 2 3 4 5 6 7 8 9 10 11 12 13 # 首先查看Java的安装位置 update-alternatives --config java # 打开/etc/environment文件 sudo vim /etc/environment # 将JAVA_HOME指定到OpenJDK11，在文件末尾添加 JAVA_HOME=\"/usr/lib/jvm/java-11-openjdk-amd64\" # 运行下述命令让shell生效 source /etc/environment # 验证JAVA_HOME环境变量 echo $JAVA_HOME vscode Java_HOME环境变量配置 settings.json 1 \"java.jdt.ls.java.home\": \"/usr/lib/jvm/java-11-openjdk-amd64\", 3. java 编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 编译单个文件 javac test.java javac test # package javac -d . *.java java animals/MammalInt javac -d ../ JNIDemo.java Java2Cplusplus.java BaseClass.java javac test.java java -Djava.library.path=./JNIDemo test # JNI javac -h . JNIDemo.java javap -s -p Java2Cplusplus.class # cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_JNIDemo.so com_huhu_test_JNIDemo.cpp 4. JNI ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.1. JAVA调用C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import com.huhu.test.*; /* 文件名 : MammalInt.java */ public class test { public static void main(String[] args) { //加载C文件 System.loadLibrary(\"com_huhu_test_JNIDemo\"); JNIDemo jniDemo = new JNIDemo(); jniDemo.testHello(); int[] data = {1, 2, 3}; float[] f = jniDemo.execute(data, 1, 2, 3); System.out.println(f[0]); System.out.println(f[1]); System.out.println(f[2]); } } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.2. 生成 头文件 com_huhu_test_JNIDemo 1 javac -h . JNIDemo.java JNIDemo.java ： 1 2 3 4 5 6 7 8 package com.huhu.test; public class JNIDemo { //定义一个方法，该方法在C中实现 public native void testHello(); public native float[] execute(int[] data, int width, int height, float ep); } com_huhu_test_JNIDemo.h : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* DO NOT EDIT THIS FILE - it is machine generated */ #include \u003cjni.h\u003e /* Header for class com_huhu_test_JNIDemo */ #ifndef _Included_com_huhu_test_JNIDemo #define _Included_com_huhu_test_JNIDemo #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_huhu_test_JNIDemo * Method: testHello * Signature: ()V */ JNIEXPORT void JNICALL Java_com_huhu_test_JNIDemo_testHello (JNIEnv *, jobject); /* * Class: com_huhu_test_JNIDemo * Method: execute * Signature: ([IIIF)[F */ JNIEXPORT jfloatArray JNICALL Java_com_huhu_test_JNIDemo_execute (JNIEnv *, jobject, jintArray, jint, jint, jfloat); #ifdef __cplusplus } #endif #endif ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.3. 实现 com_huhu_test_JNIDemo com_huhu_test_JNIDemo.cpp: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libTestJni.so // TestJni.cpp #include \"com_huhu_test_JNIDemo.h\" #include \u003cjni.h\u003e #include \u003ccstdio\u003e #include \u003ciostream\u003e #include \u003cvector\u003e #define JNI_JAVA2C_PATH \"com/huhu/test/Java2Cplusplus\" #define JNI_BASE_CLASS_PATH \"com/huhu/test/BaseClass\" JNIEXPORT void JNICALL Java_com_huhu_test_JNIDemo_testHello(JNIEnv *env, jobject thiz) { std::cout \u003c\u003c \"this is Java_com_huhu_test_JNIDemo_testHello C++ print\" \u003c\u003c std::endl; } JNIEXPORT jfloatArray JNICALL Java_com_huhu_test_JNIDemo_execute(JNIEnv *env, jobject thiz, jintArray data, jint width, jint height, jfloat ep) { std::cout \u003c\u003c \"this is Java_com_huhu_test_JNIDemo_execute C++ print\" \u003c\u003c std::endl; unsigned char *data_src = (unsigned char *)env-\u003eGetIntArrayElements(data, NULL); std::cout \u003c\u003c \"data_src \" \u003c\u003c data_src[0] \u003c\u003c \" \" \u003c\u003c data_src[1] \u003c\u003c \" \" \u003c\u003c data_src[2] \u003c\u003c \" \" \u003c\u003c std::endl; std::cout \u003c\u003c \"width height ep \" \u003c\u003c width \u003c\u003c \" \" \u003c\u003c height \u003c\u003c \" \" \u003c\u003c ep \u003c\u003c \" \" \u003c\u003c std::endl; std::vector\u003cfloat\u003e result{0.1, 0.2, 0.3}; jfloatArray resultArray = env-\u003eNewFloatArray(result.size()); env-\u003eSetFloatArrayRegion(resultArray, 0, result.size(), \u0026result[0]); /* ------------------ */ //步骤1： jclass clazz = env-\u003eFindClass(JNI_JAVA2C_PATH); //步骤2：\u003cinit\u003e是java的构造函数名，这个有点特殊。在我的一篇文章jetpack中的问题中碰见过它。 //构造函数没输入输出参数，所以这里的signature填写为()V jmethodID method_init_id = env-\u003eGetMethodID(clazz, \"\u003cinit\u003e\", \"()V\"); jmethodID method_set_id = env-\u003eGetMethodID(clazz, \"setNum\", \"(I)V\"); jmethodID method_get_id = env-\u003eGetMethodID(clazz, \"getNum\", \"()I\"); jclass base = env-\u003eFindClass(JNI_BASE_CLASS_PATH); jmethodID method_base_init_id = env-\u003eGetMethodID(base, \"\u003cinit\u003e\", \"()V\"); jobject objbase = env-\u003eNewObject(base, method_base_init_id); jmethodID method_get_jobject_id = env-\u003eGetMethodID(clazz, \"getNum\", \"(Lcom/huhu/test/BaseClass;)I\"); //步骤3： //创建了 Java2Cplusplus 对象 jobject obj = env-\u003eNewObject(clazz, method_init_id); //步骤4:调用相应的方法 env-\u003eCallVoidMethod(obj, method_set_id, 21); // set函数没返回值 int year = env-\u003eCallIntMethod(obj, method_get_id); // getYear有返回值 int year2 = env-\u003eCallIntMethod(obj, method_get_jobject_id,objbase); // getYear有返回值 std::cout \u003c\u003c \"year \" \u003c\u003c year \u003c\u003c std::endl; std::cout \u003c\u003c \"year2 \" \u003c\u003c year2 \u003c\u003c std::endl; /* ------------------ */ return resultArray; } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.4. 编译 com_huhu_test_JNIDemo.cpp 1 2 3 4 5 6 g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_JNIDemo.so com_huhu_test_JNIDemo.cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_huhu_test_UfcwStrategy.so com_huhu_test_UfcwStrategy.cpp g++ -fPIC -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/ -I /usr/lib/jvm/java-1.11.0-openjdk-amd64/include/linux/ -shared -o libcom_ufcw_strategy_UfcwStrategy.so com_ufcw_strategy_UfcwStrategy.cpp ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.5. 编译运行 java 1 2 3 4 5 6 7 8 9 javac -d ../ JNIDemo.java Java2Cplusplus.java BaseClass.java cd ../ javac test.java java -Djava.library.path=./JNIDemo test ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["java"],"content":"4.6. JNI GetFieldID和GetMethodID 所需签名参数 调用JNI的GetMethodID函数获取一个jmethodID时，需要传入一个方法名称和方法签名，方法名称就是在Java中定义的方法名，方法签名的格式为：(形参参数类型列表)返回值。 1.基本类型签名 Java Native Signature byte jbyte B char jchar C double jdouble D float jfloat F int jint I short jshort S long jlong J boolean jboolean Z void void V 2.引用数据类型的转换. Java Native Signature 所有对象 jobject L+classname +; Class jclass Ljava/lang/Class; String jstring Ljava/lang/String; Throwable jthrowable Ljava/lang/Throwable; Object[] jobjectArray [L+classname +; byte[] jbyteArray [B char[] jcharArray [C double[] jdoubleArray [D float[] jfloatArray [F int[] jintArray [I short[] jshortArrsy [S long[] jlongArray [J boolean[] jbooleanArray [Z 获取签名方式： 自己拼写 ​ 方法：int (int param); ​ 签名：(I)I 命令行生成 ​ 1、使用javac，生成对应java文件的class文件； ​ 2、使用 javap -s -p 命令获取对应签名信息，如图： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Compiled from \"Java2Cplusplus.java\" public class com.huhu.test.Java2Cplusplus { private int num; descriptor: I public com.huhu.test.Java2Cplusplus(); descriptor: ()V public void setNum(int); descriptor: (I)V public int getNum(); descriptor: ()I public int getBaseClassNum(com.huhu.test.BaseClass); descriptor: (Lcom/huhu/test/BaseClass;)I } ","date":"2023-01-18","objectID":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":["java","ubuntu"],"title":"ubuntu中java开发环境搭建","uri":"/posts/program/java/ubuntu%E4%B8%ADjava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 资源管理 状态管理 简介 RAII RAII是C++的发明者Bjarne Stroustrup提出的概念， “Resource Acquisition is Initialization” ： “资源获取即初始化” 。 RAII技术被认为是C++中管理资源的最佳方法，进一步引申，使用RAII技术也可以实现安全、简洁的状态管理，编写出优雅的异常安全的代码。 在构造函数中申请分配资源，在析构函数中释放资源。 C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。 智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。 资源管理 内存只是资源的一种，广义的资源管理,比如说文件的打开与关闭、windows中句柄的获取与释放等等。按照常规的RAII技术需要写一堆管理它们的类，有的时候显得比较麻烦。但是如果手动释放，通常还要考虑各种异常处理，比如说： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 void function() { FILE *f = fopen(\"test.txt\", 'r'); if (.....) { fclose(f); return; } else if(.....) { fclose(f); return; } fclose(f); ...... } 实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #define SCOPEGUARD_LINENAME_CAT(name, line) name##line #define SCOPEGUARD_LINENAME(name, line) SCOPEGUARD_LINENAME_CAT(name, line) #define ON_SCOPE_EXIT(callback) ScopeGuard SCOPEGUARD_LINENAME(EXIT, __LINE__)(callback) class ScopeGuard { public: explicit ScopeGuard(std::function\u003cvoid()\u003e f) : handle_exit_scope_(f){}; ~ScopeGuard(){ handle_exit_scope_(); } private: std::function\u003cvoid()\u003e handle_exit_scope_; }; int main() { { A *a = new A(); ON_SCOPE_EXIT([\u0026] {delete a; }); ...... } { std::ofstream f(\"test.txt\"); ON_SCOPE_EXIT([\u0026] {f.close(); }); ...... } system(\"pause\"); return 0; } 状态管理 RAII另一个引申的应用是可以实现安全的状态管理。 一个典型的应用就是在线程同步中，使用std::unique_lock或者std::lock_guard对互斥量std:: mutex进行状态管理。 1 2 3 4 5 6 7 8 std::mutex mutex_; void function() { mutex_.lock(); ...... ...... mutex_.unlock(); } 在互斥量lock和unlock之间的代码很可能会出现异常，或者有return语句，这样的话，互斥量就不会正确的unlock，会导致线程的死锁。所以正确的方式是使用std::unique_lock或者std::lock_guard对互斥量进行状态管理： 1 2 3 4 5 6 7 std::mutex mutex_; void function() { std::lock_guard\u003cstd::mutex\u003e lock(mutex_); ...... ...... } 在创建std::lock_guard对象的时候，会对std::mutex对象进行lock，当std::lock_guard对象在超出作用域时，会自动std::mutex对象进行解锁，这样的话，就不用担心代码异常造成的线程死锁。 ","date":"2023-01-18","objectID":"/posts/program/cpp/c++raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/:0:0","tags":["cpp"],"title":"C++:RAII(资源获取即初始化)","uri":"/posts/program/cpp/c++raii%E8%B5%84%E6%BA%90%E8%8E%B7%E5%8F%96%E5%8D%B3%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["makefile"],"content":"makefile","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 语法 target : dependencies CC CFLAGS LFLAGS $@ ，$\u003c，$^ patsubst 和 wildcard Static Pattern Rule LIBS = -lm 语法 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:0:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"target : dependencies 1 \u003ctarget\u003e:\u003cdependencies\u003e。即，目标：目标依赖的文件。 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:1:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"CC CFLAGS LFLAGS CC 表示选择的编译器（也可以改成 gcc） CFLAGS 表示编译选项，-c 即 g++ 中的 -c，-Wall 表示显示编译过程中遇到的所有 warning LFLAGS 表示链接选项 $() 将其括起来，表示这是一个变量名 ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:2:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"$@ ，$\u003c，$^ target: dependencies 对：all: library.cpp main.cpp $@ 指代 all ，即 target $\u003c 指代 library.cpp， 即第一个 dependency $^ 指代 library.cpp 和 main.cpp，即所有的 dependencies ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:3:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"patsubst 和 wildcard wildcard 用于获取符合特定规则的文件名 1 2 3 4 SOURCE_DIR = . # 如果是当前目录，也可以不指定 SOURCE_FILE = $(wildcard $(SOURCE_DIR)/*.cpp) target: @echo $(SOURCE_FILE) 输出的为当前目录下所有的 .cpp 文件： ./function1.cpp ./function2.cpp ./main.cpp patsubst 应该是 pattern substitution 的缩写。用它可以方便地将 .cpp 文件的后缀换成 .o。 $(patsubst 原模式，目标模式，文件列表) 1 2 3 4 5 SOURCES = main.cpp function1.cpp function2.cpp OBJS = $(patsubst %.cpp, %.o, $(SOURCES)) target: @echo $(SOURCES) @echo $(OBJS) 输出结果： 1 2 main.cpp function1.cpp function2.cpp main.o function1.o function2.o ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:4:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"Static Pattern Rule targets: target-pattern: prereq-patterns 其中 targets 不再是一个目标文件了，而是一组目标文件。而 target-pattern 则表示目标文件的特征。例如目标文件都是 .o 结尾的，那么就将其表示为 %.o，prereq-patterns (prerequisites) 表示依赖文件的特征，例如依赖文件都是 .cpp 结尾的，那么就将其表示为 %.cpp。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OBJS = $(patsubst %.cpp, %.o, $(wildcard *.cpp)) CC = g++ CFLAGS = -c -Wall LFLAGS = -Wall all: hello hello: $(OBJS) $(CC) $(LFLAGS) $^ -o $@ $(OBJS):%.o:%.cpp $(CC) $(CFLAGS) $\u003c -o $@ clean: rm -rf *.o hello ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:5:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["makefile"],"content":"LIBS = -lm -lm 表示连街 math 库 1 2 3 4 CC = g++ LIBS = -lm out: fun.cpp $(CC) -o $@ $^ $(LIBS) ","date":"2023-01-18","objectID":"/posts/program/makefile/makefile/:6:0","tags":["makefile"],"title":"makefile","uri":"/posts/program/makefile/makefile/"},{"categories":["正则表达式"],"content":"正则表达式","date":"2023-01-18","objectID":"/posts/program/regex/regex/","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 #说明 #目录 一、正则基础概述 1、什么是正则表达式? 2、基础语法图表 Ⅰ - 基础语法表格 Ⅱ - 常用语法示例图解析 a) 通用正则表达式 b) 手机号正则 c) 日期匹配与分组替换 3、基本匹配 二、元字符 1、元字符列举 2、点运算符 –\u003e . 3、字符集 Ⅰ- 字符集中匹配句号. –\u003e\u003e [.] Ⅱ - 否定字符集 –\u003e\u003e [^] a) 一个特殊的用法 Ⅲ - 重复次数 –\u003e\u003e *、+、? a) * 号 b) +号 c) ? 号 Ⅳ - 量词 –\u003e\u003e {} a) 正常使用示例 b) 省略第二个参数,带逗号 c) 逗号也省略 Ⅴ- 特征标群 –\u003e\u003e (...) Ⅵ - 或运算符 –\u003e\u003e | Ⅶ - 转码特殊字符 –\u003e\u003e \\ Ⅷ - 锚点(边界) –\u003e\u003e ^、$、\\b、\\B a) ^ 号 b) $ 号 c) 单词边界 \\b d) 非单词边界 \\B 三、简写字符集 四、零宽度断言 (前后预查) 1、 正先行断言 –\u003e\u003e ?=... 2、负先行断言 –\u003e\u003e ?!... 3、 正后发断言 –\u003e\u003e ?\u003c= ... 4、负后发断言 –\u003e\u003e ?\u003c!... 五、标志(修饰符) 1、全局搜索 (Global search) –\u003e\u003e \\g 2、忽略大小写 (Case Insensitive) –\u003e\u003e /i 3、 多行注释符 六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching) 1、贪婪匹配 2、 惰性匹配 七、正则常用方法 1、 RegExp对象方法: Ⅰ- exce()方法 a) 概念与介绍 b) 当正则匹配中没有分组时 c ) 当正则匹配中有分组且分组存在名字时 d) 没有匹配到符合正则的字符时 Ⅱ - test()方法 Ⅲ - compile()方法 2、支持正则表达式的String对象的方法: Ⅰ- search()方法 a) 概念与介绍 b) 举个栗子 Ⅱ - replace()方法 a) 概念与介绍 b) 替换第一个 c) 替换全部 Ⅲ - split()方法 a) 概念与介绍 b) 举个栗子 Ⅳ- match()方法 a) 概念与介绍 b) 没有g的正则匹配 c) 有g的正则匹配 d) 没有匹配到子字符串 八、ES系列中正则的拓展 1、概括与总结 2、 RegExp 构造函数 3、字符串的正则方法 4、 u 修饰符 Ⅰ- 点字符 Ⅱ - Unicode 字符表示法 Ⅲ - 量词 Ⅳ - 预定义模式 Ⅴ - i 修饰符 Ⅵ - 转义 Ⅶ- RegExp.prototype.unicode 属性 5、 y 修饰符 Ⅰ - 正常使用举例说明 Ⅱ - 使用lastIndex属性进行说明 Ⅲ - 使用字符串对象的replace方法的举例 Ⅳ - RegExp.prototype.sticky 属性 6、s 修饰符：dotAll 模式 7、 RegExp.prototype.flags 属性 8、 Unicode 属性类 9、 具名组匹配 Ⅰ- 简介 Ⅱ - 解构赋值和替换 Ⅲ - 引用 10、String.prototype.matchAll() 九、常用正则收录 1、正则表达式只保留数字 2、限制不能为空以及中文 3、关于数字常见正则 4、关于特殊符号 #说明 正则可以说是操作 [ 字符串 ] 最强大的工具了,没有之一,特别是在进行爬虫技术或 前端字符串处理时简直必备技能,然鹅正则总是学了忘、忘了学,用时还需要去百度翻资料,也是严重影响了工作效率,所以我也认真查阅许多资料认真学习梳理成此笔记. 在此我会尽量详细地对查阅的资料进行摘录梳理并加入自己理解,相信看完这个笔记后同学们能快速掌握或者定位知识点 查阅的资料或博客:【韩顺平讲Java】Java 正则表达式专题 -正则 正则表达式 元字符 限定符 Pattern Matcher 分组 捕获 反向引用等 ;[comer的60分钟正则从入门到深入]、[Vincent Ko的可能是最好的正则表达式的教程笔记了吧…]、[gitHub的learn-regex]、阮一峰的ES6文档、deerchao的正则表达式30分钟入门教程 、博客园的 只争朝夕，不负韶华的正则常用的六种方法 除此笔记外大家可以看我其他笔记 :全栈笔记、编程_前端开发学习笔记、Vue笔记整合 、React笔记、 ReactHooks笔记 、微信小程序学习笔记、Chrome开发使用及学习笔记 以及许多其他笔记就不一一例举了 #目录 [TOC] 一、正则基础概述 首先给出正则最基础的知识点概述,好让同学们能回想起一些之前学过的知识点,能更好地进行阅读 这里分享一个在线练习正则的网站,同学们可以在这里进行练习 –\u003e [ 在线练习 ] 笔记中例子中如特殊没有指出,则默认使用 /g 标志(修饰符)全局搜索作为示范 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:0:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、什么是正则表达式? 正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。通俗的讲就是按照某种规则去匹配符合条件的字符串 一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regular expression”这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。 正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:1:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、基础语法图表 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ - 基础语法表格 首先先给出最最基础部分的匹配规则,这个是肯定要会的 single char (单字符) quantifiers(数量) position(位置) \\d 匹配数字 * 0个或者更多 ^一行的开头 \\w 匹配word(数字、字母) + 1个或更多，至少1个 $一行的结尾 \\W 匹配非word(数字、字母) ? 0个或1个,一个Optional \\b 单词\"结界\"(word bounds) \\s 匹配white space(包括空格、tab等) {min,max}出现次数在一个范围内 \\S 匹配非white space(包括空格、tab等) {n}匹配出现n次的 . 匹配任何，任何的字符 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 常用语法示例图解析 此处暂时看不懂没关系,后面会进行详细的语法介绍,此处只是让我们对正则表达式更有概念,感觉不好理解可以跳过,学完再回来看 此示例图解析部分主要摘录自 comer的60分钟正则从入门到深入,本人觉得其图画的挺好的,且确实刚开始可以稍微看下正则具体应用,方便后续理解,便摘录下来 a) 通用正则表达式 b) 手机号正则 1 /^1[34578][0-9]{9}$/ c) 日期匹配与分组替换 1 /^\\d{4}[/-]d{1,2}[/-]\\d{1,2}$/ 这个正则比较复杂，画符念咒的地方太多了，一一分析： Start of line 是由^生效的表示以此开头 对应结尾End of line 由$生效表示以此结尾 接着看digit 由 d 生效表示数字 3times 由{4} 生效表示重复4次，开始的时候有疑问，为什么不是 4times 。后来明白作者的用意，正则表达式是一个规则，用这个规则去从字符串开始匹配到结束（注意计算机读字符串可是不会分行的，都是一个串，我们看到的多行，人家会认为是个 t ）这里设计好像小火车的轨道一直开到末尾。digit 传过一次，3times表示再来三次循环，共4次，后面的once同理。 自己被自己啰嗦到了。 接下来，是 one of 在手机正则里面已经出现了。表示什么都行。只要符合这两个都让通过。 好了这个正则解释完了，接下来用它做什么呢？ 我们可以验证日期的合法性 结合URL分组替换所用到的分组特性，我们可以轻松写出日期格式化的方法 改造下这个正则 1 /^(\\d{4})[/-](\\d{1,2})[/-](\\d{1,2})$/ 轻松的可以拿到 group#1 #2 #3 的内容，对应 $1 $2 $3 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:2:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、基本匹配 正则表达式其实就是在执行搜索时的格式，它由一些字母(也可以是汉字)和数字组合而成。 例如：一个正则表达式 学习的汪 H，它表示一个规则：由学开始，接着是习,…最后H。它是组个字符与输入的正则表达式作比较,同时大小写敏感 1 2 3 \"学习的汪 H\" =\u003e 努力学习的汪 hongjilin //无符合匹配字符串 努力学习的汪 Hongjilin //其中的 [ 学习的汪 H ] 高亮 结果示例: 这里分享一个在线练习正则的网站,同学们可以在这里进行练习 –\u003e [ 在线练习 ] 二、元字符 正则表达式主要依赖于元字符。 元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:3:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、元字符列举 以下是一些元字符的列举： 元字符 描述 . 句号匹配任意单个字符除了换行符。 [ ] 字符种类。匹配方括号内的任意字符。 [^ ] 否定的字符种类。匹配除了方括号里的任意字符 * 匹配\u003e=0个重复的在*号之前的字符。 + 匹配\u003e=1个重复的+号前的字符。 ? 标记?之前的字符为可选. {n,m} 匹配num个大括号之前的字符或字符集 (n \u003c= num \u003c= m). (xyz) 字符集，匹配与 xyz 完全相等的字符串. | 或运算符，匹配符号前或后的字符. \\ 转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \\ ^ 从开始行开始匹配. $ 从末端开始匹配. ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:4:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、点运算符 –\u003e . .是元字符中最简单的例子。 .匹配任意单个字符，但不匹配换行符。 例如，表达式 [...o ] 匹配3个(几个点就几位)任意字符后面跟着是 [ o ] 的字符串。 1 2 3 '...o' =\u003e //此处给出三个点 就是前三位为任意 努力学习的汪 hongjilin //其中的 [ 汪 ho ] 高亮 努力学习的汪 Hongjilin //其中的 [ 汪 Ho ] 高亮 这时,某个认真看笔记的同学提问: . 用来匹配任意字符 那么字符串中的句号.,我们又怎么匹配呢?别急,带着这个疑问继续往下看,答案就在下方字符集中 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:5:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、字符集 字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式 [ 学习的汪 [Hh] ] 匹配 [ 学习的汪 h ] 和 [ 学习的汪 H ] 。 1 2 3 \"学习的汪 [Hh]\" =\u003e 努力学习的汪 hongjilin //其中的 [ 学习的汪 h ] 高亮 努力学习的汪 Hongjilin //其中的 [ 学习的汪 H ] 高亮 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 字符集中匹配句号. –» [.] 前面我们说过点运算符,那同学们是否会有个疑惑, . 被用来匹配任意字符,那么作为字符串中的句号.,又该用什么匹配呢? 方括号的句号就表示句号。 表达式 lin[.] 匹配 lin.字符串 1 2 3 \"lin[.]\" =\u003e 努力学习的汪 hongjilins 努力学习的汪 Hongjilin. ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 否定字符集 –» [^] 一般来说 ^ 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式[^地]学习的[^帅] 匹配一个字符串为 [ 学习的 ]的, 同时前面一位字符串不能为地,后面一位字符串不能为帅 1 2 3 4 \"[^地]学习的[^帅]\" =\u003e 努力学习的汪 hongjilins //只有此处高亮 努力学习的帅汪 Hongjilin. 帅气地学习的 a) 一个特殊的用法 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 1 /foo.bar/.test('foo\\nbar') // false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 1 /foo[^]bar/.test('foo\\nbar') // true 当然,这种解决方案毕竟不太符合直觉， ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1 /foo.bar/s.test('foo\\nbar') // true 详见ES系列笔记正则部分 –\u003e ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 重复次数 –» *、+、? 后面跟着元字符 +，* or ? 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。 a) * 号 *号匹配 在*之前的字符出现大于等于0次。 例如，表达式 a* 匹配0或更多个以a开头的字符。表达式[a-z]* 匹配一个行中所有以小写字母开头的字符串。 1 2 3 4 \"[a-z]*\" =\u003e Hong ji lin VERY shuai //部分高亮 HONGJILINHAOSHUAI //全部不亮 hongjilinhaoshuai //全部高亮 *号搭配 .号 *字符和.字符搭配可以匹配所有的字符.*。 *和表示匹配空格的符号\\s连起来用，如表达式\\s*学习\\s*匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。 1 2 3 4 \"\\s*学习\\s*\" =\u003e //0~无限次,所以只要有[ 学习 ]都会被匹配,同时会被匹配的还有其紧靠的无限次的空格 努力 学习的汪 hongjilins //[ 学习 ]前一个空格,后面无空格 努力 学习 的汪hongjilins //[ 学习 ]前后多个空格 努力学习的帅汪 Hongjilin. //[ 学习 ] 前后无空格 b) +号 +号匹配+号之前的字符出现 \u003e=1 次。 例如表达式学习.+汪 匹配以中文(也可以是字母)学习开头以 [汪] 结尾，中间跟着至少一个字符的字符串。 1 2 3 4 5 \"学习.+汪\" =\u003e 努力学习的汪 hongjilins 努力学习的帅汪 Hongjilin. 努力学习 66 汪 Hongjilin. 努力的学习汪 //此行无匹配结果 c) ? 号 在正则表达式中元字符 ? 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 学习的[帅]?汪 匹配字符串 学习的汪 和 学习的帅汪。 1 2 3 4 5 \"学习的[帅]?汪\" =\u003e 努力学习的汪 hongjilins 努力学习的帅汪 Hongjilin. 努力的学习汪 //无匹配结果 努力学习的帅气汪 Hongjilin. //无匹配结果 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - 量词 –» {} a) 正常使用示例 在正则表达式中 {} 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 [0-9]{2,3} 匹配最少 2 位最多 3 位 0~9 的数字。 1 2 3 4 5 \"[0-9]{2,3}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 b) 省略第二个参数,带逗号 我们可以省略第二个参数。 例如，[0-9]{2,} 匹配至少两位 0~9 的数字。 1 2 3 4 5 \"[0-9]{2,}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 c) 逗号也省略 如果逗号也省略掉则表示重复固定的次数。 例如，[0-9]{2} 匹配2位数字 1 2 3 4 5 \"[0-9]{2}\" =\u003e 努力学习的1汪1 努力学习的233汪 努力学习的4个4444汪 努力学习的5个55555汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅴ- 特征标群 –» (...) 特征标群是一组写在 (...) 中的子模式。(...) 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 (ab)* 匹配连续出现 0 或更多个 ab。如果没有使用 (...) ，那么表达式 ab* 将匹配连续出现 0 或更多个 b 。再比如之前说的 {} 是用来表示前面一个字符出现指定次数。但如果在 {} 前加上特征标群 (...) 则表示整个标群内的字符重复 N 次。 我们还可以在 () 中用或字符 | 表示或。例如，(学习|打工)的汪 匹配 学习的汪 或 打工的汪 . 1 2 3 4 5 \"(学习|打工)的汪 (hong){2}\" =\u003e 努力学习的汪 hongjilins 努力学习打工的汪 hongjilins 努力打工的汪 honghongjilins 努力学习打工的汪 honghongjilins ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:5","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅵ - 或运算符 –» | 或运算符就表示或，用作判断条件。 举个栗子: (学习|打工)的(汪|打工人) 进行匹配 1 2 3 4 \"(学习|打工)的(汪|打工人)\" =\u003e 努力打工的汪 hongjilins 努力学习的打工人 honghongjilins 努力学习打工的打工人汪 hongjilins ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:6","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅶ - 转码特殊字符 –» \\ 反斜线 \\ 在表达式中用于转码紧跟其后的字符。用于指定 { } [ ] / \\ + * . $ ^ | ? 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 \\。 例如 . 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 . 则要写成 \\. 以下这个例子 \\.?是选择性匹配. 1 2 3 4 \"(学习|打工)的汪\\.? hong\\??\" =\u003e 努力打工的汪. hong 努力学习的汪? hong 努力学习的汪 hong? ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:7","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅷ - 锚点(边界) –» ^、$、\\b、\\B 在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。^ 指定开头，$ 指定结尾。 通常也会搭配标志(修饰符)相关知识点使用 由于还未说到标志相关知识,此处例子仍使用 [ /g ]全局搜索,如果对此有疑惑的可以留着疑问看下方的 五、标志 a) ^ 号 ^ 用来检查匹配的字符串是否在所匹配字符串的开头。 例如，在 abc 中使用表达式 ^a 会得到结果 a。但如果使用 ^b 将匹配不到任何结果。因为在字符串 abc 中并不是以 b 开头。 例如，^(学习|打工)的汪 进行匹配 1 2 3 4 5 6 \"^(学习|打工)的汪\" =\u003e //注意:下列字符串要分四次匹配,因为即使换行了,后三行字符串本质上都不在字符串开头 //或者标志换成 /m 而不是 /g 因为此处还未说到标志,所以默认大家使用/g全局搜索 学习的汪 hong 打工的汪 hong 努力打工的汪 hong 努力学习的汪 b) $ 号 同理于 ^ 号，$ 号用来匹配字符是否是最后一个。 例如，学习的(汪|打工人)$ 匹配以 [ 汪 ] 或者 [ 打工人 ] 结尾的字符串。 1 2 3 4 5 6 \"学习的(汪|打工人)$\" =\u003e //注意:下列字符串要分四次匹配,因为即使换行了,前三行字符串本质上都不在字符串结尾 //或者标志换成 /m 而不是 /g 因为此处还未说到标志,所以默认大家使用/g全局搜索 努力学习的汪 努力学习的打工人 努力学习的打工人 hongjilins 努力学习的汪_ //此处 _ 模拟表示空格 c) 单词边界 \\b \\b : 单词边界:指[a-zA-z0-9]之外的字符,举个栗子:\\bis\\b 1 2 3 4 5 '\\bis\\b'=\u003e My name is hongjilin my name@is@hong jilin myname学is习hongjilin mynameishongjilin //只有此处不被匹配 d) 非单词边界 \\B 1 2 3 4 5 '\\Bis\\B'=\u003e My name is hongjilin my name@is@hong jilin myname学is习hongjilin mynameishongjilin //只有此处被匹配,与单词边界切好相反 三、简写字符集 这些简写字符集,简洁明了且非常常用,但是也因为这样当初没有仔细去记,用时还得查阅资料十分不便,建议背下来 正则表达式提供一些常用的字符集简写。如下: 简写 描述 . 除换行符外的所有字符 \\w 匹配所有字母数字，等同于 [a-zA-Z0-9_] \\W 匹配所有非字母数字，即符号，等同于： [^\\w] \\d 匹配数字： [0-9] \\D 匹配非数字： [^\\d] \\s 匹配所有空格字符，等同于： [\\t\\n\\f\\r\\p{Z}] \\S 匹配所有非空格字符： [^\\s] \\f 匹配一个换页符 \\n 匹配一个换行符 \\r 匹配一个回车符 \\t 匹配一个制表符 \\v 匹配一个垂直制表符 \\p 匹配 CR/LF（等同于 \\r\\n），用来匹配 DOS 行终止符 四、零宽度断言 (前后预查) 先行断言和后发断言都属于非捕获簇（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。 例如，我们想要获得所有跟在 $ 符号后的数字，我们可以使用正后发断言 (?\u003c=\\$)[0-9\\.]*。 这个表达式匹配 $ 开头，后面可以跟着单个字符:[0~9]、[.]、[?],这些字符可以出现大于等于 0 次。 1 2 3 \"(?\u003c=\\$)[0-9\\.\\?]*\" =\u003e $0.,1,2,3,$4,5,6,$?7,8,$..9.9? //0. //4 //?7 //..9.9? 零宽度断言如下： 符号 描述 ?= 正先行断言-存在 ?! 负先行断言-排除 ?\u003c= 正后发断言-存在 ?\u003c! 负后发断言-排除 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:6:8","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、 正先行断言 –» ?=... ?=... 正先行断言，表示第一部分表达式之后必须跟着 ?=...定义的表达式。 返回结果只包含满足匹配条件的第一部分表达式(即不会返回先行断言匹配部分的内容)。 定义一个正先行断言要使用 ()。在括号内部使用一个问号和等号： (?=...)。 正先行断言的内容写在括号中的等号后面。 例如，表达式 学习的汪(?=\\shong) 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了正先行断言 (?=\\shong) ，即 [ 学习的汪 ]后面紧跟着 [ (空格)hong ]。 1 2 3 4 \"学习的汪(?=\\shong)\" =\u003e //此处断言中的可以再加如`+` 、`*` ......,此处举其中一个栗子说明 努力学习的汪 hong //只有此处被匹配到 返回: [学习的汪] --\u003e断言中的匹配项作为约束不会返回 努力学习的汪 帅 努力学习的汪hong //此处后面没有空格 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:7:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、负先行断言 –» ?!... 负先行断言 ?! 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 正先行断言 定义和 负先行断言 一样，区别就是 = 替换成 ! 也就是 (?!...)。 表达式 学习的汪(?!\\s+hong) 首先匹配 [ 学习的汪 ]，然后在括号中我们又定义了负先行断言 (?!\\shong) ,即 [ 学习的汪 ]后面不跟着 [ (空格)hong ]。 1 2 3 4 \"学习的汪(?!\\s+hong)\" =\u003e 努力学习的汪 hong //只有此处不被匹配到 努力学习的汪 帅 努力学习的汪hong ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:8:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、 正后发断言 –» ?\u003c= ... 正后发断言 记作(?\u003c=...) 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 (?\u003c=[学习|打工])的(汪|打工人) 匹配 [汪] 和 [打工人] ，且需要其前方跟着 [学习] 或 [打工] 。 1 2 3 4 \"(?\u003c=[学习|打工])的(汪|打工人)\" =\u003e 努力学习的汪 努力打工的打工人 努力学习汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:9:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、负后发断言 –» ?\u003c!... 负后发断言 记作 (?\u003c!...) 用于筛选所有匹配结果，筛选条件为 其前 不 跟随着断言中定义的格式。 例如，表达式 (?\u003c![学习|打工])的(汪|打工人) 匹配 [汪] 和 [打工人] ，且需要其前方 不 跟着 [学习] 或 [打工] 。 1 2 3 4 \"/(?\u003c![学习|打工])的(汪|打工人)/g\" =\u003e 努力学习的汪 努力打工的打工人 努力学习汪 五、标志(修饰符) 标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。 标志 描述 i 忽略大小写。 g 全局搜索。 m 多行修饰符：锚点元字符 ^ $ 工作范围在每行的起始。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:10:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、全局搜索 (Global search) –» \\g 修饰符 g 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 /学习的汪/g 表示搜索 任意字符（除了换行）+ 学习的汪，并返回全部结果。 1 2 3 4 \"/学习的汪/g\" =\u003e 努力学习的汪 努力学习的汪 非常努力学习的汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:11:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、忽略大小写 (Case Insensitive) –» /i 修饰语 i 用于忽略大小写。 例如，表达式 /Hong/gi 表示在全局搜索 Hong，在后面的 i 将其条件修改为忽略大小写，则变成搜索 [hong(忽略大小写)]，g 表示全局搜索。 1 2 3 4 5 \"/Hong/gi\" =\u003e //默认情况下是大小写敏感的,但此处这样标志后,就成为忽略大小写 hongjilin Hongjilin HONGJILIN hOngjilin ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:12:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、 多行注释符 多行修饰符 m 常用于执行一个多行匹配。 像之前介绍的 (^,$) 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 m。 例如，表达式 /学习的(汪|打工人)$/gm 表示 [学习的] 后面跟着 [汪] 或 [打工人] ，末尾可选除换行符外任意字符。根据 m 修饰符，现在表达式匹配每行的结尾。–\u003e此处举出上方锚点的例子 1 2 3 4 5 \"/学习的(汪|打工人)$/gm\" =\u003e //在之前说到 锚点 时提到,如果是 /g 只能一行一行匹配,而如果换成这个就可以直接匹配 努力学习的汪 努力学习的打工人 努力学习的打工人 hongjilins 努力学习的汪_ //此处 _ 模拟表示空格 六 、贪婪匹配与惰性匹配 (Greedy vs lazy matching) ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:13:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、贪婪匹配 正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。 1 2 \"/(.*汪)/\" =\u003e 努力学习的汪 非常认真读书的汪 的汪 的汪 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:14:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、 惰性匹配 我们可以使用 ? 将贪婪匹配模式转化为惰性匹配模式。 1 2 \"/(.*?汪)/\" =\u003e 努力学习的汪 非常认真读书的汪 的汪 的汪 七、正则常用方法 正则中常用方法主要分为两类，一类是：RegExp对象方法；一类是：支持正则表达式的String对象的方法。 此处主要列举常用的 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:15:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、 RegExp对象方法: RegExp对象方法:exce()、test() 、compile() ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- exce()方法 a) 概念与介绍 exec() 方法用于检索字符串中的正则表达式的匹配，如果字符串中有匹配的值返回该匹配值构成的数组 ， 该数组还有继承的属性： index：表示第一个匹配的字符在原字符串中的位置， input:表示原字符串， groups：表示当初中命名的分组时匹配到的分组对象； exec()方法没有匹配到数据时返回 null。 b) 当正则匹配中没有分组时 1 2 3 4 const str=\"努力666 123 学习! 456 的打工人! qrw\"; const patt=/\\d+/; const result=patt.exec(str); console.log(result) c ) 当正则匹配中有分组且分组存在名字时 1 2 3 4 const str=\"努力666 123 学习! 456 的打工人! qrw\"; const patt=/(?\u003c努力\u003e\\d)+/; const result=patt.exec(str); console.log(result) d) 没有匹配到符合正则的字符时 1 2 3 4 const str=\"努力学习的汪\"; const patt=/\\d+/; const result=patt.exec(str); console.log(result) //返回 null ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - test()方法 介绍：方法用于检测一个字符串是否匹配某个模式；如果字符串中有匹配的值返回 true ，否则返回 false。 1 2 3 4 5 6 7 8 9 const str=\"努力学习的汪\"; //查找\"学习\" const reg1=/学习/g; const result1=reg1.test(str); console.log(result1); //true //查找 \"打工\" const reg2=/打工/g; const result2=reg2.test(str); console.log(result2); //false ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - compile()方法 该方法的作用是能够对正则表达式进行编译，被编译过的正则在使用的时候效率会更高，适合于对一个正则多次调用的情况下，如果对一个正则只使用一两次，那么该方法没有特别显著的效应。 1 2 3 4 5 6 const reg=/[abc]/gi; console.log(reg.test('a'));//true reg=/[cde]/gi; console.log(reg.test('a')); //false reg.compile(reg); console.log(reg.test('a')); //false 被编译的正则和没有编译的正则在测试结果上没有任何区别，只是多次调用的效率上会更高一些 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:16:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、支持正则表达式的String对象的方法: 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 [ String.prototype.match ] 调用 RegExp.prototype[Symbol.match] [ String.prototype.replace ] 调用 RegExp.prototype[Symbol.replace] [ String.prototype.search ] 调用 RegExp.prototype[Symbol.search] [ String.prototype.split ] 调用 RegExp.prototype[Symbol.split] ES系列更多笔记可以点此跳转 –» ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- search()方法 a) 概念与介绍 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。 如果找到任何匹配的子串，则返回 该子串在原字符串中的第一次出现的位置。　如果没有找到任何匹配的子串，则返回 -1。 b) 举个栗子 1 2 3 4 5 6 7 8 const str1 = '努力学习 123 的汪 456'; const reg1 = /\\d+/; console.log(str1.search(reg1));//5 console.log(str1.search(\"的汪\"));//9 const str2 = 'hello world'; const reg2 = /\\d+/; console.log(str2.search(reg2));//-1 console.log(str2.search(\"打工人\"));//-1 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - replace()方法 a) 概念与介绍 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。原字符串不变，创建一个新的字符串 创建一个新的字符串，原字符串不变 b) 替换第一个 1 2 3 4 const str=\"努力学习的汪! 努力学习的汪!! 努力学习的汪!!!\"; const n=str.replace('学习',\"打工\"); console.log(str) //原字符串不变 console.log(n) //新字符串 c) 替换全部 1 2 3 4 5 6 const str=\"努力学习的汪! 努力学习的汪!! 努力学习的汪!!!\"; const n=str.replace(/学习/g,\"打工\"); //替换全部 const a=str.replace(/学习/,\"打工\"); //仍是替换单行 console.log(str) //原字符串不变 console.log(a) //仍是替换单行 console.log(n) //新字符串 全部替换 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - split()方法 a) 概念与介绍 用于把一个字符串按符合匹配条件的方式分割成一个字符串数组。不改变原字符串 b) 举个栗子 1 2 3 4 5 6 7 8 9 const str=\"How 1are 2you 3? 4I'm 5fine! 6thanks\"; const a=str.split(\" \"); const b=str.split(\" \",2); const c=str.split(/\\d/); const d=str.split(/\\d/,3); console.log(a); // [\"How\", \"1are\", \"2you\", \"3?\", \"4I'm\", \"5fine!\", \"6thanks\"] console.log(b); // [\"How\", \"1are\"] console.log(c); // [\"How \", \"are \", \"you \", \"? \", \"I'm \", \"fine! \", \"thanks\"] console.log(d); // [\"How \", \"are \", \"you \"] ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ- match()方法 a) 概念与介绍 概念: match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配 注意点: match() 方法将检索字符串 String，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。 如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配，与exce的完全一致 如果 regexp 有标志 g，它将找到全部符合正则子字符串，并返回一个数组。 如果没有找到任何匹配的文本，无论有没有g，match() 将返回 null b) 没有g的正则匹配 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/\\d+/; const result=str.match(reg); console.log(result) //没有 全局搜索 的时候返回与 exce() 完全一致 c) 有g的正则匹配 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/\\d+/g; const result=str.match(reg); console.log(result) //返回数组 d) 没有匹配到子字符串 1 2 3 4 const str = '努力学习 123 的汪 456'; const reg=/打工/g; const result=str.match(reg); console.log(result) //匹配不到返回null 八、ES系列中正则的拓展 更多ES系列知识点笔记 –\u003e ES6及后续版本学习笔记 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:17:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、概括与总结 变更RegExp构造函数入参：允许首参数为正则对象，尾参数为正则修饰符(返回的正则表达式会忽略原正则表达式的修饰符) 正则方法调用变更：字符串对象的match()、replace()、search()、split()内部调用转为调用RegExp实例对应的RegExp.prototype[Symbol.方法] u修饰符：Unicode模式修饰符，正确处理大于 [ \\uFFFF ] 的 [ Unicode字符 ] 点字符(.) Unicode表示法 量词 预定义模式 i修饰符 转义 y修饰符：粘连修饰符，确保匹配必须从剩余的第一个位置开始全局匹配(与g修饰符作用类似) unicode：是否设置u修饰符 sticky：是否设置y修饰符 flags：返回正则表达式的修饰符 重点难点 y修饰符隐含头部匹配标志^ 单单一个y修饰符对match()只能返回第一个匹配，必须与g修饰符联用才能返回所有匹配 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:18:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、 RegExp 构造函数 在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag 标志）。 1 2 3 var regex = new RegExp('xyz', 'i'); // 等价于 var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 1 2 3 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 1 2 var regex = new RegExp(/xyz/, 'i'); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 1 2 new RegExp(/abc/ig, 'i').flags // \"i\" 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:19:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、字符串的正则方法 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 [ String.prototype.match ] 调用 RegExp.prototype[Symbol.match] [ String.prototype.replace ] 调用 RegExp.prototype[Symbol.replace] [ String.prototype.search ] 调用 RegExp.prototype[Symbol.search] [ String.prototype.split ] 调用 RegExp.prototype[Symbol.split] ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:20:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、 u 修饰符 ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 1 2 /^\\uD83D/u.test('\\uD83D\\uDC2A') // false /^\\uD83D/.test('\\uD83D\\uDC2A') // true 上面代码中，\\uD83D\\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为: ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1 2 3 var s = '𠮷'; /^.$/.test(s) // false /^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - Unicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 1 2 3 /\\u{61}/.test('a') // false /\\u{61}/u.test('a') // true /\\u{20BB7}/u.test('𠮷') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配 61 个连续的u。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1 2 3 4 /a{2}/.test('aa') // true /a{2}/u.test('aa') // true /𠮷{2}/.test('𠮷𠮷') // false /𠮷{2}/u.test('𠮷𠮷') // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - 预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 1 2 /^\\S$/.test('𠮷') // false /^\\S$/u.test('𠮷') // true 上面代码的\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 1 2 3 4 5 6 7 function codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0; } var s = '𠮷𠮷'; s.length // 4 codePointLength(s) // 2 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅴ - i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 1 2 /[a-z]/i.test('\\u212A') // false /[a-z]/iu.test('\\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:5","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅵ - 转义 没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\\,）无效，而在u模式会报错。 1 2 /\\,/ // /\\,/ /\\,/u // 报错 上面代码中，没有u修饰符时，逗号前面的反斜杠是无效的，加了u修饰符就报错。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:6","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅶ- RegExp.prototype.unicode 属性 正则实例对象新增unicode属性，表示是否设置了u修饰符。 1 2 3 4 5 const r1 = /hello/; const r2 = /hello/u; r1.unicode // false r2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:21:7","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"5、 y 修饰符 提前剧透，y修饰符号相当于 /g隐含了头部匹配的标志^。带着这个思维就相对容易理解下方的粘连一次 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ - 正常使用举例说明 除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。实际上相当于默认加了一个^ y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 1 2 3 4 5 6 7 8 9 var s = 'aaa_aa_a'; var r1 = /a+/g; var r2 = /a+/y; r1.exec(s) // [\"aaa\"] --\u003e此时剩余字符串[_aa_a] r2.exec(s) // [\"aaa\"] --\u003e此时剩余字符串[_aa_a] r1.exec(s) // [\"aa\"] r2.exec(s) // null --\u003ey必须从第一个位置开始匹配,实际上相当于默认加了一个`^`,所以匹配不到 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 1 2 3 4 5 var s = 'aaa_aa_a'; var r = /a+_/y; r.exec(s) // [\"aaa_\"] r.exec(s) // [\"aa_\"] 上面代码每次匹配，都是从剩余字符串的头部开始。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 使用lastIndex属性进行说明 使用lastIndex属性，可以更好地说明y修饰符。 1 2 3 4 5 6 7 8 9 10 11 const REGEX = /a/g; // 指定从2号位置（y）开始匹配 REGEX.lastIndex = 2; // 匹配成功 const match = REGEX.exec('xaya'); // 在3号位置匹配成功 match.index // 3 // 下一次匹配从4号位开始 REGEX.lastIndex // 4 // 4号位开始匹配失败 REGEX.exec('xaya') // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 1 2 3 4 5 6 7 8 9 10 11 const REGEX = /a/y; // 指定从2号位置开始匹配 REGEX.lastIndex = 2; // 不是粘连，匹配失败 REGEX.exec('xaya') // null // 指定从3号位置开始匹配 REGEX.lastIndex = 3; // 3号位置是粘连，匹配成功 const match = REGEX.exec('xaya'); match.index // 3 REGEX.lastIndex // 4 实际上，y修饰符号隐含了头部匹配的标志^。 1 /b/y.exec('aba')// null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 使用字符串对象的replace方法的举例 下面是字符串对象的replace方法的例子。 1 2 const REGEX = /a/gy; 'aaxa'.replace(REGEX, '-') // '--xa' 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 1 2 'a1a2a3'.match(/a\\d/y) // [\"a1\"] 'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y; const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g; tokenize(TOKEN_Y, '3 + 4') // [ '3', '+', '4' ] tokenize(TOKEN_G, '3 + 4') // [ '3', '+', '4' ] function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result; } 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1 2 3 4 tokenize(TOKEN_Y, '3x + 4') // [ '3' ] tokenize(TOKEN_G, '3x + 4') // [ '3', '+', '4' ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅳ - RegExp.prototype.sticky 属性 与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 1 2 var r = /hello\\d/y; r.sticky // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:22:4","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"6、s 修饰符：dotAll 模式 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 1 /foo.bar/.test('foo\\nbar') // false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 1 /foo[^]bar/.test('foo\\nbar') // true 这种解决方案毕竟不太符合直觉， ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1 /foo.bar/s.test('foo\\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1 2 3 4 5 6 const re = /foo.bar/s; // 另一种写法 // const re = new RegExp('foo.bar', 's'); re.test('foo\\nbar') // true re.dotAll // true re.flags // 's' /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:23:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"7、 RegExp.prototype.flags 属性 ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 1 2 3 4 5 6 7 8 9 // ES5 的 source 属性 // 返回正则表达式的正文 /abc/ig.source // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 /abc/ig.flags // 'gi' ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:24:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"8、 Unicode 属性类 ES2018 引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 1 2 const regexGreekSymbol = /\\p{Script=Greek}/u; regexGreekSymbol.test('π') // true 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 1 \\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名，或者只写属性值。 1 2 \\p{UnicodePropertyName} \\p{UnicodePropertyValue} \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。 由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 1 2 const regex = /^\\p{Decimal_Number}+$/u; regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \\p{Number}甚至能匹配罗马数字。 1 2 3 4 5 // 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test('²³¹¼½¾') // true regex.test('㉛㉜㉝') // true regex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true 下面是其他一些例子。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 匹配所有空格 \\p{White_Space} // 匹配各种文字的所有字母，等同于 Unicode 版的 \\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配 Emoji /\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}|\\p{Emoji}\\uFE0F/gu // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:25:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"9、 具名组匹配 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅰ- 简介 正则表达式使用圆括号进行组匹配。 1 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 1 2 3 4 5 6 const RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj[1]; // 1999 const month = matchObj[2]; // 12 const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 1 2 3 4 5 6 const RE_DATE = /(?\u003cyear\u003e\\d{4})-(?\u003cmonth\u003e\\d{2})-(?\u003cday\u003e\\d{2})/; const matchObj = RE_DATE.exec('1999-12-31'); const year = matchObj.groups.year; // 1999 const month = matchObj.groups.month; // 12 const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加 [ “问号 + 尖括号 + 组名” ] （?\u003cyear\u003e），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 1 2 3 4 5 const RE_OPT_A = /^(?\u003cas\u003ea+)?$/; const matchObj = RE_OPT_A.exec(''); matchObj.groups.as // undefined 'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:1","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅱ - 解构赋值和替换 有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 1 2 3 let {groups: {one, two}} = /^(?\u003cone\u003e.*):(?\u003ctwo\u003e.*)$/u.exec('foo:bar'); one // foo two // bar 字符串替换时，使用$\u003c组名\u003e引用具名组。 1 2 3 4 let re = /(?\u003cyear\u003e\\d{4})-(?\u003cmonth\u003e\\d{2})-(?\u003cday\u003e\\d{2})/u; '2015-01-02'.replace(re, '$\u003cday\u003e/$\u003cmonth\u003e/$\u003cyear\u003e') // '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 1 2 3 4 5 6 7 8 9 10 11 12 '2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 {year, month, day} ) =\u003e { let {day, month, year} = groups; return `${day}/${month}/${year}`; }); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:2","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"Ⅲ - 引用 如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k\u003c组名\u003e的写法。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\k\u003cword\u003e$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 数字引用（\\1）依然有效。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\1$/; RE_TWICE.test('abc!abc') // true RE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 1 2 3 const RE_TWICE = /^(?\u003cword\u003e[a-z]+)!\\k\u003cword\u003e!\\1$/; RE_TWICE.test('abc!abc!abc') // true RE_TWICE.test('abc!abc!ab') // false ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:26:3","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"10、String.prototype.matchAll() 如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var regex = /t(e)(st(\\d?))/g; var string = 'test1test2test3'; var matches = []; var match; while (match = regex.exec(string)) { matches.push(match); } matches // [ // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"], // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"], // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] // ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1 2 3 4 5 6 7 8 9 const string = 'test1test2test3'; const regex = /t(e)(st(\\d?))/g; for (const match of string.matchAll(regex)) { console.log(match); } // [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"] // [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"] // [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for...of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用...运算符和Array.from()方法就可以了。 1 2 3 4 5 // 转为数组的方法一 [...string.matchAll(regex)] // 转为数组的方法二 Array.from(string.matchAll(regex)) 九、常用正则收录 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:27:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"1、正则表达式只保留数字 正则代码 1 2 str=str.replaceAll(\"[^0-9]\", \"\");//此表达式匹配错误 str=str.replace(/\\D/g,''); //正确 调用代码示例 1 2 3 4 5 onChange={(e)=\u003e store.changeSearchParamsValue('storeId')(e.target.value.replace(/\\D/g,''))} @action changeSearchNumberParamsValue = (type) =\u003e (value) =\u003e { //this.searchParams[type] = value.replace(/\\D/g,''); 外面限制好后传入 this.searchParams[type] = value; }; 实现效果 输入非数字内容则无法键入(替换为空) ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:28:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"2、限制不能为空以及中文 1 str=str.replace(/\\s/g, '').replace(/[\\u4E00-\\u9FA5]|[\\uFE30-\\uFFA0]/gi, ''); ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:29:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"3、关于数字常见正则 数字:\\d 位数限制:{m,n} 数字范围:[n-m], 出现次数: * + 数字：^[0-9]*$ n位的数字：^\\d{n}$ 至少n位的数字：^\\d{n,}$ m-n位的数字：^\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\\-)?\\d+(\\.\\d{1,2})?$ 正数、负数、和小数：^(\\-|\\+)?\\d+(\\.\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\\+?[1-9][0-9]*$ 非零的负整数：^\\-[1-9][]0-9\"*$ 或 ^-[1-9]\\d*$ 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:30:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["正则表达式"],"content":"4、关于特殊符号 匹配带小括号的字符串: const reg = new RegExp([(]${变量}[)], 'g') –\u003e这个变量是可以随着改变的 ","date":"2023-01-18","objectID":"/posts/program/regex/regex/:31:0","tags":["正则表达式"],"title":"正则表达式","uri":"/posts/program/regex/regex/"},{"categories":["读书笔记"],"content":"读书笔记：能力陷阱","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 打破你的认知：先⾏动，后思考 1.1. 改变思想从⾏动开始 1.2. 如何成为⼀名⾼效的领导者 1.3. “由外⽽内”原则 1.4. 转变过程中的迷失 1.5. 为什么“由外⽽内”地改变很重要 1.6. “三步⾛”助你实现领导者转变 1.7. 重新定义你的⼯作 1.8. 扩建⼈际关系⽹络 1.9. 试着朝更多不同的⽅向发展⾃⼰ 1.10. 过程和结果，哪个重要 2. 重新定义你的⼯作 1. 打破你的认知：先⾏动，后思考 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:0:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.1. 改变思想从⾏动开始 管理专家理查德·帕斯卡尔（Richard Pascale）所说：“成年⼈更倾向于先做⽽后产⽣新的想法，⽽不是先想再以⼀种新的⽅式去做。” 我们要先学会像领导者⼀样做事。⼀项关于“成年⼈学习⽅式”的研究发现，⼀般情况下的习顺序是“先思考后⾏动”；但是在⼀个⼈的改变过程中，学习顺序其实是相反的，例如，如果我们想要成为⼀名优秀的领导者，就要学会“先⾏动后思考”。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:1:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.2. 如何成为⼀名⾼效的领导者 我发现⼀个⼈之所以能成为领导者，是因为他所做的事是⼀名真正的领导者会做的事。 如果我们像⼀个领导者⼀样做事：如不断提出新观点，在专业领域之外做出贡献，或是集合⼈⼒物⼒做成⼀件很有价值的事，等等。⾝边的其他⼈也就会觉得我们越来越像⼀个真正的领导者。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:2:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.3. “由外⽽内”原则 新的经历不仅会改变你的想法——你认为什么是重要的，什么是值得去做的，还会改变你未来的样⼦。它们可以帮助你从⼀些新的成就⾥获得⾃信，使你放弃过去的⽬标，还可以改变你过去所习惯的做事⽅法。这不仅是因为过去的⽅法不再适⽤于当前的情况，还因为你有了新的⽬标，有更有意义、更有价值的事情需要去做。 与⾃省相⽐，由外⽽内地改变更能帮助你重塑形象，告诉你你能做什么。成为⼀名优秀的领导者并⾮是你发展道路上的起点，⽽是你⾃我⾝份认知的结果。 与⼤众普遍认为的观点相反，⾃省⼤多时候只会让我们停留在过去，蒙蔽我们的双眼，使我们⽆法发现我们的领导潜能，还会让我们毫⽆准备地去⾯对周围环境的根本转变。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:3:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.4. 转变过程中的迷失 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:4:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.5. 为什么“由外⽽内”地改变很重要 ⼯作上发⽣变动通常就意味着是时候该调整或重塑你的领导者形象了。与过去相⽐，现在重要的转变不仅仅是⼀个头衔或是⼀件晚礼服的改变，⽽ 是⼀些或微妙或明显的变化。这些变化会让别⼈对你产⽣⼀些新的期望（尽管有时候不是很明显），他们会期望你做出⼀些不⼀样的事，或是期望你改变⼀下做事风格。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:5:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.6. “三步⾛”助你实现领导者转变 ⼀是思考你所做⼯作的类型； ⼆是转换新⾓⾊或参与新活动能让你接触到不同的⼈，这些⼈有着与你不⼀样的世界观； 三是重新审视⾃⼰。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:6:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.7. 重新定义你的⼯作 想要成为⼀个领导者，⾸先要学会把时间投资在有意义的事情上。 在如今这个⾼速发展的商业世界⾥，价值的创造更多地来源于合作，这就意味着我们需要打破⾃给⾃⾜的企业界限。 在职业⽣涯的早期，我们被限制在⾃⼰的专业领域范围之内。当我们开始向⼀个领导者转变时，通常也都只是在我们的职能范围或专业领域之内，尤其是在我们擅长的领域内。⼀旦我们想要扮演⼀个更⾼等级的领导者⾓⾊，情况就会发⽣根本上的改变。 正如⼼理学家所说，我们应该做的事与我们实际做的事常常是两件完全不⼀样的事。从认真做事得到满意的回报转变为给别⼈提供策略指导并不是⼀件容易的事，这需要我们学会与组织外部的⼈进⾏合作。 要想成为⼀名优秀的领导者，就要先改变你的⽇常⼯作范围，从各种技术操作需求转变为提出更多的策略性指导。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:7:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.8. 扩建⼈际关系⽹络 如果遇到要做⾃⼰专业领域范围之外的事，或是需要他们提出⼀些能适应全局的策略，很多管理者都没有办法完成好这些任务，因为这不仅仅需要很强的分析能⼒，还需要⼴泛的⼈际关系⽹络基础。 与其他职能或其他公司的管理者（在我们领导范围之外的⼈）建⽴起直接或间接联系，对于弄清我们的策略是否能适应全局、如何推销⾃⼰的观点、弄清相关⾏业发展⽅向以及与其他⼈竞争资源这些⽅⾯来说都是⾮常重要的。 在我们刚接触⼀件新的任务时，我们需要有经验的⼈的建议和指导以及周围其他⼈的反馈来帮助我们成长和进步。在最开始的时候，我们的努⼒需要得到别⼈的肯定，还需要前⼈的⿎励和指导，并亲⾃给我们进⾏⽰范。当我们不确定前进的⽅向时，其他⼈所提供的建议也能为我们指明道路。 因此，想要成为⼀名优秀的领导者，你不仅仅需要学会去参与新活动或改变想法，还需要学会⽤⼀种新的⽅法去学习，即学会更多地⾃我引导，或是向同级的⼈学习，又或是在公司外部学习。 简⽽⾔之，你需要积极地去建⽴⼀个新的⼈际关系⽹络，并且你能从中学到很多，⾄少可以与上级建⽴更为密切的关系。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:8:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.9. 试着朝更多不同的⽅向发展⾃⼰ 没有⼈想要在转变的道路上迷失，然⽽要想像领导者⼀样思考的唯⼀办法就是要像领导者⼀样做事，即使最开始的时候你可能会觉得这并不是真正的你。 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:9:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["读书笔记"],"content":"1.10. 过程和结果，哪个重要 成为⼀名优秀的领导者不是⼀个项⽬或⼀个结果，⽽是⼀个过程。⾸先你需要了解这个过程，然后才能为之努⼒⽽后获得成功。 “当外在改变的速度超过内在改变速度之时，终点就在眼前。” 2. 重新定义你的⼯作 ","date":"2023-01-18","objectID":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/:10:0","tags":["能力陷阱"],"title":"读书笔记：能力陷阱","uri":"/posts/read_notes/%E8%83%BD%E5%8A%9B%E9%99%B7%E9%98%B1/"},{"categories":["tools"],"content":"配置定时任务","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":" crontab crontab定时任务语法 设置定时任务 cron 服务查看 expect 安装 expect 自动代码拉提交脚本 crontab cron是一个Linux定时执行工具，可以在无需人工干预的情况下运行作业。在Ubuntu中，cron是被默认安装并启动的。 ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:0:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"crontab定时任务语法 1 minute hour day month week user command #顺序：分 时 日 月 周 用户 命令 minute： 表示分钟，可以是从 0 到 59 之间的任何整数。 hour：表示小时，可以是从 0 到 23 之间的任何整数。 day：表示日期，可以是从 1 到 31 之间的任何整数。 month：表示月份，可以是从 1 到 12 之间的任何整数。 week：表示星期几，可以是从 0 到 7 之间的任何整数，这里的 0 或 7 代表星期日。 user：linux的用户身份，例如root，或者其他用户 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 特殊字符 星号（*）：代表所有可能的值，例如 month 字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，如*/10，如果用在 minute 字段，表示每十分钟执行一次。 ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:1:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"设置定时任务 编辑ect下crontab文件就行了，这个文件里存放的就是cron要执行的命令，以及定时执行的时间 1 sudo vim /etc/crontab 修改文件： 定时每凌晨，自动执行保存在/root目录下hello.sh脚本 1 00 00 * * * root /root/hello.sh 使用 1 2 3 00 01 * * * root /home/zyh/data/blogs/deploy.sh 00 03 * * * root /home/zyh/data/blogs/deploy.sh 00 05 * * * root /home/zyh/data/blogs/deploy.sh ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:2:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"cron 服务查看 1 2 3 4 5 service cron start # 启动服务 service cron stop # 关闭服务 service cron restart # 重启服务 service cron reload # 重新载入配置 service cron status # 查看crond状态 expect expect 就是完成一些需要与用户交互的任务，例如 telnet、ftp、ssh 远程登录机器的时候，这些命令会要求用户输入用户名、密码等相关信息，而这些，是无法通过 shell 脚本来完成的。这是因为这些命令是从控制终端而不是标准输入上读取的，所以无法事先将信息重定向到标准输入从而实现自动化运行。而 expect 就是用来解决这类问题的，举个expect 进行 ssh 登录的例子： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/expect -f set ipaddr \"localhost\" set passwd \"iforgot\" spawn ssh root@$ipaddr expect { \"yes/no\" { send \"yes\\r\"; exp_continue} \"password:\" { send \"$passwd\\r\" } } expect \"]# \" send \"touch a.txt\\r\" send \"exit\\r\" expect eof exit expect 脚本里有这么几个关键动作： spawn ：启动需要执行的命令； expect ：解析命令输出，并根据下面的匹配语句进入子控制块； send ：向命令发送信息，这些信息相当于是命令从控制终端读取的； interact ：继续命令与控制终端的交互，此时用户可以正常向命令输入信息（本例未展示）。 …… ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:3:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"安装 expect 1 2 3 4 # 安装 sudo apt-get install tcl tk expect # 查看版本 expect -v ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:4:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["tools"],"content":"自动代码拉提交脚本 timeout 1 2 set timeout -1 # 没有timeout set timeout XX # 设定具体的timeout时间（秒） 自动拉取重试 1 2 3 4 5 6 7 8 #! /usr/bin/expect -f set timeout 30 for {set i 0} {$i\u003c=10} {incr i} { puts \"start pulling git $i\" spawn git pull #expect \"Already up-to-date.\" { puts \"pulling ok\"; exit } expect \"已经是最新的。\" { puts \"pulling ok\"; exit } } 自动提交重试 1 2 3 4 5 6 7 #! /usr/bin/expect -f set timeout 30 for {set i 0} {$i\u003c=10} {incr i} { puts \"start pushing git $i\" spawn git push expect \"Everything up-to-date\" { puts \"pushing ok\"; exit } } 完整脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #!/bin/sh PATH=/bin:/usr/bin:/snap/bin export PATH # If a command fails then the deploy stops set -e cd /home/zyh/data/blogs echo \"LOG DATE:\" $(date +\"%Y-%m-%d %H:%M:%S\") DATE=`date '+%Y%m%d-%H%M%S'` echo $DATE LogNameDATE=`date '+%Y'` LogFile='./log/log'$LogNameDATE'.log' echo \" \" \u003e\u003e $LogFile echo \"———————————————–\" \u003e\u003e $LogFile echo \"BACKUP DATE:\" $(date +\"%Y-%m-%d %H:%M:%S\") \u003e\u003e $LogFile printf \"\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\" printf \"\\n\\n\" printf \"\\033[0;32mPull note files ...\\033[0m\\n\" expect pull.exp printf \"\\n\\n\" printf \"\\033[0;32mHugo build ...\\033[0m\\n\" # clean Public folder # cd public # rm -r * # cd ../ # Build the project. echo $(hugo -t LoveIt) \u003e\u003e $LogFile # if using a theme, replace with `hugo -t \u003cYOURTHEME\u003e` printf \"\\n\\n\" printf \"\\033[0;32mpush public ...\\033[0m\\n\" # Go To Public folder cd public # Add changes to git. if [ -n \"$(git status -s)\" ];then git add ./ # Commit changes. msg=\"update $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" cd ../ expect push_main.exp else cd ../ fi echo \"———————————————–\" \u003e\u003e $LogFile printf \"\\n\\n\" printf \"\\033[0;32mPush ...\\033[0m\\n\" # Add changes to git. if [ -n \"$(git status -s)\" ];then git add ./ # Commit changes. msg=\"update $(date)\" if [ -n \"$*\" ]; then msg=\"$*\" fi git commit -m \"$msg\" # Push source and build repos. expect push_master.exp fi printf \"\\n\\n\" printf \"\\033[0;32mDone\\033[0m\\n\" ","date":"2023-01-18","objectID":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/:5:0","tags":["ubuntu"],"title":"tool:ubuntu配置定时任务","uri":"/posts/tools/sys_config/ubuntu/configurescheduledtasks/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/","tags":["opencv"],"title":"opencv DNN 模块","uri":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/"},{"categories":["开源软件"],"content":"DNN模块介绍 OpenCV的DNN模块是在OpenCV3.3合并到OpenCV release中的，它最早是在扩展模块中的，它可以导入caffe、tensorflow、pytorch等深度学习框架训练生成的模型文件，从而正向传递实现预测功能。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/:0:0","tags":["opencv"],"title":"opencv DNN 模块","uri":"/posts/open_source_software/opencv/learn/dnn/opencv_dnn/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":" Mat 成员变量 Mat 通道理解 通道 图像类型的转换与显示 通道的合成与分解 创建一个Mat Scalar cv::Mat::ones cv::Mat::zeros cv::Mat::eye Mat类中数据部分组成 参考 Mat The class Mat represents an n-dimensional dense numerical single-channel or multi-channel array. It can be used to store real or complex-valued vectors and matrices, grayscale or color images, voxel volumes, vector fields, point clouds, tensors, histograms (though, very high-dimensional histograms may be better stored in a SparseMat ). 上面的一段话引用自官方的文档，Mat类用于表示一个多维的单通道或者多通道的稠密数组。能够用来保存实数或复数的向量、矩阵，灰度或彩色图像，立体元素，点云，张量以及直方图（高维的直方图使用SparseMat保存比较好）。简而言之，Mat就是用来保存多维的矩阵的。 成员变量 data: uchar型的指针。Mat类分为了两个部分:矩阵头和指向矩阵数据部分的指针，data就是指向矩阵数据的指针。 dims: 矩阵的维度，例如5*6矩阵是二维矩阵，则dims=2，三维矩阵dims=3. rows: 矩阵的行数 cols: 矩阵的列数 size: 矩阵的大小，size(cols,rows),如果矩阵的维数大于2，则是size(-1,-1) channels: 矩阵元素拥有的通道数，例如常见的彩色图像，每一个像素由BGR三部分组成，则channels = 3。 type: 表示了矩阵中元素的类型以及矩阵的通道个数，它是一系列的预定义的常量，其命名规则为CV_(位数）+（数据类型）+（通道数）。这里U（unsigned integer）表示的是无符号整数，S（signed integer）是有符号整数，F（float）是浮点数。 例如：CV_16UC2，表示的是元素类型是一个16位的无符号整数，通道为2. C1，C2，C3，C4则表示通道是1,2,3,4。type一般是在创建Mat对象时设定，如果要取得Mat的元素类型，则无需使用type，使用下面的depth depth :矩阵中元素的一个通道的数据类型，这个值和type是相关的。 例如 type为 CV_16SC2，一个2通道的16位的有符号整数。那么，depth则是CV_16S。depth也是一系列的预定义值，将type的预定义值去掉通道信息就是depth值:CV_8U CV_8S CV_16U CV_16S CV_32S CV_32F CV_64F elemSize :矩阵一个元素占用的字节数，例如：type是CV_16SC3，那么elemSize = 3 * 16 / 8 = 6 bytes elemSize1:矩阵元素一个通道占用的字节数，例如：type是CV_16CS3，那么elemSize1 = 16 / 8 = 2 bytes = elemSize / channels Mat 通道理解 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:0:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"通道 一个图像的通道数是N，就表明每个像素点处有N个数，一个a×b的N通道图像，其图像矩阵实际上是b行N×a列的数字矩阵。 OpenCV中图像的通道可以是1、2、3和4。其中常见的是1通道和3通道，2通道和4通道不常见。 1通道的是灰度图。 3通道的是彩色图像，比如RGB图像。 4通道的图像是RGBA，是RGB加上一个A通道，也叫alpha通道，表示透明度。PNG图像是一种典型的4通道图像。alpha通道可以赋值0到1，或者0到255，表示透明到不透明。 2通道的图像是RGB555和RGB565。2通道图在程序处理中会用到，如傅里叶变换，可能会用到，一个通道为实数，一个通道为虚数，主要是编程方便。RGB555是16位的，2个字节，5+6+5，第一字节的前5位是R，后三位+第二字节是G，第二字节后5位是B，可见对原图像进行压缩了。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:1:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"图像类型的转换与显示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 Mat image=imread(\"../images/RGB.jpg\"); Mat imageGRAY,imageRGBA,imageRGB555; cvtColor(image,imageGRAY,CV_RGB2GRAY); //RGB转GRAY cvtColor(image,imageRGBA,CV_RGB2BGRA); //RGB转RGBA cvtColor(image,imageRGB555,CV_RGB2BGR555); //RGB转RGB555 //来看看通道数 int n = image.channels(); //n=3 int nGRAY = imageGRAY.channels(); //nGRAY = 1 int nRGBA = imageRGBA.channels(); //nRGBA = 4 int nRGB555 = imageRGB555.channels(); //nRGB555 = 2 cout \u003c\u003c \"n: \" \u003c\u003c n \u003c\u003c \" nGRAY: \" \u003c\u003c nGRAY \u003c\u003c \" nRGBA: \" \u003c\u003c nRGBA \u003c\u003c \" nRGB555: \" \u003c\u003c nRGB555 \u003c\u003c endl; //显示GRAY、RGB和RGBA图像 imshow(\"image\",image); imshow(\"imageGRAY\",imageGRAY); imshow(\"imageRGBA\",imageRGBA); //imshow(\"imageRGB555\",imageRGB555); //无法显示 RGB转GRAY是根据一个心理学公式来的：Gray = R0.299 + G0.587 + B*0.114 RGB转GRBA，默认A通道的数值是255，也就是不透明的。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:2:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"通道的合成与分解 分解 1 2 C++: void split(const Mat\u0026 mtx, Mat* mv) C++: void split(const Mat\u0026 mtx, vector\u003cMat\u003e\u0026 mv) 参数：mtx 输入矩阵 mv 输出矩阵或矩阵数组 src 输入矩阵 dst0、dst1、dst2、dst3 最多4个单通道的输出矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void Mat_split(void) { Mat rgb(3, 4, CV_8UC3, Scalar(1, 2, 3, 4)); //这里 由于类型是 CV_8UC3 Scalar 第四个值没有用 vector\u003cMat\u003e channels; split(rgb, channels); Mat R = channels.at(0); //从vector中读数据用vector::at() Mat G = channels.at(1); Mat B = channels.at(2); cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c rgb \u003c\u003c endl; cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"G=\" \u003c\u003c endl \u003c\u003c G \u003c\u003c endl; cout \u003c\u003c \"B=\" \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 RGB= [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] R= [ 1, 1, 1, 1; 1, 1, 1, 1; 1, 1, 1, 1] G= [ 2, 2, 2, 2; 2, 2, 2, 2; 2, 2, 2, 2] B= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] 合成 1 2 C++: void merge(const Mat* mv, size_t count, OutputArray dst) C++: void merge(const vector\u003cMat\u003e\u0026 mv, OutputArray dst) 参数：mv 输入矩阵 count 当mv是C形式的array时，count表示输入矩阵个数 dst 输出矩阵 src0、src1、src2、src3 最多4个单通道的输入矩阵 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Mat_merge(void) { Mat R(3, 4, CV_8UC1, Scalar(3)); Mat G(3, 4, CV_8UC1, Scalar(2)); Mat B(3, 4, CV_8UC1, Scalar(1)); Mat RGB(3, 4, CV_8UC3); vector\u003cMat\u003e src; src.push_back(R); //往vector里存数据要用vector::push_back() src.push_back(G); src.push_back(B); merge(src, RGB); cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"G=\" \u003c\u003c endl \u003c\u003c G \u003c\u003c endl; cout \u003c\u003c \"B=\" \u003c\u003c endl \u003c\u003c B \u003c\u003c endl; cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c RGB \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 R= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] G= [ 2, 2, 2, 2; 2, 2, 2, 2; 2, 2, 2, 2] B= [ 1, 1, 1, 1; 1, 1, 1, 1; 1, 1, 1, 1] RGB= [ 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1; 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1; 3, 2, 1, 3, 2, 1, 3, 2, 1, 3, 2, 1] split( )和merge( )都是mixChannels( )的特例 1 2 C++: void mixChannels(const Mat* src, int nsrc, Mat* dst, int ndst, const int* fromTo, size_t npairs) C++: void mixChannels(const vector\u003cMat\u003e\u0026 src, vector\u003cMat\u003e\u0026 dst, const int* fromTo, int npairs) 参数：src 输入的矩阵，可以是一个矩阵也可以是多个矩阵构成的vector nsrc 输入矩阵的个数 dst 输出矩阵，可以是一个矩阵也可以是多个矩阵构成的vector ndst 输出矩阵的个数 fromTo src到dst通道对应数组 npairs fromTo中有几组对应关系 mixChannels( )本质是改变了几个通道的顺序，输入一共有几个通道，输出肯定也有几个通道，所以定义fromTo时，要知道有多少个通道，而且通道的编号一定是0,1,2，… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 void Mat_mixchannels(void) { Mat RGB(3, 4, CV_8UC3, Scalar(1, 2, 3, 4)); Mat A(3, 4, CV_8UC1, Scalar(6)); cout \u003c\u003c \"RGB=\" \u003c\u003c endl \u003c\u003c RGB \u003c\u003c endl; cout \u003c\u003c \"A=\" \u003c\u003c endl \u003c\u003c A \u003c\u003c endl; //RGB+A合成为RGBA cout \u003c\u003c \"RGB+A合成为RGBA\" \u003c\u003c endl; Mat RGBA(3, 4, CV_8UC4); Mat in[] = {RGB, A}; int fromTo1[] = {0, 0, 1, 1, 2, 2, 3, 3}; mixChannels(in, 2, \u0026RGBA, 1, fromTo1, 4); cout \u003c\u003c \"RGBA=\" \u003c\u003c endl \u003c\u003c RGBA \u003c\u003c endl; //RGB分解为R+GB cout \u003c\u003c \"RGB分解为R+GB\" \u003c\u003c endl; Mat R(3, 4, CV_8UC1); Mat GB(3, 4, CV_8UC2); Mat out[] = {R, GB}; int fromTo2[] = {0, 2, 1, 1, 2, 0}; mixChannels(\u0026RGB, 1, out, 2, fromTo2, 3); cout \u003c\u003c \"R=\" \u003c\u003c endl \u003c\u003c R \u003c\u003c endl; cout \u003c\u003c \"GB=\" \u003c\u003c endl \u003c\u003c GB \u003c\u003c endl; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 RGB= [ 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] A= [ 6, 6, 6, 6; 6, 6, 6, 6; 6, 6, 6, 6] RGB+A合成为RGBA RGBA= [ 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6; 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6; 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6, 1, 2, 3, 6] RGB分解为R+GB R= [ 3, 3, 3, 3; 3, 3, 3, 3; 3, 3, 3, 3] GB= [ 2, 1, 2, 1, 2, 1, 2, 1; 2, 1, 2, 1, 2, 1, 2, 1; 2, 1, 2, 1, 2, 1, 2, 1] 创建一个Mat 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void Mat_demo() { cv::Mat M(2, 2, CV_8UC3, Scalar(0, 0, 255)); cout \u003c\u003c M \u003c\u003c endl; cv::Mat Z = cv::Mat::zeros(3, 3, CV_64F); cout \u003c\u003c Z \u003c\u003c endl; cv::Mat F = cv::Mat::ones(2, 2, CV_64F); cout \u003c\u003c F \u003c\u003c endl; cv::Mat M0(1,2,CV_8UC3); cout \u003c\u003c M0 \u003c\u003c endl; float K[3][3] = {1, 0, 1, 0, 1, 1, 0, 0, 1}; cv::Mat M1 = cv::Mat(3,3,CV_32FC1,K); cout \u003c\u003c M1 \u003c\u003c end","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:3:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"Scalar Scalar是一个由长度为4的数组作为元素构成的结构体，Scalar最多可以存储四个值，没有提供的值默认是0。 1 2 3 4 typedef struct Scalar { double val[4]; }Scalar; 1 2 3 4 5 6 7 8 9 // 创建一个2通道，且每个通道的值都为（1,3），深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC2, Scalar(1, 3)); /* [1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3; 1, 3, 1, 3, 1, 3, 1, 3] */ 1 2 3 4 5 6 7 8 9 // 创建一个3通道，且每个通道的值都为（1,2,3），深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC3, Scalar(1, 2, 3)); /* [1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3; 1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3] */ 1 2 3 4 5 6 7 8 9 // 创建一个4通道，且每个通道的值都为（1,2,3,0）(默认为0)，深度为32，4行4列的图像矩阵。 Mat M(4, 4, CV_32FC4, Scalar(1, 2, 3)); /* [1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0; 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0] */ 1 2 3 4 5 6 7 8 9 10 11 12 Mat blue_m(256, 256, CV_8UC3, Scalar(255, 0, 0)); //cout\u003c\u003cblue_m\u003c\u003cendl; Mat green_m(256, 256, CV_8UC3, Scalar(0, 255, 0)); //cout\u003c\u003cgreen_m\u003c\u003cendl; Mat red_m(256, 256, CV_8UC3, Scalar(0, 0, 255)); //cout\u003c\u003cred_m\u003c\u003cendl; Mat previewImg(256, 256, CV_8UC3); //CV_EXPORTS void hconcat(InputArray src1, InputArray src2, OutputArray dst); hconcat(blue_m, green_m, previewImg); hconcat(previewImg, red_m, previewImg); imshow(\"previewImg\", previewImg); waitKey(0); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:4:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::ones 1 Mat m = Mat::ones(2, 2, CV_8UC3); 相当于：Mat m = Mat(2, 2, CV_8UC3, 1); // OpenCV replaces 1 with Scalar(1,0,0)相当于每个像素的第一个通道为1，其余两个通道为0； 1 2 3 4 5 6 7 cv::Mat F = cv::Mat::ones(3, 3, CV_64F); cout \u003c\u003c F \u003c\u003c endl; /* [1, 1, 1; 1, 1, 1; 1, 1, 1] */ ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:5:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::zeros Mat m = Mat::zeros(2, 2, CV_8UC3); //相当于创建一张黑色的图，每个像素的每个通道都为0,Scalar(0,0,0)； 1 2 3 4 5 6 7 cv::Mat Z = cv::Mat::zeros(3, 3, CV_64F); cout \u003c\u003c Z \u003c\u003c endl; /* [0, 0, 0; 0, 0, 0; 0, 0, 0] */ ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:6:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"cv::Mat::eye 1 2 3 4 5 6 7 cv::Mat Y = cv::Mat::eye(3, 3, CV_64F); cout \u003c\u003c Y \u003c\u003c endl; /* [1, 0, 0; 0, 1, 0; 0, 0, 1] */ Mat类中数据部分组成 矩阵头：包括矩阵尺寸、存储方法、存储地址等。 指针：该指针指向存储所有像素值的矩阵。 因为图片的数据量比较大，所以OpenCV中的Mat定义都是只申请了矩阵头和指针，尽量避免对指针指向的内容进行拷贝操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 void Mat_demo1() { Mat A, C; // Identify header only cout \u003c\u003c \"sizeof(A): \" \u003c\u003c sizeof(A) \u003c\u003c \"; sizeof(C): \" \u003c\u003c sizeof(C) \u003c\u003c endl; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; A = Mat::ones(Size(3, 3), CV_8UC1); C = A; cout \u003c\u003c \"sizeof(A): \" \u003c\u003c sizeof(A) \u003c\u003c \"; sizeof(C): \" \u003c\u003c sizeof(C) \u003c\u003c endl; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; Mat B(A); cout \u003c\u003c \"B:\\n\" \u003c\u003c B \u003c\u003c endl; B.at\u003cuchar\u003e(1, 1) = 255; cout \u003c\u003c \"C:\\n\" \u003c\u003c C \u003c\u003c endl; Mat D = A.clone(); cout \u003c\u003c \"D:\\n\" \u003c\u003c D \u003c\u003c endl; D.at\u003cuchar\u003e(0, 0) = 123; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; cout \u003c\u003c \"D:\\n\" \u003c\u003c D \u003c\u003c endl; Mat E; A.copyTo(E); cout \u003c\u003c \"E:\\n\" \u003c\u003c E \u003c\u003c endl; E.at\u003cuchar\u003e(2, 2) = 100; cout \u003c\u003c \"A:\\n\" \u003c\u003c A \u003c\u003c endl; cout \u003c\u003c \"E:\\n\" \u003c\u003c E \u003c\u003c endl; } Mat类型的变量定义以及赋值分为： 公用一个数据块 1 2 = 构造函数 不公用一个数据块 1 2 clone copyto 参考 OpenCV CV_RGB2GRAY与CV_BGR2GRAY的区别 学习OpenCV2——Mat之通道的理解 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/mat/opencv_mat/:7:0","tags":["opencv"],"title":"opencv Mat 操作","uri":"/posts/open_source_software/opencv/learn/mat/opencv_mat/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 convertTo / cvtColor convertTo cvtColor setTo 直方图均衡化 均值滤波blur 边缘检测Sobel 笛卡尔坐标转极坐标cartToPolar OpenCV中的阈值(threshold)函数 资料 gitbook learn opencv OpenCV:知乎 convertTo / cvtColor 不是所有格式的Mat型数据都能被使用保存为图片，目前OpenCV主要只支持单通道和3通道的图像，并且此时要求其深度为8bit和16bit无符号(即CV_16U)，所以其他一些数据类型是不支持的，比如说float型等。 如果Mat类型数据的深度和通道数不满足上面的要求，则需要使用convertTo()函数和cvtColor()函数来进行转换。 convertTo()函数负责转换数据类型不同的Mat，即可以将类似float型的Mat转换到imwrite()函数能够接受的类型。 cvtColor()函数是负责转换不同通道的Mat，因为该函数的第4个参数就可以设置目的Mat数据的通道数（只是我们一般没有用到它，一般情况下这个函数是用来进行色彩空间转换的）。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:0:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"convertTo 图像的对比度和亮度的调整 : dst = alpha * src + beta （alpha控制对比度，beta控制亮度） 1 2 3 4 5 6 7 8 9 //! converts matrix to another datatype with optional scalng. See cvConvertScale. void convertTo( OutputArray m, int rtype, double alpha=1, double beta=0 ) const; cv::Mat samples; cv::Mat tdata; samples.convertTo(tdata, CV_32FC1); convertTo(depth_vis, CV_8UC1, 1.0 / 255, 0); 缩放并转换到另外一种数据类型： dst：目的矩阵 type：需要的输出矩阵类型，或者更明确的，是输出矩阵的深度，如果是负值（常用-1）则输出矩阵和输入矩阵类型相同 scale和shift：缩放参数，也可以写为alpha和beta 这个命令也等价于下面的转换公式： m(x,y) = saturate_cast(α(*this)(x,y)+β) 如果scale=1，shift=0，则不进行比例缩放。 如果输入数组与输出数组的类型相同，则函数可以被用于缩放和平移矩阵或图像； ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:1:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"cvtColor 1 2 3 4 5 6 7 8 9 10 11 12 cv.cvtColor(src, code[, dst[, dstCn]] void cv::cvtColor ( InputArray src, OutputArray dst, int code, int dstCn = 0 ) //RGB图，转换成灰度图 cv.cvtColor(img, cv.COLOR_BGR2GRAY) //灰度图，转换成RGB图 cv::cvtColor(depth_vis, frame-\u003evis_data, CV_GRAY2BGR); cvtColor RGB转成其他格式时，需要注意RGB图像的三个通道的顺序，是RGB还是BGR.大部分情况下opencv为RGB,但实际上是BGR,这一点需要注意。 需要注意各个值的范围： CV_8U图像 其通道值范围为0到255 CV_16U时其值通道值范围为0到65535 CV_32F时，其通道值范围为0到1 在线性转换时，其范围没有较大关系，但是如果是非线性转换，RGB图像需要做正确的归一化，以扩展到响应的范围。例如TGB-\u003eLUV转换，如果32位的浮点图像之间是由8位的图像转换而来，那么将0到255的范围转换成0,1，那么转换之前首先需要需要所需其图像。 1 2 img *= 1./255; cvtColor(img, img, COLOR_BGR2Luv); setTo 1 2 3 4 5 6 7 /** @brief Sets all or some of the array elements to the specified value. This is an advanced variant of the Mat::operator=(const Scalar\u0026 s) operator. @param value Assigned scalar converted to the actual array type. @param mask Operation mask of the same size as \\*this. Its non-zero elements indicate which matrix elements need to be copied. The mask has to be of type CV_8U and can have 1 or multiple channels */ Mat\u0026 setTo(InputArray value, InputArray mask=noArray()); 说明： 1、功能：把矩阵mask中元素不为0的点全部变为value值； 2、当默认不添加mask的时候，表明mask是一个与原图尺寸大小一致的且元素值全为非0的矩阵，因此不加mask的时候，会将原矩阵的像素值全部赋值为value； 1 2 3 4 Mat src(3, 3, CV_8UC1); Mat mask(3, 3, CV_8UC1, Scalar(0)); src.setTo(100, mask); cout \u003c\u003c src \u003c\u003c endl; [ 0, 0, 0; 0, 0, 0; 0, 0, 0] 1 2 3 4 Mat src(3, 3, CV_8UC1); Mat mask(3, 3, CV_8UC1, Scalar(5)); src.setTo(100, mask); cout \u003c\u003c src \u003c\u003c endl; [100, 100, 100; 100, 100, 100; 100, 100, 100] 直方图均衡化 均值滤波blur 均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点，去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。 opencv提供了blur函数实现均值滤波操作，其原型如下： 1 void blur(InputArray src, OutputArray dst, Size ksize, Point anchor=Point(-1,-1), int borderType=BORDER_DEFAULT ) 参数解释： . InputArray src: 输入图像，可以是Mat类型，图像深度是CV_8U、CV_16U、CV_16S、CV_32F以及CV_64F其中的某一个。 . OutputArray dst: 输出图像，深度和类型与输入图像一致 . Size ksize: 滤波模板kernel的尺寸，一般使用Size(w, h)来指定，如Size(3,3) . Point anchor=Point(-1, -1): 字面意思是锚点，也就是处理的像素位于kernel的什么位置，默认值为(-1, -1)即位于kernel中心点，如果没有特殊需要则不需要更改 . int borderType=BORDER_DEFAULT: 用于推断图像外部像素的某种边界模式，有默认值BORDER_DEFAULT 边缘检测Sobel 检测边缘:以灰度图像为例，它的理论基础是这样的:如果出现一个边缘，那么图像的灰度就会有一定的变化。为了方便假设由黑渐变为白代表一个边界，那么对其灰度分析，在边缘的灰度函数就是一个一次函数y=kx，对其求一阶导数就是其斜率k，就是说边缘的一阶导数是一个常数，而由于非边缘的一阶导数为零，这样通过求一阶导数就能初步判断图像的边缘了。通常是X方向和Y方向的导数，也就是梯度。计算机就是通过这种方式来获得图像的边缘。 1 void cvSobel( const CvArr* src, CvArr* dst, int xorder, int yorder, intaperture_size=3 ); src：输入图像； dst：输出图像； xorder：x方向上的差分阶数； yorder：y方向上的差分阶数； aperture_size扩展Sobel核的大小（既窗口阶数），必须是1（注意这是一个3×1或1×3向量而不是一个方阵）,3, 5 或7。 笛卡尔坐标转极坐标cartToPolar 直角坐标系转为极坐标系。 1 2 3 4 5 6 7 void cv::cartToPolar( cv::InputArray x, cv::InputArray y, cv::OutputArray magnitude, cv::OutputArray angle, bool angleInDegrees = false ); OpenCV中的阈值(threshold)函数 OpenCV中提供了阈值化函数threshold，该函数原型如下： 1 2 3 4 5 double threshold(InputArray src, OutputArray dst, double thresh, double maxval, int type); 参数说明： src ： 表示输入图像 dst : 表示输出图像（尺寸和类型和输入图像一样） thresh : 表示阈值 maxval : 表示预设最大值 type : 表示阈值化处理的类型设置（type类型有一下几种） THRESH_BINARY表示大于thresh的取maxval,否则取0; THRESH_BINARY_INV表示大于thresh的取0,否则取maxvalue; THRESH_TRUNC表示大于thresh取threshold,否则不改变灰度值; THRESH_TOZERO表示大于thresh的不改变灰度值,否则取0; THRESH_TOZERO_INV表示大于thresh取0,窦泽不改变灰度值; THRESH_OTSU表示使用otsu自动计算阈值; THRESH_TRIANGLE表示使用Triangle自动计算阈值; 基本的阈值操作 OpenCV基础——threshold函数的使用 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/:2:0","tags":["opencv"],"title":"opencv 常用函数","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","tags":["opencv"],"title":"opencv 常用操作","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["开源软件"],"content":"unsigned char* 转换为 Mat类型 1 cv::Mat mmat = cv::Mat(stFrameInfo.nHeight, stFrameInfo.nWidth, CV_8UC1, stImageInfo.pBufAddr, 0); BYTE* 转换为 Mat类型 1 2 3 cv::Mat sMat = Mat(sFrameHead.iHeight, sFrameHead.iWidth, CV_8UC1);; int nLen = sMat.rows * sMat.cols * sMat.channels(); memcpy(sMat.data, m_pFrameBuffer, nLen); Mat转unsigned char* 1 unsigned char pdata= srcMat.data; // Mat =\u003e unsigned char box 渲染 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void BoxVisualization(cv::Mat frame, int tl_x, int tl_y, int br_x, int br_y, int label, float score) { // 渲染box int fontface = cv::FONT_HERSHEY_SIMPLEX; int thickness = 1; float fontScale = 0.5; int baseline = 0; cv::Scalar color(140, 199, 0); cv::Rect box((int)tl_x, (int)tl_y, (int)(br_x - tl_x), (int)(br_y - tl_y)); cv::rectangle(frame, box, color, 2, 8, 0); cv::String label_str = cv::format(\"l %d, s: %.2f\", label, score); cv::Size fontSize = cv::getTextSize(label_str, fontface, fontScale, thickness, \u0026baseline); cv::rectangle(frame, cv::Size(box.tl().x, box.tl().y - fontSize.height - baseline), cv::Size(box.tl().x + fontSize.width, box.tl().y), cv::Scalar(34, 43, 59), -1, 8); cv::putText(frame, label_str, cv::Point(box.tl().x, box.tl().y - baseline), fontface, fontScale, cv::Scalar(255, 0, 255), thickness, 8); } 画圆 1 2 3 4 5 6 7 void Visualization(cv::Mat frame, int tl_x, int tl_y, int br_x, int br_y) { // 渲染box cv::Point circle_point((br_x + tl_x) / 2, (br_y + tl_y) / 2); int len = std::min((br_y - tl_y) / 2, (br_x - tl_x) / 2); cv::circle(frame, circle_point, len, cv::Scalar(255, 0, 0), 4); } 常用颜色定义 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/:0:0","tags":["opencv"],"title":"opencv 常用操作","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 常用到的算子 1. cv::abs() 2. cv::add() 3. cv::addWeighted() 4. cv::bitwise_and() 5. cv::bitwise_not() 6. cv::bitwise_or() 7. cv::bitwise_xor() 8. cv::calcCovarMatrix() 9. cv::cartToPolar() 10. cv::checkRange() 11. cv::compare() 12. cv::completeSymm() 13. cv::convertScaleAbs() 14. cv::countNonZero() 15. cv::cvarrToMat() 16. cv::dct() 17. cv::dft() 18. cv::cvtColor() 19. cv::determinant() 20. cv::divide() 21. cv::eigen() 22. cv::exp() 23. cv::flip() 24. cv::gemm() 25. cv::idct() 26. cv::idft() 27. cv::inRange() 28. cv::invert() 29. cv::log() 30. cv::magnitude() 31. cv::Mahalanobis() 32. cv::max() 33. cv::min() 34. cv::mean() 35. cv::meanStdDev() 36. cv::merge() 37. cv::split() 38. cv::minMaxIdx() 39. cv::minMaxLoc() 40. cv::mixChannels() 41. cv::multiply() 42. cv::mulTransposed() 43. cv::norm() 44. cv::normalize() 45. cv::perspectiveTransform() 46. cv::phase() 47. cv::polarToCart() 48. cv::pow() 49. cv::randu() 50. cv::randn() 51. cv::repeat() 52. cv::scaleAdd() 53. cv::setIdentity() 54. cv::solve() 55. cv::solveCubic() 56. cv::solvePoly() 57. cv::sort() 58. cv::sortIdx() 59. cv::sqrt() 60 cv::subtract() 61. cv::sum() 62. cv::trace() 63. cv::transform() 64. cv::transpose() 常用到的算子 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:0:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"1. cv::abs() 计算矩阵的绝对值 1 2 cv::MatExpr cv::abs( cv::InputArray src ); cv::MatExpr cv::abs( const cv::MatExpr\u0026 src ); // Matrix expression ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:1:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"2. cv::add() 计算矩阵src1和src2的加和，并把结果存放在dst中。 1 2 3 4 5 6 7 void cv::add( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:2:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"3. cv::addWeighted() 该函数和上一个add()函数比较类似，是根据下面公式将结果写入dst中。可用于图像混合。 1 2 3 4 5 6 7 8 9 void cv::addWeighted( cv::InputArray src1, // First input array double alpha, // Weight for first input array cv::InputArray src2, // Second input array double beta, // Weight for second input array double gamma, // Offset added to weighted sum cv::OutputArray dst, // Result array int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:3:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"4. cv::bitwise_and() 逐元素按位与操作。 1 2 3 4 5 6 void cv::bitwise_and( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:4:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"5. cv::bitwise_not() 逐元素按位取反操作。 1 2 3 4 5 void cv::bitwise_not( cv::InputArray src, // Input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:5:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"6. cv::bitwise_or() 逐元素按位取或操作。 1 2 3 4 5 6 void cv::bitwise_or( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:6:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"7. cv::bitwise_xor() 逐元素按位异或操作。 1 2 3 4 5 6 void cv::bitwise_xor( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:7:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"8. cv::calcCovarMatrix() 给定一些向量，假设向量表示的点是近似的高斯分布，，那么该函数将计算这些点的均值和协方差矩阵。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::calcCovarMatrix( const cv::Mat* samples, // C-array of n-by-1 or 1-by-n matrices int nsamples, // num matrices pointed to by 'samples' cv::Mat\u0026 covar, // ref to return array for covariance cv::Mat\u0026 mean, // ref to return array for mean int flags, // special variations, see Table bellow. int ctype = cv::F64 // output matrix type for covar ); void cv::calcCovarMatrix( cv::InputArray samples, // n-by-m matrix, but see 'flags' below cv::Mat\u0026 covar, // ref to return array for covariance cv::Mat\u0026 mean, // ref to return array for mean int flags, // special variations. int ctype = cv::F64 // output matrix type for covar ); 该函数有两种调用方式，如上codes。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:8:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"9. cv::cartToPolar() 直角坐标系转为极坐标系。 1 2 3 4 5 6 7 void cv::cartToPolar( cv::InputArray x, cv::InputArray y, cv::OutputArray magnitude, cv::OutputArray angle, bool angleInDegrees = false ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:9:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"10. cv::checkRange() 检查src中每个元素是否在给定的范围之内。范围有minVal和maxVal设置。除非将quiet设置为true，否则抛出异常。如果都在范围内，则返回true，否则将返回false，并将第一个异常值的位置存放在pos中。 1 2 3 4 5 6 7 bool cv::checkRange( cv::InputArray src, bool quiet = true, cv::Point* pos = 0, // if non-Null, location of first outlier double minVal = -DBL_MAX, // Lower check bound (inclusive) double maxVal = DBL_MAX // Upper check bound (exclusive) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:10:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"11. cv::compare() 逐元素比较src1和src2，并将比较结果放在dst中,匹配标记为255，否则设置为0。 1 2 3 4 5 6 bool cv::compare( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array int cmpop // Comparison operator. ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:11:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"12. cv::completeSymm() 将矩阵mtx通过复制使其对称，默认情况下将上三角的所有元素都被复制到下三角对应转置的位置上，对角元素不变。如果lowerToUpper = true，那么则将下三角复制到上三角位置。 1 2 3 4 bool cv::completeSymm( cv::InputArray mtx, bool lowerToUpper = false ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:12:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"13. cv::convertScaleAbs() 该函数按照如下公式进行转换原图像。实现对原图像像素值的缩放和平移。 1 2 3 4 5 6 void cv::convertScaleAbs( cv::InputArray src, // Input array cv::OutputArray dst, // Result array double alpha = 1.0, // Multiplicative scale factor double beta = 0.0 // Additive offset factor ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:13:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"14. cv::countNonZero() 返回矩阵mtx中非零元素的个数。 1 2 3 int cv::countNonZero( // Return number of nonzero elements in mtx cv::InputArray mtx, // Input array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:14:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"15. cv::cvarrToMat() 将旧版本的图像格式转为Mat类图像。 1 2 3 4 5 6 cv::Mat cv::cvarrToMat( const CvArr* src, // Input array: CvMat, IplImage, or CvMatND bool copyData = false, // if false just make new header, else copy data bool allowND = true, // if true and possible, convert CvMatND to Mat int coiMode = 0 // if 0: error if COI set, if 1: ignore COI ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:15:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"16. cv::dct() 根据flags执行离散余弦变换或者离散余弦逆变换。 1 2 3 4 5 void cv::dct( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags, // for inverse transform or row-by-row ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:16:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"17. cv::dft() 实现离散傅里叶变换及其逆变换。 1 2 3 4 5 6 void cv::dft( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags = 0, // for inverse transform or row-by-row int nonzeroRows = 0 // only this many entries are nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:17:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"18. cv::cvtColor() 保留相同数据类型的同时将图像从一个颜色空间转换到另一个颜色空间。 1 2 3 4 5 6 void cv::cvtColor( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int code, // color mapping code, see Table 5-4. int dstCn = 0 // channels in output (0='automatic') ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:18:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"19. cv::determinant() 计算一个方阵的行列式。 1 2 3 double cv::determinant( cv::InputArray mat ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:19:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"20. cv::divide() 将src1或scale中的元素除以src2中相应的元素，然后将结果放在dst中。 1 2 3 4 5 6 7 8 9 10 11 12 13 void cv::divide( cv::InputArray src1, // First input array (numerators) cv::InputArray src2, // Second input array (denominators) cv::OutputArray dst, // Results array (scale*src1/src2) double scale = 1.0, // Multiplicative scale factor int dtype = -1 // dst data type, -1 to get from src2 ); void cv::divide( double scale, // Numerator for all divisions cv::InputArray src2, // Input array (denominators) cv::OutputArray dst, // Results array (scale/src2) int dtype = -1 // dst data type, -1 to get from src2 ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:20:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"21. cv::eigen() 计算矩阵的特征向量和特征值。 1 2 3 4 5 6 7 8 9 10 11 12 13 bool cv::eigen( cv::InputArray src, cv::OutputArray eigenvalues, int lowindex = -1, int highindex = -1 ); bool cv::eigen( cv::InputArray src, cv::OutputArray eigenvalues, cv::OutputArray eigenvectors, int lowindex = -1, int highindex = -1 ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:21:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"22. cv::exp() 计算src中所有元素的指数，并将结果存放在dst中。 1 2 3 4 void cv::exp( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:22:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"23. cv::flip() 绕x轴或者y轴旋转。 1 2 3 4 5 void cv::flip( cv::InputArray src, // Input array cv::OutputArray dst, // Result array, size and type of 'src' int flipCode = 0 // \u003e0: y-flip, 0: x-flip, \u003c0: both ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:23:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"24. cv::gemm() 广义矩阵乘法（GEMM）。 1 2 3 4 5 6 7 8 9 void cv::gemm( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array double alpha, // Weight for 'src1' * 'src2' product cv::InputArray src3, // Third (offset) input array double beta, // Weight for 'src3' array cv::OutputArray dst, // Results array int flags = 0 // Use to transpose source arrays ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:24:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"25. cv::idct() 离散余弦逆变换，相当于调用带参数的dct()。 1 2 3 4 5 void cv::idct( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags, // for row-by-row ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:25:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"26. cv::idft() 离散傅里叶逆变换，相当于调用带参数的dft()。 1 2 3 4 5 6 void cv::idft( cv::InputArray src, // Input array cv::OutputArray dst, // Result array int flags = 0, // for row-by-row, etc. int nonzeroRows = 0 // only this many entries are nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:26:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"27. cv::inRange() 判断src中的元素是否在upperb和lowerb之间，满足置为255，否则0。 1 2 3 4 5 6 void cv::inRange( cv::InputArray src, // Input array cv::InputArray upperb, // Array of upper bounds (inclusive) cv::InputArray lowerb, // Array of lower bounds (inclusive) cv::OutputArray dst // Result array, cv::U8C1 type ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:27:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"28. cv::invert() 求矩阵的逆。 1 2 3 4 5 double cv::invert( // Return 0 if 'src' is singular cv::InputArray src, // Input Array, m-by-n cv::OutputArray dst // Result array, n-by-m int method = cv::DECOMP_LU // Method for (pseudo) inverse ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:28:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"29. cv::log() 求原图像的自然对数。 1 2 3 4 void cv::log( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:29:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"30. cv::magnitude() 计算直角坐标系转换成极坐标系的幅值。 1 2 3 4 5 void cv::magnitude( cv::InputArray x, cv::InputArray y, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:30:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"31. cv::Mahalanobis() 计算两个向量的马氏距离。 1 2 3 4 5 cv::Size cv::mahalanobis( cv::InputArray vec1, cv::InputArray vec2, cv::OutputArray icovar ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:31:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"32. cv::max() 计算矩阵src1和src2中每个对应的像素对的最大值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cv::MatExpr cv::max( const cv::Mat\u0026 src1, // First input array (first position) const cv::Mat\u0026 src2 // Second input array ); MatExpr cv::max( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array (first position) double value // Scalar in second position ); MatExpr cv::max( // A matrix expression, not a matrix double value, // Scalar in first position const cv::Mat\u0026 src1 // Input array (second position) ); void cv::max( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst // Result array ); void cv::max( const Mat\u0026 src1, // First input array const Mat\u0026 src2, // Second input array Mat\u0026 dst // Result array ); void cv::max( const Mat\u0026 src1, // Input array double value, // Scalar input Mat\u0026 dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:32:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"33. cv::min() 计算矩阵src1和src2中每个对应的像素对的最小值。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 cv::MatExpr cv::min( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array const cv::Mat\u0026 src2 // Second input array ); MatExpr cv::min( // A matrix expression, not a matrix const cv::Mat\u0026 src1, // First input array (first position) double value // Scalar in second position ); MatExpr cv::min( // A matrix expression, not a matrix double value, // Scalar in first position const cv::Mat\u0026 src1 // Input array (second position) ); void cv::min( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst // Result array ); void cv::min( const Mat\u0026 src1, // First input array const Mat\u0026 src2, // Second input array Mat\u0026 dst // Result array ); void cv::min( const Mat\u0026 src1, // Input array double value, // Scalar input Mat\u0026 dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:33:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"34. cv::mean() 计算src矩阵的均值。 1 2 3 4 cv::Scalar cv::mean( cv::InputArray src, cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:34:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"35. cv::meanStdDev() 计算矩阵的均值和标准差。 1 2 3 4 5 6 void cv::meanStdDev( cv::InputArray src, cv::OutputArray mean, cv::OutputArray stddev, cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:35:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"36. cv::merge() 将多个二维矩阵合并成一个多维矩阵。 1 2 3 4 5 6 7 8 9 void cv::merge( const cv::Mat* mv, // C-style array of arrays size_t count, // Number of arrays pointed to by 'mv' cv::OutputArray dst // Contains all channels in 'mv' ); void merge( const vector\u003ccv::Mat\u003e\u0026 mv, // STL-style array of arrays cv::OutputArray dst // Contains all channels in 'mv' ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:36:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"37. cv::split() 将多通道矩阵拆分成多个单通道矩阵。 1 2 3 4 5 6 7 8 void cv::split( const cv::Mat\u0026 mtx, cv::Mat* mv ); void cv::split( const cv::Mat\u0026 mtx, vector\u003cMat\u003e\u0026 mv // STL-style vector of n 1-channel cv::Mat's ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:37:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"38. cv::minMaxIdx() 计算单通道矩阵的最大最小值，并返回其位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::minMaxIdx( cv::InputArray src, // Input array, single channel only double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) int* minIdx, // loc of min goes here (if not NULL) int* maxIdx, // loc of max goes here (if not NULL) cv::InputArray mask = cv::noArray() // search only nonzero values ); void cv::minMaxIdx( const cv::SparseMat\u0026 src, // Input sparse array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) int* minIdx, // C-style array, indices of min locs int* maxIdx, // C-style array, indices of max locs ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:38:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"39. cv::minMaxLoc() 计算矩阵的最大最小值，并返回其位置。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::minMaxLoc( cv::InputArray src, // Input array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) cv::Point* minLoc, // loc of min goes here (if not NULL) cv::Point* maxLoc, // loc of max goes here (if not NULL) cv::InputArray mask = cv::noArray() // search only nonzero values ); void cv::minMaxLoc( const cv::SparseMat\u0026 src, // Input sparse array double* minVal, // min value goes here (in not NULL) double* maxVal, // min value goes here (in not NULL) cv::Point* minLoc, // C-style array, indices of min locs cv::Point* maxLoc, // C-style array, indices of max locs ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:39:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"40. cv::mixChannels() 对于输入图像的通道按照给定的顺序重新组合。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void cv::mixChannels( const cv::Mat* srcv, // C-style array of matrices int nsrc, // Number of elements in 'srcv' cv::Mat* dstv, // C-style array of target matrices int ndst, // Number of elements in 'dstv' const int* fromTo, // C-style array of pairs, ...from,to... size_t n_pairs // Number of pairs in 'fromTo' ); void cv::mixChannels( const vector\u003ccv::Mat\u003e\u0026 srcv, // STL-style vector of matrices vector\u003ccv::Mat\u003e\u0026 dstv, // STL-style vector of target matrices const int* fromTo, // C-style array of pairs, ...from,to... size_t n_pairs // Number of pairs in 'fromTo' ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:40:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"41. cv::multiply() 矩阵对应元素相乘。 1 2 3 4 5 6 7 void cv::multiply( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array double scale = 1.0, // overall scale factor int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:41:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"42. cv::mulTransposed() 矩阵和其转置的乘积。 1 2 3 4 5 6 7 8 void cv::mulTransposed( cv::InputArray src1, // Input matrix cv::OutputArray dst, // Result array bool aTa, // If true, transpose then multiply cv::InputArray delta = cv::noArray(), // subtract from 'src1' before multiply double scale = 1.0, // overall scale factor int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:42:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"43. cv::norm() 计算一个矩阵的范数，或者如果提供两个矩阵，该函数也可以计算两个矩阵间的各种距离范数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 double cv::norm( // Return norm in double precision cv::InputArray src1, // Input matrix int normType = cv::NORM_L2, // Type of norm to compute cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); double cv::norm( // Return computed norm of difference cv::InputArray src1, // Input matrix cv::InputArray src2, // Second input matrix int normType = cv::NORM_L2, // Type of norm to compute cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); double cv::norm( const cv::SparseMat\u0026 src, // Input sparse matrix int normType = cv::NORM_L2, // Type of norm to compute ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:43:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"44. cv::normalize() 将原图像映射到一个特定范围内并放到dst中。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void cv::normalize( cv::InputArray src1, // Input matrix cv::OutputArray dst, // Result matrix double alpha = 1, // first parameter (see Table 5-8) double beta = 0, // second parameter (see Table 5-8) int normType = cv::NORM_L2, // Type of norm to compute int dtype = -1 // Output type for result array cv::InputArray mask = cv::noArray() // do for nonzero values (if present) ); void cv::normalize( const cv::SparseMat\u0026 src, // Input sparse matrix cv::SparseMat\u0026 dst, // Result sparse matrix double alpha = 1, // first parameter (see Table 5-8) int normType = cv::NORM_L2, // Type of norm to compute ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:44:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"45. cv::perspectiveTransform() 执行一系列点的平面投影变换。 1 2 3 4 5 void cv::perspectiveTransform( cv::InputArray src, // Input array, 2 or 3 channels cv::OutputArray dst, // Result array, size, type, as src1 cv::InputArray mtx // 3-by-3 or 4-by-4 transoform matrix ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:45:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"46. cv::phase() 对二维矢量场计算笛卡尔-极坐标转换的方位角（角度）部分。 1 2 3 4 5 6 void cv::phase( cv::InputArray x, // Input array of x-components cv::InputArray y, // Input array of y-components cv::OutputArray dst, // Output array of angles (radians) bool angleInDegrees = false // degrees (if true), radians (if false) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:46:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"47. cv::polarToCart() 从向量场的极坐标中计算笛卡尔坐标(x,y)。 1 2 3 4 5 6 7 void cv::polarToCart( cv::InputArray magnitude, // Input array of magnitudes cv::InputArray angle, // Input array of angles cv::OutputArray x, // Output array of x-components cv::OutputArray y, // Output array of y-components bool angleInDegrees = false // degrees (if true) radians (if false) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:47:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"48. cv::pow() 对矩阵逐元素取p次幂。 1 2 3 4 5 void cv::pow( cv::InputArray src, // Input array double p, // power for exponentiation cv::OutputArray dst // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:48:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"49. cv::randu() 返回适当类型的随机值。 1 2 3 4 5 6 template\u003ctypename _Tp\u003e _Tp randu(); // Return random number of specific type void cv::randu( cv::InputOutArray mtx, // All values will be randomized cv::InputArray low, // minimum, 1-by-1 (Nc=1,4), or 1-by-4 (Nc=1) cv::InputArray high // maximum, 1-by-1 (Nc=1,4), or 1-by-4 (Nc=1) ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:49:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"50. cv::randn() 使用正态分布的值填充矩阵mtx。 1 2 3 4 5 void cv::randn( cv::InputOutArray mtx, // All values will be randomized cv::InputArray mean, // mean values, array is in channel space cv::InputArray stddev // standard deviations, channel space ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:50:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"51. cv::repeat() 将src的内容复制到dst中。 1 2 3 4 5 6 7 8 9 10 11 void cv::repeat( cv::InputArray src, // Input 2-dimensional array int nx, // Copies in x-direction int ny, // Copies in y-direction cv::OutputArray dst // Result array ); cv::Mat cv::repeat( // Return result array cv::InputArray src, // Input 2-dimensional array int nx, // Copies in x-direction int ny // Copies in y-direction ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:51:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"52. cv::scaleAdd() 1 2 3 4 5 6 void cv::scaleAdd( cv::InputArray src1, // First input array double scale, // Scale factor applied to first array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:52:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"53. cv::setIdentity() 除了将行数和列数相等的元素设置为1（或者给定数值）外，其他所有矩阵元素设置为0。 1 2 3 4 void cv::setIdentity( cv::InputOutputArray dst, // Array to reset values const cv::Scalar\u0026 value = cv::Scalar(1.0) // Apply to diagonal elements ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:53:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"54. cv::solve() 基于invert()的函数，solve()为求解线性系统提供一条捷径，具体公式如下： 1 2 3 4 5 6 int cv::solve( cv::InputArray lhs, // Lefthand side of system, n-by-n cv::InputArray rhs, // Righthand side of system, n-by-1 cv::OutputArray dst, // Results array, will be n-by-1 int method = cv::DECOMP_LU // Method for solver ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:54:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"55. cv::solveCubic() 计算三次多项式的实根。 1 2 3 4 int cv::solveCubic( cv::InputArray coeffs, cv::OutputArray roots ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:55:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"56. cv::solvePoly() 计算任意阶数多项式的根。 1 2 3 4 5 int cv::solvePoly ( cv::InputArray coeffs, cv::OutputArray roots // n complex roots (2-channels) int maxIters = 300 // maximum iterations for solver ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:56:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"57. cv::sort() opencv的排序函数，分别对每行或列进行排序。 1 2 3 4 5 void cv::sort( cv::InputArray src, cv::OutputArray dst, int flags ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:57:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"58. cv::sortIdx() opencv的排序函数，分别对每行或列进行排序，将排序索引结果存在dst中。 1 2 3 4 5 void cv::sortIdx( cv::InputArray src, cv::OutputArray dst, int flags ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:58:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"59. cv::sqrt() 计算逐元素的平方根。 1 2 3 4 void cv::sqrt( cv::InputArray src, cv::OutputArray dst ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:59:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"60 cv::subtract() 从src1中减去src2的相应元素。 1 2 3 4 5 6 7 void cv::subtract( cv::InputArray src1, // First input array cv::InputArray src2, // Second input array cv::OutputArray dst, // Result array cv::InputArray mask = cv::noArray(), // Optional, do only where nonzero int dtype = -1 // Output type for result array ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:60:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"61. cv::sum() 计算矩阵各个通道的所有像素的总和。 1 2 3 cv::Scalar cv::sum( cv::InputArray arr ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:61:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"62. cv::trace() 计算矩阵的迹。 1 2 3 cv::Scalar cv::trace( cv::InputArray mat ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:62:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"63. cv::transform() 计算任意线性图像变换。 1 2 3 4 5 void cv::transform( cv::InputArray src, cv::OutputArray dst, cv::InputArray mtx ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:63:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"64. cv::transpose() 将src中每一个元素复制到dst中行号与列数相调换的位置上。 1 2 3 4 void cv::transpose( cv::InputArray src, // Input array, 2-dimensional, n-by-m cv::OutputArray dst, // Result array, 2-dimensional, m-by-n ); ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/:64:0","tags":["opencv"],"title":"opencv 常用算子","uri":"/posts/open_source_software/opencv/learn/opencv%E5%B8%B8%E7%94%A8%E7%AE%97%E5%AD%90/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:0","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"1.HighGUI模块做为高层GUI图形用户界面模块，包含媒体的输入输出、视频捕捉、图像和视频的编码解码、图像交互界面的接口等内容。 imread：用于读取文件中的图片到opencv中 imshow : 在指定的窗口中显示一幅图像 namedWindow：用于创建一个窗口 imwrite：输出图像到文件 createTrackbar：用于创建一个可以调整数值的轨迹条 getTrackbarPos：用于获取轨迹条的当前位置 SetMouseCallback：为指定的窗口设置鼠标回调函数 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:1","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"2.opencv中的core组件是核心功能模块主要包含以下的内容：数据基本结构、动态数据结构、绘图函数、数组操作相关函数、辅助功能和系统函数和宏、与OpenGL的互操作。 Mat::Mat() : Mat类的构造函数 Mat::Create() : Mat类的成员函数，可用于Mat类的初始化操作 Point : 用于表示点的数据结构 Scalar : 用于表示颜色的数据结构 Size : 用于表示尺寸的数据结构 Rect : 用于表示矩阵的数据结构 CvtColor() : 用于颜色的空间转换 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:2","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"3.操作图像中的像素、设置感兴趣区域（ROI）、进行图像混合、分离颜色通道、进行多通道图像混合、调整图像的对比对和亮度值、对图像进行离散傅里叶变换、输入输出XML 和YAML文件 addWeighted : 计算两个数组（图像阵列）的加权和 split : 将一个多通道数组分离成单个通道数组 merge : 将多个数组组合合并成一个多通道的数组 dft : 对一维或者二维浮点数数组进行正向或反向离散傅里叶变换 getOptimalDFTSize : 返回给定向尺寸的傅里叶最优化尺寸大小 copyMakeBorder : 扩充图像边界 magnitude : 计算二维矢量的幅值 log：计算每个数组元素绝对值的自然对数 normalize：进行矩阵归一化 FileStorage类：进行文件操作的类 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:3","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"4.imgproc组件是Image和Process这两个单词的缩写，即图像处理模块，这个模块有线性和非线性的图像滤波、图像的几何变换、其他（Miscellaneous）图像转换、直方图相关、结构分析和形状描述、运动分析和对象追踪、特征检测、目标检测等内容。 boxFilter : 使用方框滤波来模糊一张图片 blur : 对输入的图像进行均值滤波操作 GaussianBlur : 用高斯滤波器来模糊一张图片 medianBlur : 使用中值滤波器来模糊一张图片 bilateralFilter : 使用双边滤波器来模糊处理一张图片 dilate : 使用像素领域内的局部极大运算符来膨胀一张图片 erode : 使用像素领域内的局部极小运算符来腐蚀一张图片 morphologyEx : 利用基本的膨胀和腐蚀技术，来执行更加高级形态学变换，如开闭运算、形态学梯度、顶帽、黑帽等，也可以实现最基本的图像膨胀和腐蚀 floodFill : 用指定的颜色从种子点开始填充一个连接域，实现漫水填充算法 pyrUp : 向上采样并模糊一张图片，说白了就是放大一张图片 pyrDown : 向下采样并模糊一张图片，说白了就是缩小一张图片 Threshold : 对单通道数组应用固定阈值操作 adaptiveThreshold : 对矩阵采用自适应阈值操作 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:4","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"5.图像变换（image transfrom）即将一幅图像转变成图像数据的另一种表现形式。变换最常见的例子就是傅里叶变换（Fourier transfrom），即将图像转换成源图像数据的另一种表示形式。这类操作的结果仍然保存为OpenCV图像结构的形式，但是新图像的每个单独像素表示原始输出图像的频谱分量，而不是通常所考虑的空间分量。基于OpenCV的边缘检测、霍夫变换、重映射、仿射变换、直方图均衡化。 Canny : 利用canny算子来进行图像的边缘检测 Sobel : 使用拓展的Sobel算子，来计算一阶、二阶、三阶或混合图像差分 Laplacian : 计算出图像经过拉普拉斯变换后的结果 Scharr : 使用Scharr滤波器运算符计算X或Y方向的图像差分 HoughLinesP : 找出采用标准霍夫变换的二值图像线条 HoughCireles : 采用累计概率霍夫变换（PPHT）来找出二值图像中的直线 remap : 根据指定的映射形式，将源图像进行重映射几何变换 warpAffine : 依据公式对图像做仿射变换 getRotationMatrix2D : 计算二维旋转变换矩阵 equalizeHist : 实现图像的直方图均衡化 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:5","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"6.图像轮廓与图像分割修复，虽然Canny之类的边缘检测算法可以根据像素之间的差异，检测出轮廓边界的像素，但是并没有将轮廓作为一个整体。所以下一步便是把这些边缘像素组装成轮廓。查找并绘制轮廓、寻找物体的凸包、使用多边形逼近物体、认识图像的矩、利用OpenCV进行图像修补。 findContours : 在二值图像中寻找轮廓 drawContours : 在图像中绘制外部或内部轮廓 convexHull : 寻找图像点集中的凸包 BoundingRect : 计算并返回指定点集最外面（up -right）的矩形边界 minAreaRect : 寻找可旋转的最小面积的包围矩形 minEnclosingCircle : 利用一种迭代算法，对给定的2D点集，寻找面积最小的可包围他们的圆形 fitEllipse : 用椭圆拟合二维点集合 approxPolyDP：用指定精度逼近多边形曲线 moments : 计算多边形和光栅形状的最高达三阶的所有矩 contourArea : 计算整个轮廓或部分轮廓的面积 arcLength : 计算封闭轮廓的周长或曲线的长度 watershed : 实现分水岭算法 inpaint : 进行图像修补，从扫描的照片中清除灰尘和划痕，或者从静态图像或视频中去除不需要的物体。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:6","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"7.直方图和匹配，在进行物体图像和视频信息分析的过程中，我们常常会习惯于将眼中看到的物体用直方图（histogram）表示出来，得到比较直观的数据官感展示。直方图可以用来描述各种不同的参数和事物，如物体的彩色分布、物体边缘梯度模板、以及表示目标位置的当前假设的概率分布。 calcHist : 计算一个或多个阵列的直方图 minMaxLoc : 在数组中找到全局最小值和最大值 compareHist : 对两幅直方图进行比较 calcBackProject : 计算直方图反向投影 mixChannels : 由输入参数复制某通道到输出参数特定的通道中 matchTemplate : 匹配出和模板重叠的图像区域 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:7","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"8.feature2d组件，也就是Features 2D，是OpenCV的2D功能框架。自OpenCV以来的众多著名的特征检测算子（如SIFT、SURF、ORB算子等）所依赖的稳定版的特征检测与匹配相关的核心源代码已经从OpenCV3中移除了，转移到xfeature2d的第三方库当中了。特征检测器（Feature Detectors）通用接口、描述符提取器（Descriptor Extractors）通用接口、描述符匹配器（Descriptor Matchers）匹配器通用接口、关键点绘制函数和匹配功能绘制函数。 cornerHarris : 运行Harris角点检测算子来进行角点检测 goodFeaturesToTrack : 结合Shi-Tomasi 算子确定图像的强角点 cornerSubPix: 寻找亚像素角点位置 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:8","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"9.特征点的检测和匹配是计算机视觉中非常重要的技术之一。在物体检测、视觉跟踪、三维重构等领域都有很广泛的应用。 SURF类 、SurfFeatureDetector类 、SurfDescriptorExtractor类 ： 三者等价，同用与在OpenCV中进行SURF特征检测 drawKeypoints函数 ：绘制关键点 drawMatches函数 ：绘制出相匹配的两个图像的关键点 KeyPoint类：用于表示特征点的信息 BruteForceMatcher类：进行暴力匹配相关的操作 FlannBasedMatcher类：实现FLANN特征匹配 DescriptorMatcher::match函数：从每个描述符查询集中找到最佳匹配 findHomography函数：找到并返回源图像和目标图像之间的透视变换H perspectiveTransfrom函数：进行向量透视矩阵变换 ORB类、OrbFeatureDetector类、OrbDescriptorExtractor类：三者等价，同用于在OpenCV中进行ORB特征检测 参考： opencv核心函数名单 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/:0:9","tags":["opencv"],"title":"opencv 核心函数整理","uri":"/posts/open_source_software/opencv/learn/opencv%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++ 语法分析 template typename std::bind std::is_same\u003cR, void\u003e::value std::enable_if std::decay std::reverse和std::reverse_copy 可变参数模板消除冗余代码 C++ 语法分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:0:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"template 1 2 3 template\u003ctypename T\u003e struct type_xx{ typedef T type; }; 将T 类型置换为 type 使用：typename type_xx::type ，实际为类型R ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:1:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"typename “typename\"是一个C++程序设计语言中的关键字。当用于泛型编程时是另一术语\"class\"的同义词。这个关键字用于指出模板声明（或定义）中的非独立名称（dependent names）是类型名，而非变量名。 我们经常会这么用 typename，这是一项C++编程语言的泛型编程（或曰“模板编程”）的功能，typename关键字用于引入一个模板参数。 1 2 3 4 5 6 7 8 template \u003ctypename T\u003e const T\u0026 max(const T\u0026 x, const T\u0026 y) { if (y \u003c x) { return x; } return y; } 在模板定义语法中关键字 class 与 typename 的作用完全一样 1 2 3 4 5 6 7 8 template\u003cclass T\u003e const T\u0026 max(const T\u0026 x, const T\u0026 y) { if (y \u003c x) { return x; } return y; } 这里 class 关键字表明T是一个类型，后来为了避免 class 在这两个地方的使用可能给人带来混淆，所以引入了 typename 这个关键字，它的作用同 class 一样表明后面的符号为一个类型。 那class使用就够了，为什么又引入了新的关键词 typename ，关于这个问题，Stan Lippman 曾在其博客中表示，最早 Stroustrup 使用 class 来声明模板参数列表中的类型是为了避免增加不必要的关键字；后来委员会认为这样混用可能造成概念上的混淆才加上了 typename 关键字。 而使用 typename 的作用就是告诉 cpp 编译器，typename 后面的字符串为一个类型名称，而不是成员函数或者成员变量，这个时候如果前面没有 typename，编译器没有任何办法知道 T::LengthType 是一个类型还是一个成员名称(静态数据成员或者静态函数)，所以编译不能够通过。 解决的问题 1 2 3 4 template\u003ctypename T\u003e void fun(const T\u0026 proto){ T::const_iterator it(proto.begin()); } 发生编译错误是因为编译器不知道T::const_iterator是个类型。万一它是个变量呢？ T::const_iterator的解析有着逻辑上的矛盾： 直到确定了T是什么东西，编译器才会知道T::const_iterator是不是一个类型； 然而当模板被解析时，T还是不确定的。这时我们声明它为一个类型才能通过编译： 而且在模板实例化之前，完全没有办法来区分它们，这绝对是滋生各种bug的温床。这时C++标准委员会再也忍不住了，与其到实例化时才能知道到底选择哪种方式来解释以上代码，委员会决定引入一个新的关键字，这就是typename。 C++标准 对于用于模板定义的依赖于模板参数的名称，只有在实例化的参数中存在这个类型名，或者这个名称前使用了 typename 关键字来修饰，编译器才会将该名称当成是类型。除了以上这两种情况，绝不会被当成是类型。 因此，如果你想直接告诉编译器 T::const_iterator 是类型而不是变量，只需用 typename修饰： 1 typename T::const_iterator it(proto.begin()); 这样编译器就可以确定T::const_iterator是一个类型，而不再需要等到实例化时期才能确定，因此消除了前面提到的歧义。 嵌套从属类型 事实上类型T::const_iterator依赖于模板参数T， 模板中依赖于模板参数的名称称为从属名称（dependent name）， 当一个从属名称嵌套在一个类里面时，称为嵌套从属名称（nested dependent name）。 其实T::const_iterator还是一个嵌套从属类型名称（nested dependent type name）。 嵌套从属名称是需要用typename声明的，其他的名称是不可以用typename声明的。比如下面是一个合法的声明： 1 2 template\u003ctypename T\u003e void fun(const T\u0026 proto ,typename T::const_iterator it); ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:2:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::bind 参考: 当 std::bind 遇上 this bind本身是一种延迟计算的思想，它本身可以绑定普通函数、全局函数、静态函数、类静态函数甚至是类成员函数. bind能够在绑定时候就同时绑定一部分参数，未提供的参数则使用占位符表示，然后在运行时传入实际的参数值。PS：绑定的参数将会以值传递的方式传递给具体函数，占位符将会以引用传递。众所周知，静态成员函数其实可以看做是全局函数，而非静态成员函数则需要传递this指针作为第一个参数，所以std::bind能很容易地绑定成员函数。 std::bind 遇上 this : 非静态成员函数则需要传递this指针作为第一个参数. ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:3:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::is_same\u003cR, void\u003e::value 头文件 ： #include \u003ctype_traits\u003e 如果两个一样的类型会返回true ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:4:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::enable_if td::enable_if 顾名思义，满足条件时类型有效。作为选择类型的小工具，其广泛的应用在 C++ 的模板元编程（meta programming）中。它的定义也异常的简单： 1 2 3 4 5 6 7 template \u003cbool, typename T=void\u003e struct enable_if { }; template \u003ctypename T\u003e struct enable_if\u003ctrue, T\u003e { using type = T; }; 由上可知，只有当第一个模板参数为 true 时，type 才有定义，否则使用 type 会产生编译错误，并且默认模板参数可以让你不必指定类型。 1 2 3 4 5 6 7 8 9 10 11 12 // help call return value type is void function template\u003ctypename R, typename F\u003e typename std::enable_if\u003cstd::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type call_helper(F f) { f(); return 0; } // 这里的意思是 如果 template\u003ctypename R, typename F\u003e typename std::enable_if\u003c!std::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type call_helper(F f) { return f(); } 1 2 3 4 std::enable_if\u003c std::is_same\u003cR, void\u003e::value, typename type_xx\u003cR\u003e::type \u003e::type 1 2 3 4 5 6 7 8 9 template\u003ctypename R\u003e void buttonrpc::callproxy_(std::function\u003cR()\u003e func, Serializer* pr, const char* data, int len) { typename type_xx\u003cR\u003e::type r = call_helper\u003cR\u003e(std::bind(func)); value_t\u003cR\u003e val; val.set_code(RPC_ERR_SUCCESS); val.set_val(r); (*pr) \u003c\u003c val; } 1 2 3 4 5 template\u003ctypename F\u003e void buttonrpc::callproxy( F fun, Serializer* pr, const char* data, int len ) { callproxy_(fun, pr, data, len); } 1 2 3 4 5 template\u003ctypename F\u003e void buttonrpc::bind( std::string name, F func ) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF\u003e, this, func, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:5:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::decay 头文件 ： #include \u003ctype_traits\u003e 对一个类型进行退化处理，如 ： cosnt int\u0026退化为int ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:6:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"std::reverse和std::reverse_copy std::reverse：反转排序容器内指定范围中的元素。std::reverse_copy与std::reverse唯一的区别是：reverse_copy会将结果拷贝到另外一个容器中，而不影响原容器的内容。 std::reverse: defined in header , reverses the order of the elements in the range [first, last). std::reverse_copy: defined in header , copies the elements in the range[first,last) to the range beginning at result, but in reverse order. 可变参数模板消除冗余代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // client template\u003ctypename R\u003e value_t\u003cR\u003e call(std::string name); template\u003ctypename R, typename P1\u003e value_t\u003cR\u003e call(std::string name, P1); template\u003ctypename R, typename P1, typename P2\u003e value_t\u003cR\u003e call(std::string name, P1, P2); template\u003ctypename R, typename P1, typename P2, typename P3\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3); template\u003ctypename R, typename P1, typename P2, typename P3, typename P4\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3, P4); template\u003ctypename R, typename P1, typename P2, typename P3, typename P4, typename P5\u003e value_t\u003cR\u003e call(std::string name, P1, P2, P3, P4, P5); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // client template\u003ctypename R, typename... Params\u003e value_t\u003cR\u003e call(std::string name, Params... ps) { using args_type = std::tuple\u003ctypename std::decay\u003cParams\u003e::type...\u003e; args_type args = std::make_tuple(ps...); Serializer ds; ds \u003c\u003c name; package_params(ds, args); return net_call\u003cR\u003e(ds); } template\u003ctypename R\u003e value_t\u003cR\u003e call(std::string name) { Serializer ds; ds \u003c\u003c name; return net_call\u003cR\u003e(ds); } ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_02/:7:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (C++语法分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_02/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 开源地址 2. 编译运行 2.1. buttonrpc 2.2. buttonrpc_cpp14 3. 原理 3.1. RPC 3.2. buttonrpc 分析 3.2.1. Call ID映射：buttonrpc.hpp 3.2.2. 序列化和反序列化：Serializer.hpp 3.2.3. 网络传输：ZeroMQ 1. 开源地址 buttonrpc buttonrpc_cpp14 2. 编译运行 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:0:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"2.1. buttonrpc 依赖安装： 1 sudo apt-get install libzmq3-dev 编译： ubuntu 下修改文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 diff --git a/example/main_client.cpp b/example/main_client.cpp index abdec37..fab93c5 100644 --- a/example/main_client.cpp +++ b/example/main_client.cpp @@ -3,7 +3,11 @@ #include \u003cctime\u003e #include \"buttonrpc.hpp\" +#ifdef _WIN32 #include \u003cWindows.h\u003e // use sleep +#else + #include \u003cunistd.h\u003e +#endif #define buttont_assert(exp) { \\ @@ -64,7 +68,11 @@ int main() buttonrpc::value_t\u003cvoid\u003e xx = client.call\u003cvoid\u003e(\"foo_7\", 666); buttont_assert(!xx.valid()); +#ifdef _WIN32 Sleep(1000); +#else + sleep(1); +#endif } return 0; 创建CMakeLists 并编译 1 2 3 4 5 6 cd buttonrpc touch CMakeLists.txt # 内容见下 mkdir build cd build cmake .. make 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # 这个是cmake最小版本要求 cmake_minimum_required(VERSION 3.1) # Enable C++11，这一段是源码里的 set(CMAKE_CXX_STANDARD 14) set(CMAKE_CXX_STANDARD_REQUIRED TRUE) # 填写你的项目名称Project project( RPC ) aux_source_directory(${CMAKE_SOURCE_DIR}/src/ DIR_SRCS) aux_source_directory(${CMAKE_SOURCE_DIR}/example DIR_SRCS) include_directories( ${CMAKE_SOURCE_DIR} ${CMAKE_SOURCE_DIR}/src ) message(\"${CMAKE_CURRENT_SOURCE_DIR}\") # Find all *.cpp files and store in list cpps # GLOB这个参数不支持子目录， 用GLOB_RECURSE可以支持子目录。 file(GLOB cpps RELATIVE \"${CMAKE_CURRENT_SOURCE_DIR}/example\" \"${CMAKE_CURRENT_SOURCE_DIR}/example/*.cpp\") foreach(mainfile IN LISTS cpps) # Get file name without directory get_filename_component(mainname ${mainfile} NAME_WE) add_executable(${mainname} ${CMAKE_CURRENT_SOURCE_DIR}/example/${mainfile}) target_link_libraries(${mainname} zmq) endforeach() 运行demo 1 2 ./main_server ./main_client ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:1:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"2.2. buttonrpc_cpp14 参考 buttonrpc 3. 原理 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:2:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.1. RPC RPC（Remote Procedure Call）远程过程调用。要像调用本地的函数一样去调远程函数。 RPC 是需要有三个主要模块：Call ID映射，序列化和反序列化，网络传输。 Call ID映射。我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 \u003c–\u003e Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。 序列化和反序列化。客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。 网络传输。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:3:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2. buttonrpc 分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:0","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.1. Call ID映射：buttonrpc.hpp server server 中主要完成被调用函数的注册,在收到网络发送的数据进行序列化还原后找到对应的调用函数和参数,执行调用再将结果返回. 1 2 3 4 5 6 // server template\u003ctypename F\u003e void bind(std::string name, F func); template\u003ctypename F, typename S\u003e void bind(std::string name, F func, S* s); bind 函数两种模板的实现是为了兼容多参数函数的设计,其中 name 为函数名,同时也是对应的函数的索引,func 为函数指针,s 为函数参数.bind 的实现如下: 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename F\u003e void buttonrpc::bind( std::string name, F func ) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF\u003e, this, func, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } template\u003ctypename F, typename S\u003e inline void buttonrpc::bind(std::string name, F func, S* s) { m_handlers[name] = std::bind(\u0026buttonrpc::callproxy\u003cF, S\u003e, this, func, s, std::placeholders::_1, std::placeholders::_2, std::placeholders::_3); } 函数最终被放到m_handlers 中索引,m_handlers的类型如下: 1 std::map\u003cstd::string, std::function\u003cvoid(Serializer*, const char*, int)\u003e\u003e m_handlers; 映射关系为 函数名(string) — 函数指针 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename F\u003e void buttonrpc::callproxy( F fun, Serializer* pr, const char* data, int len ) { callproxy_(fun, pr, data, len); } template\u003ctypename F, typename S\u003e inline void buttonrpc::callproxy(F fun, S * s, Serializer * pr, const char * data, int len) { callproxy_(fun, s, pr, data, len); } callproxy_ 实现如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 template\u003ctypename R\u003e void buttonrpc::callproxy_(std::function\u003cR()\u003e func, Serializer* pr, const char* data, int len) { typename type_xx\u003cR\u003e::type r = call_helper\u003cR\u003e(std::bind(func)); value_t\u003cR\u003e val; val.set_code(RPC_ERR_SUCCESS); val.set_val(r); (*pr) \u003c\u003c val; } /*-------------------------------------------------------------------------------------------*/ template\u003ctypename F\u003e void callproxy(F fun, Serializer* pr, const char* data, int len); template\u003ctypename F, typename S\u003e void callproxy(F fun, S* s, Serializer* pr, const char* data, int len); // PROXY FUNCTION POINT template\u003ctypename R\u003e void callproxy_(R(*func)(), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR()\u003e(func), pr, data, len); } template\u003ctypename R, typename P1\u003e void callproxy_(R(*func)(P1), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2\u003e void callproxy_(R(*func)(P1, P2), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3\u003e void callproxy_(R(*func)(P1, P2, P3), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3, typename P4\u003e void callproxy_(R(*func)(P1, P2, P3, P4), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3, P4)\u003e(func), pr, data, len); } template\u003ctypename R, typename P1, typename P2, typename P3, typename P4, typename P5\u003e void callproxy_(R(*func)(P1, P2, P3, P4, P5), Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1, P2, P3, P4, P5)\u003e(func), pr, data, len); } // PROXY CLASS MEMBER template\u003ctypename R, typename C, typename S\u003e void callproxy_(R(C::* func)(), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR()\u003e(std::bind(func, s)), pr, data, len); } template\u003ctypename R, typename C, typename S, typename P1\u003e void callproxy_(R(C::* func)(P1), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::function\u003cR(P1)\u003e(std::bind(func, s, std::placeholders::_1)), pr, data, len); } template\u003ctypename R, typename C, typename S, typename P1, typename P2\u003e void callproxy_(R(C::* func)(P1, P2), S* s, Serializer* pr, const char* data, int len) { callproxy_(std::funct","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:1","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.2. 序列化和反序列化：Serializer.hpp 重载 \u003c\u003c \u003e\u003e 1 2 3 4 5 6 7 8 9 10 11 template\u003ctypename T\u003e Serializer \u0026operator \u003e\u003e (T\u0026 i){ output_type(i); return *this; } template\u003ctypename T\u003e Serializer \u0026operator \u003c\u003c (T i){ input_type(i); return *this; } 重载 « » 并调用 input_type output_type 将数据转化为数据流(char类型)用于网络传输 output_type \u0026 input_type 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template\u003ctypename T\u003e inline void Serializer::output_type(T\u0026 t) { ... } template\u003c\u003e inline void Serializer::output_type(std::string\u0026 in) { ... } template\u003ctypename T\u003e inline void Serializer::input_type(T t) { ... } template\u003c\u003e inline void Serializer::input_type(std::string in) { ... } template\u003c\u003e inline void Serializer::input_type(const char* in) { ... } 这里的 input_type output_type 提供了多种的特化和偏特化的实现同样是为了有多参数函数的序列化的需求. ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:2","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"3.2.3. 网络传输：ZeroMQ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 // network void buttonrpc::as_client( std::string ip, int port ) { m_role = RPC_CLIENT; m_socket = new zmq::socket_t(m_context, ZMQ_REQ); ostringstream os; os \u003c\u003c \"tcp://\" \u003c\u003c ip \u003c\u003c \":\" \u003c\u003c port; m_socket-\u003econnect (os.str()); } void buttonrpc::as_server( int port ) { m_role = RPC_SERVER; m_socket = new zmq::socket_t(m_context, ZMQ_REP); ostringstream os; os \u003c\u003c \"tcp://*:\" \u003c\u003c port; m_socket-\u003ebind (os.str()); } void buttonrpc::send( zmq::message_t\u0026 data ) { m_socket-\u003esend(data); } void buttonrpc::recv( zmq::message_t\u0026 data ) { m_socket-\u003erecv(\u0026data); } inline void buttonrpc::set_timeout(uint32_t ms) { // only client can set if (m_role == RPC_CLIENT) { m_socket-\u003esetsockopt(ZMQ_RCVTIMEO, ms); } } void buttonrpc::run() { // only server can call if (m_role != RPC_SERVER) { return; } while (1){ zmq::message_t data; recv(data); StreamBuffer iodev((char*)data.data(), data.size()); Serializer ds(iodev); std::string funname; ds \u003e\u003e funname; Serializer* r = call_(funname, ds.current(), ds.size()- funname.size()); zmq::message_t retmsg (r-\u003esize()); memcpy (retmsg.data (), r-\u003edata(), r-\u003esize()); send(retmsg); delete r; } } 网络传输使用的 ZeroMQ . ","date":"2023-01-16","objectID":"/posts/open_source_software/buttonrpc/buttonrpc_01/:4:3","tags":["buttonrpc"],"title":"开源软件:buttonrpc (代码分析)","uri":"/posts/open_source_software/buttonrpc/buttonrpc_01/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/cpufetch/cpufetch/","tags":["cpufetch"],"title":"开源软件:cpufetch","uri":"/posts/open_source_software/cpufetch/cpufetch/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. CPUFetch 2. 开源地址 3. 编译运行 4. 运行效果 5. bash 启动打印CPU信息 1. CPUFetch CPUFetch是一个简单的命令行工具，与Neofetch有点类似，但是用于在Linux，Windows，macOS和Android中获取CPU体系结构。 该工具会输出制造商徽标（例如Intel，AMD）以及基本的CPU信息，包括： CPU名称。 微架构。 纳米（nm）的半导体技术。 最大频率。 核心和线程数。 高级向量扩展（AVX） 融合乘加（FMA） L1，L2，L3缓存大小。 峰值性能。 2. 开源地址 cpufetch 3. 编译运行 1 2 3 4 git clone https://github.com/Dr-Noob/cpufetch cd cpufetch make ./cpufetch 4. 运行效果 5. bash 启动打印CPU信息 请将可执行文件复制到/usr/local/bin/ 1 sudo mv cpufetch /usr/local/bin/ .修改 .bashrc 1 2 cd ~ vi .bashrc 在.bashrc 最后位置添加 1 2 # start cpufetch cpufetch 重新打开终端 ","date":"2023-01-16","objectID":"/posts/open_source_software/cpufetch/cpufetch/:0:0","tags":["cpufetch"],"title":"开源软件:cpufetch","uri":"/posts/open_source_software/cpufetch/cpufetch/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 编译的原因 2. 环境 3. ffmpeg 3.1. 下载编译 !/bin/bash !/bin/bash download 3.2. cmake支持 !/usr/bin/env python !/usr/bin/env python coding: utf-8 note: the order matters ref: https://blog.csdn.net/zijin0802034/article/details/52779791 setup library names setup library found setup library versions final stuffs summary up and write 4. opencv 4.1. toolchain message(“begin child cmake”) message(“begin child cmake”) set cross-compiled system type, it’s better not use the type which cmake cannot recognized. when gcc-arm-aarch64-none-linux-gnu was installed, toolchain was available as below: set searching rules for cross-compiler other needed options set(GNUEABIHFCFLAGS “-Wall -fPIC -mcpu=cortex-a9 -mfpu=neon-fp16 -mfloat-abi=hard -mthumb-interwork -marm” CACHE INTERNAL docstring) set(GNUEABIHFCFLAGS “-Wall -fPIC -Wl,-rpath-link=/home/zz/soft/ffmpeg/aarch64-none-linux-gnu/lib” CACHE INTERNAL docstring) # for shared libs, rpath required 4.2. 下载编译 !/bin/bash !/bin/bash download 编译 5. References 1. 编译的原因 想在目标平台 gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf 上读取视频，作为算法 SDK 的输入数据；交叉编译了带 videoio 模块的 OpenCV，遇到 VideoCapture 无法读取 .mp4 格式视频的问题。排查后发现： 尽管不指定 FFMPEG，VideoIO 模块也能编译出来，但对应的编解码器 FOURCC 只能编解码 .avi 格式的视频，无法满足实际需求。 videoio 模块可以有不同 backend，在 PC 上先前主要是 Windows 平台，使用了预编译的 ffmpeg dll，没有对编解码 backend 引起重视；而 aarch64-none-linux-gnu 这样的嵌入式平台，没找到现成的 FFMPEG 库（如果有，请留言告知），于是手动编译 FFMPEG，并在 OpenCV 的 cmake 构建中集成。 2. 环境 Host: Ubuntu 18.04 交叉编译工具: rv1126 工具链 gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf cmake 3.20 3. ffmpeg ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:0:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"3.1. 下载编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/bin/bash OUT_DIR=../out_ffmpeg_rv1126 CROSS_PREFIX=/opt/tools/rk_docs_and_compiler/compiler/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin/arm-linux-gnueabihf- FFMPENG_BRANCH=n4.2.2 MAKE_JOBE=40 #download git clone https://git.ffmpeg.org/ffmpeg.git ffmpeg cd ffmpeg git checkout -b ${FFMPENG_BRANCH} ./configure \\ --prefix=${OUT_DIR} \\ --shlibdir=${OUT_DIR}/lib \\ --disable-shared \\ --disable-doc \\ --arch=aarch64 \\ --cross-prefix=${CROSS_PREFIX} \\ --target-os=linux \\ --disable-x86asm \\ --disable-asm \\ --disable-ffmpeg \\ --disable-ffplay \\ --disable-ffprobe \\ --enable-avresample make -j${MAKE_JOBE} make install ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:1:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"3.2. cmake支持 ffmpeg 官方不提供 cmake 构建支持，github 上找到的 ffmpeg cmake 写得很长但不起作用；简单起见，用如下 Python 代码生成 ffmpeg-config.cmake（注意库版本为手动硬编码，库的顺序也很重要） gen-ffmpeg-cmake-config.py： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 #!/usr/bin/env python #coding: utf-8 \"\"\" Generate ffmpeg-config.cmake \"\"\" # note: the order matters # ref: https://blog.csdn.net/zijin0802034/article/details/52779791 ffmpeg_lib_desc = { 'libavformat': '58.71.100', 'libavdevice': '58.12.100', 'libavcodec': '58.129.100', 'libavutil': '56.67.100', 'libswscale': '5.8.100', 'libswresample': '3.8.100', 'libavfilter': '7.109.100', 'libavresample': '4.0.0', } content_lines = [ 'set(ffmpeg_path \"${CMAKE_CURRENT_LIST_DIR}\")', '', 'set(FFMPEG_EXEC_DIR \"${ffmpeg_path}/bin\")', 'set(FFMPEG_LIBDIR \"${ffmpeg_path}/lib\")', 'set(FFMPEG_INCLUDE_DIRS \"${ffmpeg_path}/include\")', '', ] # setup library names content_lines.append('# library names') content_lines.append( 'set(FFMPEG_LIBRARIES', ) for key, value in ffmpeg_lib_desc.items(): lib_name = key lib_version = value content_lines.append( ' ${FFMPEG_LIBDIR}/' + lib_name + '.a' ) content_lines.append(' pthread') content_lines.append(')') content_lines.append('') # setup library found content_lines.append('# found status') for key, value in ffmpeg_lib_desc.items(): lib_name = key content_lines.append( 'set(FFMPEG_{:s}_FOUND TRUE)'.format(lib_name) ) content_lines.append('') # setup library versions content_lines.append('# library versions') for key, value in ffmpeg_lib_desc.items(): lib_name = key lib_version = value content_lines.append( 'set(FFMPEG_{:s}_VERSION {:s})'.format(lib_name, lib_version) ) content_lines.append('') # final stuffs content_lines.append('set(FFMPEG_FOUND TRUE)') content_lines.append('set(FFMPEG_LIBS ${FFMPEG_LIBRARIES})') # summary up and write fout = open('ffmpeg-config.cmake', 'w') for line in content_lines: fout.write(line + '\\n') fout.close() 其中版本号的设定，是为了在 OpenCV 中找到 FFMPEG 后，能通过最低版本检查。 将这个文件，放在 ffmpeg 安装路径的根目录，并运行，得到 ffmpeg-config.cmake，则后续可用 find_package(FFMPEG) 使用； 4. opencv ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:2:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"4.1. toolchain 交叉编译阶段用到的 toolchain 文件里，如果后续用的是 ffmpeg 动态库，则需要在 toolchain 里指定 rpath。本人最终用的静态库，因而未设 rpath。 如下脚本，保存为 build/aarch64-none-linux-gnu.toolchain.cmake 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # message(\"begin child cmake\") # set cross-compiled system type, it's better not use the type which cmake cannot recognized. set(CMAKE_SYSTEM_NAME Linux) set(CMAKE_SYSTEM_PROCESSOR ARM) # when gcc-arm-aarch64-none-linux-gnu was installed, toolchain was available as below: set(TOOLCHAIN_DIR \"/opt/tools/rk_docs_and_compiler/compiler/gcc-arm-8.3-2019.03-x86_64-arm-linux-gnueabihf/bin\") set(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/arm-linux-gnueabihf-g++) set(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/arm-linux-gnueabihf-gcc) # set searching rules for cross-compiler set(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) set(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) set(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # other needed options #set(GNUEABIHF_C_FLAGS \"-Wall -fPIC -mcpu=cortex-a9 -mfpu=neon-fp16 -mfloat-abi=hard -mthumb-interwork -marm\" CACHE INTERNAL docstring) #set(GNUEABIHF_C_FLAGS \"-Wall -fPIC -Wl,-rpath-link=/home/zz/soft/ffmpeg/aarch64-none-linux-gnu/lib\" CACHE INTERNAL docstring) # for shared libs, rpath required set(GNUEABIHF_C_FLAGS \"-Wall -fPIC\" CACHE INTERNAL docstring) set(GNUEABIHF_CXX_FLAGS \"\") set(CMAKE_C_FLAGS \"-march=armv7-a ${CMAKE_C_FLAGS} ${GNUEABIHF_C_FLAGS}\" CACHE STRING \"C flags\" FORCE) set(CMAKE_CXX_FLAGS \"-march=armv7-a ${CMAKE_CXX_FLAGS} ${GNUEABIHF_C_FLAGS} ${NDK_CXX_FLAGS}\" CACHE STRING \"C++ flags\" FORCE) https://stackoverflow.com/questions/12427928/configure-and-build-opencv-to-custom-ffmpeg-install ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:3:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"4.2. 下载编译 用如下脚本来编译，保存为 build/aarch64-linux-gnu.sh 并执行 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #!/bin/bash OUT_DIR=../out_opencv_rv1126 OPENCV_MODULES_DIR=../opencv_contrib/modules/ FFMPEG_DIR=../out_ffmpeg_rv1126 OPENCV_BRANCH=4.5.0 MAKE_JOBE=40 #download git clone --branch ${OPENCV_BRANCH} https://github.com/opencv/opencv.git git clone --branch ${OPENCV_BRANCH} https://github.com/opencv/opencv_contrib.git #编译 mkdir build_opencv cd build_opencv TOOLCHAIN=../cross.cmake cmake -DCMAKE_TOOLCHAIN_FILE=$TOOLCHAIN \\ -D CMAKE_BUILD_TYPE=Release \\ -D CMAKE_INSTALL_PREFIX=${OUT_DIR} \\ -D OPENCV_EXTRA_MODULES_PATH=${OPENCV_MODULES_DIR} \\ -D WITH_FFMPEG=ON \\ -D OPENCV_FFMPEG_USE_FIND_PACKAGE=ON \\ -D OPENCV_FFMPEG_SKIP_BUILD_CHECK=ON \\ -D FFMPEG_DIR=${FFMPEG_DIR} \\ -D BUILD_TESTS=OFF \\ -D BUILD_PERF_TESTS=OFF \\ -D BUILD_opencv_apps=OFF \\ -D WITH_PROTOBUF=OFF \\ -D WITH_QUIRC=OFF \\ -D WITH_1394=OFF \\ -D WITH_CUDA=OFF \\ -D WITH_OPENCL=OFF \\ -D WITH_VTK=OFF \\ -D WITH_MATLAB=OFF \\ -D BUILD_DOCS=OFF \\ -D BUILD_opencv_python3=OFF \\ -D BUILD_opencv_python2=OFF \\ -D WITH_IPP=OFF \\ -D BUILD_ANDROID_PROJECTS=OFF \\ -D BUILD_ANDROID_EXAMPLES=OFF \\ -D BUILD_ANDROID_SERVICE=OFF \\ -D BUILD_SHARED_LIBS=OFF \\ -D OPENCV_FORCE_3RDPARTY_BUILD=ON \\ -D BUILD_JAVA=OFF \\ -D BUILD_FAT_JAVA_LIB=OFF \\ -D OPENCV_GENERATE_PKGCONFIG=ON \\ ../opencv make -j${MAKE_JOBE} make install 5. References OpenCV 交叉编译：基于 FFMPEG 的 VideoIO 模块 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/:4:0","tags":["ffmpeg","opencv"],"title":"开源软件:ffmpeg \u0026 opencv_4.5.0  安装","uri":"/posts/open_source_software/opencv/ffmpeg_opencv_4.5.0_install/ffmpeg_opencv_4.5.0_install/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:0","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"explicit \u0026 implicit C++中的explicit关键字只能用于修饰只有一个参数的类构造函数, 它的作用是表明该构造函数是显示的, 而非隐式的, 跟它相对应的另一个关键字是implicit, 意思是隐藏的,类构造函数默认情况下即声明为implicit(隐式). ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:1","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"std::streambuf https://blog.csdn.net/man_sion/article/details/78110842 using ContentProvider = std::function\u003cbool(size_t offset, size_t length, DataSink \u0026sink)\u003e; using ContentProviderWithoutLength = std::function\u003cbool(size_t offset, DataSink \u0026sink)\u003e; using ContentProviderResourceReleaser = std::function\u003cvoid(bool success)\u003e; using ContentReceiverWithProgress = std::function\u003cbool(const char *data, size_t data_length, uint64_t offset,uint64_t total_length)\u003e; using ContentReceiver = std::function\u003cbool(const char *data, size_t data_length)\u003e; using MultipartContentHeader = std::function\u003cbool(const MultipartFormData \u0026file)\u003e; class ContentReader { public: using Reader = std::function\u003cbool(ContentReceiver receiver)\u003e; using MultipartReader = std::function\u003cbool(MultipartContentHeader header, ContentReceiver receiver)\u003e; ContentReader(Reader reader, MultipartReader multipart_reader) : reader_(std::move(reader)), multipart_reader_(std::move(multipart_reader)) {} bool operator()(MultipartContentHeader header, ContentReceiver receiver) const { return multipart_reader_(std::move(header), std::move(receiver)); } bool operator()(ContentReceiver receiver) const { return reader_(std::move(receiver)); } Reader reader_; MultipartReader multipart_reader_; }; class Stream { public: virtual ~Stream() = default; virtual bool is_readable() const = 0; virtual bool is_writable() const = 0; virtual ssize_t read(char *ptr, size_t size) = 0; virtual ssize_t write(const char *ptr, size_t size) = 0; virtual void get_remote_ip_and_port(std::string \u0026ip, int \u0026port) const = 0; virtual socket_t socket() const = 0; template \u003ctypename… Args\u003e ssize_t write_format(const char *fmt, const Args \u0026…args); ssize_t write(const char *ptr); ssize_t write(const std::string \u0026s); }; class TaskQueue { public: TaskQueue() = default; virtual ~TaskQueue() = default; virtual void enqueue(std::function\u003cvoid()\u003e fn) = 0; virtual void shutdown() = 0; virtual void on_idle() {} }; class ThreadPool : public TaskQueue { public: explicit ThreadPool(size_t n) : shutdown_(false) { while (n) { threads_.emplace_back(worker(*this)); n–; } } ThreadPool(const ThreadPool \u0026) = delete; ~ThreadPool() override = default; void enqueue(std::function\u003cvoid()\u003e fn) override { std::unique_lockstd::mutex lock(mutex_); jobs_.push_back(std::move(fn)); cond_.notify_one(); } void shutdown() override { // Stop all worker threads… { std::unique_lockstd::mutex lock(mutex_); shutdown_ = true; } cond_.notify_all(); // Join... for (auto \u0026t : threads_) { t.join(); } } private: struct worker { explicit worker(ThreadPool \u0026pool) : pool_(pool) {} void operator()() { for (;;) { std::function\u003cvoid()\u003e fn; { std::unique_lock\u003cstd::mutex\u003e lock(pool_.mutex_); pool_.cond_.wait( lock, [\u0026] { return !pool_.jobs_.empty() || pool_.shutdown_; }); if (pool_.shutdown_ \u0026\u0026 pool_.jobs_.empty()) { break; } fn = pool_.jobs_.front(); pool_.jobs_.pop_front(); } assert(true == static_cast\u003cbool\u003e(fn)); fn(); } } ThreadPool \u0026pool_; }; friend struct worker; std::vectorstd::thread threads_; std::list\u003cstd::function\u003cvoid()» jobs_; bool shutdown_; std::condition_variable cond_; std::mutex mutex_; }; std::vectorstd::thread threads_; ThreadPool \u0026pool_; std::list\u003cstd::function\u003cvoid()» jobs_; using SocketOptions = std::function\u003cvoid(socket_t sock)\u003e; line_reader 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 inline bool is_file(const std::string \u0026path) { struct stat st; return stat(path.c_str(), \u0026st) \u003e= 0 \u0026\u0026 S_ISREG(st.st_mode); } inline bool is_dir(const std::string \u0026path) { struct stat st; return stat(path.c_str(), \u0026st) \u003e= 0 \u0026\u0026 S_ISDIR(st.st_mode); } inline bool is_valid_path(const std::string \u0026path) { size_t level = 0; size_t i = 0; // Skip slash while (i \u003c path.size() \u0026\u0026 path[i] == '/') { i++; } while (i \u003c path.size()) { ","date":"2023-01-16","objectID":"/posts/open_source_software/httplib/httplib/:0:2","tags":["httplib"],"title":"开源软件:httplib","uri":"/posts/open_source_software/httplib/httplib/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 背景 环境 安装 参考教程 源码及依赖文件下载 问题解决 cmake 问题 编译问题解决 测试 其他 背景 需要用到OpenCV3中使用SIFT和SURF特征提取，需要手动下载opencv和opencv_contrib的源码，然后将两个源码放在一起手动编译安装。 环境 ubuntu18.04 opencv-3.2.0 opencv_contrib-3.2.0 安装 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:0:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"参考教程 在ubuntu18.04中安装opencv_contrib-3.2.0采坑教程 主要参考上面教程，包含依赖库安装，cmake 配置等，下面会补充使用上述教程中优化和解决的部分编译问题。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:1:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"源码及依赖文件下载 这里主要提供了部分源文件的国内的gitee 下载地址和cmake 自动下载的配置文件(有几率下载不成功这里做下备份)。 opencv opencv_contrib opencv3.2_CMake 问题解决 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:2:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"cmake 问题 问题： 1 2 3 4 5 6 7 8 9 10 11 12 CMake Error: The following variables are used in this project, but they are set to NOTFOUND. Please set them or make sure they are set and tested correctly in the CMake files: CUDA_nppi_LIBRARY (ADVANCED) linked by target \"opencv_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev linked by target \"opencv_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev linked by target \"opencv_test_cudev\" in directory D:/Cproject/opencv/opencv/sources/modules/cudev/test linked by target \"opencv_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_test_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core linked by target \"opencv_perf_core\" in directory D:/Cproject/opencv/opencv/sources/modules/core ... ... 解决： 参考：OpenCV3.3+CUDA9.0+Cmake3.9 环境搭建 已经更换的 FindCUDA.cmake OpenCVDetectCUDA.cmake 文件下载地址： https://gitee.com/fromyuhu/opencv3.2_CMake ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:3:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"编译问题解决 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv/modules/imgcodecs/src/grfmt_exr.hpp:52:10: fatal error: ImfChromaticities.h: 没有那个文件或目录 #include \u003cImfChromaticities.h\u003e 解决： 1 sudo apt-get install libopenexr-dev 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv/modules/videoio/src/cap_gphoto2.cpp:32:10: fatal error: gphoto2/gphoto2.h: 没有那个文件或目录 #include \u003cgphoto2/gphoto2.h\u003e 解决： 1 sudo apt-get install libgphoto2-dev 问题： 1 2 /mnt/DG/WORK/2_code/100_ZYH/opencv3.2.0-bulid/opencv_lapack.h:2:10: fatal error: LAPACKE_H_PATH-NOTFOUND/lapacke.h: 没有那个文件或目录 #include \"LAPACKE_H_PATH-NOTFOUND/lapacke.h\" 解决： 1 2 3 4 5 sudo apt-get install liblapacke-dev checkinstall 修改出现问题的文件，例如我的文件是 opencv-3.2.0/build/opencv_lapack.h 将第二行中的#include\"LAPACKE_H_PATH-NOTFOUND/lapacke.h\" 修改为#include\"lapacke.h\"即可 问题： 1 Unsupported gpu architecture 'compute_20' 解决： CUDA_GENERATION=Kepler .. 测试 获取文件： https://gitee.com/fromyuhu/COMMON/tree/master/opencv/surf mkdir bulid cd bulid cmake .. make ./demo 能正常提取匹配特征点说明正常。 其他 笔者在安装的时候，有碰到 libgtk2.0-dev 由于依赖库问题无法安装问题，努力了很久也有搞定，这里说下，如果真的有碰到相的依赖库实在无法安装的问题，可以选择重装系统。笔者曾尝试解决部分库安装问题花费了不少时间，最后也没能解决，耽误了不少时间。 ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/:4:0","tags":["opencv","opencv_contrib"],"title":"开源软件:opencv \u0026 opencv_contrib 3.2.0 安装","uri":"/posts/open_source_software/opencv/opencv3.2_install/opencv3.2.0_install/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/introduction/introduction/","tags":["opencv"],"title":"开源软件:opencv modules介绍","uri":"/posts/open_source_software/opencv/introduction/introduction/"},{"categories":["开源软件"],"content":" Main modules: core. Core functionality imgproc. Image processing imgcodecs. Image file reading and writing videoio. Video I/O highgui. High-level GUI video. Video Analysis calib3d. Camera Calibration and 3D Reconstruction features2d. 2D Features Framework objdetect. Object Detection dnn. Deep Neural Network module ml. Machine Learning flann. Clustering and Search in Multi-Dimensional Spaces photo. Computational Photography stitching. Images stitching cudaarithm. Operations on Matrices cudabgsegm. Background Segmentation cudacodec. Video Encoding/Decoding cudafeatures2d. Feature Detection and Description cudafilters. Image Filtering cudaimgproc. Image Processing cudalegacy. Legacy support cudaobjdetect. Object Detection cudaoptflow. Optical Flow cudastereo. Stereo Correspondence cudawarping. Image Warping cudev. Device layer shape. Shape Distance and Matching superres. Super Resolution videostab. Video Stabilization viz. 3D Visualizer Extra modules: aruco. ArUco Marker Detection bgsegm. Improved Background-Foreground Segmentation Methods bioinspired. Biologically inspired vision models and derivated tools ccalib. Custom Calibration Pattern for 3D reconstruction cnn_3dobj. 3D object recognition and pose estimation API cvv. GUI for Interactive Visual Debugging of Computer Vision Programs datasets. Framework for working with different datasets dnn_modern. Deep Learning Modern Module dpm. Deformable Part-based Models face. Face Analysis freetype. Drawing UTF-8 strings with freetype/harfbuzz fuzzy. Image processing based on fuzzy mathematics hdf. Hierarchical Data Format I/O routines img_hash. The module brings implementations of different image hashing algorithms. line_descriptor. Binary descriptors for lines extracted from an image matlab. MATLAB Bridge optflow. Optical Flow Algorithms ovis. OGRE 3D Visualiser phase_unwrapping. Phase Unwrapping API plot. Plot function for Mat data reg. Image Registration rgbd. RGB-Depth Processing saliency. Saliency API sfm. Structure From Motion stereo. Stereo Correspondance Algorithms structured_light. Structured Light API surface_matching. Surface Matching text. Scene Text Detection and Recognition tracking. Tracking API xfeatures2d. Extra 2D Features Framework ximgproc. Extended Image Processing xobjdetect. Extended object detection xphoto. Additional photo processing algorithms ","date":"2023-01-16","objectID":"/posts/open_source_software/opencv/introduction/introduction/:0:0","tags":["opencv"],"title":"开源软件:opencv modules介绍","uri":"/posts/open_source_software/opencv/introduction/introduction/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 源码及编译使用 源码分析 std::future 源码及编译使用 源码地址：ThreadPool 源码及编译cmake 文件 ： ThreadPool 编译 1 2 3 4 mkdir build cd build cmake .. make 运行： 1 ./example 源码分析 ","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/:0:0","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":"std::future future std::future类模板定义头文件,其函数声明如下： 1 2 3 template \u003cclass T\u003e future; template \u003cclass R\u0026\u003e future\u003cR\u0026\u003e; // specialization : T is a reference type (R\u0026) template \u003c\u003e future\u003cvoid\u003e; // specialization : T is void 对于future补充说明如下： std::async 、 std::packaged_task 或 std::promise 能提供一个std::future对象给该异步操作的创建者 异步操作的创建者能用各种方法查询、等待或从 std::future 提取值。若异步操作仍未提供值，则这些方法可能阻塞。 异步操作准备好发送结果给创建者时，它能通过接口（eg,std::promise::set_value std::future） 修改共享状态的值。 std::future使用 下面就用std::future对象来获取异步操作的结果，没有使用到全局变量，逻辑非常清晰，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // future example #include \u003ciostream\u003e // std::cout #include \u003cfuture\u003e // std::async, std::future #include \u003cchrono\u003e // std::chrono::milliseconds // a non-optimized way of checking for prime numbers: bool is_prime (int x) { for (int i=2; i\u003cx; ++i) if (x%i==0) return false; return true; } int main () { // call function asynchronously: std::future\u003cbool\u003e fut = std::async (is_prime,444444443); // do something while waiting for function to set future: std::cout \u003c\u003c \"checking, please wait\"; std::chrono::milliseconds span (100); while (fut.wait_for(span)==std::future_status::timeout) std::cout \u003c\u003c '.' \u003c\u003c std::flush; bool x = fut.get(); // retrieve return value std::cout \u003c\u003c \"\\n444444443 \" \u003c\u003c (x?\"is\":\"is not\") \u003c\u003c \" prime.\\n\"; return 0; } ","date":"2023-01-16","objectID":"/posts/open_source_software/threadpool/threadpool/:1:0","tags":["ThreadPool"],"title":"开源软件:ThreadPool C++ 线程池","uri":"/posts/open_source_software/threadpool/threadpool/"},{"categories":["开源软件"],"content":"开源软件","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":" TBB 基础 简介 并行 使用 接口 parallel_for parallel_reduce parallel_while graph 并发容器 concurrent_hash_map concurrent_vector concurrent_queue 锁 Task Scheduler ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:0:0","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"TBB 基础 Intel Threading Building Blocks TBB API ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:0","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"简介 并行 1、指令级的并行；即所谓的微程序、指令流水线等，现在cpu的一级缓存、二级缓存都很大，所以这个cache的效果还是比较好的（基于局部性原理） 2、线程级的并行；即同一个时刻多个函数在运行（现在的cpu好像都是多核的） 3、服务级别的（比如一个游戏服务器中有商店服务、也有战斗服务、聊天服务等 这里的每个服务可能对应多个逻辑线程） 4、节点级别的；即所谓的分布式系统，多个节点互相配合，使整个系统在逻辑上成为一个单一的系统。（google、qq等这些海量访问的服务统统是分布式的）。 一般来说，第一个级别的并行直接做在硬件里面，第二个级别的并行会有一些基础的框架，第三和第四个级别的并行就是应用程序自己的架构的问题了。 这里面实际上有一个争论：是在算法并行化上面花心思去研究还是采用分布式的框架来面对问题规模的增长？实际上2者各有利弊，前者可以充分利用已有硬件，但是对程序员的要求较高，维护开发成本高，风险大；后者容易实现但是浪费硬件，在有些情况下不是所有问题都可以用加个机器的方式可以解决的（比如客户端上的多媒体软件，其计算量极大，总不能要求所有用户都升级吧。） Intel Threading Building Blocks，是为了方便程序员使用多核处理器的C++库，应该是对应上面的线程级的并行。 使用 整个程序逻辑没办法自动并行化，那就针对控制流进行并行化，所以TBB中提供了 parallel_for、parallel_while、 parallel_reduce等；（这些是TBB给C++程序员的比较高层的接口）并行肯定是多线程，这样的话数据竞争问题就比较棘手，所以TBB提供并发容器；如果觉得TBB提供的这些接口还没有办法解决性能问题，那就可以更深入的研究使用mutex、atomic、task等了；可以看出，TBB从几个层次上为程序员提供了支持。 BB提供的接口： 由底层到高层，task_scheduler——–concurrent_container——–parallel_for—pipeline简单说，TBB帮我们调度一个个task（比OS的调度要高效），实现高效的并行算法。 要使用TBB进行并行化，首先程序员要知道哪些是可以并行化；其次，要熟悉TBB并行化的框架（主要是泛型编程）；再次，程序员要大概知道并行算法的执行步骤；最后，利用TBB的组件，实现并行化的算法。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:1","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"接口 parallel_for parallel_for 适用场合：多个数据或请求彼此没有依赖关系，所要进行的操作是一样的（典型SPMD）。 blocked_range 1 2 3 4 5 6 7 // 典型的c++泛型编程 blocked_range 是要处理的多个数据，3个参数依次是开始的指针（迭代器）、结束指针、每个任务分配的数据数 //! Construct range over half-open interval [begin,end), with the given grainsize. blocked_range( Value begin_, Value end_, size_type grainsize_=1 ) : my_end(end_), my_begin(begin_), my_grainsize(grainsize_) { __TBB_ASSERT( my_grainsize\u003e0, \"grainsize must be positive\" ); } 第一个参数表示起始，第二个参数表示结束，它们的类型为const_iterator，表示的区间为[begin，end)这样一个半开区间。第三个参数，grainsize，表示的是一个“合适的大小”块，这个块会在一个循环中进行处理，如果数组比这个grainsize还大，parallel_for会把它分割为独立的block，然后分别进行调度（有可能由多个线程进行处理）。 这样我们知道，grainsize其实决定了TBB什么时候对数据进行划分，如果我们把grainsize指定得太小，那就可能会导致产生过多得block，从而使得不同block间的overhead增加（比如多个线程间切换的代价），有可能会使性能下降。相反，如果grainsize设得太大，以致于这个数组几乎没有被划分，那又会导致不能发挥parallel_for期望达到的并行效果，也没有达到理想得性能。所以我们在决定grainsize时需要小心，最好是能够经过调整测试后得到的值，当然你也可以如本例中一样不指定，让TBB帮你来决定合适的值（一般不是最优的）。一个调整grainsize的经验性步骤： 1）首先把grainsize设得比预想的要大一些，通常设为10000 2）在单处理机机器上运行，得到性能数据 3）把grainsize减半，看性能降低多少，如果降低在5%-10%之间，那这个grainsize就已经是一个不错的设定。 parallel_for 1 2 3 4 5 6 //! Parallel iteration over range with simple partitioner. /** @ingroup algorithms **/ template\u003ctypename Range, typename Body\u003e void parallel_for( const Range\u0026 range, const Body\u0026 body, const simple_partitioner\u0026 partitioner ) { internal::start_for\u003cRange,Body,const simple_partitioner\u003e::run(range,body,partitioner); } 其参数： 1）range：指定划分block的范围。 2）body：指定对block应用的操作，Body可以看成是一个操作子functor，它的operator(…)会以blocked_range为参数进行调用，当然如果我们传过来的是一个函数指针也是可以的，只要它能以blocked_range为参数进行调用。 3）partitioner：指定划分器，可选的两种simple_partitioner和auto_partitioner。 1 parallel_for(0,100,[](int v){cout\u003c\u003cv\u003c\u003cendl;}); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // parallel_forFibBody可以简单理解为一个函数对象（c++里是用运算符重载实现的，即（）是通信的接口） parallel_for( blocked_range\u003cint\u003e( 1, my_n, 10 ), parallel_forFibBody(my_stream) ); struct parallel_forFibBody { QueueStream \u0026my_stream; //! fill functor arguments parallel_forFibBody(QueueStream \u0026s) : my_stream(s) { } // 这里是并行的代码 void operator()( const blocked_range\u003cint\u003e \u0026range ) const { int i_end = range.end(); for( int i = range.begin(); i != i_end; ++i ) { my_stream.Queue.push( Matrix1110 ); // push initial matrix } } }; parallel_reduce parallel_reduce 适合于需要汇总的情况，即各个数据的结果需要汇总回来。 1 2 3 4 5 6 7 8 9 10 11 12 /** parallel_reduce overloads that work with anonymous function objects (see also \\ref parallel_reduce_lambda_req \"requirements on parallel_reduce anonymous function objects\"). **/ //! Parallel iteration with reduction and default partitioner. /** @ingroup algorithms **/ template\u003ctypename Range, typename Value, typename RealBody, typename Reduction\u003e Value parallel_reduce( const Range\u0026 range, const Value\u0026 identity, const RealBody\u0026 real_body, const Reduction\u0026 reduction ) { internal::lambda_reduce_body\u003cRange,Value,RealBody,Reduction\u003e body(identity, real_body, reduction); internal::start_reduce\u003cRange,internal::lambda_reduce_body\u003cRange,Value,RealBody,Reduction\u003e,const __TBB_DEFAULT_PARTITIONER\u003e ::run(range, body, __TBB_DEFAULT_PARTITIONER() ); return body.result(); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 float ParallelSumFoo(float a[], size_t n) { return parallel_reduce(tbb::blocked_range\u003csize_t\u003e(0, n), float(0.f), [a](const tbb::blocked_range\u003csize_t\u003e\u0026 r, const float\u0026 x) -\u003e float { float sum = x; for (size_t i = r.begin(); i != r.end(); ++i) { sum += foo(a[i]); } return sum; }, [](const float\u0026 x, const float\u0026 y) -\u003e float{ return x + y; }); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //注意分发下去和汇总回来的方法 float ParallelSumFoo( const float a[], size_t n ) { SumFoo sf(a); parallel_reduce(blocked_range\u003csize_t\u003e(0,n,IdealGrainSize), sf ); return sf.sum; } class SumFoo { float* my_a; public: float sum; void operator()( const blocked_range\u003csize_t\u003e\u0026 r ) { float *a = my_a; for( size_t i=r.begin(); i!=r.end(); ++i ) sum += Foo(a[i]); } SumFoo( SumFoo\u0026 x, split ) : my_a(x.my_a), sum(0) {} // 分发任务，注意这个构造器要求是线程安全的 void join( const SumFoo\u0026 y ) {sum+=y.sum;} // 收集汇总结果 SumFoo(float a[] ) : my_a(a), sum(0) {} }","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:2","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"graph 1 2 3 4 5 //! Makes an edge between a single predecessor and a single successor template\u003c typename T \u003e inline void make_edge( sender\u003cT\u003e \u0026p, receiver\u003cT\u003e \u0026s ) { internal_make_edge( p, s ); } ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:3","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"并发容器 大部分程序都有容器类，在多线程环境下就有数据污染的问题，为了使并发的线程串行化，一般是使用加锁的办法，如果这个容器由程序员自己来实现，难度还是比较大的，这样就需要有线程安全的容器类。 concurrent_hash_map hash接口与stl类似 concurrent_vector grow_by(n) 插入n个item（动态增长） grow_to_at_least（）设定容器的大小 size() 包括正在并发增长的部分 因为有可能会同时取，所以程序员需要自己维护自己的class的线程安全性 clear() 不是线程安全的 concurrent_queue pop_if_present(item) 非阻塞， pop（） 阻塞， concurrent_queue::size() 负数时表示有多少个消费者在等待 set_capacity（）指定队列大小，会使push操作被阻塞 在并行时，paralell_while pipeline 的效率要高于concurrent_queue ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:4","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"锁 如果觉得TBB的加锁效率不高，可以自己控制锁，最常用的是spin lock。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:5","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["开源软件"],"content":"Task Scheduler 整个TBB引擎的核心是 Task Scheduler（基于任务图来实现），提高效率的核心是threading stealing，保证cpu的效率。 ","date":"2023-01-16","objectID":"/posts/open_source_software/parallel_computing/tbb/tbb/:1:6","tags":["并行编程框架","TBB"],"title":"开源软件:并行编程框架TBB","uri":"/posts/open_source_software/parallel_computing/tbb/tbb/"},{"categories":["java"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Android NDK JNI之C\u0026C++调用Java NDK-动态和静态库 1. 静态库 1.1. 静态库编译流程 1.2. 静态库使用 2. 动态库 2.1. 动态库编译流程 2.2. 动态库使用 2.3. readelf工具 3. 总结 Android NDK Android NDK JNI之C\u0026C++调用Java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 //使用jni调用java的代码, 必须了解java的反射机制; //在jni中反射调用java代码的话, 一定要写异常处理 // jni中异常处理: if (pEnv-\u003eExceptionCheck()) //这里异常判断一定要写 { pEnv-\u003eExceptionDescribe(); pEnv-\u003eExceptionClear();//如果出现异常,不清除,返回也会崩溃; } //这里就直接贴jni代码了, 详细在注释里说明; //异常处理 #define isException() if (pEnv-\u003eExceptionCheck())\\ {pEnv-\u003eExceptionDescribe();pEnv-\u003eExceptionClear();} JNIEXPORT jint JNICALL Java_org_bing_testjni_MainActivity_Add (JNIEnv *env, jobject obj, jint a, jint b) { //通过包名或的类的类型 //如果是静态函数, 那么第二个参数就是jclass jclass clsMainActivity = pEnv-\u003eFindClass(\"cr25/myjni/MainActivity\"); isException();//异常处理 //获取构造 //参数1: 类的类型jclass //参数2: 构造函数名称, java中所有类的构造函数名都是”\u003cinit\u003e” //参数3: 记录了参数个数, 类型, 返回值类型, 下面会详细说 jmethodID methodConstruct = pEnv-\u003eGetMethodID(clsMainActivity, \"\u003cinit\u003e\", \"()V\"); isException(); //创建类对象 jobject objMain = pEnv-\u003eNewObject(clsMainActivity, methodConstruct); isException(); //获取javaAdd方法地址 jmethodID JavaAdd= pEnv-\u003eGetMethodID(clsMainActivity,\"JavaAdd\", \"(II)I\"); isException(); //执行函数, 注意这个CallXXXMethod, XXX是要根据返回值类型来确定 //如: CallByteMethod, CallStringMethod, CallFloatMethod //因为在JAVA反射中可以用Object统一返回值, C++没法来统一返回值 int resutl = pEnv-\u003eCallIntMethod(objMain , JavaAdd, a, b); //到这里就调用完了函数, 还说一下字段获取与修改 //获取字段 //参数1: jclass //参数2: 字段名 //参数3: 字段类型记录 jfieldID mData = pEnv-\u003eGetFieldID(clsMainActivity, \"mData\", \"I\"); //设置字段的值 pEnv-\u003eSetIntField(objMainActivity, mData, 2); return resutl ; } Daalvik字节码类型描述符 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 单独说一下GetMethodID与GetFieldID第三个参数意义, 其实这些字符串就是代表了参数与返回值类型的的简写; 括号内的代表参数, 括号外代表返回值 如: (II)V I是代表int , V是代表viod, 表示有两个int的参数, 返回值是void类型 如: (Ljava/lang/String;ILjava/lang/String;)J Ljava/lang/String;代表是类的类型, 格式为L[包名]; 注意是”;”结束 J是代表Long 表示有三个参数, String, int, String, 返回值为Long V void 只能用于返回值类型 Z boolean 变量值只能是 真(true) 或 假(false) B byte 字节型 S short 短整型 C char 字符型 I int 整数型 J long（64位） 长整型 F float 浮点型 D double(64位) 双精度浮点型 L java类类型 package.name.ObjectName Lpackage/name/ObjectName; [ 数组类型 [I表示一个整型一维数组，等于java中的int[]。注意多位数数组的维数最大为255个。 [[I=int[][] [[[I=int[][][] NDK-动态和静态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:0:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1. 静态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1.1. 静态库编译流程 gcc——\u003e obj 文件—-\u003e多个obj使用ar—–\u003e静态库文件 需要用到的核心命令: 1 2 3 4 gcc –g –c mod1.c mod2.c mod3.c 编译obj (debug版) AR r libdemo.a mod1.o mod2.o mod3.o 将3个obj 添加到libdemo.a中 AR tv libdemo.a 查看libdemo.a中的obj文件 AR d libdemo.a mod3.o 将mod3.o从libdemo.a中删除 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:1","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"1.2. 静态库使用 代码中包含头文件, 在链接的时候使用libdemo.a链接即可; ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:1:2","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2. 动态库 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.1. 动态库编译流程 gcc——\u003e obj 文件—-\u003e多个obj使用gcc的 -shared—–\u003eso文件 需要用到的核心命令: 1 2 3 4 5 6 7 8 gcc -g -c -fpic -Wall mod1.c mod2.c mod3.c gcc -g -shared mod1.o mod2.o mod3.o -o libfoo.so gcc -g -fpic -Wall -shared mod1.o mod2.o mod3.o -o libfoo.so -fpic 表示代码中地址全部使用相对地址, 不使用绝对地址,解决重定位 -c 只编译不链接 -Wall 显示所有警告 -g 生成Debug版 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:1","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.2. 动态库使用 静态使用 直接把So文件当作obj一起链接到文件, 文件中会存so信息, 在使用时会在目录中搜索so linux动态库搜索顺序: system -\u003e lib -\u003e 环境变量 增加新环境变量, 用于系统搜索到我们的so, 这个环境变量是一次性的 adb shell export LD_LIBRARY_PATH += /data/local/tmp 动态使用 使用api加载指定目录的so, 再使用; dlopen打开一个so文件 dlsym根据函数名拿到函数指针 一个工程代码如果同时有静态和动态编译, 那么就只编译动态库; ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:2","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"2.3. readelf工具 使用readelf工具可以查看elf文件的符号表 命令: 平台-readelf - s elf文件 ,当value值为0表示为导入函数 1 __attribute__() //关键字可以指定函数属性 如: 1 2 __attribute__(visibility(\"hidden\")) // 隐藏函数 __attribute__(visibility(\"defult\")) // 导出函数 以下在so的装载和卸载的时候被调用(老版本, 已经被淘汰, 但是可以用); 1 2 void _init() // 初始化函数 void _fini() // 反初始化函数 在新版本的初始化与反初始化机制中, 可以设置多个函数, 名字可以自定义; 1 2 3 4 void __attribute__((constructor)) OnLoad() // 初始化函数 void __attribute__((destructor)) UnLoad() // 反初始化 void __attribute__((constructor)) OnLoad1() // 初始化函数1 void __attribute__((destructor)) UnLoad1() // 反初始化1 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:2:3","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["java"],"content":"3. 总结 1.相关函数 1 2 3 4 dlopen()函数打开一个共享库 dlsym()函数在库中搜 dlclose() 函数光比之前dlopen打开的库 dlerror() 函数返回一个错误消息的字符串 2.隐藏函数 1 void __attribute__ ((visibility(\"hidden\"))) fun() {} so构造析构(会在so加载和卸载的时候调用) 1 2 void __attribute__ ((constructor)) Load() void __attribute__ ((destructor)) UnLoad() _init()和_fini()函数 会在so加载和卸载时调用 _init函数比构造函数来的早 hidden后在用dlsym函数无法找到 ","date":"2023-01-15","objectID":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/:3:0","tags":["java","jni"],"title":"Android应用中使用C和C++代码","uri":"/posts/program/java/android%E5%BA%94%E7%94%A8%E4%B8%AD%E4%BD%BF%E7%94%A8c%E5%92%8Cc++%E4%BB%A3%E7%A0%81/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 第一部分 bash简介 第二部分 bash示例和书写流程 第三部分 bash基础语法 1. 条件判断 1.1 test判断语句 1.2 []条件判断 1.3 测试逻辑表达式 2. if then else语句 3. case语句 4. for循环 5. until循环 6. while循环 7. 使用break和continue控制循环 第四部分 bash数组 1. 数组定义 2. 数组操作 第五部分 函数 1. 函数定义 2. 函数调用和传参 3. 函数返回值 4. 应用实例 第六部分 数值运算 应用实例一：分别用上面四种方式实现\"3*(5+2)\"。 应用实例二：分别勇上面四种方式实现“数值+1”。 应用实例三：计算1/3,保留3位小数。 第七部分 字符运算 1. 字符串定义 2. 字符串操作 2.1 string操作公式表 2.2 应用实例 第八部分 bash自带参数 第九部分 bash调试 1. bash命令调试 2. echo调试 3. printf 第十部分 bash注释 1. 单行注释 2. 多行注释 第十一部分 bash内建指令 1. 内建命令查看方法 2. 常用内建命令说明 第一部分 bash简介 在介绍bash之前，需要先了解它的起源——shell。 shell俗称壳，它是指UNIX系统下的一个命令解析器；主要用于用户和系统的交互。 UNIX系统上有很多种Shell。首个shell，即Bourne Shell，于1978年在V7(AT\u0026T的第7版)UNIX上推出。后来，又演变出C shell、bash等不同版本的shell。 bash，全称为Bourne-Again Shell。它是一个为GNU项目编写的Unix shell。bash脚本功能非常强大，尤其是在处理自动循环或大的任务方面可节省大量的时间。bash是许多Linux平台的内定Shell，这也是我们介绍它主要的原因。 第二部分 bash示例和书写流程 1 新建文件test.sh $ touch test.sh 2 添加可执行权限 $ chmod +x test.sh 3 编辑test.sh，test.sh内容如下： #!/bin/bash echo \"hello bash\" exit 0 说明： (01) #!/bin/bash : 它是bash文件声明语句，表示是以/bin/bash程序执行该文件。它必须写在文件的第一行！ (02) echo “hello bash” : 表示在终端输出“hello bash” (03) exit 0 : 表示返回0。在bash中，0表示执行成功，其他表示失败。 4 执行bash脚本 $ ./test.sh 在终端输出“bash hello” 第三部分 bash基础语法 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:0:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 条件判断 条件判断有2中格式，分别是“test EXPRESSION”和“[ EXPRESSION ]”。 “test”判断语句，在实际中应用的比较少；相反的，“[]”判断语句应用很广。下面分别对它们进行介绍 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.1 test判断语句 基本格式 test EXPRESSION 格式说明 test是关键字，表示判断； EXPRESSION是被判断的语句。 应用实例 表达式 说明 test -d File 判断File是不是\"目录\" test -f File 判断File是不是\"普通文件\" test -L File 判断File是不是\"符号链接\" test -r File 判断File是不是\"可读\" test -s File 判断File是不是\"文件长度大于0、非空\" test -w File 判断File是不是\"可写\" test -u File 判断File是不是\"有suid位设置\" test -x File 判断File是不是\"可执行\" ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:1","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.2 []条件判断 基本格式 [ EXPRESSION ] 格式说明 中括号的左右扩弧和EXPRESSION之间都必须有空格！ 应用实例 表达式 说明 [ (expr) ] expr为真 [ !expr ] expr为假 [ expr1 -a expr2 ] expr1和expr2同时为真 [ expr1 -o expr2 ] expr1或expr2为真 [ -n string ] string的长度不为0 [ -z string ] string的长度为0 [ string1 = string2 ] 两个字符串string1和string2相等 [ string1 != string2 ] 两个字符串string1和string2不等 [ integer1 -eq integer2 ] 两个integer1和integer2整数相等 [ integer1 -ne integer2 ] integer1不等于integer2 [ integer1 -ge integer2 ] integer1大于或等于integer2 [ integer1 -gt integer2 ] integer1大于integer2 [ integer1 -le integer2 ] integer1小于或等于integer2 [ integer1 -lt integer2 ] integer1小于integer2 [ file1 -ef file2 ] 文件file1和file2有相同的device和inode数目 [ file1 -nt file2 ] file1的修改事件早于file2 [ file1 -ot file2 ] file1的修改事件晚于file2 [ -b file ] file是块设备 [ -c file ] file是字符设备 [ -d file ] file是文件夹 [ -e file ] file是存在 [ -f file ] file是普通文件 [ -g file ] file存在，且有group-ID [ -G file ] file存在，且group-ID是有效的 [ -h file ] file存在，且是一个硬链接 [ -L file ] file存在，且是一个软链接 [ -r file ] file存在，且可读 [ -w file ] file存在，且可写 [ -x file ] file存在，且可执行 例如， 一、判断文件/home/skywang/123.txt是否存在 $ [ -f /home/skywang/123.txt ] 二、判断变量val是否等于字符串“skywang” $ [ \"$val\" = \"skywang\" ] 三，判断变量num是否等于数字100 $ [ \"$num\" -eq \"100\" ] ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:2","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1.3 测试逻辑表达式 基本格式 符号 说明 -a 逻辑与,操作符两边均为真,结果为真,否则为假。 -o 逻辑或,操作符两边一边为真,结果为真,否则为假。 ! 逻辑否,条件为假,结果为真。 应用实例 一、判断文件123.txt是不是可读写 $ [ -r 123.txt -a -w 123.txt ] 等价于 $ [ -r 123.txt ] \u0026\u0026 [ -w 123.txt ] 二、判断变量num是不是等于数字101或102 $ [ \"$num\" -eq \"101\" -o \"$num\" -eq \"102\" ] 等价于 $ [ -r 123.txt ] || [ -w 123.txt ] 三、判断文件123.txt是不是不可读 $ [ ! -r 123.txt ] ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:1:3","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. if then else语句 基本格式 if 条件1 then 命令1 elif 条件2 then 命令2 else 命令3 if 格式说明 if 语句必须以单词 fi 终止。 elif 和 else 为可选项,如果语句中没有否则部分,那么就不需要 elif 和 else 部分。 if 语句可以有许多 elif 部分。最常用的 if 语句是 if then fi 结构。 应用实例 一、判断文件文件123.txt是否存在，存在则输出“file exist”；没有则输出“file not exist”。bash文件内容如下： #!/bin/bash if [ -f 123.txt ];then echo \"file exist\" else echo \"file not exist\" fi exit 0 二、提示用户输入值。若输入的值小于0，则输出“negtive number”；若等于0,则输出“number zero”，否则，输出“positive number”。bash文件内容如下： #!/bin/bash # 提示用户输入一个值 echo -n \"please input a number:\" # 保存用户输入的值到num中 read num if [ \"$num\" -lt \"0\" ];then # 小于0,则输出“negtive number” echo \"negtive number\" elif [ \"$num\" -gt \"0\" ];then # 大于0,则输出“positive number” echo \"positive number\" else # 大于0,则输出\"number zero\" echo \"number zero\" fi exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:2:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. case语句 case语句为多选择语句。可以用case语句匹配一个值与一个模式,如果匹配成功,执行相匹配的命令。 基本格式 case 值 in 模式1} 命令1 ... ;; 模式2) 命令2 ... ;; esac 格式说明 “模式”部分可能包括元字符，即: 符号 说明 * 任意字符。 ? 任意单字符。 [..] 类或范围中任意字符 应用实例 一、提示用户输入Y/y或N/n。若输入Y/y，则输出“yes”；若输入N/n,则输出“no”；否则，“incorrect input”。bash文件内容如下： #!/bin/bash # 提示用户输入一个值 echo -n \"are you femail(Y/N):\" # 保存用户输入的值到val中 read val case $val in Y|y) # 用户输入Y或y echo \"yes\" ;; N|n) # 用户输入N或n \"no\" ;; *) # 其它输入 echo \"incorrect input\" ;; esac exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:3:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"4. for循环 基本格式 for 变量名in列表 do 命令1 命令2... done 格式说明 当变量值在列表里, for循环即执行一次所有命令,使用变量名访问列表中取值。 命令可为任何有效的 shell命令和语句。变量名为任何单词。 in列表用法是可选的,如果不用它, for循环使用命令行的位置参数。 应用实例 一、输入当前文件夹的一级子目录中文件名字。bash脚本内容如下： #!/bin/bash # 将ls的结果保存到变量CUR_DIR中 CUR_DIR=`ls` # 显示ls的结果 echo $CUR_DIR for val in $CUR_DIR do # 若val是文件，则输出该文件名 if [ -f $val ];then echo \"FILE: $val\" fi done exit 0 二、输出1-10之间数字的总和。bash脚本内容如下： #!/bin/bash sum=0 for ((i=1;i\u003c10;i++)) do ((sum=$sum+$i)) done echo \"sum=$sum\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:4:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"5. until循环 until循环执行一系列命令直至条件为真时停止。 until循环与 while循环在处理方式上刚好相反。一般 while循环优于until循环,但在某些时候 — 也只是极少数情况下, until循环更加有用。 基本格式 until 条件 命令1 ... done 格式说明 条件可为任意测试条件,测试发生在循环末尾,因此循环至少执行一次 — 请注意这一点。 应用实例 一、从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 until [ \"$val\" -eq \"5\" ] do # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) done exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:5:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"6. while循环 基本格式 while 命令 do 命令1 命令2 ... done 应用实例 一、从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while [ \"$val\" -lt \"5\" ] do # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) done exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:6:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"7. 使用break和continue控制循环 基本格式 break命令允许跳出循环。 continue命令类似于 break命令,只有一点重要差别,它不会跳出循环,只是跳过这个循环步。 应用实例 一、[break应用]从0开始逐步递增，当数值等于5时，停止递增。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while true do if [ \"$val\" -eq \"5\" ];then # 如果val=5，则跳出循环 break; else # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) fi done exit 0 二、[continue应用]从0开始逐步递增到10：当数值为5时，将数值递增2；否则，输出数值。Bash脚本内容如下： #!/bin/bash # 设置起始值为0 val=0 while [ \"$val\" -le \"10\" ] do if [ \"$val\" -eq \"5\" ];then # 如果val=5，则将数值加2 ((val=$val+2)) continue; else # 输出数值 echo \"val=$val\" # 将数值加1 ((val++)) fi done exit 0 第四部分 bash数组 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:7:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 数组定义 方法一 array=(10 20 30 40 50) 一对括号表示是数组，数组元素用“空格”符号分割开。引用数组时从序号0开始。 方法二 array[0]=10 array[1]=20 array[2]=30 array[3]=40 array[4]=50 方法三 var=\"10 20 30 40 50\"; array=($var) ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:8:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 数组操作 (01) 显示数组中第2项 $ echo ${array[i]} 说明：数组是从序号0开始计算(即第1项为array[0])。 (02) 显示数组中的所有元素 $ echo ${array[@]} 或者 $ echo ${array[*]} (03) 显示数组长度 $ echo ${#array[@]} 或者 $ echo ${#array[*]} (04) 删除数组第2项元素 $ unset array[1] 说明：unset仅仅只清除array[1]的值，并没有将array[1]删除掉 (05) 删除整个数组 $ unset array (06) 输出数组的第1-3项 $ echo ${array[@]:0:3} 说明：参考“${数组名[@或*]:起始位置:长度}” (07) 将数组中的0替换成1 $ echo ${a[@]/0/1} 说明：${数组名[@或*]/查找字符/替换字符 第五部分 函数 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:9:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 函数定义 基本格式 function 函数名() { ... } 格式说明 function可有可无。但建议保留，因为保留的话看起来更加直观。 应用实例 function foo() { # 定义局部变量i local i=0 # 定义局部变量total=传入foo的参数总数 local total=$# # 输出参数总数 echo \"total param =$total\" # 输出传入foo的每一个参数 for val in $@ do ((i++)) echo \"$i -- val=$val\" done # 返回参数总数 return $total } ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:10:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 函数调用和传参 调用方法 直接通过函数名去调用。 应用实例 foo param1 param2 param3 说明：调用函数foo，并传入param1 param2 param3三个参数 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:11:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. 函数返回值 使用方法 return 返回值 方法说明 例如，foo param1 param2 param3之后，再调用$?就是上次调用的返回值 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:12:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"4. 应用实例 编辑一个函数foo：打印foo的输入参数的总数，并输入每个参数和参数对应的序号。 #!/bin/bash function foo() { # 定义局部变量i local i=0 # 定义局部变量total=传入foo的参数总数 local total=$# # 输出参数总数 echo \"total param =$total\" # 输出传入foo的每一个参数 for val in $@ do ((i++)) echo \"$i -- val=$val\" done # 返回参数总数 return $total } foo foo param1 param2 param3 # 输出foo param1 param2 param3的返回值 echo \"return value=$?\" exit 0 输出结果: total param =0 total param =3 1 -- val=param1 2 -- val=param2 3 -- val=param3 return value=3 第六部分 数值运算 数值比较请参考\"第三部分\"的1.2节，本部分只介绍数值运算。 常用的4种数值运算说明 数值元算主要有4种实现方式：(())、let、expr、bc。 工作效率：(()) == let \u003e expr \u003e bc (01), (())和let是bash内建命令，执行效率高；而expr和bc是系统命令，会消耗内存，执行效率低。 (02), (())、let和expr只支持整数运算，不支持浮点运算；而bc支持浮点运算。 下面分别介绍这4种实现方式的使用方法。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:13:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例一：分别用上面四种方式实现\"3*(5+2)\"。 #!/bin/bash # 数值i=3*(5+2) (方法一:$(())实现) val=$((3*(5+2))) echo \"val=$val\" # 数值i=3*(5+2) (方法二:let实现) let \"val=3*(5+2)\" echo \"val=$val\" # 数值i=3*(5+2) (方法三:expr实现) val=`expr 3 \\* \\( 5 + 2 \\)` echo \"val=$val\" # 数值i=3*(5+2) (方法四:bc实现) val=`echo \"3*(5+2)\"|bc` echo \"val=$val\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:14:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例二：分别勇上面四种方式实现“数值+1”。 #!/bin/bash val=0 # 数值加1 (方法一) ((val++)) echo \"val=$val\" val=0 # 数值加1 (方法二) let val++ echo \"val=$val\" val=0 # 数值加1 (方法三) val=`expr $val + 1` echo \"val=$val\" val=0 # 数值加1(方法四) val=`echo \"$val+1\"|bc` echo \"val=$val\" exit 0 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:15:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"应用实例三：计算1/3,保留3位小数。 #!/bin/bash # 数值i=3*(5+2) (方法四:bc实现) val=`echo \"scale=3; 1/3\"|bc` echo \"val=$val\" exit 0 第七部分 字符运算 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:16:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 字符串定义 表达式 说明 ${var} 变量var的值, 与$var相同 ${var-DEFAULT} 如果var没有被声明, 那么就以$DEFAULT作为其值 ${var:-DEFAULT} 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 ${var=DEFAULT} 如果var没有被声明, 那么就以$DEFAULT作为其值 ${var:=DEFAULT} 如果var没有被声明, 或者其值为空, 那么就以$DEFAULT作为其值 ${var+OTHER} 如果var声明了, 那么其值就是$OTHER, 否则就为null字符串 ${var:+OTHER} 如果var被设置了, 那么其值就是$OTHER, 否则就为null字符串 ${var?ERR_MSG} 如果var没被声明, 那么就打印$ERR_MSG ${var:?ERR_MSG} 如果var没被设置, 那么就打印$ERR_MSG ${!varprefix*} 匹配之前所有以varprefix开头进行声明的变量 ${!varprefix@} 匹配之前所有以varprefix开头进行声明的变量 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:17:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 字符串操作 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2.1 string操作公式表 表达式 说明 ${#string} $string的长度 ${string:position} 在$string中, 从位置$position开始提取子串 ${string:position:length} 在$string中, 从位置$position开始提取长度为$length的子串 ${string#substring} 从变量$string的开头, 删除最短匹配$substring的子串 ${string##substring} 从变量$string的开头, 删除最长匹配$substring的子串 ${string%substring} 从变量$string的结尾, 删除最短匹配$substring的子串 ${string%%substring} 从变量$string的结尾, 删除最长匹配$substring的子串 ${string/substring/replacement} 使用$replacement, 来代替第一个匹配的$substring ${string//substring/replacement} 使用$replacement, 代替所有匹配的$substring ${string/#substring/replacement} 如果$string的前缀匹配$substring, 那么就用$replacement来代替匹配到的$substring ${string/%substring/replacement} 如果$string的后缀匹配$substring, 那么就用$replacement来代替匹配到的$substring ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:1","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2.2 应用实例 首先，我们定义个str字符串变量，然后再对此变量进行字符串操作。 $ str=\"hello world\" (01) 显示字符串长度 $ echo ${#str} (02) 提取world $ echo ${str:6} (03) 提取or $ echo ${str:7:2} (04) 删除hello $ echo ${str#hello} 或 $ echo ${str#*lo} (05) 删除world $ echo ${str%world} 或 $ echo ${str%wo*} (06) 将所有的字符“l”替换为“m” $ echo ${str//l/m} 第八部分 bash自带参数 表达式 说明 $? 上次指令或程序的执行结果。如果执行成功则为0，否则为非0 $# 参数个数 $@ 代表全部变量，例如，\"$1\" “$2” “$3” “$4”，每个变量是独立的，且用双引号括起来 $* 代表全部变量，例如，$1 $2 $3 $4 $- 在shell启动或使用set命令时提供选项 $$ 当前shell的进程号 $0 当前shell进程名 $n n表示数字。例如，$1表示第1个参数，$2表示第2个参数 第九部分 bash调试 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:18:2","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. bash命令调试 bash [-nvx] scripts.sh 选项与参数: -n :不要执行 script,仅查询语法的问题; -v :再执行 sccript 前,先将 scripts 的内容输出到屏幕上; -x :将使用到的 script 内容显示到屏幕上,这是很有用的参数! 例如，想要执行bash脚本，并查看bash的调用流程，可以通过以下命令： $ bash -x test.sh ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:19:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. echo调试 echo [OPTION] STRING 说明： -n : 输出内容之后，不换行。默认是输入内容之后，换行。 -e : 开启反斜线“\\”转义功能 -E : 开启反斜线“\\”转义功能（默认）。 例如，输出“please input a number:”之后不换行。 $ echo -n \"please input a number:\" ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:20:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"3. printf 和echo一样，printf也能用于输出。语法格式和C语言中printf一样。 例如，输出“hello printf”之后换行。 $ printf \"hello printf\\n\" 第十部分 bash注释 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:21:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 单行注释 # echo \"single line\" 说明：#放在文件开头，表示注释掉本行。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:22:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 多行注释 可以通过以下两种方法实现多行注释： :||{ ....被注释的多行内容 } 或者 if false ; then ....被注释的多行内容 fi 第十一部分 bash内建指令 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:23:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"1. 内建命令查看方法 基本格式 type cmd 格式说明 type是命令关键字，cmd表示查看的命令；若输出builtin，则该命令是bash的内建命令。 例如: $ type echo 除此之外，用户也可以通过man bash或者man builtins查看bash的全部内置命令. ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:24:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"2. 常用内建命令说明 指令 使用示例 说明 echo echo arg 在屏幕上显示出由arg指定的字串 read read变量名表 从标准输入设备读入一行，分解成若干字，赋值给bash程序内部定义的变量 shift shift [N] (N为大于0的整数；当N省略时，等价与于“shift 1”) 所有的参数依次向左移动N个位置，并使用$#减少N，直到$#=0为止。 alias alias name=‘value’ 别名。用name替换value，value要用单引号括住。 export export变量名[=变量值] export可以把bash的变量向下带入子bash(即子bash中可以使用父bash的变量)，从而让子进程继承父进程中的环境变量。但子bash不能用export把它的变量向上带入父bash。 readonly readonly 变量名 定义只读变量。不带任何参数的readonly命令将显示出所有只读变量。 exec exec 命令参数 当bash执行到exec语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时，该进程（也就是最初的bash）就终止了，所以bash程序中exec后面的语句将不再被执行。 “.\"(点) bash程序文件名 使bash读入指定的bash程序文件并依次执行文件中的所有语句。 exit exit N 退出Shell程序。在exit之后可有选择地指定一个数位作为返回状态。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_01/:25:0","tags":["bash"],"title":"bash 编程笔记 (一)","uri":"/posts/program/bash/bash_note_01/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_03/","tags":["bash"],"title":"bash 编程笔记 (三)","uri":"/posts/program/bash/bash_note_03/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 实例一：备份/更新文件的脚本 实例一：备份/更新文件的脚本 编写一个脚本文件backup.sh，备份android、kernel或uboot中的文件，备份的时候要保留文件在备份文件夹(即保留文件的相对路径)。 (01) 新建list_file.txt，并在list_file.txt中记录要备份的文件的路径。 (02) 当执行“./backup.sh bb”命令时：backup.sh会新建bb目录，然后读取list_file.txt中记录的文件路径，并将记录的文件路径对应的文件备份到bb目录下。 (03) 当执行“./backup.sh tt”命令时，backup.sh会判断是否存在tt目录，若存在tt目录的话，则tt中的文件更新到list_file.txt所记录的文件路径；否则的话，不更新文件。 脚本内容如下： #!/bin/bash ##############################NOTE############################ # # AUTHOR : skyWang # DATE : 2012-07-16 # DESCRIPTION : 用于备份文件 or 更新文件 # # 1. 备份文件 # (1) 备份命令 : ./run.sh bb # (2) 备份文件所在目录: bb # 这个是在步骤(1)之后，在当前目录下自动建立bb目录 # # 2. 更新文件 # (1) 更新命令 : ./run.sh tt # (2) 更新文件所在目录: tt # 这个是必须在步骤(1)之前已经存在的目录。因为，就是为了用tt目录中的文件去替换到目标文件。 # # OTHER : 1. list_file.txt 文件说明(即，list_file.txt中的文件必须满足一下条件）： # “变量COMMPATH_PATH的值”和“list_file.txt中的每一行内容”组合起来得到的完整路径所对应的文件，必须存在！ # # 例如： COMMON_PATH=/root/ # list_file.txt中有以下1行内容： # android/build/core/Makefile # 这样，“变量COMMPATH_PATH的值”和“list_file.txt中的行”组合起来得到的完整路径就是： # /root/android/build/core/Makefile # # “/root/android/build/core/Makefile”这个文件必须存在于电脑中。 # # （1）若list_file.txt满足以上条件，运行“./run.sh bb”就可以备份“/root/android/build/core/Makefile”。 # 备份时，会自动(在当前目录下)建立目录“bb”，并将文件备份到“bb”目录下 # （2）若将bb目录重命名成tt，运行“./run.sh tt”就可以将“tt”中的文件更新到“/root/android/build/core/Makefile”。 # # ##############################NOTE############################ #########TODO...START######### # 假设android、kernel、uboot在同一级目录； # 则，COMMON_PATH是它们所在目录的路径。 COMMON_PATH=/home/skywang/a8/gingerbread/code/ #########TODO...END########### #########CONSTANT...START######### LIST_FILE=\"list_file.txt\" B_FOLDER=\"bb/\" T_FOLDER=\"tt/\" # android工程的文件夹名字 ANDROID_FOLDER=\"android\" # kernel工程的文件夹名字 KERNEL_FOLDER=\"kernel\" # uboot工程的文件夹名字 UBOOT_FOLDER=\"uboot\" # android长度 ANDROID_FOLDER_LEN=`expr length \"$ANDROID_FOLDER\"` # kernel长度 KERNEL_FOLDER_LEN=`expr length \"$KERNEL_FOLDER\"` # uboot长度 UBOOT_FOLDER_LEN=`expr length \"$UBOOT_FOLDER\"` #########CONSTANT...END########### # 功能说明：根据源文件和目标文件所在完整路径，将源文件更新到目标文件 # 更新成功的话，输出更新的起止路径；否则，打印错误信息 # 输入参数：src_full_path —— 源文件所在完整路径。 # dst_full_path —— 目标文件所在完整路径。 # 例如：src_full_path=\"tt/android/hardware/libsensor/sensors.cpp\" # dst_full_path=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/code/android/hardware/libsensor/sensors.cpp\" function func_update_file_by_path() { local src_full_path=$1 local dst_full_path=$2 local dst_full_dir=`dirname $dst_full_path` if [ -f \"$src_full_path\" ];then if [ -e \"$dst_full_path\" ] || [ -d \"$dst_full_dir\" ];then cp -v $src_full_path $dst_full_path else mkdir -p $dst_full_dir cp -v $src_full_path $dst_full_path fi else echo copy file ERROR: echo file $src_full_path not existes!!! fi } # 功能说明：将“输入文件”中全部文件全部更新到代码中 # 更新成功的话，输出更新的起止路径；否则，打印错误信息 # 输入参数：input_file —— “输入文件”所在的完整路径 # 例如：input_file=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/backup/exmaple/list_file.txt\" function func_push_files() { local input_file=$1 local full_path local backup_path local count=0 while read -r line do let count=`expr $count + 1` if [ `expr match $line $ANDROID_FOLDER` == \"$ANDROID_FOLDER_LEN\" ] || [ `expr match $line $KERNEL_FOLDER` == \"$KERNEL_FOLDER_LEN\" ] || [ `expr match $line $UBOOT_FOLDER` == \"$UBOOT_FOLDER_LEN\" ];then echo \"$count : right push path\" src_path=${T_FOLDER}${line} dst_path=${COMMON_PATH}${line} func_update_file_by_path $src_path $dst_path else echo \"$count : push file $line is invalidate!\" fi done \u003c $input_file } # 功能说明：根据源文件所在完整路径，将源文件拷贝到另一个目录下 # 备份成功的话，输出备份的起止路径；否则，打印错误信息 # 输入参数：src_full_path —— 源文件所在完整路径。 # dst_full_dir —— 目标路径 # 例如：src_full_path=\"/home/skywang/mnt/sda6/a8/a72/3g/iceCreamSandwish/code/android/hardware/libsensor/sensors.cpp\" # dst_full_dir=\"bb/android/hardware/libsensor/\" function func_backup_file_by_path() { local src_full_path=$1 local dst_full_dir=$2\"/\" if [ -f \"$src_full_path\" ];then if [ -d \"$dst_full_dir\" ];then cp -v $src_full_path $dst_full_dir else mkdir -p $dst_full_dir cp -v $src_full_path $dst_full_dir fi else echo back","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_03/:0:0","tags":["bash"],"title":"bash 编程笔记 (三)","uri":"/posts/program/bash/bash_note_03/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 第一部分 awk工具 1. awk介绍 第二部分 sed工具 1. sed介绍 第三部分 正则表达式和grep 1. 正则表达式 2. 正则表达式特殊符号 3. grep表达式 4. 应用实例 5. egrep 5.1. egrep说明 5.2. egrep应用实例 本文主要通过实例对bash中需要用到的一些高级工具(如awk、sed、…)进行说明。 学习的时候，请以“应用实例”为中心，以其它内容为参考进行学习。如果遇到文章中未讲解的内容，可以通过man去查阅用法。 第一部分 awk工具 本章主要通过awk的一些应用实例，来说明awk的相关语法。这样，更利于我们进行理解；所以，阅读本章时，请以“应用实例”为中心进行阅读，其它部分是参考内容。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:0:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. awk介绍 awk是一种用于处理文本的编程语言工具。awk本身就是linux下的一个工具，既可以单独使用，也可以嵌入到bash中。 awk语言的最基本功能是在文件或字符串中基于指定规则浏览和抽取信息。 awk抽取信息后,才能进行其他文本操作。完整的 awk脚本通常用来格式化文本文件中的信息。 ## 2. awk环境变量 变量 说明 $n 当前记录的第n个字段，字段由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认是%.6g) ENVIRON 环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 同NR，当FNR是相对于当前文件而言 FS 字段分隔符(默认是任意的空格符) IGNORECASE 若为真，则匹配时忽略大小写 NF 当前记录中的字段数 NR 已读的记录数 OFMT 数字的输出格式(默认是%.6g) OFS 输出域分隔符(默认是一个空格) ORS 输出记录分隔符(默认是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 控制记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数字下标分隔符(默认值是\\034) ## 3. awk条件操作符 符号 描述 \u003c 小于 \u003c= 小于或等于 == 等于 != 不等于 \u003e= 大于或等于 \u003e 大于 ! 匹配正则表达式 !~ 不匹配正则表达式 ## 4. awk字符串操作 表达式 说明 gsub(r,s) 在整个$0中用s替换r gsub(r,s,t) 在整个t中用s替换r index(s,t) 返回s中字符串t的第一个位置 length(s) 返回s的长度 match(s,r) 测试s是否包含匹配r的字符串 split(s,a,fs) 在fs上将s分成序列a sprint(fmt,exp) 返回经fmt格式化后的exp sub(r,s) 用$0中最左边最长的子串代替s substr(s,p) 返回字符串s中从p开始的后缀部分 substr(s,p,n) 返回字符串s中从p开始的长度为n后缀部分 ## 5. 正则表达式中常用类 表达式 说明 [[:upper:]] [A-Z] [[:lower:]] [a-z] [[:alpha:]] [a-zA-Z] [[:digit:]] [0-9] [[:alnum:]] [0-9a-zA-Z] [[:space:]] 空格或tab键 ## 6 awk应用实例 首先建立一个123.txt，添加任意文本，然后进行以下练习。 (01), 输出文件全部文本 $ awk '{print $0}' 123.txt 说明: {}：表示一段awk命令。 print：输出指令。 $0：当前行的全部文本。 awk工具操作文件时，是以行为单位，逐步对每行进行操作。拿本例来说{print $0}，意味着“对每一行都执行print $0操作，即输出每一行的全部文本”。 $N：当N\u003e1时，$N表示当前行的第N段；每一行中以FS(默认值是空格)来分段。 (02), 输出\"ls -l\"中每行的field1、field9 $ ls -l | awk '{printf(\"%s %s\\n\", $1, $9)}' 说明: |：管道符号。表示将“前面指令的输出”作为“后面指令的输入”，即将“ls -l”的输出作为“awk”的输入。 printf：输出指令。它的使用方法和C语言中printf的使用方法一样。 $1：该行的第1段。 $9：该行的第9端。 (03), 在上一题的基础上添加功能：第一，输出每一行的行号和该行所包括的域的总数。第二，第1行和最后一行输出提示语 $ ls -l | awk 'BEGIN{printf(\"----begin----\\n\")} {printf(\"Line-%3d Field-%d : %s %s\\n\", NR, NF, $1, $9)} END{printf(\"----end----\\n\")}' 说明： BEGIN：表示在文本进行操作之前进行的工作。 END：表示在对文本的所有行都处理完毕之后前进行的工作。 在awk中，请尽量使用{}来进行区分指令段，{}可以嵌套使用！这样做的好处写出的脚本不容易出错，而且可读性更强！ (04), 输出\"ls -l\"中文件(夹)名字包括数字的完整信息 $ ls -l | awk '{if($9 ~ /[[:digit:]]/) {print $0}}' 说明： $9 ~ /[[:digit:]]/ ： 表示能够匹配数字的“第一行的第9段”。 (05), 输出\"ls -l\"中非文件夹的完整信息 $ ls -l | awk '{if($1 !~ /^d/) {print $0}}' 说明： ^d ： 以d开头的。^表示起始位。此外，$表示结束位。如d$，表示以d结尾的。 (06), 找到\"ls -l\"中文件(夹)名字的长度大于10的行，然后输出其完整信息。 $ ls -l | awk '{if(length($9) \u003e 10) {print $0}}' (07), 如何给文本的每一行添加行号？ $ awk '{printf(\"%03d %s\\n\",NR, $0)}' ori.txt \u003e dst.txt (08), 打印字段数大于3的行的总数 $ awk 'BEGIN{COUNT=0}; {if(NF\u003e3) COUNT++}; END{printf(\"COUNT=%d\\n\", COUNT)}' ori.txt (09), 将文本中的各行合并一行，中间用“|”分割 $ awk 'BEGIN{ORS=\"|\"}{print $0 }END{print \"\\n\"}' ori.txt \u003e dst.txt 说明： ORS：表示记录分割符，每条记录表示每行。ORS默认值为换行符。 (10), 将文本中空格换成换行符 $ awk 'BEGIN{FS=\" \";OFS=\"\\n\"}{print $1 }END{print \"\\n\"}' ori.txt \u003e dst.txt (11), 将3行合并成一行，并输入行号 $ awk 'BEGIN{ORS=\"\";i=0}{ j=1; while(j\u003c=NF){ if(i%3==0){printf(\"%02d \",i/3+1)}; printf(\"%s \",$j); i++; j++; if(i%3==0){print \"\\n\"} }} END{print \"\\n\"}' ori.txt \u003e dst.txt 第二部分 sed工具 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:1:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. sed介绍 sed是一个非交互性文本流编辑器。和awk一样，它是个独立的工具，当然也可以和bash联合使用。 它可以随意编辑文件或标准输入,对它们进行编辑、删除。它能一次性处理所有改变,对用户来讲,十分高效。sed编辑文件或标准输入时，编辑的是它们的拷贝；也就是说，不会改变原始的文件。若需要保存修改，可以通过重定向操作符»、»\u003e,或者在利用sed的写入参数。 ## 2. 基本格式 sed [选项] 输入文件 -n 不打印;sed不写编辑行到标准输出,缺省为打印所有行(编辑和未编辑)。 -p 命令可以用来打印编辑行。 -c 下一命令是编辑命令。使用多项编辑时加入此选项。如果只用到一条 sed命令,此选项无用,但指定它也没有关系。 -e 追加执行脚本 -f 如果正在调用 sed脚本文件,使用此选项。 ## 3. 使用sed在文件中定位文本的方式 方式 说明 x x为行号。例如，1 x,y 表示行号范围从x到y。例如，2,5表示从第2行到第5行 x,y! 查询不包含指定行(x到y) /pattern/ 查询包含pattern模式的行。例如, /disk/或/[a-z]/ pattern/,x 在给定行号上查询包含pattern模式的行。例如， /ribbon/,3 x,/pattern/ 通过行号和模式查询匹配行。 例如， 3,/vdu/ ## 4. sed编辑命令 方式 说明 p 打印匹配行 = 显示文件行号 a\\ 在定位行后附加文本信息 i\\ 在定位行前附加文本信息 d 删除定位行 c\\ 用新文本替换定位文本 s 使用替换模式 r 从另一个文件中读文本 w 写文本到一个文件 q 第一个模式匹配完成后退出 {} 在定位行指定的命令组 n 从另一个文件中读取，并追加在下一行 ## 5. 应用实例 首先建立一个123.txt，添加任意文本，然后进行以下练习。 (01), 输出文件第5行 $ sed -n '5p' 123.txt 说明：-n表示默认不输出任何内容。5p表示输出第5行：5表示第5行，p表示输出。 (02), 输出文件除1-3行之外的行 $ sed -n '1,3!p' 123.txt 说明： “1,3\"表示输出范围是第1-3行; “1,3!“表示输出范围是除第1-3行之外。 ‘1,$p’表示输出全部行，因为$表示最后一行。 (03), 输出\"ls -l\"结果中的第1-3行 $ ls -l |sed -n '1,3p' 说明：|是管道符号，表示将ls -l的输出作为sed的输入。 (04), 输出匹配“the”的行 $ sed -n '/the/p' 123.txt 说明：/the/表示匹配the的行 (05), 输出匹配“the”的行，并且输出每行行号 $ sed -n -e '/the/p' -e '/the/=' 123.txt 说明：-e表示对每行进行多重编辑，多重编辑的每一个命令前都需要添加-e。 本例中，-e ‘/the/p’打印匹配the的行；-e ‘/the/=‘表示输出匹配the的行的行号。 (06), 删除匹配“the”的行 $ sed '/the/d' 123.txt 说明：d表示删除。 (07), 删除匹配“the”的行；然后输出删除操作之后的所有行，并输出每行行号 $ sed '/the/d' 123.txt | sed -n -e '1,$p' -e '1,$=' 说明： sed ‘/the/d’ 123.txt ：得到了删除“the”之后的行 | ：管道符号。意味着前面的输出作为后面的输入 sed -n -e ‘1,$p’ -e ‘1,$=’ ：表示输出全部行之后，在输出每行行号 (08), 在每一行前面插入2行文本，第一行是line1,第2行是line2 $ sed '1,$iline1\\nline2' 123.txt 说明： 1,$i表示第一行到最后一行的每一行都执行插入操作。 line1\\nline2表示插入的文本，其中\\n转义之后表示“换行”符号。 (09), 在最后一行后面插入1行文本，内容是end $ sed '$aend' 123.txt 说明：$表示最后一行，a表示在文本后插入，end是插入的内容 (10), 将“this”全部替换成“that” $ sed 's/this/that/g' 123.txt 说明： [ address[,address ] ] s / pattern-to-find / replacement-pattern/[gpwn] s 表示替换操作。查询pattern-to-find,成功后用replacement-pattern替换它。 替换选项如下: g 缺省情况下只替换每行的第一次匹配，g表示替换每行的所有匹配。 p 缺省sed将所有被替换行写入标准输出，加p选项将使-n选项无效。-n选项不打印输出结果。 w 后接“文件名”，表示将输出定向到一个文件。 (11), 将“this”全部替换成“this boy” $ sed 's/this/this boy/g' 123.txt 或 $ sed 's/this/boy \u0026/g' 123.txt 说明： sed ’s/this/boy \u0026/pg’ 123.txt中\u0026表示附加修改(即在原始内容的基础上添加内容)。 \u0026表示匹配的内容。即，boy \u0026等价于boy this (12), 去掉空白行后另存文件 $ sed '/^$/d' 123.txt \u003e 456.txt 或 $ sed '/^$/c\\' 123.txt \u003e 456.txt 说明： /^$/表示空白行：^表示开启，$表示结尾，开始和结尾之间没有任何内容，即是空白行。 c\\表示修改。 (13), 去掉文件扩展名 $ echo \"hello.txt\"| sed 's/.txt//g' (14), 添加文件扩展名 $ echo \"hello\"| sed 's/$/.txt/g' (15), 删除文本中每一行的第2个字符 $ sed 's/.//2' ori.txt \u003e dst.txt (16), 删除文本中每一行的倒数第2个字符 $ sed 's/\\(.\\)\\(.\\)$/\\2/' ori.txt \u003e dst.txt 说明：考察了sed中”( )“的含义和用法 (17), 删除每一行的第2个单词 $ sed 's/\\([[:alpha:]]\\+\\)\\(\\ \\)\\([[:alpha:]]\\+\\)*/\\1/' ori.txt \u003e dst.txt (18), 隔行删除 $ sed '0~2 d' ori.txt \u003e dst.txt 第三部分 正则表达式和grep ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:2:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"1. 正则表达式 正则表达式就是字符串的表达式。它能通过具有意义的特殊符号表示一列或多列字符串。 grep是linux系统下常用的正则表达式工具，可以使用grep来检索文本等输入流的字符串。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:3:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"2. 正则表达式特殊符号 表达式 说明 ^ 匹配行首 $ 匹配行尾 . 任意字符 * 匹配0～N个某字符或某表达式。例如， [a-z]*表示匹配0到多个小写字母 [] 匹配中括号类的字符。中括号内可以用-表示范围，例如，[1-5]等价于[12345] \\ 屏蔽具有字符的特殊含义 \u003c 匹配以某内容为开始的项。例如， \u003cst表示匹配以st开始的项 \u003e 匹配以某内容为结束的项。例如， nd\u003e表示匹配以end结尾的项 string{m,n} 连续m到n个string string{m} 出现m次string string{m} 至少出现m次string [[:upper:]] A-Z的任意大写字母 [[:lower:]] a-z的任意小写字母 [[:alpha:]] 任意字母 [[:digit:]] 0-9的任意数字 [[:xdigit:]] 十六禁止的数字类型，包括：0-9，A-F，a-f [[:alnum:]] 任意字母或数字 [[:blank:]] 空格或tab键 [[:space:]] 任何会产生空白的字母，包括空格、TAB、CR等 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:4:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"3. grep表达式 基本格式 grep [OPTIONS] PATTERN [FILE...] 格式说明 PATTERN : 匹配模式。可以是字符串，也可以是正则表达式。 [FILE…] : 是grep搜索的文件(集) [OPTIONS] : 是grep的选项。常用的选项有以下选项。 -c : 只输出匹配行的计数。 -I : 不区分大 小写(只适用于单字符)。 -h : 查询多文件时不显示文件名。 -l : 查询多文件时只输出包含匹配字符的文件名。 -n : 显示匹配行及 行号。 -s : 不显示不存在或无匹配文本的错误信息。 -v : 显示不包含匹配文本的所有行。 -r : 当FILE中包含文件夹名时，遍历该文件夹的所有子目录；默认情况下，不会遍历子目录。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:5:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"4. 应用实例 下面以input.txt为例，对grep进行说明。input.txt的文本内容如下： \"Open Source\" is a good mechanism to develop programs. apple is my favorite food. Football game is not use feet only. this dress doesn't fit me. However, this dress is about $ 3183 dollars.^M GNU is free air not free beer.^M Her hair is very beauty.^M I can't finish the test.^M Oh! The soup taste good.^M motorcycle is cheap than car. This window is clear. the symbol '*' is represented as start. Oh! My god! The gd software is a library for drafting programs.^M You are the best is mean you are the no. 1. The world \u003cHappy\u003e is the same with \"glad\". I like dog. google is the best tools for search keyword. goooooogle yes! go! go! Let's go (01), 查找包含“the”的行，并显示行号。 $ grep -n \"the\" input.txt 说明：-n表示显示“行号” (02), 不区分大小写，查找包括“the”的行，并显示行号。 $ grep -in \"the\" input.txt 说明：-n表示显示“行号”；-i表示不区分大小写，即ignore大小写。 (03), 查找不包括“the”的行，统计行数。 $ grep -cv \"the\" input.txt 说明：-c表示统计(count)；-v表示不匹配的项。 (04), 查找“当前目录”及其“所有子目录”中包含“the”的文件，并显示“the”在其中的行号。 $ grep -rn \"the\" . 说明：-r表示递归查找；-n表示显示行号。 (05), 查找匹配“t?st”的项，其中?为任意字符。 $ grep -n \"t.st\" input.txt 说明：.表示匹配任意字符 (06), 查找包含数字的行 $ grep -n \"[0-9]\" input.txt 或 $ grep -n \"[[:digit:]]\" input.txt 说明：[0-9]表示0-9之间的一个数字；[[:digit:]]也表示0-9之间的一个数字 (07), 查找以the开头的行 $ grep -n \"^the\" input.txt 说明：\"^the\"表示以the开头 (08), 查找以小写字母结尾的行。 $ grep -n \"[a-z]$\" input.txt 说明：[a-z]表示一个小写字母，$表示结束符；[a-z]$表示以小写字母结束的项。 (09), 查找空白行。 $ grep -n \"^$\" input.txt 说明：^表示开头，如^t表示以字母t开头；$表示结尾，如e$表示以e结尾。^$表示空白行。 (10), 查找以字母g开头的单词 $ grep -n \"\\\u003cg\" input.txt 说明：\u003c表示单词的开始，\u003cg表示以g开始的单词。 (11), 查找字符串为go的单词。注意：不能包括goo,good等字符串 $ grep -n \"\\\u003cgo\\\u003e\" input.txt 说明：\u003c表示单词的开始，\u003e表示单词结尾。\u003cgo\u003e表示以字母g开头，以字母o结尾。 (12), 查找包括2-5个字母o的行。 $ grep -n \"o\\{2,5\\}\" input.txt 说明：pattern{n,m}表示n到m个pattern。o{2,5}表示2-5个字母o。 (13), 查找包括2个以上字母o(包括2个)的行。 $ grep -n \"ooo*\" input.txt 或 $ grep -n \"oo\\+\" input.txt 或 $ grep -n \"o\\{2,\\}\" input.txt 说明： ooo*: 前面两个oo表示匹配2个字母o，后面的o*表示匹配0到多个字母o。 oo+: 第一个字母o表示匹配单个字母o；最后的“o+”一起发挥作用，其中，+是转义后的+，表示1到多个；而o+表示1到多个字母o。 pattern{n,}表示多于n个pattern。o{2,}表示多于2个字母o。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:6:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5. egrep ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:0","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5.1 egrep说明 egrep是扩展的grep，即它的功能比grep更多一些。“egrep\"等价于\"grep -e”。 egrep相比与grep，支持括号“()”以及操作符“|”(表示或)。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:1","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["bash"],"content":"5.2 egrep应用实例 仍然以上面的input.txt为输入文本进行说明 (01), 查找包含the或者this的行 $ egrep -n \"the|this\" input.txt 说明：-n表示输出匹配项的行号，“the|this\"表示包括the或者包括this的项。 (02), 查找包含the或者this的行 $ egrep -vn \"(the|this)\" input.txt 说明：-n表示输出匹配项的行号，“the|this\"表示包括the或者包括this的项；-v表示匹配的对立面。即 -v “the|this\"表示既不包括the又不包括this的项。 ","date":"2023-01-15","objectID":"/posts/program/bash/bash_note_02/:7:2","tags":["bash"],"title":"bash 编程笔记 (二)","uri":"/posts/program/bash/bash_note_02/"},{"categories":["cpp"],"content":"整理部分现代C++作用在函数后的关键字","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 C++函数后面加const关键字 C++函数后面加throw关键字 C++11引入的关键字=default、=delete、override、final 1. =default 2. =delete 3. override C++函数后面加const关键字 非静态成员函数后面加const（加到非成员函数或静态成员后面会产生编译错误）,表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用） 唯一的例外是对于mutable修饰的成员。 加了const的成员函数可以被非const对象和const对象调用,但不加const的成员函数只能被非const对象调用 1 2 3 4 char getData() const { return this-\u003eletter; } C++函数后面加throw关键字 void fun() throw() 表示fun不允许抛出任何异常，即fun是异常安全的。 void fun() throw(…) 表示fun可以抛出任何形式的异常。 void fun() throw(exceptionType) 表示fun只能抛出exceptionType类型的异常。 void GetTag() throw(int); 表示只抛出int类型异常 void GetTag() throw(int，char); 表示抛出in，char类型异常 void GetTag() throw(); 表示不会抛出任何类型异常 void GetTag() throw(…); 表示抛出任何类型异常 那么，void GetTag() throw(int); 表示只抛出int类型异常 这句解释怎么理解呢？ 并不表示一定会抛出异常，但是一旦抛出异常只会抛出int类型。 如果抛出非int类型异常，调用unexsetpion()函数，退出程序。 C++11引入的关键字=default、=delete、override、final ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"1. =default 在C++11中，如果需要使用默认的构造、析构函数，需要在参数列表后面加上=default关键字，与之对应，如果你不想使用默认的构造、析构函数，就在参数列表后面加上=delete，这样编译器就会删除对应的默认构造、析构函数。 1 2 3 4 5 6 7 8 9 //demo.h #pragma once class CobjectA { public: CobjectA(int i); CobjectA() = default; }; 再次编译输出： 1 Test Con ! 这样可以看出，当我们需要使用编译器默认生成的构造函数，只需要在头文件声明的时候，在参数列表后加上关键字=default，不需要在对应的cpp文件中进行定义。 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:1:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"2. =delete 为了不让一个类被拷贝，可以将其拷贝构造函数声明为private属性，但是有了delete关键字后，可以直接在拷贝构造函数的参数列表后面加上=delete，对于一些不需要构造、析构函数的类，可以在其默认的构造、析构函数参数列表后加上=delete，减少生成可执行文件的体积。 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:2:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cpp"],"content":"3. override 在继承机制中会用到override关键字，使用该关键字可以避免一些低级错误的出现。例如，定义类A与类B，并让B继承A。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func1() override { std::cout \u003c\u003c \"class B func1\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func1(); return 0; } A中有虚函数func1，在B中继承后重新实现了一下，输出结果： 1 2 class A func1 class B func1 在B中改写func1，其后增加了override关键字，如果存在这样一种情况，本想改写从A中继承来的func1，由于疏忽，修改了函数的签名： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func2() override //将func1写成了func2 { std::cout \u003c\u003c \"class B func2\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func2(); return 0; } 结果编译出错： 1 2 3 test2.cpp:15:18: error: ‘virtual void B::func2()’ marked ‘override’, but does not override 15 | virtual void func2() override //将func1写成了func2 | 提示没有重写基类的方法，所以，有了override关键字，一定要重写基类的方法，这里的func2相当于是在类B中重新定义的一个函数。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u003ciostream\u003e class A { public: virtual void func1() { std::cout \u003c\u003c \"class A func1\" \u003c\u003c std::endl; } }; class B : A { public: virtual void func2() //这里去掉override关键字，相当于自己定义了一个func2函数 { std::cout \u003c\u003c \"class B func2\" \u003c\u003c std::endl; } }; int main() { A a; a.func1(); B b; b.func2(); return 0; } 输出结果： 1 2 class A func1 class B func2 ","date":"2023-01-15","objectID":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/:3:0","tags":["cpp"],"title":"C++:函数后的关键字","uri":"/posts/program/cpp/c++%E5%87%BD%E6%95%B0%E5%90%8E%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/note/","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"[TOC] CMake -D 定义 -DCMAKE_INSTALL_PREFIX= 指定安装路径，相当于 –prefix= -DCMAKE_C_COMPILER= 指定 C 编译器，相当于 CC= -DCMAKE_CXX_COMPILER=指定 CXX 编译器，相当于 CXX= CMake中条件判断语句 1 2 3 4 5 if(\u003cconstant\u003e) ... else() ... endif() \u003cconstant\u003e表示一个常量，其取值与对应逻辑值如下（不区分大小写）： 逻辑值 常量值 true 1、ON、YES、TRUE、Y、非0数字 false 0、OFF、NO、FALSE、N、IGNORE、NOTFOUNT、空字符串、-NOTFOUND结尾字符串 变量 1 if(\u003cvariable\u003e) \u003cvariable\u003e表示一个变量，变量取值不是上述定义的false常量时其逻辑值为true，否则逻辑值为false。 注： 宏参数不是变量，环境变量不可作为条件。 使用变量时，不要用${}表示变量，直接使用变量名即可。 字符串 1 if(\u003cstring\u003e) \u003cstring\u003e表示带引号的字符串。以下情况其逻辑值为true: 字符串内容为上述定义的true常量 策略 CMP0054 未设置为 NEW，并且字符串的值恰好是受 CMP0054 行为影响的变量名称。 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:0:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"逻辑运算 1 2 3 4 if(NOT \u003ccondition\u003e) # 非运算 if(\u003ccond1\u003e AND \u003ccond2\u003e) # 与运算 if(\u003ccond1\u003e OR \u003ccond2\u003e) #或运算 if((condition) AND (condition OR (condition))) # 有括号时，先计算括号的逻辑值 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:1:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"存在性判断 1 2 3 4 5 6 if(COMMAND command-name) # true 给定参数是可调用的命令、宏、函数时 if(POLICY policy-id) # true 给定的策略存在时 if(TARGET target-name) # true 给定的目标参数是通过add_executable()、add_library() 或 add_custom_target() 命令创建并存在的 if(TEST test-name) # true 给定参数是通过add_test()创建并存在的 if(DEFINED \u003cname\u003e|CACHE{\u003cname\u003e}|ENV{\u003cname\u003e}) # true 如果变量、缓存、环境变量存在（其取值无关） if(\u003cvariable|string\u003e IN_LIST \u003cvariable\u003e) # true 如果\u003cvariable|string\u003e存在于列表变量\u003cvariable\u003e中 1 2 3 4 5 6 # 以下路径参数可以为相对路径或绝对路径，相对是指相对于当前执行cmake的路径。 if(EXISTS path-to-file-or-directory) # true 如果文件/目录存在，当参数是连接时表示连接指向的实体存在。 if(file1 IS_NEWER_THAN file2) # true file1比file2新 if(IS_DIRECTORY path-to-directory) # true 如果参数是目录 if(IS_SYMLINK file-name)# true 如果参数是一个链接 if(IS_ABSOLUTE path) # true 如果参数是绝对路径 ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:2:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"正则匹配 如果\u003cvariable|string\u003e匹配了正则表达式regex，则为true \u003cvariable|string\u003e可以是字符串，或者内容为字符串的变量。 1 if(\u003cvariable|string\u003e MATCHES regex) ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:3:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"数字比较 \u003cvariable|string\u003e表示存储数字的变量，或合法的数字字符串（如 “512”） 1 2 3 4 5 if(\u003cvariable|string\u003e LESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e GREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e EQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e LESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e GREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:4:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"字符串比较 \u003cvariable|string\u003e可以是字符串，或者内容为字符串的变量。 1 2 3 4 5 if(\u003cvariable|string\u003e STRLESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e STRGREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e STREQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e STRLESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e STRGREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:5:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"版本号比较 \u003cvariable|string\u003e表示存储版本号的变量，或合法的版本号字符串（如 “3.1.4”） 1 2 3 4 5 if(\u003cvariable|string\u003e VERSION_LESS \u003cvariable|string\u003e) # \u003c if(\u003cvariable|string\u003e VERSION_GREATER \u003cvariable|string\u003e) # \u003e if(\u003cvariable|string\u003e VERSION_EQUAL \u003cvariable|string\u003e) # == if(\u003cvariable|string\u003e VERSION_LESS_EQUAL \u003cvariable|string\u003e) # \u003c= if(\u003cvariable|string\u003e VERSION_GREATER_EQUAL \u003cvariable|string\u003e) # \u003e= ","date":"2023-01-15","objectID":"/posts/program/cmake/note/:6:0","tags":["cmake"],"title":"cmake note","uri":"/posts/program/cmake/note/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 CMake CMake中常用预定义变量 CMake的预定义变量 系统信息预定义变量 开关选项 常用语法 CMAKE_MINIMUM_REQUIRED PROJECT 外部构建与内部构建 SET ADD_SUBDIRECTORY INCLUDE_DIRECTORIES ADD_EXECUTABLE ADD_LIBRARY 变量EXECUTABLE_OUTPUT_PATH, LIBRARY_OUTPUT_PATH LINK_DIRECTORIES TARGET_LINK_LIBRARIES MESSAGE SET_TARGET_PROPERTIES AUX_SOURCE_DIRECTORY 基本控制语法 实战 单个源文件 多个源文件 同一目录，多个源文件 多个目录，多个源文件 自定义编译选项 安装和测试 定制安装规则 为工程添加测试 参考资料 CMake CMakeLists.txt cmake PATH ccmake PATH ccmake 和 cmake 的区别在于前者提供了一个交互式的界面 PATH 是 CMakeLists.txt 所在的目录 使用 make 命令进行编译。 CMake中常用预定义变量 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:0:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"CMake的预定义变量 PROJECT_SOURCE_DIR：工程根目录； PROJECT_BINARY_DIR：运行cmake命令的目录。笔者建议定义为${PROJECT_SOURCE_DIR}/ build下。具体原因见后文外部编译部分； CMAKE_INCLUDE_PATH：环境变量，非cmake变量； CMAKE_LIBRARY_PATH：环境变量； CMAKE_CURRENT_SOURCE_DIR：当前处理的CMakeLists.txt文件所在路径； CMAKE_CURRENT_BINARY_DIR：target编译目录； 使用ADD_SURDIRECTORY指令可以更改该变量的值； SET(EXECUTABLE_OUTPUT_PATH \u003c dir \u003e) 指令不会对该变量有影响，但改变了最终目标文件的存储路径； CMAKE_CURRENT_LIST_FILE：输出调用该变量的CMakeLists.txt的完整路径； CMAKE_CURRENT_LIST_LINE：输出该变量所在的行； CMAKE_MODULE_PATH：定义自己的cmake模块所在路径； EXECUTABLE_OUTPUT_PATH：重新定义目标二进制可执行文件的存放位置； LIBRARY_OUTPUT_PATH：重新定义目标链接库文件的存放位置； PROJECT_NAME：返回由PROJECT指令定义的项目名称； CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS：用来控制IF…ELSE…语句的书写方式； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:1:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"系统信息预定义变量 CMAKE_MAJOR_VERSION cmake主版本号,如2.8.6中的2 CMAKE_MINOR_VERSION cmake次版本号,如2.8.6中的8 CMAKE_PATCH_VERSION cmake补丁等级,如2.8.6中的6 CMAKE_SYSTEM 系统名称,例如Linux-2.6.22 CMAKE_SYSTEM_NAME 不包含版本的系统名,如Linux CMAKE_SYSTEM_VERSION 系统版本,如2.6.22 CMAKE_SYSTEM_PROCESSOR 处理器名称,如i686 UNIX 在所有的类UNIX平台为TRUE,包括OS X和cygwin WIN32 在所有的win32平台为TRUE,包括cygwin ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:2:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"开关选项 BUILD_SHARED_LIBS 控制默认的库编译方式。 注：如果未进行设置,使用ADD_LIBRARY时又没有指定库类型,默认编译生成的库都是静态库。 CMAKE_C_FLAGS 设置C编译选项 CMAKE_CXX_FLAGS 设置C++编译选项 常用语法 CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 # 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。 每一个需要进行cmake操作的目录下面，都必须存在文件CMakeLists.txt 。 cmake指令不区分大小写。 cmake内置变量是区分大小写的，或者干脆就说，cmake的所有变量都是区分大小写的。 变量使用${}方式取值，但是在 IF 控制语句中是直接使用变量名； 指令(参数 1 参数 2…)，参数使用括弧括起，参数之间使用空格或分号分开； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:3:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"CMAKE_MINIMUM_REQUIRED 该语句一般都可以放置在CMakeLists.txt的开头，用于说明CMake最低版本要求。 这行命令是可选的，我们可以不写这句话，但在有些情况下，如果CMakeLists.txt文件中使用了一些高版本cmake特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行cmake。 1 cmake_minimum_required (VERSION 2.6) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:4:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"PROJECT 1 PROJECT(name) name：工程名称 该指令一般置于CMakeLists.txt的开头，定义了工程的名称。但项目最终编译生成的可执行文件并不一定是这个项目名称。 执行了该条指令之后，将会自动创建两个变量： 1 2 \u003c projectname \u003e_BINARY_DIR：二进制文件保存路径； \u003c projectname \u003e_SOURCE_DIR：源代码路径； 1 project(CRNode) 执行了上一条指令，即定义了一个项目名称CRNode，相应的会生成两个变量：CRNode_BINARY_DIR, CRNode_SOURCE_DIR。 cmake中预定义了两个变量：PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR。 在这个例子中： 1 2 PROJECT_BINARY_DIR = CRNode_BINARY_DIR PROJECT_SOURCE_DIR = CRNode_SOURCE_DIR 推荐直接使用PROJECT_BINARY_DIR与PROJECT_SOURCE_DIR，这样及时项目名称发生了变化，也不会影响CMakeLists.txt文件。 关于上面两个变量是否相同的问题，涉及到编译方法是内部编译还是外部编译。如果是内部编译，则上面两个变量相同；如果是外部编译，则两个变量不同。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"外部构建与内部构建 假设此时已经完成了CMakeLists.txt的编写，在CMakeLists.txt所在目录下，有两种执行cmake的方法： 1 2 cmake ./ make 以及： 1 2 3 4 mkdir build cd ./build cmake ../ make 第一种方法是内部构建，第二种方法是外部构建。上述两种方法中，最大不同在于cmake与make的工作路径不同。 内部构建方法中，cmake生成的中间文件和可执行文件都会存放在项目目录中；外部构建方法中，中间文件与可执行文件都存放在build目录中。 建议使用外部构建方法。优点显而易见：最大限度的保持了代码目录的整洁，生成、编译与安装是不同于项目目录的其他目录中，在外部构建方法下，PROJECT_SOURCE_DIR指向目录与内部构建相同，为CMakeLists.txt所在根目录；而PROJECT_BINARY_DIR不同，它指向CMakeLists.txt所在根目录下的build目录。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:5:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"SET 1 SET(VAR [VALUE] [CACHE TYPEDOCSTRING [FORCE]]) eg: 1 SET(CMAKE_INSTALL_PREFIX /usr/local) 我们显式的将CMAKE_INSTALL_PREFIX的值定义为/usr/local，如此在外部构建情况下执行make install命令时，make会将生成的可执行文件拷贝到/usr/local/bin目录下。 当然，可执行文件的安装路径CMAKE_INSTALL_PREFIX也可以在执行cmake命令的时候指定，cmake参数如下： 1 cmake -DCMAKE_INSTALL_PREFIX=/usr .. 如果cmake参数和CMakeLists.txt文件中都不指定该值的话，则该值为默认的/usr/local。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:6:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_SUBDIRECTORY 1 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) source_dir：源文件路径； [binary_dir]：中间二进制与目标二进制存放路径； [EXECLUDE_FROM_ALL]：将这个目录从编译过程中排除； 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。 EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如，工程有时候存在example，可能就需要工程构建完成后，再进入example目录单独进行构建。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:7:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"INCLUDE_DIRECTORIES 1 INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) [AFTER|BEFORE]：追加标志，指定控制追加或置前； [SYSTEM]：（笔者也不知道干嘛用的） dir1, …, dir n：添加的一系列头文件搜索路径； 向工程添加多个特定的头文件搜索路径，路径之间用空格分隔。类似于gcc中的编译参数-l，即指定编译过程中编译器搜索头文件的路径。当项目需要的头文件不在系统默认的搜索路径时，则指定该路径。 AFTER/BEFORE参数，控制追加或置前。默认情况下，追加当前头文件搜索路径的后面。 注：如果路径包含空格，可以使用双引号将它括起来。 eg： 1 INCLUDE_DIRECTORIES(/usr/include/thrift) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:8:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_EXECUTABLE 1 ADD_EXECUTABLE(exename srcname) exename：可执行文件名 srcname：生成该可执行文件的源文件 该命令给出源文件名称，并指出需要编译出的可执行文件名。 eg： 1 ADD_EXECUTABLE(hello ${SRC_LIST}) 上述例程说明SRC_LIST变量中的源文件，需要编译出名为hello的可执行文件。 eg: 1 2 3 4 5 6 7 8 9 10 SET(SRC_LIST main.cc rpc/CRNode.cpp rpc/Schd_types.cpp task/TaskExecutor.cpp task/TaskMoniter.cpp util/Const.cpp util/Globals.cc ) ADD_EXECUTABLE(CRNode ${SRC_LIST}) 该例程中，定义了该工程会生成一个名为CRNode的可执行文件，所依赖的源文件是变量SRC_LIST定义的源文件列表。 注：如果前文PROJECT()指令中定义的项目名称也定义为CRNode，也没有什么问题，两者之间没有任何关系。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:9:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"ADD_LIBRARY 1 ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN) libname：库文件名称； [SHARED|STATIC|MODULE]：生成库文件类型（共享库/静态库） [EXCLUDE_FROM_ALL]：表示该库不会被默认构建 source1, …, sourceN：生成库所依赖的源文件 eg： 1 ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:10:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"变量EXECUTABLE_OUTPUT_PATH, LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH为生成可执行文件路径，LIBRARY_OUTPUT_PATH为生成库文件路径。 我们可以通过SET指令对其进行设置最终的目标二进制的位置，即最终生成的工程可执行文件与最终的共享库，而不包含编译生成的中间文件。 1 2 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 注：指令ADD_EXECUTABLE, ADD_LIBRARY出现的位置，如果需要改变目标存放路径，就在该处添加上述定义。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:11:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"LINK_DIRECTORIES 1 LINK_DIRECTORIES(directory1 directory2 ...) 该指令用于添加外部库的搜索路径。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:12:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"TARGET_LINK_LIBRARIES 1 TARGET_LINK_LIBRARIES(target library1 \u003cdebug | optimized\u003e library2 ..) target：目标文件； library1, …, libraryN：链接外部库文件； 指定链接目标文件时需要链接的外部库，效果类似于gcc编译参数-L，解决外部库依赖的问题。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:13:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"MESSAGE 1 MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] “message to display” …) 向终端输出用户定义的信息或变量值 SEND_ERROR：产生错误，生成过程被跳过； STATUS：输出前缀为 – 的信息； FATAL_ERROR：立即终止所有cmake过程； ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:14:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"SET_TARGET_PROPERTIES 1 2 SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ...) 设置目标的某些属性，改变它们构建的方式。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:15:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"AUX_SOURCE_DIRECTORY 基本控制语法 实战 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:16:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"单个源文件 1 2 3 4 5 6 7 8 9 10 11 # CMake 最低版本号要求 # cmake_minimum_required：指定运行此配置文件所需的 CMake 的最低版本 cmake_minimum_required (VERSION 2.8) # 项目信息 # project：参数值是 Demo1，该命令表示项目的名称是 Demo1 project (Demo1) # 指定生成目标 # add_executable： 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件 add_executable(Demo main.cc) cmake . ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:17:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"多个源文件 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"同一目录，多个源文件 1 2 3 4 5 6 7 8 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo2) # 指定生成目标 add_executable(Demo main.cc MathFunctions.cc) aux_source_directory: 查找指定目录下的所有源文件，然后将结果存进指定变量名。 1 aux_source_directory(\u003cdir\u003e \u003cvariable\u003e) 1 2 3 4 5 6 7 8 9 10 11 12 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo2) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(Demo ${DIR_SRCS}) ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"多个目录，多个源文件 add_subdirectory : 项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理。 target_link_libraries：指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo3) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 添加 math 子目录 add_subdirectory(math) # 指定生成目标 add_executable(Demo main.cc) # 添加链接库 target_link_libraries(Demo MathFunctions) 子目录中的 CMakeLists.txt： 1 2 3 4 5 6 # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_LIB_SRCS 变量 aux_source_directory(. DIR_LIB_SRCS) # 生成链接库 add_library (MathFunctions ${DIR_LIB_SRCS}) 该文件中使用命令 add_library 将 src 目录中的源文件编译为静态链接库。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:18:2","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"自定义编译选项 CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # CMake 最低版本号要求 cmake_minimum_required (VERSION 2.8) # 项目信息 project (Demo4) # 加入一个配置头文件，用于处理 CMake 对源码的设置 configure_file ( \"${PROJECT_SOURCE_DIR}/config.h.in\" \"${PROJECT_BINARY_DIR}/config.h\" ) # 是否使用自己的 MathFunctions 库 option (USE_MYMATH \"Use provided math implementation\" ON) # 是否加入 MathFunctions 库 if (USE_MYMATH) include_directories (\"${PROJECT_SOURCE_DIR}/math\") add_subdirectory (math) set (EXTRA_LIBS ${EXTRA_LIBS} MathFunctions) endif (USE_MYMATH) # 查找当前目录下的所有源文件 # 并将名称保存到 DIR_SRCS 变量 aux_source_directory(. DIR_SRCS) # 指定生成目标 add_executable(Demo ${DIR_SRCS}) target_link_libraries (Demo ${EXTRA_LIBS}) 其中： 第7行的 configure_file 命令用于加入一个配置头文件 config.h ，这个文件由CMake 从 config.h.in 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。 第13行的 option 命令添加了一个 USE_MYMATH 选项，并且默认值为 ON 。 第17行根据 USE_MYMATH 变量的值来决定是否使用我们自己编写的 MathFunctions 库。 config.h.in 1 #cmakedefine USE_MYMATH CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。 从中可以找到刚刚定义的 USE_MYMATH 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 enter 键可以修改该选项。修改完成后可以按下 c 选项完成配置，之后再按 g 键确认生成 Makefile 。ccmake 的其他操作可以参考窗口下方给出的指令提示。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:19:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"安装和测试 CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 make install 和 make test 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 install 和 test 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:0","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"定制安装规则 math/CMakeLists.txt 指明 MathFunctions 库的安装路径 1 2 3 # 指定 MathFunctions 库的安装路径 install (TARGETS MathFunctions DESTINATION bin) install (FILES MathFunctions.h DESTINATION include) 改根目录的 CMakeLists 文件 1 2 3 4 # 指定安装路径 install (TARGETS Demo DESTINATION bin) install (FILES \"${PROJECT_BINARY_DIR}/config.h\" DESTINATION include) 通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 /usr/local/bin 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 /usr/local/include 中。（这里的 /usr/local/ 是默认安装到的根目录，可以通过修改 CMAKE_INSTALL_PREFIX 变量的值来指定这些文件应该拷贝到哪个根目录）。 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:1","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"为工程添加测试 添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 add_test 命令。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 # 启用测试 enable_testing() # 测试程序是否成功运行 add_test (test_run Demo 5 2) # 测试帮助信息是否可以正常提示 add_test (test_usage Demo) set_tests_properties (test_usage PROPERTIES PASS_REGULAR_EXPRESSION \"Usage: .* base exponent\") # 测试 5 的平方 add_test (test_5_2 Demo 5 2) set_tests_properties (test_5_2 PROPERTIES PASS_REGULAR_EXPRESSION \"is 25\") # 测试 10 的 5 次方 add_test (test_10_5 Demo 10 5) set_tests_properties (test_10_5 PROPERTIES PASS_REGULAR_EXPRESSION \"is 100000\") # 测试 2 的 10 次方 add_test (test_2_10 Demo 2 10) set_tests_properties (test_2_10 PROPERTIES PASS_REGULAR_EXPRESSION \"is 1024\") 上面的代码包含了四个测试。第一个测试 test_run 用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 PASS_REGULAR_EXPRESSION 用来测试输出是否包含后面跟着的字符串。 可以通过编写宏来实现 1 2 3 4 5 6 7 8 9 10 11 # 定义一个宏，用来简化测试工作 macro (do_test arg1 arg2 result) add_test (test_${arg1}_${arg2} Demo ${arg1} ${arg2}) set_tests_properties (test_${arg1}_${arg2} PROPERTIES PASS_REGULAR_EXPRESSION ${result}) endmacro (do_test) # 使用该宏进行一系列的数据测试 do_test (5 2 \"is 25\") do_test (10 5 \"is 100000\") do_test (2 10 \"is 1024\") 参考资料 CMake 入门实战 CMake 入门实战源码 CMake语法 ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/:20:2","tags":["cmake"],"title":"cmake 知识整理","uri":"/posts/program/cmake/cmake%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/","tags":["cmake"],"title":"CMake交叉编译配置","uri":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 几个重要的变量 使用变量来控制编译步骤 demo CMake给交叉编译预留了一个很好的变量即CMAKE_TOOLCHAIN_FILE,它定义了一个文件的路径，这个文件即toolChain,里面set了一系列你需要改变的变量和属性，包括C_COMPILER,CXX_COMPILER,如果用Qt的话需要更改QT_QMAKE_EXECUTABLE以及如果用BOOST的话需要更改的BOOST_ROOT(具体查看相关Findxxx.cmake里面指定的路径)。CMake为了不让用户每次交叉编译都要重新输入这些命令，因此它带来toolChain机制，简而言之就是一个cmake脚本，内嵌了你需要改变以及需要set的所有交叉环境的设置。 几个重要的变量 CMAKE_SYSTEM_NAME: 即你目标机target所在的操作系统名称，比如ARM或者Linux你就需要写\"Linux\",如果Windows平台你就写\"Windows\",如果你的嵌入式平台没有相关OS你即需要写成\"Generic\",只有当CMAKE_SYSTEM_NAME这个变量被设置了，CMake才认为此时正在交叉编译，它会额外设置一个变量CMAKE_CROSSCOMPILING为TRUE. CMAKE_C_COMPILER: 顾名思义，即C语言编译器，这里可以将变量设置成完整路径或者文件名，设置成完整路径有一个好处就是CMake会去这个路径下去寻找编译相关的其他工具比如linker,binutils等，如果你写的文件名带有arm-elf等等前缀，CMake会识别到并且去寻找相关的交叉编译器。 CMAKE_CXX_COMPILER: 同上，此时代表的是C++编译器。 CMAKE_FIND_ROOT_PATH: 代表了一系列的相关文件夹路径的根路径的变更，比如你设置了/opt/arm/,所有的Find_xxx.cmake都会优先根据这个路径下的/usr/lib,/lib等进行查找，然后才会去你自己的/usr/lib和/lib进行查找，如果你有一些库是不被包含在/opt/arm里面的，你也可以显示指定多个值给CMAKE_FIND_ROOT_PATH,比如 1 set(CMAKE_FIND_ROOT_PATH /opt/arm /opt/inst) CMAKE_FIND_ROOT_PATH_MODE_PROGRAM: 对FIND_PROGRAM()起作用，有三种取值，NEVER,ONLY,BOTH,第一个表示不在你CMAKE_FIND_ROOT_PATH下进行查找，第二个表示只在这个路径下查找，第三个表示先查找这个路径，再查找全局路径，对于这个变量来说，一般都是调用宿主机的程序，所以一般都设置成NEVER CMAKE_FIND_ROOT_PATH_MODE_LIBRARY: 对FIND_LIBRARY()起作用，表示在链接的时候的库的相关选项，因此这里需要设置成ONLY来保证我们的库是在交叉环境中找的. CMAKE_FIND_ROOT_PATH_MODE_INCLUDE: 对FIND_PATH()和FIND_FILE()起作用，一般来说也是ONLY,如果你想改变，一般也是在相关的FIND命令中增加option来改变局部设置，有NO_CMAKE_FIND_ROOT_PATH,ONLY_CMAKE_FIND_ROOT_PATH,BOTH_CMAKE_FIND_ROOT_PATH BOOST_ROOT： 对于需要boost库的用户来说，相关的boost库路径配置也需要设置，因此这里的路径即ARM下的boost路径，里面有include和lib。 QT_QMAKE_EXECUTABLE: 对于Qt用户来说，需要更改相关的qmake命令切换成嵌入式版本，因此这里需要指定成相应的qmake路径（指定到qmake本身） 使用变量来控制编译步骤 CMAKE_CROSSCOMPILING：是否处于交叉编译环境 ANDROID：安卓的编译环境 APPLE：是否是苹果系列的编译环境 IOS：是否是苹果手机环境 UNIX：是否是 UNIX 或者 UNIX-like 的环境 WIN32、MSVC：是否是 Windows demo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # this is required SET(CMAKE_SYSTEM_NAME Linux) # where is the target environment SET(TOOLCHAIN_DIR \"/usr/local/aarch64-himix100-linux-toolchain-libra-v3\") SET(CMAKE_FIND_ROOT_PATH ${TOOLCHAIN_DIR}) # search for programs in the build host directories (not necessary) SET(CMAKE_FIND_ROOT_PATH_MODE_PROGRAM NEVER) # for libraries and headers in the target directories SET(CMAKE_FIND_ROOT_PATH_MODE_LIBRARY ONLY) SET(CMAKE_FIND_ROOT_PATH_MODE_INCLUDE ONLY) # specify the cross compiler SET(CMAKE_C_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-gcc) SET(CMAKE_CXX_COMPILER ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-gcc) SET(STRIP ${TOOLCHAIN_DIR}/bin/aarch64-himix100-linux-strip) # configure Boost and Qt SET(QT_QMAKE_EXECUTABLE /opt/qt-embedded/qmake) SET(BOOST_ROOT /opt/boost_arm) 指定编译工具链 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_TOOLCHAIN_FILE=xxx/toochain.cmake make ","date":"2023-01-15","objectID":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/:0:0","tags":["cmake"],"title":"CMake交叉编译配置","uri":"/posts/program/cmake/cmake%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E9%85%8D%E7%BD%AE/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 类的成员 1. 类的属性 1.1. 静态属性的创建方式 1.2. 实例属性 2. 类的方法 类成员的修饰符 类的特殊成员 类的专有方法： 继承 1. 单继承 2. 多继承 3. 方法重写 运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Document(): def __init__(self, title, author, context): print('init function called') self.title = title self.author = author self.__context = context # __ 开头的属性是私有属性 def get_context_length(self): return len(self.__context) def intercept_context(self, length): self.__context = self.__context[:length] harry_potter_book = Document('Harry Potter', 'J. K. Rowling', '... Forever Do not believe any thing is capable of thinking independently ...') print(harry_potter_book.title) print(harry_potter_book.author) print(harry_potter_book.get_context_length()) harry_potter_book.intercept_context(10) print(harry_potter_book.get_context_length()) print(harry_potter_book.__context) 类：一群有着相似性的事物的集合，这里对应 Python 的 class。 对象：集合中的一个事物，这里对应由 class 生成的某一个 object，比如代码中的 harry_potter_book。 属性：对象的某个静态特征，比如上述代码中的 title、author 和 __context。 函数：对象的某个动态能力，比如上述代码中的 intercept_context () 函数。 1. 类的成员 类的成员包括：属性和方法。 属性可以分为：静态属性和实例属性 方法可以分为：普通方法、类方法和静态方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #!/usr/bin/python3 class MyClass: \"\"\"一个简单的类实例\"\"\" i = 12345 def f(self): return 'hello world' # 实例化类 x = MyClass() # 访问类的属性和方法 print(\"MyClass 类的属性 i 为：\", x.i) print(\"MyClass 类的方法 f 输出为：\", x.f()) ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:0:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1. 类的属性 属性可以分为：静态属性和实例属性。 实例属性属于对象，而静态属性属于类。 通过类创建对象时，如果每个对象都具有相同的属性，那么就使用静态属性。 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1.1. 静态属性的创建方式 静态属性是属于类的，所以不用创建对象访问。 1 2 3 4 5 6 7 8 9 10 #!/usr/bin/python3 class Province: # 静态字段 country ＝ '中国' # 直接访问静态字段 Province.country ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:1","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.1.2. 实例属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 lass Goods: def __init__(self): # 原价 self.original_price = 100 # 折扣 self.discount = 0.8 @property def price(self): # 实际价格 = 原价 * 折扣 new_price = self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price = value @price.deleter def price(self): del self.original_price 实例属性可以在构造方法中进行初始化。@property装饰器可以把一个实例方法变成其同名属性，以支持.号访问。我们可以根据属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除。 扩展： 对于静态属性还可以使用property函数的形式定义一个属性。与@property实现原理类似。 property(fget=None, fset=None, fdel=None, doc=None) 1 2 3 4 5 6 7 8 9 10 11 12 13 class Foo: def get_bar(self): return 'get_bar' # *必须两个参数 def set_bar(self, value): return 'set value' + value def del_bar(self): return 'del_bar' age = property(fget=get_bar,fset=set_bar,fdel=del_bar,doc='description...') ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:1:2","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"1.2. 类的方法 方法包括：普通方法、类方法和静态方法。 普通方法：由对象调用；至少一个self参数；执行普通方法时，自动将调用该方法的对象赋值给self； 类方法：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类复制给cls； 静态方法：由类调用；无默认参数； 如果Python中没有属性，方法完全可以代替其功能。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Foo: def __init__(self, name): self.name = name def ord_func(self): \"\"\" 定义普通方法，至少有一个self参数 \"\"\" # print self.name print('普通方法') @classmethod def class_func(cls): \"\"\" 定义类方法，至少有一个cls参数 \"\"\" print('类方法') @staticmethod def static_func(): \"\"\" 定义静态方法 ，无默认参数\"\"\" print('静态方法') 2. 类成员的修饰符 对于每一个类的成员而言都有两种形式： 公有成员，在任何地方都能访问。 私有成员，只有在类的内部才能方法。 私有成员和公有成员的定义不同：私有成员命名时，前两个字符是下划线。（特殊成员除外，例如：init、call、__dict__等） ps：如果想要强制访问私有字段，可以通过 【对象._类名__私有字段明 】访问（如：obj._C__foo），不建议强制访问私有成员。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class C: name = '公有静态字段' __sname ='私有静态字段' def pub_func(self): print(C.name) def pra_func(self): print(C._sname) class D(C): def pub_show(self): print(C.name) def pra_show(self): print(C._sname) 注：不建议强制访问私有成员。 3. 类的特殊成员 __doc__ : 表示类的描述信息。 __module__ : 表示当前操作的对象在哪个模块 __class__ : 表示当前操作的对象的类是什么 __init__ : 构造方法，通过类创建对象时，自动触发执行。 1 2 3 4 5 6 7 8 #!/usr/bin/python3 class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) print(x.r, x.i) # 输出结果：3.0 -4.5 __del__ : 当对象在内存中被释放时，自动触发执行。 __call__ : 对象后面加括号，触发执行。 __dict__ : 类或对象中的所有成员。 __str__ : 如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。有点像java中的toString方法。 __getitem__、__setitem__、__delitem__ : 用于索引操作，如字典。以上分别表示获取、设置、删除数据。 __getslice__、__setslice__、__delslice__ : 三个方法用于分片操作。 __iter__ : 用于迭代器，之所以列表、字典、元组可以进行for循环，是因为类型内部定义了 __iter__。 4. 类的专有方法： __init__ : 构造函数，在生成对象时调用 __del__ : 析构函数，释放对象时使用 __repr__ : 打印，转换 __setitem__ : 按照索引赋值 __getitem__: 按照索引获取值 __len__: 获得长度 __cmp__: 比较运算 __call__: 函数调用 __add__: 加运算 __sub__: 减运算 __mul__: 乘运算 __truediv__: 除运算 __mod__: 求余运算 __pow__: 乘方 5. 继承 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:2:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.1. 单继承 Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 1 2 3 4 5 6 class DerivedClassName(BaseClassName): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 子类（派生类 DerivedClassName）会继承父类（基类 BaseClassName）的属性和方法。 BaseClassName（实例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1 class DerivedClassName(modname.BaseClassName): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) s = student('ken',10,60,3) s.speak() ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:3:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.2. 多继承 1 2 3 4 5 6 class DerivedClassName(Base1, Base2, Base3): \u003cstatement-1\u003e . . . \u003cstatement-N\u003e 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #!/usr/bin/python3 #类定义 class people: #定义基本属性 name = '' age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(\"%s 说: 我 %d 岁。\" %(self.name,self.age)) #单继承示例 class student(people): grade = '' def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(\"%s 说: 我 %d 岁了，我在读 %d 年级\"%(self.name,self.age,self.grade)) #另一个类，多重继承之前的准备 class speaker(): topic = '' name = '' def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(\"我叫 %s，我是一个演说家，我演讲的主题是 %s\"%(self.name,self.topic)) #多重继承 class sample(speaker,student): a ='' def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t) test = sample(\"Tim\",25,80,4,\"Python\") test.speak() #方法名同，默认调用的是在括号中参数位置排前父类的方法 ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:4:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"5.3. 方法重写 如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 #!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print ('调用父类方法') class Child(Parent): # 定义子类 def myMethod(self): print ('调用子类方法') c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child,c).myMethod() #用子类对象调用父类已被覆盖的方法 super() 函数是用于调用父类(超类)的一个方法。 执行以上程序输出结果为： 6. 运算符重载 Python同样支持运算符重载，我们可以对类的专有方法进行重载，实例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #!/usr/bin/python3 class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return 'Vector (%d, %d)' % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b) v1 = Vector(2,10) v2 = Vector(5,-2) print (v1 + v2) ","date":"2023-01-15","objectID":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/:5:0","tags":["python"],"title":"Python中的class","uri":"/posts/program/python/3_python%E4%B8%AD%E7%9A%84class/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. python 中的类 2. 类 class 中为啥用使用 self 3. 在Python中类的定义 4. def __init__self 方法 5. 为啥要使用 self 6. self 到底是什么 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:0:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.1. python 中的类 在Python类中规定，函数的第一个参数是实例对象本身，并且约定俗成，把其名字写为self。其作用相当于java中的this，表示当前类的对象，可以调用当前类中的属性和方法。 class是面向对象的设计思想，instance（也即是 object，对象）是根据 class 创建的。一个类（class）应该包含数据和操作数据的方法，通俗来讲就是属性和函数（即调用方法）。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:1:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.2. 类 class 中为啥用使用 self 在类的代码（函数）中，需要访问当前的实例中的变量和函数，即访问Instance中的： 对应的变量（property)：Instance.ProperyNam，去读取之前的值和写入新的值。 调用对应函数（function）：Instance.function()，即执行对应的动作。 需要访问实例的变量和调用实例的函数，当然需要对应的实例Instance对象本身。 Python中就规定好了，函数的第一个参数，就必须是实例对象本身，并且建议，约定俗成，把其名字写为self。 所以，我们需要self（需要用到self）。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:2:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.3. 在Python中类的定义 在python中，类是通过关键字 class 定义的： class 后面紧跟类名，即 Person，类名通常大写字母开头，紧接着是(object),表示该类是从哪个类继承下来的，通常，如果没有合适的 继承类，就使用 object 类，这是所有类最终都会继承的类。 1 2 class Person（object）: pass 将 Person类实例化，创建实例化是通过 类名+() 实现的。 1 2 3 4 5 6 7 8 9 10 11 class Person(object): pass student = Person() # 创建类的实例化 print(student) print(Person) --------------------------------- 输出： \u003c__main__.Person object at 0x7f8a4bb14e20\u003e \u003cclass '__main__.Person'\u003e 可以看到，变量 student 指向的就是一个 Person的 object，后面的 0x7f8a4bb14e20 是内存地址，每个 object 的地址都不一样，而 Person 本身则是一个类。 也可以给实例变量绑定属性，比如：为 student 绑定 name 和 score 属性 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Person(object): pass student = Person() # print(student) # print(Person) student.name = \"Gavin\" # 为实例变量 # student 绑定 name 属性 类似于 赋值 操作 student.score = 100 # 为 其绑定 # score 属性 print(student.name) print(student.score) --------------------------------- 输出： Gavin 100 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:3:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.4. def init(self) 方法 上述的方法虽然可以为类的实例变量绑定属性，但是不够方便和elegant , 由于类 可以起到模板的作用，故在创建实例的时候，可以将我们认为必须绑定 属性 强制填写进去，在python中，是通过 类中通常都会使用的一个方法，即def init(self) 方法，在创建实例变量的时候，就把 name 和 score 等属性绑上去。 1 2 3 4 5 6 7 8 9 10 11 12 13 class Person(object): def __init__(self,name,score): self.name = name self.score = score student = Person('Gavin',100) # 传入 __init__ 方法中需要的参数 print(student.name) print(student.score) --------------------------------- 输出： Gavin 100 传入空参数的情况，会报错： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Person(object): def __init__(self,name,score): self.name = name self.score = score student = Person() print(student.name) print(student.score) --------------------------------- 输出： File \"/mnt/DATA/code/COMMON/Program/python/self/self2.py\", line 6, in \u003cmodule\u003e student = Person() TypeError: __init__() missing 2 required positional arguments: 'name' and 'score' 注意： 1、init 方法的第一个参数永远是 self ，表示创建的实例本身，因此，在 init 方法的内部，就可以把各种属性绑定到 self，因为 self 就指向创建的实例本身。 2、使用了 init 方法，在创建实例的时候就不能传入 空的参数了，必须传入与 init 方法匹配的参数，但是 self 不需要传，python解释器会自己把实例变量传进去。 在类中定义多个函数相互调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self): sum = self.x + self.y return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self): c = self.add() + self.square() return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square()) --------------------------------- 输出： 7 25 --------- 我是可爱的分割线----------- 32 通过上述的例子可以看出，与普通的函数相比，在类中定义的函数只有两点不同： 1、第一个参数永远是 self ，并且调用时不用传递该参数 2、在类中函数相互调用要加 self ，如上例中： c = self.add()+self.square(), 不加 self ，会报错： 函数未定义。 除此之外，类的方法和普通函数没甚区别，当然也可以使用 默认参数、可变参数和关键字参数，例子如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self, z=16): # 设置 默认变量 z =16,这只是个普通的局部变量，非实例变量，实例变量需要 self.z = z,这样定义 sum = self.x + self.y + z return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self, z): # 调用时传入变量，这也是个普通的局部变量，非实例变量 c = self.add() + self.square() + z return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square(16)) --------------------------------- 输出： 23 25 --------- 我是可爱的分割线----------- 64 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:4:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.5. 为啥要使用 self 看了上述的例子可能还是不明白 self 到底是个什么鬼，为啥要使用 self 这鬼东西？没关系，往下看： 其实 self 这家伙简单的说就是把 class 中 定义的 变量和函数 变成 实例变量和实例函数，作为类 class 的成员，使得成员间能互相调用，而不需要从外部调用 数据（变量）和 方法（函数），以实现数据的封装，以上面的 Person 类为例： 创建实例的时候需要给出实例变量 x,y, 调用函数时给出 z ，调用很容易，却不知道内部实现的细节。 总之，类是创建实例的模板，而实例则是一个一个具体的对象，各个实例拥有的数据都相互独立、互不影响；方法是与实例绑定的函数，和普通的函数不同，方法可以直接访问实例的数据。 其实 self 中存储的是实例变量和实例函数的属性，可以理解为一个字典（ dict ），如：{'name':'zhang','age':'18'}就是这些。 注意只有数据属性，并没有创建新的类的方法。 类—–\u003e通过实例化生成—-对象—-\u003e（对象只是一串类似于字典的数据，没有把类的里的方法复制给你，python没有new这个方法！） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Person(object): def __init__(self, x, y): self.x = x self.y = y def add(self, z=16): # 设置 z 为实例变量，即 self.z = z, z # 是 class 的一个成员了，而非普通局部变量 self.z = z sum = self.x + self.y + z # z虽然已被实例化，但是依然可以当作 普通变量来用 r return sum def square(self): squr = pow(self.x, 2) + pow(self.y, 2) return squr def add_square(self): c = self.add() + self.square() + self.z # 调用实例变量 z return c student = Person(3, 4) print(student.add()) print(student.square()) print(\"--------- 我是可爱的分割线-----------\") print(student.add_square()) print(student.z) # 函数add 中的 z 被实例化以后，就可以利用实例化的方法访问它 --------------------------------- 输出： 23 25 --------- 我是可爱的分割线----------- 64 16 通过这个例子可以看出， z 本来是 add() 函数的默认形参，通过将其实例化，就可以在其他函数体内调用实例变量z 被实例化以后，就可以利用实例化的方法访问它。 ","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:5:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"0.6. self 到底是什么 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Box(object): def __init__(self, boxname, size, color): self.boxname = boxname self.size = size self.color = color # self就是用于存储对象属性的集合，就算没有属性self也是必备的 def open(self, myself): print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (self.color, self.size, self.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) b = Box(\"魔盒\", \"14m\", \"红色\") b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'size': '14m', 'color': '红色'} self代表类的实例，而非类；self 就是 对象/实例 属性集合 Box 是个类—–》self 实例化——》 b对象/ 实例 class 抽象体——》实例化——》对象/实例，含有属性：{‘boxname’:‘魔盒’, ‘size’：‘14m’, ‘color’:‘red’}，即 self self 看似是整个对象，实际上清楚地描述了类就是产生对象的过程，描述了 self 就是得到了 对象，所以 self 内的键值可以直接使用 正如自然界中一个有效的对象，必须包括： 描述对象的属性； 对象的方法 所以 self是必须的，也是对象中重要的特性。 看下面的代码，感觉就更神奇了： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Box(object): def myInit(mySelf, boxname, size, color): print(mySelf.__dict__) # 显示为{}空字典 mySelf.boxname = boxname mySelf.__dict__[\"aa\"] = \"w\" # 甚至可以像字典一样操作 mySelf.size = size mySelf.color = color # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self return mySelf # 返回给实例化过程一个对象！神奇！并且含有对象属性/字典 # def __init__(self, boxname, size, color): # self.boxname = boxname # self.size = size # self.color = color #注释掉原来标准的初始化 def open(self, myself): print(self) print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) # 经过改造，运行结果和标准初始化没区别 b = Box().myInit(\"魔盒\", \"14m\", \"红色\") # b = Box('魔盒', '14m', '红色')#注释掉原来标准的初始化方法 b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 \u003c__main__.Box object at 0x7f0c536c3e20\u003e --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'aa': 'w', 'size': '14m', 'color': '红色'} 换个角度来讲，对类的操作有： 定义属性 ； 调用方法 对类的反馈有： 得到属性 ； 执行方法 在 class 类的函数中，为什么 self是必要的，因为 self 是对象的载体，可以理解成一个字典，看下面代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Box(object): def myInit(mySelf, boxname, size, color): print(mySelf.__dict__) # 显示为{}空字典 mySelf.boxname = boxname mySelf.__dict__[\"aa\"] = \"w\" # 甚至可以像字典一样操作 mySelf.size = size mySelf.color = color # 自己写一个初始化函数，一样奏效,甚至不用self命名。其它函数当中用标准self return mySelf # 返回给实例化过程一个对象！神奇！并且含有对象属性/字典 # def __init__(self, boxname, size, color): # self.boxname = boxname # self.size = size # self.color = color #注释掉原来标准的初始化 def open(self, myself): print(self) print( \"--\u003e用自己的myself，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname) ) print(\"--\u003e用类自己的self，打开那个%s,%s的%s\" % (myself.color, myself.size, myself.boxname)) def close(self): print(\"--\u003e关闭%s，谢谢\" % self.boxname) # 经过改造，运行结果和标准初始化没区别 b = Box().myInit(\"魔盒\", \"14m\", \"红色\") # b = Box('魔盒', '14m', '红色')#注释掉原来标准的初始化方法 b.close() b.open(b) # 本来就会自动传一个self，现在传入b，就会让open多得到一个实例对象本身，print看看是什么。 print(b.__dict__) # 这里返回的就是self本身，self存储属性，没有动作。 --------------------------------- 输出： --\u003e关闭魔盒，谢谢 \u003c__main__.Box object at 0x7fe655060e20\u003e --\u003e用自己的myself，打开那个红色,14m的魔盒 --\u003e用类自己的self，打开那个红色,14m的魔盒 {'boxname': '魔盒', 'aa': 'w', 'size': '14m', 'color': '红色'} 注意此处的： mySelf.dict[‘aa’] = ‘w’ #甚至可以像字典一样操作； 在 b.dict 的结果中显示为：‘aa’:‘w’ 故可以把 self 理解成存储 实例化对象属性的字典(dict), self 存储属性，而没有动作执行。 self总是指调用时的类的实例。 python 中一些特殊的实例变量： 私有变量(private),只有内部可以访问，外部不能访问，私有变量是在名称前以两个下划线开头，如：__name，其实私有变量也不是完全不能被外部访问，不能直接访问是因为python解释器对外把 __name 变量改成了 _类名__name,所仍然可以通过 _类名__name 来访问 __name。 在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 以一个下","date":"2023-01-15","objectID":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/:6:0","tags":["python"],"title":"Python中的self用法","uri":"/posts/program/python/2_python%E4%B8%AD%E7%9A%84self%E7%94%A8%E6%B3%95/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 列表和元组 2. Python 中的列表和元组都支持负数索引 3. 列表和元组都支持切片操作 4. 列表和元组都可以随意嵌套 5. 两者也可以通过 list 和 tuple 函数相互转换 6. 列表和元组常用的内置函数 7. 列表和元组存储方式的差异 8. 列表和元组的性能 9. 列表和元组的使用场景 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:0:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"1. 列表和元组 相同点： 列表和元组，都是一个可以放置任意数据类型的有序集合。 不同点： 列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。 而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。 1 2 3 4 5 6 7 8 9 10 l = [1, 2, 3, 4] l[3] = 40 # 和很多语言类似，python 中索引同样从 0 开始，l[3] 表示访问列表的第四个元素 l [1, 2, 3, 40] tup = (1, 2, 3, 4) tup[3] = 40 Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e TypeError: 'tuple' object does not support item assignment 想对已有的元组做任何\"改变“ 只能创建新的元组，对于列表来说，由于其是动态的，我们只需简单地在列表末尾，加入对应元素就可以了。 1 2 3 4 5 6 7 8 9 tup = (1, 2, 3, 4) new_tup = tup + (5, ) # 创建新的元组 new_tup，并依次填充原元组的值 new _tup (1, 2, 3, 4, 5) l = [1, 2, 3, 4] l.append(5) # 添加元素 5 到原列表的末尾 l [1, 2, 3, 4, 5] ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:1:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"2. Python 中的列表和元组都支持负数索引 Python 中的列表和元组都支持负数索引，-1 表示最后一个元素，-2 表示倒数第二个元素。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:2:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"3. 列表和元组都支持切片操作 1 2 3 4 5 6 7 l = [1, 2, 3, 4] l[1:3] # 返回列表中索引从 1 到 2 的子列表 [2, 3] tup = (1, 2, 3, 4) tup[1:3] # 返回元组中索引从 1 到 2 的子元组 (2, 3) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:3:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"4. 列表和元组都可以随意嵌套 1 2 3 l = [[1, 2, 3], [4, 5]] # 列表的每一个元素也是一个列表 tup = ((1, 2, 3), (4, 5, 6)) # 元组的每一个元素也是一元组 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:4:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"5. 两者也可以通过 list() 和 tuple() 函数相互转换 1 2 3 4 5 list((1, 2, 3)) [1, 2, 3] tuple([1, 2, 3]) (1, 2, 3) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:5:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"6. 列表和元组常用的内置函数 count(item) 表示统计列表 / 元组中 item 出现的次数。 index(item) 表示返回列表 / 元组中 item 第一次出现的索引。 list.reverse() 和 list.sort() 分别表示原地倒转列表和排序（注意，元组没有内置的这两个函数)。 reversed() 和 sorted() 同样表示对列表 / 元组进行倒转和排序，但是会返回一个倒转后或者排好序的新的列表 / 元组。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 l = [3, 2, 3, 7, 8, 1] l.count(3) 2 l.index(7) 3 l.reverse() l [1, 8, 7, 3, 2, 3] l.sort() l [1, 2, 3, 3, 7, 8] tup = (3, 2, 3, 7, 8, 1) tup.count(3) 2 tup.index(7) 3 list(reversed(tup)) [1, 8, 7, 3, 2, 3] sorted(tup) [1, 2, 3, 3, 7, 8] ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:6:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"7. 列表和元组存储方式的差异 列表的存储空间略大于元组。 列表是动态的、可变的，它需要存储指针，来指向对应的元素，为了减小每次增加 / 删减操作时空间分配的开销，Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)。。元组长度大小固定，元素不可变，所以存储空间固定。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:7:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"8. 列表和元组的性能 列表的性能略逊于元组。 ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:8:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"9. 列表和元组的使用场景 1. 如果存储的数据和数量不变，比如你有一个函数，需要返回的是一个地点的经纬度，然后直接传给前端渲染，那么肯定选用元组更合适。 1 2 3 def get_location(): ..... return (longitude, latitude) 2. 如果存储的数据或数量是可变的，比如社交平台上的一个日志功能，是统计一个用户在一周之内看了哪些用户的帖子，那么则用列表更合适。 1 2 3 4 viewer_owner_id_list = [] # 里面的每个元素记录了这个 viewer 一周内看过的所有 owner 的 id records = queryDB(viewer_id) # 索引数据库，拿到某个 viewer 一周内的日志 for record in records: viewer_owner_id_list.append(record.id) ","date":"2023-01-15","objectID":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/:9:0","tags":["python"],"title":"Python中的列表和元组","uri":"/posts/program/python/7_python%E5%88%97%E8%A1%A8%E5%92%8C%E5%85%83%E7%BB%84/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 字典排序 1. 字典排序 2. 字典列表排序 计算字典值之和 移除字典点键值 合并字典 使用字典格式化字符串 1. 简介 字典是另一种可变容器模型，且可存储任意类型对象。 字典的每个键值 key=\u003evalue 对用冒号 : 分割，每个对之间用逗号(,)分割，整个字典包括在花括号 {} 中 ,格式如下所示： 1 d = {key1 : value1, key2 : value2, key3 : value3 } 键必须是唯一的，但值则不必。 值可以取任何数据类型，但键必须是不可变的，如字符串，数字。 1.1. 字典排序 ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:0:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"1.2. 字典排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 # coding:utf-8 from random import randint def key_sort(dict): print(\"按键(key)排序:\") # sorted(key_value) 返回重新排序的列表 # 字典按键排序 for i in sorted(dict): print((i, dict[i]), end=\" \") print(\"\\r\") def value_sort(dict): print(\"按键(value)排序:\") # sorted(key_value) 返回重新排序的列表 # 字典按键排序 for i in sorted(dict.items(), key=lambda kv: (kv[1])): print(i) print(\"\\r\") def main(): d = {x: randint(60, 100) for x in \"xyzabc\"} key_sort(d) value_sort(d) # 主函数 if __name__ == \"__main__\": main() ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:1:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"1.3. 字典列表排序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # coding:utf-8 def main(): lis = [ {\"name\": \"Taobao\", \"age\": 100}, {\"name\": \"Runoob\", \"age\": 7}, {\"name\": \"Google\", \"age\": 100}, {\"name\": \"Wiki\", \"age\": 200}, ] print(\"\\r\") # 通过 age 升序排序 print(\"列表通过 age 升序排序: \") print(sorted(lis, key=lambda i: i[\"age\"])) print(\"\\r\") # 先按 age 排序，再按 name 排序 print(\"列表通过 age 和 name 排序: \") print(sorted(lis, key=lambda i: (i[\"age\"], i[\"name\"]))) print(\"\\r\") # 按 age 降序排序 print(\"列表通过 age 降序排序: \") print(sorted(lis, key=lambda i: i[\"age\"], reverse=True)) # 主函数 if __name__ == \"__main__\": main() 2. 计算字典值之和 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # coding:utf-8 from random import randint def returnSum(Dict): sum = 0 for i in Dict: sum = sum + Dict[i] return sum def main(): d = {x: randint(60, 100) for x in \"xyzabc\"} print(returnSum(d)) # 主函数 if __name__ == \"__main__\": main() 3. 移除字典点键值 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 # coding:utf-8 from random import randint def main(): test_dict = {x: randint(0, 50) for x in \"abcdefg\"} # 输出原始的字典 print (\"字典移除前 : \" + str(test_dict)) # 使用 del 移除 Zhihu del test_dict['a'] # 使用 pop 移除 Zhihu removed_value = test_dict.pop('b') print(\"removed_value : \" + str(removed_value)) # 使用 pop 移除 Zhihu new_dict = {key:val for key, val in test_dict.items() if key != 'c'} # 输出移除后的字典 print (\"字典移除后 : \" + str(test_dict)) print (\"字典移除后 : \" + str(new_dict)) # 主函数 if __name__ == \"__main__\": main() 4. 合并字典 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # coding:utf-8 from random import randint def Merge1(dict1, dict2): return(dict2.update(dict1)) def Merge2(dict1, dict2): res = {**dict1, **dict2} return res def main(): d1 = {x: randint(0, 50) for x in \"abc\"} d2 = {x: randint(50, 100) for x in \"xyz\"} Merge1(d1, d2) print(d2) dict2 = Merge2(d1, d2) print(dict2) # 主函数 if __name__ == \"__main__\": main() 5. 使用字典格式化字符串 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # coding:utf-8 from random import randint def main(): # 字符串模板中使用key temp = '教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s' book = {'name':'Python基础教程', 'price': 99, 'publish': 'C语言中文网'} # 使用字典为字符串模板中的key传入值 print(temp % book) book = {'name':'C语言小白变怪兽', 'price':159, 'publish': 'C语言中文网'} # 使用字典为字符串模板中的key传入值 print(temp % book) # 主函数 if __name__ == \"__main__\": main() ","date":"2023-01-15","objectID":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/:2:0","tags":["python"],"title":"Python中的字典","uri":"/posts/program/python/5_python%E4%B8%AD%E7%9A%84%E5%AD%97%E5%85%B8/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 字典和集合基础 字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，字典有序是一个 implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。 相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数时间复杂度内完成。 而集合和字典基本相同，唯一的区别，就是集合没有键和值的配对，是一系列无序的、唯一的元素组合。 Python 中字典和集合，无论是键还是值，都可以是混合类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 d1 = {'name': 'jason', 'age': 20, 'gender': 'male'} d2 = dict({'name': 'jason', 'age': 20, 'gender': 'male'}) d3 = dict([('name', 'jason'), ('age', 20), ('gender', 'male')]) d4 = dict(name='jason', age=20, gender='male') d1 == d2 == d3 ==d4 True s = {1, 'hello', 5.0} s1 = {1, 2, 3} s2 = set([1, 2, 3]) s1 == s2 True ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:0:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"元素访问 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"字典 字典访问可以直接索引键，如果不存在，就会抛出异常 1 2 3 4 5 6 7 d = {'name': 'jason', 'age': 20} d['name'] 'jason' d['location'] Traceback (most recent call last): File \"\u003cstdin\u003e\", line 1, in \u003cmodule\u003e KeyError: 'location' 也可以使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值。比如下面这个示例，返回了'null'。 1 2 3 4 5 d = {'name': 'jason', 'age': 20} d.get('name') 'jason' d.get('location', 'null') 'null' ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:1","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"集合 集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:1:2","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"增加、删除、更新等操作 字典和集合也同样支持增加、删除、更新等操作。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 d = {'name': 'jason', 'age': 20} d['gender'] = 'male' # 增加元素对'gender': 'male' d['dob'] = '1999-02-01' # 增加元素对'dob': '1999-02-01' d {'name': 'jason', 'age': 20, 'gender': 'male', 'dob': '1999-02-01'} d['dob'] = '1998-01-01' # 更新键'dob'对应的值 d.pop('dob') # 删除键为'dob'的元素对 '1998-01-01' d {'name': 'jason', 'age': 20, 'gender': 'male'} s = {1, 2, 3} s.add(4) # 增加元素 4 到集合 s {1, 2, 3, 4} s.remove(4) # 从集合中删除元素 4 s {1, 2, 3} 集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你无法知道会删除哪个元素，因此这个操作得谨慎使用。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:2:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"排序 1 2 3 4 5 6 7 d = {'b': 1, 'a': 2, 'c': 10} d_sorted_by_key = sorted(d.items(), key=lambda x: x[0]) # 根据字典键的升序排序 d_sorted_by_value = sorted(d.items(), key=lambda x: x[1]) # 根据字典值的升序排序 d_sorted_by_key [('a', 2), ('b', 1), ('c', 10)] d_sorted_by_value [('b', 1), ('a', 2), ('c', 10)] 返回了一个列表。列表中的每个元素，是由原字典的键和值组成的元组。 对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表。 1 2 3 s = {3, 4, 2, 1} sorted(s) # 对集合的元素进行升序排序 [1, 2, 3, 4] ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:3:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"性能 对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。 而对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。 ","date":"2023-01-15","objectID":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/:4:0","tags":["python"],"title":"Python中的字典和集合","uri":"/posts/program/python/8_python%E5%AD%97%E5%85%B8%E5%92%8C%E9%9B%86%E5%90%88/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:0:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串基础 Python 中单引号、双引号和三引号的字符串是一模一样的，没有区别。 1 2 3 4 5 s1 = 'hello' s2 = \"hello\" s3 = \"\"\"hello\"\"\" s1 == s2 == s3 True Python 的三引号字符串，则主要应用于多行字符串的情境，比如函数的注释等等。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:1:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"转义字符 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:1:1","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串的常用操作 Python 的字符串同样支持索引，切片和遍历等等操作。 1 2 3 4 5 name = 'jason' name[0] 'j' name[1:3] 'as' Python 的字符串是不可变的（immutable）,Python 中字符串的改变，通常只能通过创建新的字符串来完成。 1 2 3 4 5 # 是直接用大写的'H'，通过加号'+'操作符，与原字符串切片操作的子字符串拼接而成新的字符串。 s = 'H' + s[1:] # 是直接扫描原字符串，把小写的'h'替换成大写的'H'，得到新的字符串。 s = s.replace('h', 'H') 使用加法操作符'+='的字符串拼接方法。 1 2 3 s = '' for n in range(0, 100000): s += str(n) 对于字符串拼接问题，除了使用加法操作符，我们还可以使用字符串内置的 join 函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来。 1 2 3 4 l = [] for n in range(0, 100000): l.append(str(n)) l = ' '.join(l) 由于列表的 append 操作是 O(1) 复杂度，字符串同理。因此，这个含有 for 循环例子的时间复杂度为 n*O(1)=O(n)。 ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:2:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"split() string.split(separator)，表示把字符串按照 separator 分割成子字符串，并返回一个分割后子字符串组合的列表 string.strip(str)，表示去掉首尾的 str 字符串 string.lstrip(str)，表示只去掉开头的 str 字符串 string.rstrip(str)，表示只去掉尾部的 str 字符串 1 2 3 s = ' my name is jason ' s.strip() 'my name is jason' ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:3:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"字符串的格式化 1 2 3 4 5 6 print('no data available for person with id: {}, name: {}'.format(id, name)) 'no data available for person with id: 123, name: jason' # 在 Python 之前版本中，字符串格式化通常用 % 来表示 print('no data available for person with id: %s, name: %s' % (id, name)) ","date":"2023-01-15","objectID":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/:4:0","tags":["python"],"title":"Python中的字符串操作","uri":"/posts/program/python/9_%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/"},{"categories":["python"],"content":"python 编程笔记","date":"2023-01-15","objectID":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/","tags":["python"],"title":"Python中的装饰器","uri":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["python"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 装饰器(Decorators) 装饰器(Decorators) 装饰器（Decorator）是Python中一个重要部分，它本质上是一个函数，不同于普通函数，装饰器的返回值是一个函数对象。通过利用装饰器，我们可以让其他函数在不做任何代码改动的情况下增加额外的功能，同时也能够让代码更加简洁。 ","date":"2023-01-15","objectID":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/:0:0","tags":["python"],"title":"Python中的装饰器","uri":"/posts/program/python/6_python%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"categories":["rust"],"content":"rust 编程笔记","date":"2023-01-15","objectID":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["rust"],"title":"rust环境搭建","uri":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["rust"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Rust 程序设计语言 中文版 安装 rust Getting started 1 2 3 4 5 6 7 8 9 10 11 # 安装 curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh # 升级 rustup update # 卸载 rustup self uninstall # 查看版本 rustc --version vscode 插件：rust-analyzer ： Rust 语言服务器 (RLS) 已被弃用，取而代之的是 rust-analyzer。RLS 用户应该改用 rust-analyzer。 （2022-07-02） 编译运行 rustc rustc 只适合简单的程序。 1 rustc main.rs cargo Cargo 是 Rust 的构建系统和包管理器。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 查看版本 cargo --version # 构建项目 cargo new hello_cargo cd hello_cargo # 构建了项目，并使用 ./target/debug/hello_cargo 运行了程序 cargo build # cargo run 在一个命令中同时编译代码并运行生成的可执行文件 cargo run # 快速检查代码确保其可以编译，但并不产生可执行文件 cargo check # 优化编译项目 cargo build --release cargo build --debug 使用 Cargo 当作习惯 1 2 3 git clone example.org/someproject cd someproject cargo build ","date":"2023-01-15","objectID":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["rust"],"title":"rust环境搭建","uri":"/posts/program/rust/1.rust%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["rust"],"content":"rust 编程笔记","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Rust 程序设计语言 中文版 关键字 as - 强制类型转换，消除特定包含项的 trait 的歧义，或者对 use 和 extern crate 语句中的项重命名 async - 返回一个 Future 而不是阻塞当前线程 await - 暂停执行，直到 Future 的结果准备好 break - 立刻退出循环 const - 定义常量或不变裸指针（constant raw pointer） continue - 继续进入下一次循环迭代 crate - 链接（link）一个外部 crate 或一个代表宏定义的 crate 的宏变量 dyn - 动态分发 trait 对象 else - 作为 if 和 if let 控制流结构的 fallback enum - 定义一个枚举 extern - 链接一个外部 crate 、函数或变量 false - 布尔字面量 false fn - 定义一个函数或 函数指针类型 (function pointer type) for - 遍历一个迭代器或实现一个 trait 或者指定一个更高级的生命周期 if - 基于条件表达式的结果分支 impl - 实现自有或 trait 功能 in - for 循环语法的一部分 let - 绑定一个变量 loop - 无条件循环 match - 模式匹配 mod - 定义一个模块 move - 使闭包获取其所捕获项的所有权 mut - 表示引用、裸指针或模式绑定的可变性 pub - 表示结构体字段、impl 块或模块的公有可见性 ref - 通过引用绑定 return - 从函数中返回 Self - 实现 trait 的类型的类型别名 self - 表示方法本身或当前模块 static - 表示全局变量或在整个程序执行期间保持其生命周期 struct - 定义一个结构体 super - 表示当前模块的父模块 trait - 定义一个 trait true - 布尔字面量 true type - 定义一个类型别名或关联类型 unsafe - 表示不安全的代码、函数、trait 或实现 use - 引入外部空间的符号 where - 表示一个约束类型的从句 while - 基于一个表达式的结果判断是否进行循环 变量和可变性 ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:0:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"immutable \u0026 immutable 不可变的（immutable），可变的（immutable）。 1 2 3 4 5 6 fn main() { let mut x = 5; println!(\"The value of x is: {}\", x); x = 6; println!(\"The value of x is: {}\", x); } ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:1:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"常量 常量（constant）是绑定到一个常量名且不允许更改的值。 1 const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3; ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:2:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"遮蔽 遮蔽（shadow）：以声明和前面变量具有相同名称的新变量，这意味着当我们使用变量时我们看到的会是第二个变量的值。 1 2 3 4 5 6 7 8 9 10 11 12 fn main() { let x = 5; let x = x + 1; { let x = x * 2; println!(\"The value of x in the inner scope is: {}\", x); } println!(\"The value of x is: {}\", x); } mut 和遮蔽之间的另一个区别是，因为我们在再次使用 let 关键字时有效地创建了一个新的变量，所以我们可以改变值的类型，但重复使用相同的名称。 1 2 let spaces = \" \"; let spaces = spaces.len(); 数据类型 Rust 是一种静态类型（statically typed）的语言，这意味着它必须在编译期知道所有变量的类型。 1 let guess: u32 = \"42\".parse().expect(\"Not a number!\"); ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:3:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"标量类型 标量（scalar）类型表示单个值。Rust 有 4 个基本的标量类型：整型、浮点型、布尔型和字符。 整型 长度 有符号类型 无符号类型 8 位 i8 u8 16 位 i16 u16 32 位 i32 u32 64 位 i64 u64 128 位 i128 u128 arch isize usize 整型字面量 数字字面量 示例 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 (仅限于 u8) b'A' 浮点型 Rust 的浮点型是 f32 和 f64，它们的大小分别为 32 位和 64 位。默认浮点类型是 f64，因为在现代的 CPU 中它的速度与 f32 的几乎相同，但精度更高。所有浮点型都是有符号的。 数字运算 Rust 的所有数字类型都支持基本数学运算：加法、减法、乘法、除法和取模运算。整数除法会向下取整。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 fn main() { // addition let sum = 5 + 10; // subtraction let difference = 95.5 - 4.3; // multiplication let product = 4 * 30; // division let quotient = 56.7 / 32.2; let floored = 2 / 3; // Results in 0 // remainder let remainder = 43 % 5; } bool 1 let f: bool = false; char 1 let c = 'z'; ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:4:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"复合类型 Rust 有两种基本的复合类型：元组（tuple）和数组（array）。 1 2 3 4 5 6 7 let tup: (i32, f64, u8) = (500, 6.4, 1); let a = [1, 2, 3, 4, 5]; let months = [\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]; let a: [i32; 5] = [1, 2, 3, 4, 5]; // i32 是每个元素的类型。分号之后，数字 5 表明该数组包含 5 个元素。 let a = [3; 5]; // 变量名为 a 的数组将包含 5 个元素，这些元素的值初始化为 3。 函数 Rust 中的函数定义以 fn 开始，后跟着函数名和一对圆括号。大括号告诉编译器函数体在哪里开始和结束。 参数 1 2 3 4 5 6 7 fn main() { another_function(5); } fn another_function(x: i32) { println!(\"The value of x is: {}\", x); } 语句和表达式 语句（statement）是执行一些操作但不返回值的指令。表达式（expression）计算并产生一个值 1 2 3 4 5 6 7 8 fn main() { let y = { let x = 3; x + 1 // 注意，x + 1 行的末尾没有分号，这与你目前见过的大部分代码行不同。表达式的结尾没有分号。如果在表达式的末尾加上分号，那么它就转换为语句，而语句不会返回值。 }; println!(\"The value of y is: {}\", y); } 带有返回值的函数 1 2 3 4 5 6 7 8 9 fn five() -\u003e i32 { 5 } fn main() { let x = five(); println!(\"The value of x is: {}\", x); } 控制流 ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:5:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["rust"],"content":"if 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 fn main() { let number = 6; if number % 4 == 0 { println!(\"number is divisible by 4\"); } else if number % 3 == 0 { println!(\"number is divisible by 3\"); } else if number % 2 == 0 { println!(\"number is divisible by 2\"); } else { println!(\"number is not divisible by 4, 3, or 2\"); } let condition = true; let number = if condition { 5 } else { 6 }; println!(\"The value of number is: {}\", number); } 循环 Rust 有三种循环：loop、while 和 for。 loop loop 关键字告诉 Rust 一遍又一遍地执行一段代码直到你明确要求停止。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 fn main() { let mut count = 0; 'counting_up: loop { println!(\"count = {}\", count); let mut remaining = 10; loop { println!(\"remaining = {}\", remaining); if remaining == 9 { break; } if count == 2 { break 'counting_up; } remaining -= 1; } count += 1; } println!(\"End count = {}\", count); } 从循环返回 1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let mut counter = 0; let result = loop { counter += 1; if counter == 10 { break counter * 2; } }; println!(\"The result is {}\", result); } while 在程序中计算循环的条件也很常见。当条件为真，执行循环。当条件不再为真，调用 break 停止循环。这个循环类型可以通过组合 loop、if、else 和 break 来实现. for 1 2 3 4 5 6 7 fn main() { let a = [10, 20, 30, 40, 50]; for element in a { println!(\"the value is: {}\", element); } } ","date":"2023-01-15","objectID":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/:6:0","tags":["rust"],"title":"rust通用编程概念","uri":"/posts/program/rust/2.rust%E9%80%9A%E7%94%A8%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/shell/","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 资料 note：关键字 1. $#,$@,$0,$1,$2 2. while循环和遍历参数 3. i 4. 通配符wildcard 5. 元字符（特殊字符 Meta） 6. shell转义符 7. 管道和重定向 note:代码段 1. 判断文件夹或文件是否存在 资料 ABS_GUIDE Linux Shell 通配符、元字符、转义符使用实例介绍 note：关键字 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:0:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"$#,$@,$0,$1,$2 $$ Shell本身的PID（ProcessID） $! Shell最后运行的后台Process的PID $? 最后运行的命令的结束代码（返回值） $- 使用Set命令设定的Flag一览 $* 所有参数列表。如\"$*\"用「\"」括起来的情况、以\"$1 $2 … $n\"的形式输出所有参数。 $@ 所有参数列表。如\"$@\"用「\"」括起来的情况、以\"$1\" \"$2\" … \"$n\" 的形式输出所有参数。 $# 添加到Shell的参数个数 $0 Shell本身的文件名 $1～$n 添加到Shell的各参数值。$1是第1参数、$2是第2参数…。 1 2 3 4 5 6 7 8 9 10 #!/bin/bash printf \"The complete list is %s\\n\" \"$$\" printf \"The complete list is %s\\n\" \"$!\" printf \"The complete list is %s\\n\" \"$?\" printf \"The complete list is %s\\n\" \"$*\" printf \"The complete list is %s\\n\" \"$@\" printf \"The complete list is %s\\n\" \"$#\" printf \"The complete list is %s\\n\" \"$0\" printf \"The complete list is %s\\n\" \"$1\" printf \"The complete list is %s\\n\" \"$2 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:1:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"while循环和遍历参数 1 2 3 4 5 while [ $# -gt 0 ] ; do echo $1 #左移一个参数，这样可以使用$1遍历所有参数 shift done ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:2:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"i 1 2 3 4 5 !! 重复前一个命令 !字符 重复前一个以此字符开头的命令 !num 重复历史记录里序号为num的命令 !?abc 重复执行之前命令中包含abc的命令 !-n 重复之前第n个命令 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:3:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"通配符(wildcard) ​ 通配符是由shell处理的（不是由所涉及到命令语句处理的，其实我们在shell各个命令中也没有发现有这些通配符介绍）, 它只会出现在 命令的“参数”里（它不用在 命令名称里， 也不用在 操作符上）。当shell在“参数”中遇到了通配符时，shell会将其当作路径或文件名去在磁盘上搜寻可能的匹配：若符合要求的匹配存在，则进行代换(路径扩展)；否则就将该通配符作为一个普通字符传递给“命令”，然后再由命令进行处理。总之，通配符 实际上就是一种shell实现的路径扩展功能。在 通配符被处理后, shell会先完成该命令的重组，然后再继续处理重组后的命令，直至执行该命令。 1 2 3 4 5 6 * 匹配一个或多个 M* 以M 开头的字符串 ？匹配任意一个字符 M？ 以M开头的两个字符 [0-9]匹配0-9中的一个数字 [abc]匹配abc中的一个字符 [^abc]匹配abc以外的一个字符 ls Do[ab]ument 报错，匹配不到 ls Document 字符 含义 实例 * 匹配 0 或多个字符 a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。 ? 匹配任意一个字符 a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。 [list] 匹配 list 中的任意单一字符 a[xyz]b a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。 [!list] 匹配 除list 中的任意单一字符 a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b… a9b。 {string1,string2,…} 匹配 sring1 或 string2 (或更多)其一字符串 a{abc,xyz,123}b a与b之间只能是abc或xyz或123这三个字符串之一。 需要说明的是：通配符看起来有点象正则表达式语句，但是它与正则表达式不同的，不能相互混淆。把通配符理解为shell 特殊代号字符就可。而且涉及的只有，*,? [] ,{} 这几种。 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:4:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"元字符（特殊字符 Meta） shell 除了有通配符之外，由shell 负责预先先解析后，将处理结果传给命令行之外，shell还有一系列自己的其他特殊字符。 字符 说明 IFS 由 或 或 三者之一组成(我们常用 space )。 CR 由 产生。 = 设定变量。 $ 作变量或运算替换(请不要与 shell prompt 搞混了)。 \u003e 重导向 stdout。 * \u003c 重导向 stdin。 * | 命令管线。 * \u0026 重导向 file descriptor ，或将命令置于背境执行。 * ( ) 将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 * { } 将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。 ; 在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 * \u0026\u0026 在前一个命令结束时，若返回值为 true，继续执行下一个命令。 * || 在前一个命令结束时，若返回值为 false，继续执行下一个命令。 * ! 执行 history 列表中的命令。* 加入”*” 都是作用在命令名直接。可以看到shell 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。 以下是man bash 得到的英文解析： metacharacter A character that, when unquoted, separates words. One of the following: | \u0026 ; ( ) \u003c \u003e space tab control operator A token that performs a control function. It is one of the following symbols: || \u0026 \u0026\u0026 ; ;; ( ) | ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:5:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"shell转义符 有时候，我们想让 通配符，或者元字符 变成普通字符，不需要使用它。那么这里我们就需要用到转义符了。 shell提供转义符有三种。 字符 说明 ‘’(单引号) 又叫硬转义，其内部所有的shell 元字符、通配符都会被关掉。注意，硬转义中不允许出现’(单引号)。 “”(双引号) 又叫软转义，其内部只允许出现特定的shell 元字符：$用于参数代换 `用于命令代替 (反斜杠) 又叫转义，去除其后紧跟的元字符或通配符的特殊意义。 man bash 英文解释如下： There are three quoting mechanisms: the escape character, single quotes, and double quotes. ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:6:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"管道和重定向 多命令协作:通过管道和重定向完成.(将多个命令结合在一起),几乎所有命令的输入和返回输出是纯文本. example : cat 输入 文件路径 返回 文件文本内容 命令行shell的数据流定义: 名称 说明 编号 默认 STDIN 标准输入 0 键盘 STDOUT 标准输出 1 终端 STDERR 标准错误 2 终端 命令通过STDIN接收参数或数据，通过STDOUT输出结果或通过STDERR输出错误. 分类 关键字 定义 例子 重定向 \u003e 将STDOUT重定向到文件(覆盖) echo “baidu” \u003e outfile / ls \u003e outfile » 将STDOUT重定向到文件(追加) echo “baidu” » outfile/ date »outfile 2\u003e 将STDERROR重定向到文件(覆盖) ls nothere 2\u003e errorout 2\u003e\u00261 将STDERROR与STDOUT结合 ls nothere 2\u003e\u00261 alloutput \u003c 重定向STDIN grep linuxcast \u003c /etc/passwd 管道 | 将一个命令的STDOUT ls -l | grep linuxcast 作为另一个命令的STDIN find / -user linuxcast | grep video 2\u003e /dev/null 重定向给null,丢弃 note:代码段 ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:7:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"判断文件夹或文件是否存在 文件夹不存在则创建 1 2 3 4 5 if [ ! -d \"/data/\" ];then mkdir /data else echo \"文件夹已经存在\" fi 文件存在则删除 1 2 3 4 5 if [ ! -f \"/data/filename\" ];then echo \"文件不存在\" else rm -f /data/filename fi 判断文件夹是否存在 1 2 3 4 5 if [ -d \"/data/\" ];then echo \"文件夹存在\" else echo \"文件夹不存在\" fi 判断文件是否存在 1 2 3 4 5 if [ -f \"/data/filename\" ];then echo \"文件存在\" else echo \"文件不存在\" fi 文件比较符 1 2 3 4 5 6 7 8 9 10 11 12 13 -e 判断对象是否存在 -d 判断对象是否存在，并且为目录 -f 判断对象是否存在，并且为常规文件 -L 判断对象是否存在，并且为符号链接 -h 判断对象是否存在，并且为软链接 -s 判断对象是否存在，并且长度不为0 -r 判断对象是否存在，并且可读 -w 判断对象是否存在，并且可写 -x 判断对象是否存在，并且可执行 -O 判断对象是否存在，并且属于当前用户 -G 判断对象是否存在，并且属于当前用户组 -nt 判断file1是否比file2新 [ \"/data/file1\" -nt \"/data/file2\" ] -ot 判断file1是否比file2旧 [ \"/data/file1\" -ot \"/data/file2\" ] ","date":"2023-01-15","objectID":"/posts/program/bash/shell/:8:0","tags":["bash"],"title":"shell","uri":"/posts/program/bash/shell/"},{"categories":["bash"],"content":"bash 编程笔记","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 # 井号 (comments) ~ 帐户的 home 目录 ; 分号 (Command separator) ;; 连续分号 (Terminator) 逗号 (dot,就是“点”) ‘string’ 单引号 (single quote) “string” 双引号 (double quote) command 倒引号 (backticks) , 逗点 (comma，标点中的逗号) / 斜线 (forward slash) \\ 倒斜线 | 管道 (pipeline) ! 惊叹号(negate or reverse) : 冒号 ? 问号 (wild card) * 星号 (wild card) ** 次方运算 $ 钱号(dollar sign) 1. 变量替换(Variable Substitution)的代表符号。 2. ${} 变量的正规表达式 3. $* 4. $@ 5. $# 6. $? 状态值 (status variable) 7. $$ () 指令群组 (command group) 1. (())) {} 大括号 (Block of code) 1. 常规用法 1.1. 大括号拓展 1.2. 代码块 2. 几种特殊的替换结构 3. 四种模式匹配替换结构 4. 字符串提取和替换 [] 中括号 [[]] || \u0026\u0026 \u0026 1. ||或逻辑符号 2. \u0026\u0026 逻辑符号 3. \u0026后台工作 / 单字边界 + 加号 (plus) - 减号 (dash) % 除法 (Modulo) = 等号 (Equals) == 等号 (Equals) != 不等于 ^ 参考： 在shell中常用的特殊符号罗列如下： 1 2 3 4 5 # ; ;; . , / \\\\ 'string'| ! $ ${} $? $$ $* \\\"string\\\"* ** ? : ^ $# $@ `command`{} [] [[]] () (()) || \u0026\u0026 {xx,yy,zz,...}~ ~+ ~- \u0026 \\\\\u003c...\\\\\u003e + - %= == != # 井号 (comments) 这几乎是个满场都有的符号，除了先前已经提过的\"第一行\" #!/bin/bash 井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。 1 2 # This line is comments. echo \\\"a = $a\\\" # a = 0 由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。 1 echo \\\"a = $a\\\" # a = 0 如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。 ~ 帐户的 home 目录 算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份： 1 ~/bin ~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。 1 2 # echo ~+/ var/log ~- 上次的工作目录，这个符号代表上次的工作目录。 1 2 # echo ~- /etc/httpd/logs ; 分号 (Command separator) 在 shell 中，担任\"连续指令\"功能的符号就是\"分号\"。譬如以下的例子： 1 cd ~/backup ; mkdir startup ;cp ~/.* startup/. ;; 连续分号 (Terminator) 专用在 case 的选项，担任 Terminator 的角色。 1 2 3 4 5 6 7 8 case \\\"$fop\\\" inhelp) echo \\\"Usage: Command -help -version filename\\\" ;; version) echo \\\"version 0.1\\\" ;; esac 逗号 (dot,就是“点”) 在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。 1 CDPATH=.:~:/home:/home/web:/var:/usr/local 在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。 如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。 除此之外，在 regular expression 中，一个 dot 代表匹配一个字元。 ‘string’ 单引号 (single quote) 被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。 1 2 heyyou=home echo '$heyyou' # We get $heyyou \"string\" 双引号 (double quote) 被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。 通配符是一种特殊语句，主要有星号(*)和问号(?)，用来模糊搜索文件。 当查找文件夹时，可以使用它来代替一个或多个真正字符；当不知道真正字符或者懒得输入完整名字时，常常使用通配符代替一个或多个真正的字符。 实际上用“*Not?pad”可以对应Notepad\\MyNotepad【*可以代表任何字符串；?仅代表单个字符串，但此单字必须存在】;Notep[ao]d可以对应Notepad\\Notepod【ao代表a与o里二选一】，其余以此类推。 1 2 heyyou=home echo \"$heyyou\" # We get home command 倒引号 (backticks) 在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。 1 2 fdv=`date +%F` echo \"Today $fdv\" 在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。 , 逗点 (comma，标点中的逗号) 这个符号常运用在运算当中当做\"区隔\"用途。如下例 1 2 let \"t1= ((a = 5 + 3, b = 7 - 1, c = 15 / 5),(a + b + c))\" echo \"t1= $t1, a = $a, b = $b\" let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。 如果表达式中包含了空格或其他特殊字符，则必须引起来。 / 斜线 (forward slash) 在路径表示时，代表目录。 1 2 3 cd /etc/rc.d cd ../.. cd / 通常单一的 / 代表 root 根目录的意思； 在四则运算中，代表除法的符号。 let \"num1 = ((a = 10 / 2, b = 25 / 5))\" \\ 倒斜线 在交互模式下的escape 字元，有几个作用: 放在指令前，有取消 aliases的作用； 放在特殊符号前，则该特殊符号的作用消失； 放在指令的最末端，表示指令连接下一行。 1 2 # type rmrm is aliased to `rm -i' # \\\\rm ./*.log 上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。 1 # bkdir=/home# echo \\\"Backup dir, \\\\$bkdir = $bkdir\\\"Backup dir,$bkdir = /home 上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。 | 管道 (pipeline) pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。 1 2 3 4 5 who | wc -l # wc命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。 # - c 统计字节数。 # - l 统计行数。 # - w 统计字数。 善用这个观念，对精简 script 有相当的帮助。 ! 惊叹号(negate or reverse) 通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表”不等于” 1 2 3 4 if [ \"$?\" != 0 ]then echo \"Executes error\" exit 1 fi 在规则表达式中她担任 “反逻辑” 的角色 1 ls a[!0-9] 上例，代表显示除了a0, a1 …. a9 这几个文件的其他文件。 : 冒号 在 bash 中，这是一个内建指令：”什么事都不干”，但返回状态值 0。 1 2 3 : echo $? # 回应为 0 : \u003e f.$$ 上面这一行，相当于 cat /dev/null \u003e f.$$。不仅写法简短了，而且执行效率也好上许多。 有时，也会出现以下这类的用法 1 : ${HOSTNAME?} ${USER?} ${MAIL?} 这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if 这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:0:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. 变量替换(Variable Substitution)的代表符号。 1 2 vrs=123 echo \"vrs = $vrs\" # vrs = 123 另外，在 Regular Expressions 里被定义为 “行” 的最末端 (end-of-line)。这个常用在 grep、sed、awk 以及 vim(vi) 当中。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:1:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. ${} 变量的正规表达式 bash 对 ${} 定义了不少用法。以下是取自线上说明的表列 1 2 3 4 5 ${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameter:offset} ${parameter:offset:length} ${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/string} ${parameter//pattern/string} ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:2:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. $* $* 引用script 的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下： 1 $0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}….. 个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。 $* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。 1 echo “$*” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:3:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"4. $@ $@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。 符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:4:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"5. $# 这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。 1 echo “$#” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:5:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"6. $? 状态值 (status variable) 一般来说，UNIX(linux) 系统的进程以执行系统调用exit() 来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。 一般指令程序倘若执行成功，其回传值为 0；失败为 1。 1 tar cvfz dfbackup.tar.gz /home/user \u003e /dev/nullecho “$?” ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:6:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"7. $$ 由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script 会需要产生临时文件，用来存放必要的资料。 而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。 符号$$或许可以符合这种需求。它代表当前shell 的 PID。 1 echo “$HOSTNAME, $USER, $MAIL” \u003e ftmp.$$ 使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。 ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果 script 执行完毕后仍不加以清除，会产生其他问题。 () 指令群组 (command group) 用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子： 1 (cd ~ ; vcgh=`pwd` ; echo $vcgh) 指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子 1 # cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e “/n $a /n”)echo $a# ./ftmp-01incgfsh 除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape 字元才能使用的场合，如运算式。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:7:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. (())) 这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let 指令要好许多。 1 2 3 4 5 #!/bin/bash (( a = 10 )) echo -e \"inital value, a = $a/n\" (( a++ )) echo \"after a++, a = $a\" {} 大括号 (Block of code) ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:8:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. 常规用法 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1.1. 大括号拓展 (通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt 1 2 3 4 5 6 # ls {ex1,ex2}.sh ex1.sh ex2.sh # ls {ex{1..3},ex4}.sh ex1.sh ex2.sh ex3.sh ex4.sh # ls {ex[1-3],ex4}.sh ex1.sh ex2.sh ex3.sh ex4.sh ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:1","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1.2. 代码块 又被称为内部组，这个结构事实上创建了一个匿名函数 。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。 大括号也被运用在 “函数” 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script 也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:9:2","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. 几种特殊的替换结构 1 2 3 4 ${var:-string} ${var:+string} ${var:=string} ${var:?string} 1、${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，否则变量var不为空时，则用变量var的值来替换${var:-string}；对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： ${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。 2、${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 3、{var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。 补充扩展：在上面这五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。 此外，大括号还有另一种用法，如下 1 {xx,yy,zz,…} 这种大括号的组合，常用在字串的组合上，来看个例子 1 mkdir {userA,userB,userC}-{home,bin,data} 我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子 1 chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}} 如果不是因为这种用法，我们得写几行重复几次呀！ ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:10:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. 四种模式匹配替换结构 模式匹配记忆方法： 1 2 # 是去掉左边(在键盘上#在$之左边) % 是去掉右边(在键盘上%在$之右边) #和%中的单一符号是最小匹配，两个相同符号是最大匹配。 1 2 3 4 ${var%pattern} ${var%%pattern ${var#pattern} ${var##pattern} 第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式 第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式 第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式 这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # var=testcase # echo $var testcase # echo ${var%s*e} testca # echo $var testcase # echo ${var%%s*e} te # echo ${var#?e} stcase # echo ${var##?e} stcase # echo ${var##*e} # echo ${var##*s} e # echo ${var##test} case ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:11:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"4. 字符串提取和替换 1 2 3 4 ${var:num} ${var:num1:num2} ${var/pattern/pattern} ${var//pattern/pattern} 第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。 第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。 第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。 第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [root@centos ~]# var=/home/centos [root@centos ~]# echo $var /home/centos [root@centos ~]# echo ${var:5} /centos [root@centos ~]# echo ${var: -6} centos [root@centos ~]# echo ${var:(-6)} centos [root@centos ~]# echo ${var:1:4} home [root@centos ~]# echo ${var/o/h} /hhme/centos [root@centos ~]# echo ${var//o/h} /hhme/cenths [] 中括号 常出现在流程控制中，扮演括住判断式的作用。 1 2 3 4 if [ \"$?\" != 0 ]then echo \"Executes error\" exit 1 fi 这个符号在正则表达式中担任类似 “范围” 或 “集合” 的角色 1 rm -r 200[1234] 上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。 [[]] 这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与 \u0026\u0026 逻辑等符号。 1 2 3 4 5 #!/bin/bash read ak if [[ $ak \u003e 5 || $ak \u003c 9 ]]then echo $ak fi || \u0026\u0026 \u0026 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:12:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"1. ||或逻辑符号 这个会时常看到，代表 or 逻辑的符号。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:13:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"2. \u0026\u0026 逻辑符号 这个也会常看到，代表 and 逻辑的符号。 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:14:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["bash"],"content":"3. \u0026后台工作 单一个\u0026 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。 1 tar cvfz data.tar.gz data \u003e /dev/null \u0026 / 单字边界 这组符号在规则表达式中，被定义为”边界”的意思。譬如，当我们想找寻 the 这个单字时，如果我们用 1 grep the FileA 你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there 的一部份。如果我们要必免这种情况，就得加上 “边界” 的符号 1 grep ‘/' FileA + 加号 (plus) 在运算式中，她用来表示 “加法”。 1 expr 1 + 2 + 3 此外在规则表达式中，用来表示”很多个”的前面字元的意思。 1 # grep '10/+9′ fileB109100910000910000931010009#这个符号在使用时，前面必须加上 escape 字元。 - 减号 (dash) 在运算式中，她用来表示 “减法”。 1 expr 10 – 2 此外也是系统指令的选项符号。 1 ls -expr 10 – 2 在 GNU 指令中，如果单独使用 – 符号，不加任何该加的文件名称时，代表”标准输入”的意思。这是 GNU 指令的共通选项。譬如下例 1 tar xpvf - 这里的 – 符号，既代表从标准输入读取资料。 不过，在 cd 指令中则比较特别 1 cd - 这代表变更工作目录到”上一次”工作目录。 % 除法 (Modulo) 在运算式中，用来表示 “除法”。 1 expr 10 % 2 此外，也被运用在关于变量的规则表达式当中的下列 1 ${parameter%word}${parameter%%word} 一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。 = 等号 (Equals) 常在设定变数时看到的符号。 1 2 vara=123 echo \"vara = $vara\" 或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。 == 等号 (Equals) 常在条件判断式中看到，代表 “等于” 的意思。 1 2 if [ $vara == $varb ] …下略 != 不等于 常在条件判断式中看到，代表 “不等于” 的意思。 1 2 if [ $vara != $varb ] …下略 ^ 这个符号在规则表达式中，代表行的 “开头” 位置 ","date":"2023-01-15","objectID":"/posts/program/bash/special_symbol/:15:0","tags":["bash"],"title":"shell 中的特殊符号","uri":"/posts/program/bash/special_symbol/"},{"categories":["tools"],"content":"repo","date":"2023-01-15","objectID":"/posts/tools/git/repo/","tags":["repo"],"title":"tool: repo 代码库管理工具","uri":"/posts/tools/git/repo/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 ","date":"2023-01-15","objectID":"/posts/tools/git/repo/:0:0","tags":["repo"],"title":"tool: repo 代码库管理工具","uri":"/posts/tools/git/repo/"},{"categories":["tools"],"content":"android studio 安装使用","date":"2023-01-15","objectID":"/posts/tools/android/android_studio/","tags":["android studio"],"title":"tool:android studio 安装使用","uri":"/posts/tools/android/android_studio/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 下载 安装 配置 插件 快捷键设置 1. 下载 studio 2. 安装 1 2 3 mv android-studio-2021.2.1.15-linux.tar.gz /opt/ cd /opt sudo tar -zxvf android-studio-2021.2.1.15-linux.tar.gz 更改 /opt/android-studio/bin/idea.porperties： 1 sudo gedit /opt/android-studio/bin/idea.properties 文末添加 1 disable.android.first.run=true 此操作防止第一次打开Android Studio时卡在”Fetching Android SDK component information” 。 更改/opt/android-studio/bin目录权限： 1 sudo chmod 777 /opt/android-studio/bin 配置 插件 Rainbow Brackets 快捷键设置 参考: 【Android – 开发工具】Android Studio 设置快捷键 File → Settings → keymap 代码返回快捷键 ： Ctrl + Alt + left/right ","date":"2023-01-15","objectID":"/posts/tools/android/android_studio/:0:0","tags":["android studio"],"title":"tool:android studio 安装使用","uri":"/posts/tools/android/android_studio/"},{"categories":["tools"],"content":"下载工具","date":"2023-01-15","objectID":"/posts/tools/aria2c/aria2c/","tags":["aria2c"],"title":"tool:aria2c下载工具","uri":"/posts/tools/aria2c/aria2c/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 安装 配置 服务模式开机启动 简介 Aria2 是一个多平台轻量级，支持 HTTP、FTP、BitTorrent 等多协议、多来源的命令行下载工具。Aria2 可以从多个来源、多个协议下载资源，最大的程度上利用了你的带宽。Aria2 有着非常小的资源占用，在关闭磁盘缓存的情况下，物理内存占用通常为 4M（正常 HTTP/FTP 下载的情况下），BitTorrent 下载每秒2.8M/S的情况下，CPU 占有率约为 6%。Aria2 支持 JSON-RPC 和 XML-RPC 接口远程调用。 安装 1 sudo apt-get install aria2 配置 创建配置文件 : 1 2 3 4 sudo mkdir /etc/aria2 #新建文件夹 sudo touch /etc/aria2/aria2.session #新建session文件 sudo chmod 777 /etc/aria2/aria2.session #设置aria2.session可写 sudo vi /etc/aria2/aria2.conf #创建配置文件 配置文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 ## 全局设置 ## ============================================================ # 日志 #log-level=warn #log=/PATH/.aria2/aria2.log # 后台运行 #daemon=true # 下载位置, 默认: 当前启动位置(***) dir=/home/***/Downloads # 从会话文件中读取下载任务(***) input-file=/usr/customer/aria2/aria2.session # 在Aria2退出时保存`错误/未完成`的下载任务到会话文件(***) save-session=/usr/customer/aria2/aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=30 # 断点续传 continue=true # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M #disk-cache=32M # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u003c falloc ? trunc \u003c prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=none https://www.jianshu.com/p/6adf79d29add # 客户端伪装 user-agent=netdisk;5.2.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia referer=http://pan.baidu.com/disk/home # 禁用IPv6, 默认:false disable-ipv6=true # 其他 always-resume=true check-integrity=true ## 下载位置 ## ============================================================ # 最大同时下载任务数, 运行时可修改, 默认:5 max-concurrent-downloads=10 # 同一服务器连接数, 添加时可指定, 默认:1 max-connection-per-server=10 # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 split=5 # 整体下载速度限制, 运行时可修改, 默认:0 #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0 #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0 #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0 #max-upload-limit=0 ## RPC设置 ## ============================================================ # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许非外部访问, 默认:false rpc-listen-all=true # 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同 #event-poll=select # RPC监听端口, 端口被占用时可以修改, 默认:6800 rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 #rpc-secret=\u003cTOKEN\u003e # 是否启用 RPC 服务的 SSL/TLS 加密, # 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接 #rpc-secure=true # 在 RPC 服务中启用 SSL/TLS 加密时的证书文件, # 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥 #rpc-certificate=/path/to/certificate.pem # 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件 #rpc-private-key=/path/to/certificate.key ## BT/PT下载相关 ## ============================================================ # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true #follow-torrent=true # BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999 listen-port=51413 # 单个种子最大连接数, 默认:55 #bt-max-peers=55 # 打开DHT功能, PT需要禁用, 默认:true enable-dht=false # 打开IPv6 DHT功能, PT需要禁用 #enable-dht6=false # DHT网络监听端口, 默认:6881-6999 #dht-listen-port=6881-6999 dht-file-path=/opt/var/aria2/dht.dat dht-file-path6=/opt/var/aria2/dht6.dat # 本地节点查找, PT需要禁用, 默认:false #bt-enable-lpd=false # 种子交换, PT需要禁用, 默认:true enable-peer-exchange=false # 每个种子限速, 对少种的PT很有用, 默认:50K #bt-request-peer-speed-limit=50K # 设置 peer id 前缀 peer-id-prefix=-TR2770- # 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0 seed-ratio=0 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # BT校验相关, 默认:true #bt-hash-check-seed=true # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverif","date":"2023-01-15","objectID":"/posts/tools/aria2c/aria2c/:0:0","tags":["aria2c"],"title":"tool:aria2c下载工具","uri":"/posts/tools/aria2c/aria2c/"},{"categories":["tools"],"content":"gdb","date":"2023-01-15","objectID":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/","tags":["gdb"],"title":"tool:gdb 常用调试方法记录","uri":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 gdb 启动程序带运行参数 指定断点位置 gdb 启动程序带运行参数 1 2 3 set args --gtest_filter=TestAdasPipe.AssetsData r --gtest_filter=TestAdasPipe.AssetsData 指定断点位置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 断点管理 https://blog.csdn.net/wohu1104/article/details/125052150 # 查看断点 info b i b # 启用断点并命中N次 enable count 数量 断点编号 # 忽略断点前N次命中 ignore 断点编号 次数 # 删除所有断点 delete # 删除指定断点 delete 断点编号 # 删除指定范围的断点 delete 范围 delete 5-7 delete 5-7 10-12 # 删除指定函数的断点 clear 函数名 # 删除指定行号的断点 clear demo.cpp:10 执行到下一个断点 c ","date":"2023-01-15","objectID":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/:0:0","tags":["gdb"],"title":"tool:gdb 常用调试方法记录","uri":"/posts/tools/gdb/%E5%B8%B8%E7%94%A8%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/"},{"categories":["tools"],"content":"git tag","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git tag ","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/:0:0","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":"git tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git tag # 列出已有的标签 git tag -l \"v0.1\" # 过滤列出已有的标签 git tag -a v1.4 -m \"my version 1.4\" # 创建标签 git show v1.4 # 查看标签信息和与之对应的提交信息 git tag -d v1.4 # 删除标签 git push origin :refs/tags/v1.4 # 删除远程标签 git push origin --delete v1.4 # 删除远程标签 git checkout v1.4 # 切换到 v1.4 tag git checkout -b version_v1.4 v1.4 # 切换到 v1.4 tag version_v1.4 git push origin v1.4 # 传送标签到远程仓库服务器 git push origin --tags # 把所有不在远程仓库服务器上的标签全部传送到远程仓库服务器 后期打标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git log --pretty=oneline dd1db2ddf7ab23a57b0197abe80167ba4847f185 (HEAD -\u003e master, tag: v0.0.2, origin/master, origin/HEAD) Merge branch 'release-0.0.2' 1967f19f3d2f7b13d18f80dada14da1b8385ecc3 (release-0.0.2) version update :v0.0.2 28b3ff52ea28221314264482d6db6fb7349cf2f8 (develop) Merge branch 'release-0.0.1' into develop e2d4b5d8eb8407d7141c9846c4459cd1733922fb (release-0.0.1) version update :v0.0.1 2c6ffbce9ffd31e4cee8ca5013924324b49ec898 add bump-version.sh 9c29190a5388ae74f6c983468c8637de40653816 (origin/develop) Merge remote-tracking branch 'origin/hotfix' into develop 5a0a3d928c59a35e3421d2dc029b0487e24a2772 add HotFix/01.fix 78881870f888c519f21025d22869eb5d38b75030 Merge remote-tracking branch 'origin/myfeature_02' into develop 1c9e156e9b54c6714a6f6e8075b8f6cf316ca7c5 Merge remote-tracking branch 'origin/myfeature_01' into develop b2dc34bc80ce6c9a77a9c399abc7633d09bf9359 Merge branch 'myfeature' into develop 696a92f6e0f77700c1aef37a57abcbc5d69a6673 add TestFile/4.text 5f57182ab7113fdadfa855e4c78237e1a29292b8 Merge branch 'myfeature' into develop 18dd8ba9bb27dc1ff1e414c8538转载说明beb9e904c9032 TestFile/3.test 2124458eef016c34a4d0a0af68dc93166e93ba84 TestFile/2.test 754b56d1c44e49923d679c41839e84e0dfb650d6 add TestFile/1.test 3a8af3c6e7d2852d24b6de6711530cc0ddcc8760 Merge branch 'myfeature' into develop 963672575df191249da5c7f1aaef56afa9cccf2e (origin/feature, feature) add new file 395f4fbd335500cf7c5b51735a27231bea028cd8 (origin/release) Initial commit git tag -a v0.0.1 5a0a3d928c59a35e3421d2dc029b0487e24a2772 git tag -a v0.0.0 -m \"version 0.0.0\" 395f4fbd335500cf7c5b51735a27231bea028cd8 ","date":"2023-01-15","objectID":"/posts/tools/git/git_tag/:1:0","tags":["git"],"title":"tool:git tag 的使用","uri":"/posts/tools/git/git_tag/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. Git提交代码的流程 2. git commit –amend 3. git 查看 4. git 修改某次提交 5. 修改提交时间 6. commit 撤回及修改 重写历史 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:0:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"Git提交代码的流程 提交流程 1 2 3 4 git pull --rebase git add . git commit -m\"\" git push origin xxx 1 2 3 git push origin --delete xx # 删除远程分支 git push origin xxx --force # 强制推送到远程分支 git push origin dev-zyh # 推送到指定分支 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:1:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git commit –amend 1 2 3 git commit --amend # 会通过 core.editor 指定的编辑器进行编辑 git commit --amend --no-edit # 不会进入编辑器，直接进行提交 git commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\" ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:2:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git 查看 1 2 3 4 5 6 7 8 9 git log -1 --stat git show 548c72f42f51c22dbf2fdf133426e094c59789e4 --stat git show //最新的commit git show commitId //指定commit git show commitId fileName //指定commit的某个文件 # 查看指定commit id对应修改文件列表 git show --raw git show --raw commit_id ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:3:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git 修改某次提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 commit f2711319a72fa9d3a5486c397c7a10511b970036 (HEAD -\u003e master) Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Mon Aug 24 13:08:12 2020 +0800 update shll sys folder commit 1caaf17d90a3288aff8897fca08e33c81a6b9703 Author: yuhuzhang \u003cyuhuzhang@deepglint.com\u003e Date: Mon Aug 24 12:56:55 2020 +0800 add RunPowerOn.sh commit 8ac823f3e93e82638db5b076952bdcfa12e93cfb Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Fri Aug 21 19:44:06 2020 +0800 add go test file 1 2 3 4 5 6 7 8 git rebase -i 8ac823f3e93e82638db5b076952bdcfa12e93cfb edit b8901f3 add RunPowerOn.sh pick 5593c97 update shll sys folder git cazyh git rebase --continue 1 2 3 4 1.git rebase -i 分支~移动数字 2. 选择对应操作 3.git commit --amend 4.git rebase continue ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:4:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"修改提交时间 1 git commit --amend --date=\"2020-11-28T09:51:07\" --no-edit ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:5:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"commit 撤回及修改 1 2 3 git reset --soft :取消commit git reset --mixed :取消commit ，取消add git reset --hard :取消commit ，取消add，取消源文件修改 ","date":"2023-01-15","objectID":"/posts/tools/git/git_commit/:6:0","tags":["git"],"title":"tool:git 修改提交","uri":"/posts/tools/git/git_commit/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git 缓存清理（解决ignore不生效问题） .git 文件夹过大 出现原因 删除历史操作 脚本操作 git 缓存清理（解决ignore不生效问题） 明明.ignore文件中标明了忽略，提交时还是有这些文件？ .ignore文件可以按照其注明的规则让git忽略文件，但是有时候，有部分我们不想让git管理的文件已经被git管理了，我们再在.ingore中添加规则，是不能生效的，这时我们清理下git缓存就好 删除git 缓存 1 2 3 git rm -r --cached . git add . git commit -m 'update .gitignore' 下次提交我们就不会看到.ignore中的文件了 .git 文件夹过大 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"出现原因 .git文件主要用来记录每次提交的变动，当我们的项目越来越大的时候， .git文件越来越大。 很大的可能是因为提交了大文件，如果你提交了大文件 A，那么即使你在之后的版本中将其删除，但实际上，记录中的大文件仍然存在。 原因在于虽然你在后面的版本中删除了大文件A，但是Git是有版本倒退功能，那么如果大文件A不记录下来，git拿什么来回退呢？ git给出了解决方案，使用git branch-filter来遍历git history tree, 可以永久删除history中的大文件，达到让.git文件瘦身的目的。 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"删除历史操作 首先找出git中前N大的文件 1 git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}' | sed ':a;N;$!ba;s/\\n/|/g'` 删除文件 遍历所有提交： commit多了会比较慢 1 git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch \u003cfile\u003e' --tag-name-filter cat -- --all 回收内存 1 2 3 4 5 6 7 8 9 10 11 rm -Rf .git/refs/original rm -Rf .git/logs/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now 提交到远程仓库 1 git push --force [remote] master 上述操作最重要的两条命令是 git filter-branch 和 gc, filter-branch 真正在清理，但是只运行它也是没用的，需要再删除备份的文件，重新打包之类的，最后的gc命令，用来收集产生的垃圾，最终清除大文件。 ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"脚本操作 编辑脚本文件： git_clean.sh 脚本文件下载：git_clean.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git rev-list --objects --all | grep -E `git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -10 | awk '{print$1}' | sed ':a;N;$!ba;s/\\n/|/g'` \u003e1.txt for value in `cat 1.txt |awk '{print $2}'` do # echo ${value} git log --pretty=oneline --branches -- ${value} git filter-branch --index-filter \"git rm --cached --ignore-unmatch ${value}\" -- --all rm -Rf .git/refs/original rm -Rf .git/logs/ git reflog expire --expire=now --all git fsck --full --unreachable git repack -A -d git gc --aggressive --prune=now done 将脚本文件放置到仓库根目录（与.git 同级） 执行 1 ./git_clean.sh 更新远程仓库 1 git push --force [remote] master ","date":"2023-01-15","objectID":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","tags":["git"],"title":"tool:git 常见问题","uri":"/posts/tools/git/git%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["tools"],"content":"git","date":"2023-01-15","objectID":"/posts/tools/git/git/","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 git 部分概念 四个工作区域 工作流程 文件的四种状态 git 常用命令 git 安装配置 git 乱码 Git提交代码的流程 git commit –amend git 查看 git diff git diff meld git rm git reset git config git stash git alias git log git fetch / merge /pull git tag git 常用操作 git 修改某次提交 修改提交时间 添加子项目/库 移动代码到另一个仓库保留提交点 全局修改邮箱地址 拉取远程分支强制覆盖本地 常见概念 Pull Request branch 开发/发布/缺陷分离模型 (支持 master/develop/feature/release/hotfix 类型分支) 参考资料 git 部分概念 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:0:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"四个工作区域 Git本地有四个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)、git仓库(Remote Directory)。 Workspace： 工作区，就是你平时存放项目代码的地方 Index / Stage： 暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息 Repository： 仓库区（或版本库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本 Remote： 远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:1:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"工作流程 git的工作流程一般是这样的： １、在工作目录中添加、修改文件； ２、将需要进行版本管理的文件放入暂存区域； ３、将暂存区域的文件提交到git仓库。 因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed) ","date":"2023-01-15","objectID":"/posts/tools/git/git/:2:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"文件的四种状态 GIT不关心文件两个版本之间的具体差别，而是关心文件的整体是否有改变，若文件被改变，在添加提交时就生成文件新版本的快照，而判断文件整体是否改变的方法就是用 SHA-1算法计算文件的校验和。 Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified.如果使用git rm移出版本库, 则成为Untracked文件 Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过,返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存,文件状态为Modified 新建文件—\u003eUntracked 使用add命令将新建的文件加入到暂存区—\u003eStaged 使用commit命令将暂存区的文件提交到本地仓库—\u003eUnmodified 如果对Unmodified状态的文件进行修改—\u003e modified 如果对Unmodified状态的文件进行remove操作—\u003eUntracked git 常用命令 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:3:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 安装配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 sudo apt-get install git git config --global user.name \"yuhuzhang\" git config --global user.email \"yuhuzhang@deepglint.com\" git config --global user.name \"zhangyuhu\" git config --global user.email \"zhangyuhu@didiglobal.com\" ssh-keygen -C 'yuhuzhang@deepglint.com' -t rsa cat ~/.ssh/id_rsa.pub sudo apt install gitk sudo apt-get install git-gui gitk git config --global core.editor vim git config --add core.filemode false # 忽略filemode发生改变 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:4:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 乱码 编辑 .gitconfig 1 2 [gui] encoding = utf-8 1 2 3 git config --global gui.encoding utf-8 图形界面编码 git config --global i18n.commit.encoding utf-8 提交信息编码 git config --global i18n.logoutputencoding utf-8 输出 log 编码 1 2 3 4 5 # \"linux\\347\\263\\273\\347\\273\\237\\347\\256\\241\\347\\220\\206.md\" git config --global core.quotepath false # core.quotepath的作用是控制路径是否编码显示的选项。当路径中的字符大于0x80的时候，如果设置为true，转义显示；设置为false，不转义。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:5:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"Git提交代码的流程 提交流程 1 2 3 4 git pull --rebase git add . git commit -m\"\" git push origin xxx 1 2 3 git push origin --delete xx # 删除远程分支 git push origin xxx --force # 强制推送到远程分支 git push origin dev-zyh # 推送到指定分支 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:6:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git commit –amend 1 2 3 git commit --amend # 会通过 core.editor 指定的编辑器进行编辑 git commit --amend --no-edit # 不会进入编辑器，直接进行提交 git commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:7:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 查看 1 2 3 4 5 git log -1 --stat git show 548c72f42f51c22dbf2fdf133426e094c59789e4 --stat git show //最新的commit git show commitId //指定commit git show commitId fileName //指定commit的某个文件 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:8:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git diff 1 2 3 4 5 6 7 8 9 10 11 12 #比较工作空间中的文件和暂存区文件的差异 git diff [files] #比较暂存区的文件与之前已经提交过的文件差异 git diff --cached [files] #比较repo与工作空间中的文件差异 git diff HEAD [files] #查看本地分支和远程差异 git diff origin/master git diff origin/HEAD ","date":"2023-01-15","objectID":"/posts/tools/git/git/:9:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git diff meld 1 2 3 4 5 sudo apt-get install meld git config --global diff.tool meld git difftool master..devel git difftool dev-adas-730 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:10:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git rm 1 2 3 4 5 #当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用（⚠️） git rm file_path #当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 这个时候直接push那边这个文件就没有，如果push之前重新add那么还是会有。 git rm --cached file_path ","date":"2023-01-15","objectID":"/posts/tools/git/git/:11:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git reset 1 2 3 4 5 6 7 #如果出现:将不必要的文件commit 或者 上次提交觉得是错的 或者 不想改变暂存区内容，只是想调整提交的信息 #移除不必要的添加到暂存区的文件 git reset HEAD 文件名 #去掉上一次的提交（会直接变成add之前状态） git reset HEAD^ #去掉上一次的提交（变成add之后，commit之前状态） git reset --soft HEAD^ ","date":"2023-01-15","objectID":"/posts/tools/git/git/:12:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git config git config config 配置有system级别 global（用户级别） 和local（当前仓库）三个 设置先从system-》global-》local 底层配置会覆盖顶层配置 分别使用–system/global/local 可以定位到配置文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 查看系统config git config --system --list # 查看当前用户（global）配置 git config --global --list # 查看当前仓库配置信息 git config -- local --list # 显示当前的Git配置 git config --list # 编辑Git配置文件 git config -e [--global] ","date":"2023-01-15","objectID":"/posts/tools/git/git/:13:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git stash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 git stash git stash save 'message...'可以添加一些注释 git stash list git stash pop [–index] [stash_id] git stash pop 恢复最新的进度到工作区。git默认会把工作区和暂存区的改动都恢复到工作区。 git stash pop --index 恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区） git stash pop stash@{1}恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 通过git stash pop命令恢复进度后，会删除当前进度。 git stash apply [–index] [stash_id] 除了不删除恢复的进度之外，其余和git stash pop 命令一样。 git stash drop [stash_id] 删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。 git stash clear 删除所有存储的进度。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:14:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git alias 配置别名 1 2 3 4 5 locate .gitconfig cd xx cat .gitconfig git config --global alias.cazyh 'commit --amend --no-edit --author \"zhangyuhu \u003czhangyuhude@163.com\u003e\"' ","date":"2023-01-15","objectID":"/posts/tools/git/git/:15:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git log 1 2 3 git log --graph git config --global alias.lg \"log --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)\u003c%an\u003e%Creset' --abbrev-commit --date=relative\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:16:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git fetch / merge /pull git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。 而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。 1 2 3 4 5 6 # 从远程的origin仓库的master主分支更新最新的版本到origin/master分支上 git fetch origin master # 比较本地的master分支和origin/master分支的差别 git log -p master..origin/master # 合并内容到本地master分支 git merge origin/master 尽量少用git pull，多用git fetch和merge ","date":"2023-01-15","objectID":"/posts/tools/git/git/:17:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git tag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 git tag # 列出已有的标签 git tag -l \"v0.1\" # 过滤列出已有的标签 git tag -a v1.4 -m \"my version 1.4\" # 创建标签 git show v1.4 # 查看标签信息和与之对应的提交信息 git tag -d v1.4 # 删除标签 git push origin :refs/tags/v1.4 # 删除远程标签 git push origin --delete v1.4 # 删除远程标签 git checkout v1.4 # 切换到 v1.4 tag git checkout -b version_v1.4 v1.4 # 切换到 v1.4 tag version_v1.4 git push origin v1.4 # 传送标签到远程仓库服务器 git push origin --tags # 把所有不在远程仓库服务器上的标签全部传送到远程仓库服务器 后期打标签 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 git log --pretty=oneline dd1db2ddf7ab23a57b0197abe80167ba4847f185 (HEAD -\u003e master, tag: v0.0.2, origin/master, origin/HEAD) Merge branch 'release-0.0.2' 1967f19f3d2f7b13d18f80dada14da1b8385ecc3 (release-0.0.2) version update :v0.0.2 28b3ff52ea28221314264482d6db6fb7349cf2f8 (develop) Merge branch 'release-0.0.1' into develop e2d4b5d8eb8407d7141c9846c4459cd1733922fb (release-0.0.1) version update :v0.0.1 2c6ffbce9ffd31e4cee8ca5013924324b49ec898 add bump-version.sh 9c29190a5388ae74f6c983468c8637de40653816 (origin/develop) Merge remote-tracking branch 'origin/hotfix' into develop 5a0a3d928c59a35e3421d2dc029b0487e24a2772 add HotFix/01.fix 78881870f888c519f21025d22869eb5d38b75030 Merge remote-tracking branch 'origin/myfeature_02' into develop 1c9e156e9b54c6714a6f6e8075b8f6cf316ca7c5 Merge remote-tracking branch 'origin/myfeature_01' into develop b2dc34bc80ce6c9a77a9c399abc7633d09bf9359 Merge branch 'myfeature' into develop 696a92f6e0f77700c1aef37a57abcbc5d69a6673 add TestFile/4.text 5f57182ab7113fdadfa855e4c78237e1a29292b8 Merge branch 'myfeature' into develop 18dd8ba9bb27dc1ff1e414c8538转载说明beb9e904c9032 TestFile/3.test 2124458eef016c34a4d0a0af68dc93166e93ba84 TestFile/2.test 754b56d1c44e49923d679c41839e84e0dfb650d6 add TestFile/1.test 3a8af3c6e7d2852d24b6de6711530cc0ddcc8760 Merge branch 'myfeature' into develop 963672575df191249da5c7f1aaef56afa9cccf2e (origin/feature, feature) add new file 395f4fbd335500cf7c5b51735a27231bea028cd8 (origin/release) Initial commit git tag -a v0.0.1 5a0a3d928c59a35e3421d2dc029b0487e24a2772 git tag -a v0.0.0 -m \"version 0.0.0\" 395f4fbd335500cf7c5b51735a27231bea028cd8 git 常用操作 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:18:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"git 修改某次提交 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 commit f2711319a72fa9d3a5486c397c7a10511b970036 (HEAD -\u003e master) Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Mon Aug 24 13:08:12 2020 +0800 update shll sys folder commit 1caaf17d90a3288aff8897fca08e33c81a6b9703 Author: yuhuzhang \u003cyuhuzhang@deepglint.com\u003e Date: Mon Aug 24 12:56:55 2020 +0800 add RunPowerOn.sh commit 8ac823f3e93e82638db5b076952bdcfa12e93cfb Author: zhangyuhu \u003czhangyuhude@163.com\u003e Date: Fri Aug 21 19:44:06 2020 +0800 add go test file 1 2 3 4 5 6 7 8 git rebase -i 8ac823f3e93e82638db5b076952bdcfa12e93cfb edit b8901f3 add RunPowerOn.sh pick 5593c97 update shll sys folder git cazyh git rebase --continue 1 2 3 4 1.git rebase -i 分支~移动数字 2. 选择对应操作 3.git commit --amend 4.git rebase continue ","date":"2023-01-15","objectID":"/posts/tools/git/git/:19:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"修改提交时间 1 git commit --amend --date=\"2020-11-28T09:51:07\" --no-edit ","date":"2023-01-15","objectID":"/posts/tools/git/git/:20:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"添加子项目/库 git submodule add 仓库地址 路径 仓库地址是指子模块仓库地址，路径指将子模块放置在当前工程下的路径。 1 git submodule add -f https://gitee.com/fromyuhu/helloword ","date":"2023-01-15","objectID":"/posts/tools/git/git/:21:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"移动代码到另一个仓库保留提交点 查看当前分支远程状态 1 2 3 git remote # 列出已经存在的远程分支 git remote -v # 列出已经存在的远程分支 在每一个名字后面列出其远程url git remote show origin # 查看远程仓库，以及与本地仓库的关系 添加远程仓库 1 2 git remote add \u003cshortname\u003e \u003curl\u003e #添加一个新的远程 Git 仓库，同时指定一个方便使用的简写 git remote add origin_repo_b git@server_ip:/path/repo_b.git 推送代码到指定远程 1 2 3 git push origin_repo_b branch_a # origin_repo_b:远程 仓库repo_b的名字 # branch_a: 仓库repo_a的branch_a分支 克隆仓库repo_b，或者使用页面，检查是否push成功 1 git clone git@server_ip:/path/repo_b.git 远程仓库的重命名与移除 1 2 3 git remote rename origin_repo_b zyh_origin # 修改一个远程仓库的简写名 git remote remove origin_repo_b # 移除一个远程仓库 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:22:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"全局修改邮箱地址 另一个常见的情形是在你开始工作时忘记运行 git config 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 filter-branch 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 –commit-filter： 1 2 3 4 5 6 7 8 9 $ git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"yuhuzhang@deepglint.com\" ]; then GIT_AUTHOR_NAME=\"zhangyuhu\"; GIT_AUTHOR_EMAIL=\"zhangyuhude@163.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_NAME\" = \"yuhuzhang\" ]; then GIT_AUTHOR_NAME=\"zhangyuhu\"; GIT_AUTHOR_EMAIL=\"zhangyuhude@163.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 1 2 3 4 5 6 7 8 9 git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"zhangyuhude@163.com\" ]; then GIT_AUTHOR_NAME=\"yuhuzhang\"; GIT_AUTHOR_EMAIL=\"yuhuzhang@deepglint.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD 这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:23:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"拉取远程分支强制覆盖本地 1 2 3 git fetch --all git reset --hard master git pull #可省略 1 git fetch --all \u0026\u0026 git reset --hard master \u0026\u0026 git pull 常见概念 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:24:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"Pull Request 有一个仓库，叫Repo A。你如果要往里贡献代码，首先要Fork这个Repo，于是在你的Github账号下有了一个Repo A2,。然后你在这个A2下工作，Commit，push等。然后你希望原始仓库Repo A合并你的工作，你可以在Github上发起一个Pull Request，意思是请求Repo A的所有者从你的A2合并分支。如果被审核通过并正式合并，这样你就为项目A做贡献了。 当你想更正别人仓库里的bug 或者增加 feature 时，要走一个流程： 先 fork 别人的仓库，相当于拷贝一份，不会有人直接让你改修原仓库的 clone 到本地分支，做一些 bug fix 或者 feature 开发 发起 pull request 给原仓库，让他看到你修改的 bug 原仓库 review 这个 bug，如果是正确的话，就会 merge 到他自己的项目中 至此，整个 pull request 的过程就结束了。 ","date":"2023-01-15","objectID":"/posts/tools/git/git/:25:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"branch 分支（branches）是用来标记特定的代码提交，每一个分支通过SHA1sum值来标识，所以对分支进行的操作是轻量级的——你改变的仅仅是SHA1sum值。所以为什么git提倡大家多使用分支，因为它即轻量级又灵活。 本地分支(local branches) 1 git branch 远程分支(remote branches) 1 git branch -r 分支在本地存储 .git/refs/head/[本地分支] .git/refs/remotes/[正在跟踪的分支] ","date":"2023-01-15","objectID":"/posts/tools/git/git/:26:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"开发/发布/缺陷分离模型 (支持 master/develop/feature/release/hotfix 类型分支) 介绍一个成功的 Git 分支模型(master - hotfix - develop - feature - release) 参考资料 gitbook 1 2 btime = !\"for k in `git branch|perl -pe s/^..//`;do echo `git show --pretty=format:\\\"%Cgreen%ci %Cblue%cr%Creset\\\" $k|head -n 1`\\\\\\t$k;done|sort\" brtime = !\"for k in `git branch -r|perl -pe s/^..//`;do echo `git show --pretty=format:\\\"%Cgreen%ci %Cblue%cr%Creset\\\" $k|head -n 1`\\\\\\t$k;done|sort\" ","date":"2023-01-15","objectID":"/posts/tools/git/git/:27:0","tags":["git"],"title":"tool:git: 常用命令笔记","uri":"/posts/tools/git/git/"},{"categories":["tools"],"content":"mac电脑常用配置","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":" 终端： homebrew : git mac快捷键 通用 Mac系统设置git命令自动补全 mac 使用 zsh ZSH oh-my-zsh zsh-syntax-highlighting 终端： iterm2 homebrew : 一、brew 安装脚本 （自动选择软件源） /bin/zsh -c “$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" 二、brew 卸载脚本 /bin/zsh -c “$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)\" 三、常用命令 安装软件：brew install xxx 卸载软件：brew uninstall xxx 搜索软件：brew search xxx 更新软件：brew upgrade xxx 查看列表：brew list 更新brew：brew update 清理所有包的旧版本：brew cleanup 清理指定包的旧版本：brew cleanup $FORMULA 查看可清理的旧版本包，不执行实际操作：brew cleanup -n git git config –global user.name “zhangyuhu” git config –global user.email “zhangyuhu@didiglobal.com” ssh-keygen -C ‘zhangyuhu@didiglobal.com’ -t rsa cat ~/.ssh/id_rsa.pub mac快捷键 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:0:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"通用 Command是Mac里最重要的修饰键，在大多数情况下相当于Windows下的Ctrl。 所以以下最基本操作很好理解： Command + Z 撤销 Command + X 剪切 Command + C 拷贝（Copy） Command + V 粘贴 Command + A 全选（All） Command + S 保存（Save) Command + F 查找（Find） Mac系统设置git命令自动补全 brew install bash-completion brew info bash-completion 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 DIDI-FVFDH0A8P3Y1:bash_completion.d didi$ brew info bash-completion bash-completion: stable 1.3 (bottled) Programmable completion for Bash 3.2 https://salsa.debian.org/debian/bash-completion Conflicts with: bash-completion@2 (because each are different versions of the same formula) /usr/local/Cellar/bash-completion/1.3_3 (189 files, 608.3KB) * Poured from bottle on 2021-09-15 at 00:40:57 From: https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git/Formula/bash-completion.rb ==\u003e Caveats Add the following line to your ~/.bash_profile: [[ -r \"/usr/local/etc/profile.d/bash_completion.sh\" ]] \u0026\u0026 . \"/usr/local/etc/profile.d/bash_completion.sh\" Bash completion has been installed to: /usr/local/etc/bash_completion.d ==\u003e Analytics install: 8,329 (30 days), 25,293 (90 days), 111,168 (365 days) install-on-request: 7,394 (30 days), 22,291 (90 days), 98,980 (365 days) build-error: 0 (30 days) git –version 1 git version 2.30.1 (Apple Git-130) curl https://raw.githubusercontent.com/git/git/v2.30.1/contrib/completion/git-completion.bash -o /usr/local/etc/bash_completion.d/git-completion.bash brew unlink bash-completion brew link bash-completion mac 使用 zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:1:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"ZSH 查看安装的 shell 1 2 3 4 5 6 7 8 cat /etc/shells /bin/bash /bin/csh /bin/ksh /bin/sh /bin/tcsh /bin/zsh 使用 brew 更新 zsh 1 2 3 4 5 6 brew install zsh ==\u003e Downloading https://homebrew.bintray.com/bottles/zsh-5.5.1.high_sierra.bottle.tar.gz ######################################################################## 100.0% ==\u003e Pouring zsh-5.5.1.high_sierra.bottle.tar.gz /usr/local/Cellar/zsh/5.5.1: 1,444 files, 12MB 切换为 zsh 1 chsh -s /bin/zsh 重启终端即可使用 zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:2:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"oh-my-zsh 下载安装脚本 1 sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 配置主题 1 2 ZSH_THEME=\"bira\" source ~/.zshrc 插件 自动补全插件 1 2 3 4 mkdir ~/.oh-my-zsh/custom/plugins/incr cd ~/.oh-my-zsh/custom/plugins/incr wget -O incr.plugin.zsh http://mimosa-pudica.net/src/incr-0.2.zsh # wget -O ~/.oh-my-zsh/plugins/incr/incr.plugin.zsh http://mimosa-pudica.net/src/incr-0.2.zsh incr 下载后，还需要在 ~/.zshrc 中添加： 1 2 3 4 5 plugins=( zsh-autosuggestions git incr ) 在 ~/.zshrc 文件末尾添加： 1 source ~/.oh-my-zsh/custom/plugins/incr/incr*.zsh ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:3:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"zsh-syntax-highlighting 官网 作用 平常用的ls、cd 等命令输入正确会绿色高亮显示，输入错误会显示其他的颜色。 安装 克隆项目 1 git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting 在 ~/.zshrc 中配置 1 plugins=(其他的插件 zsh-syntax-highlighting) 使配置生效 1 source ~/.zshrc 常用插件： zsh oh-my-zsh 插件推荐 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/mac/mac/:4:0","tags":["mac"],"title":"tool:mac电脑常用配置","uri":"/posts/tools/sys_config/mac/mac/"},{"categories":["tools"],"content":"Markdown","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 MD 语法示例 代码插入行数 高亮 表格 删除线 图片居中 MD 语法示例 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:0:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"代码插入行数 1 2 //11 //22 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:1:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"高亮 高亮 高亮 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:2:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"表格 项目 价格 Computer $1600 Phone $12 Pipe 可以使用冒号来定义对齐方式： 项目 价格 数量 Computer 1600 元 5 Phone 12 元 12 Pipe 1 元 234 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:3:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"删除线 我是删除线 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:4:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"图片居中 ","date":"2023-01-15","objectID":"/posts/tools/markdown/markdown/:5:0","tags":["Markdown"],"title":"tool:markdown语法示例","uri":"/posts/tools/markdown/markdown/"},{"categories":["tools"],"content":"minicom","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 简介 Minicoms使用 安装 相关配置 更多 Ctrl+A 自动保存log 退出软件 其他问题 配置串口权限 方式一：使用命令更改 方式二：配置udev规则(推荐) 配置默认文件 使用自动脚本 简介 minicom是一个串口通信工具，就像Windows下的超级终端。可用来与串口设备通信，如调试交换机和Modem等。 Minicoms使用 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:0:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"安装 1 sudo apt-get install minicom ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:1:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"相关配置 使用前需要进行配置，执行 1 sudo minicom -s 可打开minicom并进入配置模式，使用方向键，选择需要配置的项目，如 Serial port setup ，回车进入配置，可以看到多个配置项，此时光标在最下方。 需要修改某个配置，则输入对应的字母，光标即会跳转到对应的项，编辑后，回车确认，光标再次回到最下方。 一般而言，需要修改 1 2 3 A - Serial Device # A配置项，指定USB设备。一般USB转串口会生成设备/dev/ttyUSBx，x是数字序号。 E - Bps/Par/Bits # E配置项，根据实际情况，指定波特率等参数 F - Hardware Flow Control # F配置项，硬件流控，要看你的设备是否有。如果没有，或者你不确定的话，可以先关掉，将默认的Yes切换为No. 修改好之后，回车退到上一个界面，此时记得往下，选择 Save setup as dfl 将刚刚的修改保存为默认配置，避免下次使用还需要再次配置。 最后，选择 Exit 会退出配置界面，并打开minicom软件才会使用上述参数进行初始化。选择 Exit from Minicom 则会直接退出minicom。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:2:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"更多 可以使用 minicom -h 查看，也可在mincon中，按 Ctrl+A 再按 Z 查看。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"Ctrl+A Ctrl+A 是mimicom的特殊功能前缀按键，但还有另一个很实用的作用，就是暂停屏幕输出。在设备开始大量输出log时，基本看不清屏幕内容。此时可以按 Ctrl+A，暂停输出，方便查看所需log。 Ctrl+A 进入特殊功能： 按Z进入设置菜单 按 O键：打开配置选项 按 W键：自动卷屏。当显示的内容超过一行之後，自动将後面的内容换行。这个功能在查看内核的啓动信息时很有用 按 C键：清除屏幕的显示内容 按 B键：浏览minicom的历史显示 按 X键：退出minicom，会提示确认退出 按 N键：可激活时间戳，在每行log前添加当前系统的时间戳 按 S键：可向设备端发送文件 按 R键：可接收文件 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:1","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"自动保存log 让 minicom 自动保存log，可以方便调试。 查看参数，minicom可以使用 -C 参数指定保存log文件。于是完善脚本，自动把log以日期命名，保存到/tmp目录下。tmp目录关机即清空，如果想持久保存log，需要修改到其他目录。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:3:2","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"退出软件 minicom使用前缀按键 Ctrl-A，即执行特殊操作时，都需要先按 Ctrl+A，再按某个按键使用对应的功能。 Ctrl+A，再按 Z， 可查看帮助，从帮助可以看到，退出时，要先按 Ctrl+A，再按 X 其他问题 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:4:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"配置串口权限 minicom 本身不需要sudo权限，但因为要打开串口设备/dev/xxx ，所以一般会需要使用sudo来启动minicom。 这里我们可以修改下串口设备的权限，这样以后就不用使用sudo了。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"方式一：使用命令更改 简单粗暴地使用chmod命令修改 1 sudo chmod 666 /dev/ttyUSB0 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:1","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"方式二：配置udev规则(推荐) 修改配置文件 1 sudo vim /etc/udev/rules.d/70-ttyusb.rules 增加一行 1 KERNEL==\"ttyUSB[0-9]*\", MODE=\"0666\" 修改后，需要重新插拔设备，以重新生成设备节点。 ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:5:2","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"配置默认文件 在/etc/minicom/目录下是minicom的配置文件 增加配置文件如下： 1 sudo vi /etc/minicom/minirc.ttyUSB0 1 2 3 4 5 6 7 8 pr port /dev/ttyUSB0 pu baudrate 115200 pu bits 8 pu parity N pu stopbits 1 pu minit pu mreset pu rtscts No 执行 1 minicom ttyUSB0 加载默认配置文件 使用自动脚本 参考：EasierMinicom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 com() { local ports_USB ports_ACM ports datename dev devs dev_count ports_USB=$(ls /dev/ttyUSB* 2\u003enull | xargs -I {} basename {}) ports_ACM=$(ls /dev/ttyACM* 2\u003enull | xargs -I {} basename {}) ports=\"$ports_USB $ports_ACM\" #check lock devs=\"\" dev_count=0 for dev in ${ports}; do ! ls /run/lock/*\"${dev}\"* \u0026\u003e/dev/null \u0026\u0026 { devs+=\"${dev} \" ((dev_count++)) } done [ -z \"$devs\" ] \u0026\u0026 echo \"No Unlock Devices\" \u0026\u0026 return 0 datename=$(date +%Y%m%d-%H%M%S) if [ $dev_count -eq 1 ]; then dev=$devs else #select dev to open echo \"Please select one device: (Ctrl+C to abort)\" select dev in $devs; do if [ \"$dev\" ]; then echo \"You select the '$dev'\" break else echo \"Invaild selection\" fi done fi out=\"/tmp/$(basename ${dev}).$datename.log\" keep_dir=\"${HOME}/minicom_keep\" minicom $dev -C \"${out}\" \"$@\" [ -f \"${out}\" ] \u0026\u0026 { echo log : \"${out}\" read -p \"Keep it? [y|N]: \" keep [ \"${keep}\" = 'Y' -o \"${keep}\" = 'y' ] \u0026\u0026 { read -p \"Enter file name \u003e \" keep_file_name [ x\"$keep_file_name\" = x\"\" ] \u0026\u0026 keep_file_name=$(basename \"${out}\") mkdir -p \"$keep_dir\" cp \"${out}\" \"${keep_dir}/$keep_file_name\" echo \"saved in $keep_dir/$keep_file_name\" } } read -p \"Vim it? [y|N]: \" edit_vim [ \"${edit_vim}\" = 'Y' -o \"${edit_vim}\" = 'y' ] \u0026\u0026 vim \"${out}\" } 自动检测未锁定的设备，如果有多个则列出给用户选择，如果只有一个则直接使用。 默人加载 /etc/minicom/minirc.${dev} 的配置文件 自动保存log到/tmp目录，退出时，询问是否要保存到另外的目录。 使用 1 2 3 echo \"source $(pwd)/EasierMinicom.sh\" \u003e\u003e ~/.bashrc source ~/.bashrc com ","date":"2023-01-15","objectID":"/posts/tools/minicom/minicom/:6:0","tags":["minicom"],"title":"tool:minicom(串口通信工具的使用)","uri":"/posts/tools/minicom/minicom/"},{"categories":["tools"],"content":"NFS","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 什么是NFS Network File System SUN RPC 基本原理 NFS过程 NFS客户端和NFS服务端通讯过程 NFS服务的优缺点 Ubuntu主机的NFS共享文件夹 nfs server 安装 nfs client 安装 /etc/exports 参数 mount 参数 什么是NFS ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:0:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"Network File System 网络文件系统（英语：Network File System，缩写作 NFS）是一种分布式文件系统，力求客户端主机可以访问服务器端文件，并且其过程与访问本地存储时一样，它由Sun微系统（已被甲骨文公司收购）开发，于1984年发布。 它基于开放网络运算远程过程调用（ONC RPC）系统：一个开放、标准的RFC系统，任何人或组织都可以依据标准实现它。 开放网络运算远程过程调用（英语：Open Network Computing Remote Procedure Call，缩写为ONC RPC），一种被广泛应用的远程过程调用（RPC）系统，是一种属于应用层的协议堆栈，底层为TCP/IP协议。开放网络运算（ONC）最早源自于Sun微系统（Sun），是网络文件系统计划的一部分，因此它经常也被称为Sun ONC 或 Sun RPC。现今在多数类UNIX系统上都实现了这套系统，微软公司也以Windows Services for UNIX在他们产品上提供ONC RPC的支持。2009年，Sun微系统以标准三条款的BSD许可证发布这套系统。2010年，收购了Sun微系统的甲骨文公司确认了这套软件BSD许可证的有效性与适用范围。 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:1:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"SUN RPC 基本原理 客户端触发调用远程过程，实际上是选取了对应RPC程序封装的函 数，并将相关参数（包括远程方法名，方法参数等）封装成IP数据包，发送给服务器 服务器进程接收到此数据包后，提取参数，执行相应方法过程 服务器方法过程返回后，将返回结果封装成IP数据包，发送给客户端 客户端进程，收取到数据包后，提取返回结果 RPC程序包提供了数据报文封装和传递，保证异构环境下的可用性，客户端和服务器端应用程序设计时不需要考虑系统差异带来的数据格式，编码解码等问题，提供了很大方便。 客户程序和服务程序更多的职责是在于去定义描述具体远程过程及其触发，并将其注册绑定到RPC程序包中。 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:2:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"NFS过程 NFS客户可以是一个用户进程，对服务器进行显式调用。而服务器也可以是一个用户进程 — 因为两个理由，NFS一般不这样实现。 首先，访问一个NFS文件必须对客户透明。因此，NFS的客户调用是由客户操作系统代表用户进程来完成的。第二，出于效率的考虑， N F S服务器在服务器操作系统中实现。如果NFS服务器是一个用户进程，每个客户请求和服务器应答（包括读和写的数据）将不得不在内核和用户进程之间进行切换，这个代价太大。 一个客户对一个NFS服务器的访问开始于安装协议，返回给客户一个文件句柄。客户接着可以使用那个文件句柄来访问服务器文件系统中的文件。在服务器上，一次检查文件名的一个成员，返回每个成员的一个新的文件句柄。最后的结果就是要引用的文件的一个文件句柄，它可以在随后的读写操作中被使用。 初始时，文件系统协议安装，客户端需知道服务端的文件系统，后续的交互处理都是基于这一文件系统 客户端与服务端之间通过文件句柄来表示所访问文件，客户端每打开一个文件，就会获得服务端的一个文件句柄（可理解成文件描述符ID） 可能触发的远程过程（下面这些并非都会存在）： GETATTR。返回一个文件的属性：文件类型（一般文件，目录等）、访问权限、文件 大小、文件的属主者及上次访问时间等信息。 SETATTR。设置一个文件的属性。只允许设置文件属性的一个子集： 访问权限、文件的属主、组的属主、文件大小、上次访问时间和上次修改时间。 STATFS。返回一个文件系统的状态：可用空间的大小、最佳传送大小等。例如 U n i x的 d f命令使用此过程。 LOOKUP。查找一个文件。每当一个用户进程打开一个 N F S服务器上的一个文件时， N F S客户调用此过程。 READ。从一个文件中读数据。客户说明文件的句柄、读操作的开始位置和读数据的 最大字节数（最多8192个字节）。 WRITE。对一个文件进行写操作。客户说明文件的句柄、开始位置、写数据的字节数 和要写的数据。 CREATE。创建一个文件。 REMOVE。删除一个文件。 RENAME。重命名一个文件。 LINK。为一个文件构造一个硬链接。硬链接是一个 U n i x的概念，指的是磁盘中的一 个文件可以有任意多个目录项（即名字，也叫作硬链接）指向它。 SYMLINK。为一个文件创建一个符号链接。符号链接是一个包含另一个文件名字的 文MKDIR。创建一个目录。 RMDIR。删除一个目录。 READDIR。读一个目录。例如 Un ix的l s命令使用此过程 比如在windows上用记事本打开共享目录下的某一文本文件，会产生的过程有GETATTR来确认访问权限，LOOKUP确认文件存在，READ返回文件内容（当然实际windows上操作时，GETATTR和LOOKUP在打开共享目录的时候已经完成）件。大多数引用符号链接的操作（例如，打开）实际上引用的是符号链接所指的文件。 READLINK。读一个符号链接。即返回符号链接所指的文件的名字。 MKDIR。创建一个目录。 RMDIR。删除一个目录。 READDIR。读一个目录。例如 Un ix的l s命令使用此过程 比如在windows上用记事本打开共享目录下的某一文本文件，会产生的过程有GETATTR来确认访问权限，LOOKUP确认文件存在，READ返回文件内容（当然实际windows上操作时，GETATTR和LOOKUP在打开共享目录的时候已经完成） ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:3:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"NFS客户端和NFS服务端通讯过程 首先服务器端启动RPC服务，并开启111端口 服务器端启动NFS服务，并向RPC注册端口信息 客户端启动RPC（portmap服务），向服务端的RPC(portmap)服务请求服务端的NFS端口 服务端的RPC(portmap)服务反馈NFS端口信息给客户端 客户端通过获取的NFS端口来建立和服务端的NFS连接并进行数据的传输 NFS服务的优缺点 优点 ： 节省本地存储空间，将常用的数据存放在一台服务器可以通过网络访问该数据 简单容易上手 方便部署非常快速，维护十分简单 缺点 ： 局限性容易发生单点故障，服务器机宕机的话所有客户端都不能访问 在高并发情况下下NFS效率/性能有限 客户端没用用户认证机制，且数据是通过明文传送，安全性一般（一般建议在局域网内使用） NFS的数据是明文的，对数据完整性不做验证 多台机器挂载NFS服务器时，连接管理维护麻烦 Ubuntu主机的NFS共享文件夹 ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:4:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"nfs server 安装 1 2 3 4 5 6 # 安装server apt-get install nfs-common nfs-kernel-server # 创建配置文件 vi /etc/exports sudo gedit /etc/exports 配置文件内容 1 2 # home /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) 启动nfs server 1 2 3 4 5 # 启动 sudo service nfs-kernel-server restart # 查看共享目录 showmount -e 设置启动 nfs server 别名 1 2 3 alias nfsstart='sudo service nfs-kernel-server restart' vi ~/.bashrc source ~/.bashr ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:5:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"nfs client 安装 安装 1 2 3 4 5 6 7 # nfs client安装 sudo apt-get install nfs-common # 查看nfs server上共享的目录 showmount -e \u003cip address of nfs server\u003e showmount -e 10.42.0.1 创建挂载点 1 2 3 4 5 mkdir /path-to-mount chmod 777 -R /path-to-mount mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount sudo mount -t nfs -o nolock,rw,rsize=32768,wsize=32768 10.42.0.1:/home/didi/work/Dedge /home/zyh/dedge 开机自动挂载： 1 2 3 4 # 将 mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount mount -t nfs 192.168.xx.xx:/path-to-share /path-to-mount # 添加到 /etc/rc.local /etc/rc.local ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:6:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"/etc/exports 参数 1 2 3 4 /path-to-share *(rw,sync,no_subtree_check,no_root_squash) # path-to-share是要共享的目录，根据自己情况修改,*表示允许所有的网段访问，也可以使用具体的IP /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) 参数 说明 ro 只读访问 rw 读写访问 sync 所有数据在请求时写入共享 async nfs 在写入数据前可以响应请求 secure nfs 通过 1024 以下的安全 TCP/IP 端口发送 insecure nfs 通过 1024 以上的端口发送 wdelay 如果多个用户要写入 nfs 目录，则归组写入（默认） no_wdelay 如果多个用户要写入 nfs 目录，则立即写入，当使用 async 时，无需此设置 hide 在 nfs 共享目录中不共享其子目录 no_hide 共享 nfs 目录的子目录 subtree_check 如果共享 /usr/bin 之类的子目录时，强制 nfs 检查父目录的权限（默认） no_subtree_check 不检查父目录权限 all_squash 共享文件的 UID 和 GID 映射匿名用户 anonymous，适合公用目录 no_all_squash 保留共享文件的 UID 和 GID（默认） root_squash root 用户的所有请求映射成如 anonymous 用户一样的权限（默认）客户机用root访问该共享文件夹时，不映射root用户。（root_squash：客户机用root用户访问该共享文件夹时，将root用户映射成匿名用户） no_root_squash root 用户具有根目录的完全管理访问权限 anonuid=xxx 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 UID anongid=xxx 指定 nfs 服务器 /etc/passwd 文件中匿名用户的 GID ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:7:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"mount 参数 1 Mount -t nfs -o rw,hard,nointr,tcp,noac,vers=3,timeo=600,rsize=32768,wsize=32768 192.168.100.189:/mnt/DG/WORK/2_code/3_T4/aiva /home/firefly/zyh/aiva 指定参数具体含义如下： 参数 说明 rw 以读写方式安装文件系统（也必须要以相同的方式来导出） ro 以只读方式安装文件系统 bg 如果安装失败（服务器没有响应），在后台一直尝试，继续发其它的安装请求 hard 以硬方式安装文件系统(这是默认情况)。如果服务器当机，让试图访问它的操作被阻塞，直到服务器恢复为止 soft 以软方式安装文件系统。如果服务器当机，让试图访问它的操作失败，返回一条出错消息。这项功能对于避免进程“挂”在无关紧要的安装操作上来说非常有用 intr 允许用户中断被阻塞的操作（并且让它们返回一条出错消息） nointr 不允许用户中断 retrans=n 指定在以软方式安装的文件系统上，在返回一条出错消息之前重复发出请求的次数 timeo=n 设置请求的超时时间（以十分之一秒为单位） rsize=n 设置读缓冲的大小为n字节。对TCP和UDP安装都适用，但最优值不一样（32K较好） wsize=n 设置写缓冲的大小为n字节。对TCP和UDP安装都适 nfsvers=n 设置NFS协议的版本 2 或者 3 （在正常情况下是自动的） tcp 选择通过TCP来传输。默认选择UDP fg 和bg正好相反，是默认的参数 mountport 设定mount的端口[@more@] ","date":"2023-01-15","objectID":"/posts/tools/nfs/nfs/:8:0","tags":["NFS"],"title":"tool:NFS(Network File System(网络文件系统))","uri":"/posts/tools/nfs/nfs/"},{"categories":["tools"],"content":"tmux的使用","date":"2023-01-15","objectID":"/posts/tools/tmux/tmux/","tags":["tmux"],"title":"tool:tmux的使用","uri":"/posts/tools/tmux/tmux/"},{"categories":["tools"],"content":" tmux 自定义快捷操作 参考 tmux 自定义快捷操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 1 新建会话 alias tnew=\"tmux new -s \" # 2 分离会话(ctrl+b d) alias tdetach=\"tmux detach\" # 3 列出会话(ctrl+b s) alias tlist=\"tmux ls\" # 4 接入会话 alias tattach=\"tmux attach -t \" # 5 杀死指定会话 alias tkill=\"tmux kill-session -t \" # 6 杀死全部会话 alias tkillall=\"tmux kill-server\" # 7 切换会话 alias tswitch=\"tmux switch -t \" # 8 重命名会话(ctrl+b $) alias trename=\"tmux rename-session -t \" # 9 窗口上下划分窗格 alias tsplitud=\"tmux split-window\" # 10 窗口左右划分窗格 alias tsplitlr=\"tmux split-window -h\" # 11 光标到上方窗格 alias tmoveu=\"tmux select-pane -U\" # 12 光标到下方窗格 alias tmoved=\"tmux select-pane -D\" # 13 光标到上方窗格 alias tmovel=\"tmux select-pane -L\" # 14 光标到上方窗格 alias tmover=\"tmux select-pane -R\" # 15 交换窗格位置(当前窗格上移) alias tswapu=\"tmux swap-pane -U\" # 16 交换窗格位置(当前窗格下移) alias tswapd=\"tmux swap-pane -D\" 参考 Tmux 使用教程 ","date":"2023-01-15","objectID":"/posts/tools/tmux/tmux/:0:0","tags":["tmux"],"title":"tool:tmux的使用","uri":"/posts/tools/tmux/tmux/"},{"categories":["tools"],"content":"ubuntu(linux)系统常用配置","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":" 1. ununtu 设置 1.1. ubuntu 自动挂载机械硬盘 1.2. ubuntu 开机自启动程序 1.3. Ubuntu主机的NFS共享文件夹 1.4. 软链接 1.4.1. 创建软链接 1.4.2. 删除软链接 1.5. Ubuntu终端显示Git当前所在分支 1.6. SSH 使用别名代替IP地址登录 1.7. ubuntu 显示字体大小设置 1.8. ubuntu 设置wifi 上网，有线连接局域网设备 1.9. 快捷键 1.9.1. 文件管理器 1.10. 任务栏设置 1.11. 修改主机名 2. 常用软件安装 2.1. vim 2.2. 微信 2.3. net-tools 2.4. opencv 2.5. openssl 2.6. cmake 2.7. terminator 2.8. tree 2.9. doublecmd 2.10. gnome-tweaks 2.11. VLC 2.12. Typora 2.13. Samba 2.14. 截图工具 flameshot 2.15. Finalshell 2.16. 搜狗输入法 2.17. ubuntu 删除应用显示图标 2.18. ZSH 和 oh-my-sh 2.19. clash 2.20. jq 工具 2.21. screenkey 2.22. pycharm 2.23. android stduio 内网穿透 cpolar 1. ununtu 设置 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:0:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.1. ubuntu 自动挂载机械硬盘 Ubuntu18.04 自动挂载硬盘 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:1:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.2. ubuntu 开机自启动程序 参考： ubuntu-18.04 设置开机启动脚本 建立rc-local.service文件 1 sudo vi /etc/systemd/system/rc-local.service rc-local.service: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 [Unit] Description=/etc/rc.local Compatibility ConditionPathExists=/etc/rc.local [Service] Type=forking ExecStart=/etc/rc.local start TimeoutSec=0 StandardOutput=tty RemainAfterExit=yes SysVStartPriority=99 [Install] WantedBy=multi-user.target 创建文件rc.local　1 sudo vi /etc/rc.local rc.local : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/bin/sh -e # # rc.local # # This script is executed at the end of each multiuser runlevel. # Make sure that the script will \"exit 0\" on success or any other # value on error. # # In order to enable or disable this script just change the execution # bits. # # By default this script does nothing. cd /usr/local ./RunPowerOn.sh exit 0 RunPowerOn.sh 给rc.local加上权限/启用服务/启动服务并检查状态 1 2 3 4 sudo chmod +x /etc/rc.local sudo systemctl enable rc-local sudo systemctl start rc-local.service sudo systemctl status rc-local.service 重启并检查日志文件 1 2 ls /mnt/DG/DATA/LOG/sys_start/ cat xxx ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:2:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.3. Ubuntu主机的NFS共享文件夹 ubuntu: 1 2 3 4 apt-get install nfs-common nfs-kernel-server vi /etc/exports sudo gedit /etc/exports 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 /home/zyh/T3-libra *(rw,sync,no_root_squash,no_subtree_check) /home/zyh/DATA *(rw,sync,no_root_squash,no_subtree_check) /home/zyh/sensor_test *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/RGBD2 *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/RGBD *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/DATA/test_roi *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/rknn_demo *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/T3RHeadDetectTest *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/t3r_pressure_test *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/rockchip_mpp *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/99_TEST/mpp *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/libra_v3/release *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/DATA/T3R/encoder/image *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/4_T3R/HaomuF *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/9_other/StereoCamera *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/WORK/2_code/9_other/librealsense *(rw,sync,no_root_squash,no_subtree_check) /mnt/DG/ZYH/COMMON/Multimedia/rkmmp *(rw,sync,no_root_squash,no_subtree_check) /home/ubuntu/workspace/yuhuzhang/mpp *(rw,sync,no_root_squash,no_subtree_check) # home /mnt/DATA/CODE/beagle-bone *(rw,sync,no_root_squash,no_subtree_check) mount -t nfs -o nolock 192.168.100.189:/mnt/DATA/CODE/beagle-bone 1 2 3 4 5 sudo service nfs-kernel-server restart alias nfsstart='sudo service nfs-kernel-server restart' vi ~/.bashrc source ~/.bashr T3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 mount -t nfs -o nolock 192.168.101.15:/home/zyh/code /mnt ls /mnt mount -t nfs -o nolock 192.168.101.98:/media/zyh/DG/WORK/2_code/1_T3/libra_v3 /mnt mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /root/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/ubuntu/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/sensor_test /home/sensor_test T4DEMO mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/3_T4/libra_v3/release /home/deepglint/zyh/zyh_libra RK mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo /home/toybrick/Rockchip/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo/rknn_demo /home/toybrick/Rockchip/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/toybrick/Rockchip/zyh/zyh_libra mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/99_TEST/mpp /home/toybrick/Rockchip/zyh/mpp mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/libra_v3/release mount -t nfs -o nolock 192.168.100.189:/mnt/DG/DATA/T3R/encoder/image /home/deepglint/zyh/image mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/99_TEST/t3r_pressure_test /home/toybrick/Rockchip/zyh/t3r_pressure_test mount -t nfs -o nolock 192.168.100.189:/mnt/DG/DATA/T3R/encoder/image /home/toybrick/Rockchip/zyh/image mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/9_other/StereoCamera /home/toybrick/Rockchip/zyh/StereoCamera mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/rknn_demo/rknn_demo /home/zyh/rknn_demo mount -t nfs -o nolock 192.168.100.189:/mnt/DG/WORK/2_code/4_T3R/HaomuF /home/toybrick/Rockchip/zyh/HaomuF mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra /home/zyh_libra mount -t nfs -o nolock 192.168.100.189:/home/zyh/BeagleBone /root/BeagleBone 1 2 3 4 5 6 7 8 9 10 11 //////////////////////////////////////////////////////////////////////////////// mount -t nfs -o nolock 192.168.100.189:/home/zyh/T3-libra ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:3:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4. 软链接 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4.1. 创建软链接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # rk3399 sudo ln -fs /mnt/DG/DATA/tool_chain/aarch64-buildroot-linux-gnu_rk3399-buildroot /usr/local/aarch64-rk3399-linux-toolchain-libra-v4 # aarch64-himix100 sudo ln -fs /mnt/DG/DATA/tool_chain/aarch64-buildroot-linux-gnu_sdk-buildroot /usr/local/aarch64-himix100-linux-toolchain-libra-v3 # gnueabihf sudo ln -fs /mnt/DG/DATA/tool_chain/arm-buildroot-linux-gnueabihf_sdk-buildroot /usr/local/arm-linux-gnueabihf-toolchain-libra-v3 # BeagleBone sudo ln -fs /mnt/DG/DATA/tool_chain/arm-buildroot-linux-gnueabihf_sdk-buildroot /usr/local/arm-linux-gnueabihf-toolchain # code sudo ln -fs /mnt/DG/WORK/2_code/1_T3/libra_v3 /home/zyh/T3-libra sudo ln -fs /mnt/DG/WORK/2_code/100_ZYH/COMMON/BeagleBone /home/zyh/BeagleBone sudo ln -fs /mnt/DG/WORK/2_code/99_TEST/libra_v3 /home/zyh/sensor_test ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:1","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.4.2. 删除软链接 正确的是：rm -rf hb_link 错误的是：rm -rf hb_link/ 这个会把整个目录都删了 备注：想要删除链接文件要用以下命令 rm /home/hb_link 只是少了一个“ / ” 删除的 就是链接文件, 也就是在文件的最后不要加上/ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:4:2","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.5. Ubuntu终端显示Git当前所在分支 cd ~ vi .bashrc 插入代码 1 2 3 4 5 6 7 8 9 10 11 function git_branch { branch=\"`git branch 2\u003e/dev/null | grep \"^\\*\" | sed -e \"s/^\\*\\ //\"`\" if [ \"${branch}\" != \"\" ];then if [ \"${branch}\" = \"(no branch)\" ];then branch=\"(`git rev-parse --short HEAD`...)\" fi echo \" ($branch)\" fi } export PS1='\\u@\\h \\[\\033[01;36m\\]\\W\\[\\033[01;32m\\]$(git_branch)\\[\\033[00m\\] \\$ ' source ./.bashrc ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:5:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.6. SSH 使用别名代替IP地址登录 如果要想把前面的ssh root@192.168.1.2使用一个好记的别名（比如：test），则可以在~/.ssh/config添加如下的配置： 1 2 3 Host test HostName 192.168.1.2 User root 保存文件后，即可以用下面的方式登录了： 1 $ ssh test ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:6:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.7. ubuntu 显示字体大小设置 终端命令： 安装gnome-tweaks桌面配置工具; 1 sudo apt install gnome-tweaks Alt+F2 在运行窗口输入 gnome-tweaks 命令，回车; 打开的优化窗口中，字体一栏，调整缩放比例（如1.5则会放大）。 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:7:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.8. ubuntu 设置wifi 上网，有线连接局域网设备 配置有线网如下 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:8:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.9. 快捷键 设置-\u003e 设备 -\u003e 键盘 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:9:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.9.1. 文件管理器 1 nautilus . ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:9:1","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.10. 任务栏设置 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:10:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"1.11. 修改主机名 2. 常用软件安装 自动安装 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:11:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.1. vim 1 2 sudo apt-get install vim wget -qO- https://raw.github.com/ma6174/vim/master/setup.sh | sh -xY ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:12:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.2. 微信 1 2 wget -O- https://deepin-wine.i-m.dev/setup.sh | sh sudo apt-get install deepin.com.wechat Ubuntu通过deepin-wine安装wechat和wechat Work ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:13:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.3. net-tools 1 sudo apt install net-tools ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:14:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.4. opencv 1 sudo apt-get install libopencv-dev ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:15:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.5. openssl 1 2 sudo apt-get install openssl sudo apt-get install libssl-dev ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:16:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.6. cmake 1 sudo apt install cmake ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:17:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.7. terminator 1 sudo apt-get install terminator 快捷键： Ctrl-E(注意是大E要按住Shift)可以垂直分割终端 Ctrl-O 可水平分割终端 按住Alt然后按上下左右可以在不同的分割窗中切换 Ctrl-D 可以关闭分割窗 terminator配置文件 ：~/.config/terminator/config 1 2 3 4 5 6 7 8 font = Monaco 10 #设置体字 background_color = \"#204070\" # 背景颜色 foreground_color = \"#F0F0F0\" # 字体颜色 cursor_blink = True # 设置光标 scrollbar_position = disabled # 禁用滚动条 titlebars = no # 禁用标题栏 background_darkness = 0.4 background_type = transparent # 背景类型可以设置为图片 更多配置： 1 man terminator_config ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:18:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.8. tree 1 sudo apt install tree ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:19:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.9. doublecmd 文件管理工具 1 2 3 4 5 sudo add-apt-repository ppa:alexx2000/doublecmd sudo apt-get update sudo apt-get install doublecmd-gtk sudo apt-get remove doublecmd-* ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:20:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.10. gnome-tweaks unutu 桌面配置 1 2 3 4 5 6 # 安装 sudo apt-get gnome-tweaks # 启动 gnome-tweaks ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:21:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.11. VLC ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:22:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.12. Typora Linux安装及美化Typora详细步骤 ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:23:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.13. Samba Samba 是种用来让UNIX系列的操作系统与微软Windows操作系统的SMB / CIFS（服务器消息块/通用Internet文件系统）网络协议做链接的自由软件。第三版不仅可访问及分享SMB的文件夹及打印机，本身还可以集成入Windows Server的网域，扮演为网域控制站（域控制器）以及加入Active Directory成员。简而言之，此软件在Windows与UNIX系列操作系统之间搭起一座桥梁，让两者的资源可互通有无。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 # 安装 sudo apt-get install samba # 查看是否安装成功 samba # samba 配置文件路径 /etc/samba/smb.conf # 修改配置文件 - 文件最后添加 [ZYH-DATA] comment = zyh ubuntu data path = /mnt/DG public = yes browseable = yes public = yes writeable = yes read only = no valid users = zyh create mask = 0777 directory mask = 0777 force user = nobody force group = nogroup available = yes # 添加密码 sudo smbpasswd -a zyh # 重启samba 服务器 sudo service smbd restart # win 访问 \\\\+ ip ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:24:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.14. 截图工具 flameshot 1 2 3 4 5 6 7 8 9 # 安装 sudo apt-get install flameshot # 手动下载 https://github.com/flameshot-org/flameshot/releases # 启动 flameshot gui ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:25:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.15. Finalshell github release 1 2 3 4 rm -f finalshell_install_linux.sh wget www.hostbuf.com/downloads/finalshell_install_linux.sh chmod +x finalshell_install_linux.sh ./finalshell_install_linux.sh 安装路径 1 /usr/lib/FinalShell/ 配置文件路径 1 /home/$USER/.finalshell/ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:26:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.16. 搜狗输入法 https://shurufa.sogou.com/linux/guide ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:27:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.17. ubuntu 删除应用显示图标 删除系统自带的图标 1 sudo nautilus /usr/share/applications 删除wine等软件安装的自定义图标 1 sudo nautilus ~/.local/share/applications ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:28:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.18. ZSH 和 oh-my-sh 1 2 3 4 5 6 7 8 9 10 11 12 # zsh sudo apt-get install zsh # oh-my-sh sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" # 设置默认终端 chsh -s /bin/zsh root # 切换回bash也是相同的方法 chsh -s /bin/bash root ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:29:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.19. clash 参考 ：ubuntu 20.04 配置使用 clash for linux 下载地址 1 2 https://github.com/Dreamacro/clash wget -O clash.gz https://github.com/Dreamacro/clash/releases/download/v1.4.1/clash-linux-amd64-v1.4.1.gz 安装 1 2 3 4 5 6 7 8 9 gzip -f clash.gz -d chmod +x clash cp clash /usr/bin vi .bashrc alias clash='sudo ./usr/bin/clash -d ~/.config/clash/' ./clash 配置 拷贝 mac / win 上配置文件到ubuntu 使用 Web 工具管理 clash 地址：http://clash.razord.top/#/proxies 配置 ubunutu 网络代理 打开 设置 -\u003e 网络 -\u003e 网络代理 配置 HTTP 代理和 socket 代理 分别为上面的端口号 其他问题 git clone 报错 ：Failed to receive SOCKS4 connect request ack. 因为 clash 代理的 socket5，github 是 socket4 1 2 3 # 7891 是clash 代理 socket 的端口 git config --global http.proxy 'socks5://127.0.0.1:7891' git config --global https.proxy 'socks5://127.0.0.1:7891' ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:30:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.20. jq 工具 官网 1 2 3 4 sudo apt-get install jq # json 格式化 cat Recfront_20200916_095044_refine.json |jq . \u003edata_2.json ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:31:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.21. screenkey 下载 https://www.thregr.org/~wavexx/software/screenkey/ 安装 1 2 3 4 5 6 tar xvf screenkey-1.5.tar.gz cd screenkey-1.5 sudo ./setup.py install cd data sudo cp ./screenkey.desktop /usr/share/applications/ 使用 1 screenkey 设置 参考 ： https://gitlab.com/screenkey/screenkey#interactive-placement 1 screenkey -p fixed -g 30%x10%+65%-10% ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:32:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.22. pycharm 下载 ： https://www.jetbrains.com/pycharm/download/#section=linux 解压 cp xxx/* /opt/pycharm alias pycharm=‘cd /opt/pycharm/bin \u0026\u0026 ./pycharm.sh \u0026’ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:33:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"2.23. android stduio 下载 https://developer.android.google.cn/studio 解压 cp xxx/* /opt/android-studio/ alias android=‘cd /opt/android-studio/bin \u0026\u0026 ./studio.sh \u0026’ ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:34:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"内网穿透 cpolar cpolar一键安装脚本 1 curl -L https://www.cpolar.com/static/downloads/install-release-cpolar.sh | sudo bash 配置cpolar开机自启动 1 2 3 sudo systemctl enable cpolar sudo systemctl start cpolar sudo systemctl status cpolar 获取ssh隧道的公网地址 http://localhost:9200 配置 远程登陆 1 ssh linux用户名@cpolar所生成的公网地址 -p XXXXX（cpolar生成的端口号） ","date":"2023-01-15","objectID":"/posts/tools/sys_config/ubuntu/linuxconfig/:35:0","tags":["ubuntu"],"title":"tool:ubuntu(linux)系统常用配置","uri":"/posts/tools/sys_config/ubuntu/linuxconfig/"},{"categories":["tools"],"content":"UML","date":"2023-01-15","objectID":"/posts/tools/uml/uml/","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. UML 1.1. UML常用图表 2. 常见类图 2.1. 类（Class) 2.2. 接口（Interface） 2.3. 类图中关系（relation） 2.3.1. 泛化（Generalization） 2.3.2. 实现（Realization） 2.3.3. 关联（Association) 2.3.4. 聚合（Aggregation） 2.3.5. 组合(Composition) 2.3.6. 依赖(Dependency) 2.3.7. 总结 3. 类图的绘制 3.1. 绘制要点 3.2. 类的UML图示 4. 参考 1. UML ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:0:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"1.1. UML常用图表 项目 价格 数量 泛化（继承） B——▷A B 类作为 A 类的子类存在 实现 B——▷A B 类实现 A 接口 依赖 A——\u003eB B 类作为 A 类某个方法的参数，表示A想做某些事情需要依赖 B，不然做不成 关联 A——\u003eB（单向） B 类作为 A 类的属性存在，语义上 A 类和 B 类的地位或水平相等 A \u003c——\u003e B（双向) B 类作为 A 类的属相存在， A 类作为 B 类的属性存在，语义上 A 类和 B 类的地位或水平相等 聚合 A♢——\u003eB B 类作为 A 类的属性存在，语义上 B 类可作为 A 类的一部分，这个关系可有可无，是A has–a B 的关系，如房子（A），桌子（B） 组合 A♦——\u003eB B 类作为 A 类的属性存在，语义上 B 类是 A 类的一部分，这部分必须有，是 A contain–a B 的关系，如（人），大脑（B） 2. 常见类图 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:1:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.1. 类（Class) 在面向对象（OO) 编程中，类是对现实世界中一组具有相同特征的物体的抽象。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:2:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.2. 接口（Interface） 接口是一种特殊的类，具有类的结构但不可被实例化，只可以被实现（继承）。在UML中，接口使用一个带有名称的小圆圈来进行表示。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:3:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3. 类图中关系（relation） 在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.1. 泛化（Generalization） 【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。 例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:1","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.2. 实现（Realization） 【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:2","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.3. 关联（Association) 【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生， 丈夫与妻子关联可以是双向的，也可以是单向的。 双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。 但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联: ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:3","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.4. 聚合（Aggregation） 【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。 如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:4","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.5. 组合(Composition) 【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。 如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系， 它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:5","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.6. 依赖(Dependency) 【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助， 所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 \u003e 组合 \u003e 聚合 \u003e 关联 \u003e 依赖 下面这张UML图，比较形象地展示了各种类图关系： ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:6","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"2.3.7. 总结 依赖： 对类 B 进行修改会影响到类 A 。 关联： 对象 A 知道对象 B。 类 A 依赖于类 B。 聚合： 对象 A 知道对象 B 且由 B 构成。 类 A 依赖于类 B。 组合： 对象 A 知道对象 B、 由 B 构成而且管理着 B 的生命周期。 类 A 依赖于类 B。 实现： 类 A 定义的方法由接口 B 声明。 对象 A 可被视为对象 B。 类 A 依赖于类 B。 继承： 类 A 继承类 B 的接口和实现， 但是可以对其进行扩展。 对象 A 可被视为对象 B。 类 A 依赖于类 B。 3. 类图的绘制 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:4:7","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"3.1. 绘制要点 类的操作是针对类自身的操作，而不是它去操作人家。比如书这个类有上架下架的操作，是书自己被上架下架，不能因为上架下架是管理员的动作而把它放在管理员的操作里。 两个相关联的类，需要在关联的类中加上被关联类的ID，并且箭头指向被关联类。可以理解为数据表中的外键。比如借书和书，借书需要用到书的信息，因此借书类需包含书的ID，箭头指向书。 由于业务复杂性，一个显示中的实体可能会被分为多个类，这是很正常的，类不是越少越好。类的设计取决于怎样让后台程序的操作更加简单。比如单看逻辑，借书类可以不存在，它的信息可以放在书这个类里。然而借还书和书的上架下架完全不是一回事，借书类对借书的操作更加方便，不需要去重复改动书这个类中的内容。此外，如果书和借书是1对多的关系，那就必须分为两个类。 类图中的规范问题，比如不同关系需要不同的箭头，可见性符号等。 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:5:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"3.2. 类的UML图示 1 2 3 4 5 6 7 8 9 10 public class Employee { private String name; private int age; private String email; public void modifyInfo() { ...... } } 在UML类图中，类一般由三部分组成： (1) 第一部分是类名：每个类都必须有一个名字，类名是一个字符串。 (2) 第二部分是类的属性(Attributes)：属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性 UML规定属性的表示方式为： 可见性 名称:类型 [ = 缺省值 ] 其中： “可见性”表示该属性对于类外的元素而言是否可见，包括公有(public)、私有(private)和受保护(protected)三种，在类图中分别用符号+、-和#表示。 “名称”表示属性名，用一个字符串表示。 “类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。 “缺省值”是一个可选项，即属性的初始值。 (3) 第三部分是类的操作(Operations)：操作是类的任意一个实例对象都可以使用的行为，是类的成员方法。 UML规定操作的表示方式为： 可见性 名称(参数列表) [ : 返回类型] 4. 参考 解析UML类图符号意义 深入浅出UML类图 敏捷软件开发：原则、模式与实践——第20章　咖啡的启示 ","date":"2023-01-15","objectID":"/posts/tools/uml/uml/:6:0","tags":["UML"],"title":"tool:UML图标示意","uri":"/posts/tools/uml/uml/"},{"categories":["tools"],"content":"vscode基础配置","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 1. 资料 2. vs code 快捷键 2.1. 将下一个查找匹配项添加到选择 3. VS 插件 3.1. Markdown TOC 3.2. Markdown Preview Enhanced 3.3. Markdown All in One 3.4. GitLens 3.5. Code Spell Checker 3.6. Remote - SSH 3.7. vscode-fileheader 3.8. Rainbow Brackets 3.9. vscode-pdf 3.10. vscode-drawio 3.11. Comment Translate 3.12. shellman 3.13. shell-format 3.14. shellcheck 4. 问题及配置 4.1. ubuntu vscode 字体间隔大 4.2. ubuntu vscode 代码空格小 4.3. 显示空格和tab 4.4. 保存去除行尾字符 4.5. markdown 去除 保存去除行尾字符 4.6. linux下vscode编写cpp占用内存过高问题 4.7. 设置忽略文件 1. 资料 官方文档 第一次使用VS Code时你应该知道的一切配置 2. vs code 快捷键 1 2 3 4 5 6 7 8 9 10 11 12 The cmd key for Windows is ctrl. Shortcuts Functionality cmd-k v or ctrl-k v Open preview to the Side cmd-shift-v or ctrl-shift-v Open preview ctrl-shift-s Sync preview / Sync source shift-enter Run Code Chunk ctrl-shift-enter Run all Code Chunks cmd-= or cmd-shift-= Preview zoom in cmd-- or cmd-shift-_ Preview zoom out cmd-0 Preview reset zoom esc Toggle sidebar TOC ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:0:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"2.1. 将下一个查找匹配项添加到选择 vsCode多选多个元素进行统一修改 1 2 3 4 5 { \"key\": \"ctrl+d\", \"command\": \"editor.action.addSelectionToNextFindMatch\", \"when\": \"editorFocus\" } 3. VS 插件 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:1:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.1. Markdown TOC 自动生成目录 VScode markdown md TOC 插件目录生成错误auto 搜索eol 改为’\\n' ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:2:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.2. Markdown Preview Enhanced markdown 预览 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:3:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.3. Markdown All in One ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:4:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.4. GitLens VsCode中好用的git源代码管理插件GitLens ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:5:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.5. Code Spell Checker 代码拼写检查工具 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:6:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.6. Remote - SSH 连接远程主机 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:7:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.7. vscode-fileheader 自动生成文件头 1 /* \\r\\n* @file xxx\\r\\n* @brief xxx\\r\\n* @author ZYH\\r\\n* @version v0.1\\r\\n* @date 2020/07/22\\r\\n* @copyright 2019, Deepglint All rights reserved.\\r\\n*/ ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:8:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.8. Rainbow Brackets 彩虹括号 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:9:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.9. vscode-pdf PDF 查看器 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:10:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.10. vscode-drawio VSCode Drawio ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:11:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.11. Comment Translate VSCode 注释翻译 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:12:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.12. shellman 编辑过程中会有代码提示 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:13:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.13. shell-format 右键 -\u003e 格式化文档（Ctrl + Alt + L） ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:14:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"3.14. shellcheck 语法错误检查插件 安装shellcheck（shellcheck插件依赖于shellcheck） : sudo apt-get install shellcheck 在编辑过程中，会提示语法错误 4. 问题及配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:15:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.1. ubuntu vscode 字体间隔大 修改：“terminal.integrated.fontFamily”: “monospace”， ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:16:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.2. ubuntu vscode 代码空格小 修改： \" Editor:Font Family\":‘monospace’ ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:17:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.3. 显示空格和tab 修改 ：\" Editor: Render Whitespace “:all ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:18:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.4. 保存去除行尾字符 启用 ：trimTrailingWhitespace ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:19:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.5. markdown 去除 保存去除行尾字符 markdown 文件根目录配置 1 2 3 { \"files.trimTrailingWhitespace\": false } ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:20:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.6. linux下vscode编写cpp占用内存过高问题 intelli Sense Cache Size 默认大小为5G,将其改为2048(2G)或者其他任意，不要太大。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:21:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"4.7. 设置忽略文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \"files.exclude\": { \"*.metadata\": true, \"*.settings\": true, \"**/*.pyc\": true, //隐藏所有pyc文件 \"**/*.meta\": true, //隐藏所有meta文件 \"**/*.prefab\": true, //隐藏所有prefab文件 \"**/*.d.ts\": true, //隐藏所有d.ts文件 \"**/*.fnt\": true, \"**/*.sln\": true, \"**/*.csproj\": true, \"**/.vscode\": true, \"**/*.anim\": true, \"**/*.controller\": true, \"**/Logs\": true, \"**/[Pp]lugins\": true, //使用中括号时表示不区分大小写 \"**/[Mm]aterials\": true, \"**/[Aa]nimation\": true, \"**/[Pp]ackages\": true, \"**/[Tt]extures\": true, \"**/[Ss]cenes\": true, \"**/temp\": true, //隐藏temp文件夹 \"**/library\": true, //隐藏library文件夹 \"**/audio\": true, //隐藏audio文件夹 \"**/video\": true, //隐藏video文件夹 } ","date":"2023-01-15","objectID":"/posts/tools/vscode/base_config/vscode/:22:0","tags":["vsoced"],"title":"tool:vscode基础配置","uri":"/posts/tools/vscode/base_config/vscode/"},{"categories":["tools"],"content":"vscode配置文件(config.json)设置","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"参考： Using C++ on Linux in VS Code Getting Started with Python in VS Code 【笔记】vscode做C++开发，launch.json、tasks.json、settings.json写法示例 教你如何快速解决需要在每个新项目新建launch.json文件的问题？ Tips and Tricks Ctrl+R : Displays a Quick Pick dropdown with the list from File \u003e Open Recent with recently opened folders and workspaces followed by files. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:0:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Command line 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # open code with current directory code . # open the current directory in the most recently used code window code -r . # create a new window code -n # change the language code --locale=es # open diff editor code --diff \u003cfile1\u003e \u003cfile2\u003e # open file at specific line and column \u003cfile:line[:character]\u003e code --goto package.json:10:5 # see help options code --help # disable all extensions code --disable-extensions . ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:1:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":".vscode folder Workspace specific files are in a .vscode folder at the root. For example, tasks.json for the Task Runner and launch.json for the debugger. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:2:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Ignore files / folders Removes these files / folders from your editor window. 1 2 3 4 \"files.exclude\": { \"somefolder/\": true, \"somefile\": true } Remove these files / folders from search results. 1 2 3 4 \"search.exclude\": { \"someFolder/\": true, \"somefile\": true } launch.json、tasks.json、settings.json settings.json User and Workspace Settings User Settings - Settings that apply globally to any instance of VS Code you open. Workspace Settings - Settings stored inside your workspace and only apply when the workspace is opened. ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:3:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"User Settings ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:4:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Settings file locations# Depending on your platform, the user settings file is located here: Windows %APPDATA%\\Code\\User\\settings.json macOS $HOME/Library/Application\\ Support/Code/User/settings.json Linux $HOME/.config/Code/User/settings.json ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:4:1","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"Workspace Settings launch.json Configure C/C++ debugging ","date":"2023-01-15","objectID":"/posts/tools/vscode/config_files/vscode_config/:5:0","tags":["vsoced"],"title":"tool:vscode配置文件(config.json)设置","uri":"/posts/tools/vscode/config_files/vscode_config/"},{"categories":["tools"],"content":"工具使用","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":" 代码管理工具 代码格式化工具ClangFormat 简介 文档 安装 使用 使用vscode 手动格式化 git 自动格式化提交文件 手动格式化 静态扫描工具 cppcheck 安装 使用 Tscancode 安装 使用 文档自动生成工具 doxygen 安装 常用配置 根据配置生成doxygen文档 vscode 自动生成 Doxygen 注释 下载 配置文件 使用 建议安装的插件及配置 Code Spell Checker 其他配置 保存去除行尾字符 保存文件在文件末尾插入最终行 代码管理工具 为了团队协作方便以及代码代码稳定性建设，团队内可以使用统一的工具进行代码格式化，生成文档等。这里整理下相关工具及导入工程实施的方法。 以下工具基于如Ubuntu 18.04 LTS环境进行验证，但工具到时跨平台，保持配置文件一致，其他平台环境安装需要使用的同学自行解决。 代码格式化工具ClangFormat ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:0:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"简介 ClangFormat 是一个规范代码的工具 ClangFormat 支持的语言有：C/C++/Java/JavaScript/Objective-C/Protobuf/C# ClangFormat 支持的规范有：LLVM，Google，Chromium，Mozilla 和 WebKit ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:1:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"文档 官方文档 其配置文件的官方文档 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:2:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 2 3 4 # 安装 sudo apt install clang-format # 查看版本 clang-format --version ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:3:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用vscode 手动格式化 安装 插件 clang-format 将默认格式化工具设置为 clang-format vscode 设置中 搜索 defaultFormatter ，选择默认配置为 clang-format 。 将配置文件 .clang-format 放到工程根目录，以DVR 工程为例： 使用快捷格式化 ，windows：Shift+Alt+F Mac：Shift+Option+F Ubuntu：Ctrl+Shift+I ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"git 自动格式化提交文件 git pre-commit 在提交代码的时候对变动的文件进行格式化, 将 pre-commit 拷贝到 git/hooks 目录下 1 cp ./pre-commit ../../.git/hooks/ 此后git在提交的时候会进行自动格式化。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"手动格式化 使用 clang-format 命令 ```bash clang-format -style=google -i xxx.cpp 指定格式化方式 clang-format -style=file .clang-format -i xxx.cpp 指定配置文件 clang-format -i xxx.cpp # 使用工程默认 ``` 使用脚本格式化以有文件 现有代码可能格式不一致，可以使用提供的脚本进行统一格式化做单次提交到服务器。可以使用 tools/format 文件夹下 format.sh 对文件夹内文件递归进行格式化。 1 ./format.sh /home/didi/work/http/src/http 静态扫描工具 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:4:3","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"cppcheck CppCheck是一个C/C++代码缺陷静态检查工具。不同于C/C++编译器及其它分析工具，CppCheck只检查编译器检查不出来的bug，不检查语法错误。所谓静态代码检查就是使用一个工具检查我们写的代码是否安全和健壮，是否有隐藏的问题 源码下载地址：cppcheck ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 2 3 4 5 6 # 安装 sudo apt-get install cppcheck # 查看版本 cppcheck --version # Cppcheck 1.82 c++11 最好使用1.8 异常版本，如果apt 安装非最新版本可以下载源码安装 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 使用参考 1 cppcheck xxx/ --enable=all --output-file=./xxxx.txt ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:5:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"Tscancode TscanCode是一款腾讯开源的静态代码扫描工具，TscanCode旨在助力开发与测试人员从代码层面挖掘问题，将那些长期困扰项目的诸如空指针宕机等问题，扼杀于萌芽阶段。支持用户根据不同需求自定义配置检查项，有极强的扩展性和可维护性。平均扫描速度10W行/分钟。 TscanCode支持以下类型规则扫描： 空指针检查，包含可疑的空指针，判空后解引用比如Crash等共3类subid检查。 数据越界，Sprintf_S越界共1类subid检查。 内存泄漏，分配和释放不匹配同1类subid检查。 逻辑错误，重复的代码分支，bool类型和INT进行比较，表达式永远True或者false等共18类检查。 可疑代码检查，if判断中含有可疑的=号，自由变量返回局部变量等共计15类检查。 运算错误，判断无符号数小于0,对bool类型进行++自增等，共计11类检查。 代码仓库 ：TscanCode ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 release 文件下载地址 ：release 文件下载 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 工具 使用参考 1 ./tscancode --xml --enable=all -q ../../../src/ \u003escan_result.xml 2\u003e\u00261 说明 ： 工程里集成了脚本和生成的文件 见 ： tools/codescan/ 路径 文档自动生成工具 doxygen ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:6:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"安装 1 安装doxygen—\u003e 安装Graphviz—\u003e生成doxygen配置文件—\u003e修改doxygen配置文件—\u003e生成doxygen文档 安装doxygen 1 sudo apt-get install doxygen 安装Graphviz 1 sudo apt-get install graphviz 生成doxygen配置文件 1 doxygen -s -g 注释：上述s 和 g 分别表示simple和generate ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"常用配置 常用选项如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 # 项目名称，将作为于所生成的程序文档首页标题 PROJECT_NAME = “Test” # 文档版本号，可对应于项目版本号，譬如 svn、cvs 所生成的项目版本号 PROJECT_NUMBER = \"1.0.0 # 程序文档输出目录 OUTPUT_DIRECTORY = /home/user1/docs # 程序文档输入目录 INPUT = /home/user1/project/kernel # 程序文档语言环境 OUTPUT_LANGUAGE = Chinese # 只对头文件中的文档化信息生成程序文档 FILE_PATTERNS = # 递归遍历当前目录的子目录，寻找被文档化的程序源文件 RECURSIVE = YES # 如果是制作 C 程序文档，该选项必须设为 YES，否则默认生成 C++ 文档格式 OPTIMIZE_OUTPUT_FOR_C = YES #提取信息，包含类的私有数据成员和静态成员 EXTRACT_ALL = yes EXTRACT_PRIVATE = yes EXTRACT_STATIC = yes # 对于使用 typedef 定义的结构体、枚举、联合等数据类型，只按照 typedef 定义的类型名进行文档化 TYPEDEF_HIDES_STRUCT = YES # 在 C++ 程序文档中，该值可以设置为 NO，而在 C 程序文档中，由于 C 语言没有所谓的域/名字空间这样的概念，所以此处设置为 YES HIDE_SCOPE_NAMES = YES # 让 doxygen 静悄悄地为你生成文档，只有出现警告或错误时，才在终端输出提示信息 QUIET = YES # 递归遍历示例程序目录的子目录，寻找被文档化的程序源文件 EXAMPLE_RECURSIVE = YES # 允许程序文档中显示本文档化的函数相互调用关系 REFERENCED_BY_RELATION = YES REFERENCES_RELATION = YES REFERENCES_LINK_SOURCE = YES # 不生成 latex 格式的程序文档 GENERATE_LATEX = NO # 在程序文档中允许以图例形式显示函数调用关系，前提是你已经安装了 graphviz 软件包 HAVE_DOT = YES CALL_GRAPH = YES CALLER_GRAPH = YES #在最后生成的文档中，把所有的源代码包含在其中 SOURCE BROWSER = YES $这会在HTML文档中，添加一个侧边栏，并以树状结构显示包、类、接口等的关系 GENERATE TREEVIEW ＝ ALL ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"根据配置生成doxygen文档 1 doxygen Doxyfile 效果 文件 class namespase ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:7:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"vscode 自动生成 Doxygen 注释 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"下载 vscode 下载插件 ：Generate Doxygen Comments ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:1","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"配置文件 安装插件后，File–Preferences–Settings– 中打开 用户 setting.json文件 ,增加如下内容 (配置可以根据自己需要修改): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // Doxygen documentation generator set \"doxdocgen.file.copyrightTag\" : [ \"@copyright Copyright (c) 2012-2021 Beijing Xiaoju Technology Co, Ltd.\" ], \"doxdocgen.file.customTag\": [ \"@par 修改日志:\", \"\u003ctable\u003e\", \"\u003ctr\u003e\u003cth\u003eDate \u003cth\u003eVersion \u003cth\u003eAuthor \u003cth\u003eDescription\", \"\u003ctr\u003e\u003ctd\u003e{date} \u003ctd\u003ev1.0 \u003ctd\u003ezhangyuhu \u003ctd\u003e内容\", \"\u003c/table\u003e\", ], \"doxdocgen.file.fileOrder\": [ \"file\", \"brief\", \"author\", \"version\", \"date\", \"copyright\", \"empty\", \"custom\", ], \"doxdocgen.file.fileTemplate\": \"@file {name}\", \"doxdocgen.file.versionTag\": \"@version v1.0\", \"doxdocgen.generic.authorEmail\": \"zhangyuhu@didiglobal.com\", \"doxdocgen.generic.authorName\": \"zhangyuhu\", \"doxdocgen.generic.authorTag\": \"@author {author} ({email})\", \"doxdocgen.generic.order\": [ \"brief\", \"tparam\", \"param\", \"return\" ], \"doxdocgen.generic.paramTemplate\": \"@param{indent:8}{param}{indent:25}My Param doc\", \"doxdocgen.generic.returnTemplate\": \"@return {type} \", \"doxdocgen.generic.splitCasingSmartText\": true, ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:2","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 Vs code自动生成Doxygen格式注释 在文件 / 函数等 输入 /** 回车可自动生成注释 建议安装的插件及配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:8:3","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"Code Spell Checker 拼写检查工具 示例1: 示例2: 其他配置 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:9:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"保存去除行尾字符 设置中搜索 trimTrailingWhitespace ，并启用。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:10:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"保存文件在文件末尾插入最终行 设置中搜索 insert final newline ，并启用。 ","date":"2023-01-15","objectID":"/posts/tools/vscode/format/format/:11:0","tags":["vsoced"],"title":"tool:vsoced代码格式化配置","uri":"/posts/tools/vscode/format/format/"},{"categories":["tools"],"content":"使用 gdb 调试","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 GDB 概述 调试示例 使用GDB 1. 编译程序 2. 启动GDB的方法 常用指令 1. 查看代码 2. 断点设置 2.1. 设置断点 2.2. 查看断点 2.3. 删除断点： 2.4. 禁用与启用断点 2.5. 断点命令列表 3. 调试 3.1. 启动 3.2. 查看栈帧 3.3. 输出当前值 3.4. 浏览以前的GDB命令 3.5. 运行 参考 GDB 概述 GDB是GNU开源组织发布的一个强大的UNIX下的程序调试工具。或许，各位比较喜欢那种图形界面方式的，像VC、BCB等IDE的调试，但如果你是在UNIX平台下做软件，你会发现GDB这个调试工具有比VC、BCB的图形化调试器更强大的功能。所谓“寸有所长，尺有所短”就是这个道理。 一般来说，GDB主要帮忙你完成下面四个方面的功能： 1、启动你的程序，可以按照你的自定义的要求随心所欲的运行程序。 2、可让被调试的程序在你所指定的调置的断点处停住。（断点可以是条件表达式） 3、当程序被停住时，可以检查此时你的程序中所发生的事。 4、动态的改变你程序的执行环境。 调试示例 原程序 ： gdb_test.c 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u003cstdio.h\u003e int func(int n) { int sum = 0, i; for (i = 0; i \u003c n; i++) { sum += i; } return sum; } main() { int i; long result = 0; for (i = 1; i \u003c= 100; i++) { result += i; } printf(\"result[1-100] = %d /n\", result); printf(\"result[1-250] = %d /n\", func(250)); } 编译 ： gcc -g gdb_test.c -o test 使用GDB调试： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 zyh@zyh gdb (master) $ gdb test \u003c---------- 启动GDB GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttp://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: \u003chttp://www.gnu.org/software/gdb/bugs/\u003e. Find the GDB manual and other documentation resources online at: \u003chttp://www.gnu.org/software/gdb/documentation/\u003e. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from test...done. (gdb) l \u003c-------------------- l命令相当于list，从第一行开始例出原码。 1 #include \u003cstdio.h\u003e 2 3 int func(int n) 4 { 5 int sum=0,i; 6 for(i=0; i\u003cn; i++) 7 { 8 sum+=i; 9 } 10 return sum; (gdb) \u003c-------------------- 直接回车表示，重复上一次命令 11 } 12 13 14 main() 15 { 16 int i; 17 long result = 0; 18 for(i=1; i\u003c=100; i++) 19 { 20 result += i; (gdb) break 16 \u003c-------------------- 设置断点，在源程序第16行处。 Breakpoint 1 at 0x8048496: file tst.c, line 16. (gdb) break func \u003c-------------------- 设置断点，在函数func()入口处。 Breakpoint 2 at 0x8048456: file tst.c, line 5. (gdb) info break \u003c-------------------- 查看断点信息。 Num Type Disp Enb Address What 1 breakpoint keep y 0x08048496 in main at tst.c:16 2 breakpoint keep y 0x08048456 in func at tst.c:5 (gdb) r \u003c--------------------- 运行程序，run命令简写 Starting program: /home/hchen/test/tst Breakpoint 1, main () at tst.c:17 \u003c---------- 在断点处停住。 17 long result = 0; (gdb) n \u003c--------------------- 单条语句执行，next命令简写。 18 for(i=1; i\u003c=100; i++) (gdb) n 20 result += i; (gdb) n 18 for(i=1; i\u003c=100; i++) (gdb) n 20 result += i; (gdb) c \u003c--------------------- 继续运行程序，continue命令简写。 Continuing. result[1-100] = 5050 \u003c----------程序输出。 Breakpoint 2, func (n=250) at tst.c:5 5 int sum=0,i; (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p i \u003c--------------------- 打印变量i的值，print命令简写。 $1 = 134513808 (gdb) n 8 sum+=i; (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p sum $2 = 1 (gdb) n 8 sum+=i; (gdb) p i $3 = 2 (gdb) n 6 for(i=1; i\u003c=n; i++) (gdb) p sum $4 = 3 (gdb) bt \u003c--------------------- 查看函数堆栈。 #0 func (n=250) at tst.c:5 #1 0x080484e4 in main () at tst.c:24 #2 0x400409ed in __libc_start_main () from /lib/libc.so.6 (gdb) finish \u003c--------------------- 退出函数。 Run till exit from #0 func (n=250) at tst.c:5 0x080484e4 in main () at tst.c:24 24 printf(\"result[1-250] = %d /n\", func(250) ); Value returned is $6 = 31375 (gdb) c \u003c--------------------- 继续运行。 Continuing. result[1-250] = 31375 \u003c----------程序输出。 Program exited with code 027. \u003c--------程序退出，调试结束。 (gdb) q \u003c--------------------- 退出gdb。 使用GDB ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:0:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"编译程序 一般来说GDB主要调试的是C/C++的程序。要调试C/C++的程序，首先在编译时，我们必须要把调试信息加到可执行文件中。使用编译器（cc/gcc/g++）的 -g 参数可以做到这一点。如： 1 2 \u003e gcc -g hello.c -o hello \u003e g++ -g hello.cpp -o hello 如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。当你用-g把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用gdb来调试他。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:1:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"启动GDB的方法 gdb + ProgramName 说明：ProgramName 也就是你的执行文件，一般在当前目录下。 gdb + ProgramName +core 说明：用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。 gdb + ProgramName +PID 说明：如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。 gdb -command=z x 说明：在调用GDB时可以指定启动文件，如：$gdb-command=z x 表示要在可执行文件x上运行GDB，首先要从文件z中读取命令。 gdb启动文件 \u003e 有时候我们在完成调试前可能需要退出GDB，比如需要离开比较长的一段时间而且不能保持登录在计算机中。为了不丢失某些信息，可以将断点和设置的其他命令放在一个GDB启动文件中，然后每次启动GDB时会自动加载它们。 \u003e GDB启动文件默认名为.gdbinit。可以将一个文件放在主目录中用于一般用途，另一个文件放在特定项目专用的目录中。例如，可以将设置断点的命令放在后一个目录的启动文件中，在主目录的.gdbinit文件中存储开发的一些通用的宏。最好不要将编程项目放在主目录中，因为不能将项目特有的信息放在.gdbinit中。 GDB启动时，可以加上一些GDB的启动开关，详细的开关可以用gdb -help查看。下面只列举一些比较常用的参数： –symbols=SYMFILE 从指定文件中读取符号表。 –se=FILE 从指定文件中读取符号表信息，并把他用在可执行文件中。 –core=COREFILE 调试时core dump的core文件。 –directory=DIR 加入一个源文件的搜索路径。默认搜索路径是环境变量中PATH所定义的路径。 常用指令 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:2:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看代码 list 命令可用于显示指定位置处的源代码。list命令会影响当前行和当前文件。list命令有多种方式指定要显示的源代码范围，可以是行号，函数名，甚至是指令地址。常用的如下： list linenum：显示指定行数附近的代码。 list function：显示指定函数附近的代码。 list + 列出当前行的后面代码行。 list - 列出当前行的前面代码行。 list ＊addr：显示指定地址附近的代码。默认情况下，GDB显示指定位置处以及其前后的10行代码，但是这是一个可设置的值。 set listsize count：设置list命令显示的源代码数量最多为count行，0表示不限制行数。 show listsize：显示listsize的值。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:3:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"断点设置 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"设置断点 break line_number：在某一行设置断点。 break function（函数名）：在某个函数的入口（第一行可执行代码）处设置断点。 break filename:function：在源代码文件filename的函数function入口处处设置断点。 conditionbreak_p_num（断点编号） cond（条件）：将正常断点转变为条件断点 举例：condition 30 index == 5 break line_num（行号） if cond（条件）：用break if可以将break和condition命令组合成一个步骤：举例：(gdb) break 30 if index == 5 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:1","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看断点 info break：显示所有断点信息 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:2","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"删除断点： deletebreak_point_num:删除编号为break_point_num的断点； delete:删除所有断点； clear function:删除在function函数处设定的断点 clearfilename:funtion删除在filename文件的function函数处设定的断点 clear line_number:删除在line_number行设定的断点 clearfilename:line_number:删除在filename文件的line_number行设定的断点 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:3","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"禁用与启用断点 disablebreakpoint-list（是用空格分隔开的多个断点标识符）：禁用断点 disable：禁用所有现存断点 enablebreakpoint-list：启用断点 enable oncebreakpoint-list：在下次引起GDB暂停执行后禁用 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:4","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"断点命令列表 让GDB在每次到达某个断点时自动执行一组命令，从而自动完成某一任务。 使用commands命令设置命令列表： commands breakpoint_number … commands … end 如果嫌GDB输出太冗长，可以使用silent命令，只需将其添加到设置的命令列表最开始处即可。 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:4:5","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"调试 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:0","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"启动 run ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:1","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"查看栈帧 frame num（栈帧编号） 注意栈帧编号规则，当前正在执行的函数的帧被编号为0，其父帧（即该函数的调用者的栈帧）被编号为1，父帧的父帧被编号为2，以此类推。 跳到调用栈中的下一个父帧：up 引向相反方向：down 显示整个栈，即当前存在的所有帧的集合 ：backtrace ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:2","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"输出当前值 print或者p ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:3","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"浏览以前的GDB命令 上一个Ctrl+P、下一个Ctrl+N 可以直接按下回车再次执行最近执行过的那条命令 ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:4","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":["tools"],"content":"运行 单步执行： step（s）、next（n），仅执行到代码的下一行后再次暂停。 注意二者区别：在函数调用时step会进入函数，next导致下一次暂停出现在调用函数之后。next被称为单步越过（stepping over）函数，而step被称为单步进入（stepping into）函数。next和step都可以采用一个可选的数值参数，来表示要使用next或step执行的额外行数。 无条件恢复程序的执行： continue（c） 直到遇到另一个断点或者程序结束。continue可以接受一个可选的数值参数n，要求GDB忽略下面n个断点。 用finish（fin）或until（u）命令恢复 finish命令指示GDB恢复执行，直到恰好在当前帧完成之后为止。 until命令通常用来在不进一步在循环中暂停（除了循环中的中间断点）的情况下完成正在执行的循环。until会执行循环的其余部分（如果遇到断点，还是会暂停），让GDB在循环后面的第一行代码处暂停。 until命令也可以接受源代码中的位置作为参数，其用法与break命令同。 如果GDB触发了main函数入口处的一个断点，那么可以使用下面这些命令方便地使程序一直执行到swap()的入口： until 13 until swap until swapflaw.c:13 until swapflaw.c:swap 跳出循环 until NUM 执行到一个比当前行号大的行，或者也可以指定在当前frame（我理解成函数）中的某一行 跳出函数 finish 执行，直到选定的frame执行结束，然后打印返回值，将其放入历史值中，停止 退出 quit(q) 参考 【Linux】GDB用法详解(5小时快速教程) ","date":"2023-01-15","objectID":"/posts/tools/gdb/gdb/:5:5","tags":["gdb"],"title":"tool:使用 gdb 调试","uri":"/posts/tools/gdb/gdb/"},{"categories":null,"content":"关于","date":"2023-01-15","objectID":"/about/","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"nothing … ","date":"2023-01-15","objectID":"/about/:0:0","tags":null,"title":"关于","uri":"/about/"},{"categories":null,"content":"工具资源列表","date":"2023-01-15","objectID":"/posts/tools/blogs/tools_index/","tags":null,"title":"工具资源列表","uri":"/posts/tools/blogs/tools_index/"},{"categories":null,"content":" 提示 工具资源，奇门遁甲。 常用网址 编程 工具导航站 学术资源 quora cppreference 我爱运营 scihub检1 scihub检2 动手学深度学习 cplusplus 及时工具 Oalib OpenCV c-cpp 果汁实验室 iData 开源软件汇总 purecpp 创造师导航 谷歌学术镜像 金步国作品集 refactoring 工具达人 Library genesis Google 开源项目风格指南 C语言中文网 网站检测 360 安全规则集合 菜鸟教程 blogs GitHub 网盘 其他 一面之猿网 文叔叔 z-library 电子书 thisPointer 钛盘 迅捷画图 轻松传 在线流程图 airportal 地址信息生成 临时邮箱 云短信 视频压缩 在线抠图 ","date":"2023-01-15","objectID":"/posts/tools/blogs/tools_index/:0:0","tags":null,"title":"工具资源列表","uri":"/posts/tools/blogs/tools_index/"},{"categories":null,"content":"工具资源列表","date":"2023-01-15","objectID":"/tool/","tags":null,"title":"工具资源列表","uri":"/tool/"},{"categories":null,"content":" 在线搜索 常用网址 编程 工具导航站 学术资源 quora cppreference 我爱运营 scihub检1 scihub检2 动手学深度学习 cplusplus 及时工具 Oalib OpenCV c-cpp 果汁实验室 iData 开源软件汇总 purecpp 创造师导航 谷歌学术镜像 金步国作品集 refactoring 工具达人 Library genesis Google 开源项目风格指南 C语言中文网 公众号 Markdown 编辑器 网站检测 360 安全规则集合 菜鸟教程 blogs GitHub 网盘 其他 一面之猿网 文叔叔 z-library 电子书 thisPointer 钛盘 迅捷画图 轻松传 在线流程图 airportal 地址信息生成 临时邮箱 云短信 视频压缩 在线抠图 ","date":"2023-01-15","objectID":"/tool/:0:0","tags":null,"title":"工具资源列表","uri":"/tool/"},{"categories":["cmake"],"content":"cmake 编程","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":" 本文采用知识共享署名 4.0 国际许可协议进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。 Modern CMake 简体中文版 CMake菜谱（CMake Cookbook中文版） ARM SIMD 指令集：NEON 简介 现代的 CMake 现代的 CMake 。是 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！ 运行 CMake ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:0:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"设置选项 在 CMake 中，你可以使用 -D 设置选项。你能使用 -L 列出所有选项，或者用 -LH 列出人类更易读的选项列表。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:1:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"详细和部分的构建 我们已经提到了在构建时可以有详细输出，但你也可以看到详细的 CMake 配置输出。--trace 选项能够打印出运行的 CMake 的每一行。由于它过于冗长，CMake 3.7 添加了 --trace-source=\"filename\" 选项，这让你可以打印出你想看的特定文件运行时执行的每一行。如果你选择了要调试的文件的名称（在调试一个 CMakeLists.txt 时通常选择父目录，因为它们名字都一样），你就会只看到这个文件里运行的那些行。这很实用！ 1 2 cmake --trace --trace-source=\"filename\" .. make VERBOSE=1 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:2:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"选项 CMake 支持缓存选项。CMake 中的变量可以被标记为 “cached”，这意味着它会被写入缓存（构建目录中名为 CMakeCache.txt 的文件）。你可以在命令行中用 -D 预先设定（或更改）缓存选项的值。CMake 查找一个缓存的变量时，它就会使用已有的值并且不会覆盖这个值。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:3:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"标准选项 大部分软件包中都会用到以下的 CMake 选项： -DCMAKE_BUILD_TYPE= 从 Release， RelWithDebInfo， Debug， 或者可能存在的更多参数中选择。 -DCMAKE_INSTALL_PREFIX= 这是安装位置。UNIX 系统默认的位置是 /usr/local，用户目录是 ~/.local，也可以是你自己指定的文件夹。 -DBUILD_SHARED_LIBS= 你可以把这里设置为 ON 或 OFF 来控制共享库的默认值（不过，你也可以明确选择其他值而不是默认值） -DBUILD_TESTING= 这是启用测试的通用名称，当然不会所有软件包都会使用它，有时这样做确实不错。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:3:1","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"CMake 行为准则(Do’s and Don’ts) 基础知识简介 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:4:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"最低版本要求 1 cmake_minimum_required(VERSION 3.1) 从 CMake 3.12 开始，版本号可以声明为一个范围，例如 VERSION 3.1...3.15；这意味着这个工程最低可以支持 3.1 版本，但是也最高在 3.15 版本上测试成功过。 1 2 3 4 5 6 7 cmake_minimum_required(VERSION 3.7) if(${CMAKE_VERSION} VERSION_LESS 3.21) cmake_policy(VERSION ${CMAKE_MAJOR_VERSION}.${CMAKE_MINOR_VERSION}) else() cmake_policy(VERSION 3.21) endif() ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:5:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"设置一个项目 1 2 3 project(MyProject VERSION 1.0 DESCRIPTION \"Very nice project\" LANGUAGES CXX) 这里的字符串是带引号的，因此内容中可以带有空格。项目名称是这里的第一个参数。所有的关键字参数都可选的。VERSION 设置了一系列变量，例如 MyProject_VERSION 和 PROJECT_VERSION。语言可以是 C,CXX,Fortran,ASM,CUDA(CMake 3.8+),CSharp(3.8+),SWIFT(CMake 3.15+ experimental)，默认是C CXX。在 CMake 3.9，可以通过DESCRIPTION 关键词来添加项目的描述。这个关于 project 的文档可能会有用。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:6:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"生成一个可执行文件 1 add_executable(one two.cpp three.h) one 既是生成的可执行文件的名称，也是创建的 CMake 目标(target)的名称。紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。在大多数情况下，头文件将会被忽略；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。你可以在 buildsystem 中找到更多关于一般构建系统与目标的信息。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:7:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"生成一个库 1 add_library(one STATIC two.cpp three.h) 你可以选择库的类型，可以是 STATIC,SHARED, 或者MODULE.如果你不选择它，CMake 将会通过BUILD_SHARED_LIBS 的值来选择构建 STATIC 还是 SHARED 类型的库。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:8:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"目标时常伴随着你 1 target_include_directories(one PUBLIC include) target_include_directories 为目标添加了一个目录。 PUBLIC 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。其他选项还有 PRIVATE（只影响当前目标，不影响依赖），以及 INTERFACE（只影响依赖）。 接下来我们可以将目标之间链接起来： 1 2 add_library(another STATIC another.cpp another.h) target_link_libraries(another PUBLIC one) target_link_libraries 可能是 CMake 中最有用也最令人迷惑的命令。它指定一个目标，并且在给出目标的情况下添加一个依赖关系。如果不存在名称为 one 的目标，那他会添加一个链接到你路径中 one 库（这也是命令叫 target_link_libraries 的原因）。或者你可以给定一个库的完整路径，或者是链接器标志。最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 PUBLIC 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。 只要记得在任何使用目标的地方都指定关键字，那么就不会有问题。 目标可以有包含的目录、链接库（或链接目标）、编译选项、编译定义、编译特性等等。正如你将在之后的两个项目章节中看到的，你经常可以得到目标（并且经常是指定目标）来代表所有你使用的库。甚至有些不是真正的库，像 OpenMP，就可以用目标来表示。这也是为什么现代 CMake 如此的棒！ ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:9:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"更进一步 1 2 3 4 5 6 7 8 9 10 cmake_minimum_required(VERSION 3.8) project(Calculator LANGUAGES CXX) add_library(calclib STATIC src/calclib.cpp include/calc/lib.hpp) target_include_directories(calclib PUBLIC include) target_compile_features(calclib PUBLIC cxx_std_11) add_executable(calc apps/calc.cpp) target_link_libraries(calc PUBLIC calclib) 为 CMake 项目添加特性 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:10:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"默认的构建类型 1 2 3 4 5 6 7 8 9 set(default_build_type \"Release\") if(NOT CMAKE_BUILD_TYPE AND NOT CMAKE_CONFIGURATION_TYPES) message(STATUS \"Setting build type to '${default_build_type}' as none was specified.\") set(CMAKE_BUILD_TYPE \"${default_build_type}\" CACHE STRING \"Choose the type of build.\" FORCE) # Set the possible values of build type for cmake-gui set_property(CACHE CMAKE_BUILD_TYPE PROPERTY STRINGS \"Debug\" \"Release\" \"MinSizeRel\" \"RelWithDebInfo\") endif() 为 CMake 项目添加选项 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:11:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"地址无关代码(Position independent code) 用标志 -fPIC 来设置这个是最常见的。大部分情况下，你不需要去显式的声明它的值。CMake 将会在 SHARED 以及 MODULE 类型的库中自动的包含此标志。如果你需要显式的声明，可以这么写： 1 set(CMAKE_POSITION_INDEPENDENT_CODE ON) 这样会对全局的目标进行此设置，或者可以这么写： 1 set_target_properties(lib1 PROPERTIES POSITION_INDEPENDENT_CODE ON) 来对某个目标进行设置是否开启此标志。 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:12:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"Little libraries 如果你需要链接到 dl 库，在 Linux 上可以使用 -ldl 标志，不过在 CMake 中只需要在 target_link_libraries 命令中使用内置的 CMake 变量 ${CMAKE_DL_LIBS} 。这里不需要模组或者使用 find_package 来寻找它。（这个命令包含了调用 dlopen 与 dlclose 的一切依赖） 不幸的是，想要链接到数学库没这么简单。如果你需要明确地链接到它，你可以使用 target_link_libraries(MyTarget PUBLIC m)，但是使用 CMake 通用的 find_library 可能更好，如下是一个例子： 1 2 3 4 find_library(MATH_LIBRARY m) if(MATH_LIBRARY) target_link_libraries(MyTarget PUBLIC ${MATH_LIBRARY}) endif() 通过快速搜索，你可以很容易地找到这个和其他你需要的库的 Find*.cmake 文件，大多数主要软件包都具有这个 CMake 模组的辅助库 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:13:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"},{"categories":["cmake"],"content":"程序间优化(Interprocedural optimization) INTERPROCEDURAL_OPTIMIZATION，最有名的是 链接时间优化 以及 -flto 标志，这在最新的几个 CMake 版本中可用。你可以通过变量 CMAKE_INTERPROCEDURAL_OPTIMIZATION（ CMake 3.9+ 可用）或对目标指定 INTERPROCEDURAL_OPTIMIZATION 属性来打开它。在 CMake 3.8 中添加了对 GCC 及 Clang 的支持。如果你设置了 cmake_minimum_required(VERSION 3.9) 或者更高的版本（参考 CMP0069），当在编译器不支持 INTERPROCEDURAL_OPTIMIZATION 时，通过变量或属性启用该优化会产生报错。你可以使用内置模块 CheckIPOSupported 中的 check_ipo_supported() 来检查编译器是否支持 IPO 。下面是基于 CMake 3.9 的一个例子： 1 2 3 4 5 include(CheckIPOSupported) check_ipo_supported(RESULT result) if(result) set_target_properties(foo PROPERTIES INTERPROCEDURAL_OPTIMIZATION TRUE) endif() CCache 和一些其他的实用工具 CMake 中一些有用的模组 ","date":"2023-01-15","objectID":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/:14:0","tags":["cmake"],"title":"现代CMAKE","uri":"/posts/program/cmake/%E7%8E%B0%E4%BB%A3cmake/"}]